import{_ as s,c as i,o as e,ag as n}from"./chunks/framework.Bksy39di.js";const k=JSON.parse('{"title":"文档化 Kotlin 代码：KDoc","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/kotlin-doc.md","filePath":"kotlin/kotlin-doc.md","lastUpdated":1754307826000}'),t={name:"kotlin/kotlin-doc.md"};function l(p,a,o,r,h,d){return e(),i("div",null,a[0]||(a[0]=[n(`<h1 id="文档化-kotlin-代码-kdoc" tabindex="-1">文档化 Kotlin 代码：KDoc <a class="header-anchor" href="#文档化-kotlin-代码-kdoc" aria-label="Permalink to &quot;文档化 Kotlin 代码：KDoc&quot;">​</a></h1><p>用于文档化 Kotlin 代码的语言（等同于 Java 的 Javadoc）称为 <strong>KDoc</strong>。本质上，KDoc 结合了 Javadoc 用于块标签的语法（已扩展以支持 Kotlin 的特定构造）和 Markdown 用于内联标记。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Kotlin 的文档引擎 Dokka 能够理解 KDoc，并可用于生成各种格式的文档。 更多信息，请参阅我们的 <a href="/kotlin/dokka-introduction">Dokka 文档</a>。</p></div><h2 id="kdoc-语法" tabindex="-1">KDoc 语法 <a class="header-anchor" href="#kdoc-语法" aria-label="Permalink to &quot;KDoc 语法&quot;">​</a></h2><p>与 Javadoc 一样，KDoc 注释以 <code>/**</code> 开头，以 <code>*/</code> 结尾。注释的每一行可以星号开头，星号不被视为注释内容的一部分。</p><p>按照惯例，文档文本的第一个段落（从文本开头到第一个空行之间的文本块）是元素的摘要描述，后续文本是详细描述。</p><p>每个块标签都在新行开始，并以 <code>@</code> 字符开头。</p><p>以下是一个使用 KDoc 文档化的类示例：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 一组 *成员*。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 这个类没有实际的逻辑；它只是一个文档示例。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> T</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 组中成员的类型。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@property</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> name</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 此组的名称。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@constructor</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 创建一个空组。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Group</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 向此组添加一个 [member]。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@return</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 组的新大小。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(member: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="块标签" tabindex="-1">块标签 <a class="header-anchor" href="#块标签" aria-label="Permalink to &quot;块标签&quot;">​</a></h3><p>KDoc 当前支持以下块标签：</p><h3 id="param-name" tabindex="-1">@param <em>name</em> <a class="header-anchor" href="#param-name" aria-label="Permalink to &quot;@param _name_&quot;">​</a></h3><p>文档化函数的实参或类、属性或函数的类型形参。为了更好地将形参名与描述分离，如果您愿意，可以将形参名用方括号括起来。因此，以下两种语法是等效的：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@param name description.</span></span>
<span class="line"><span>@param[name] description.</span></span></code></pre></div><h3 id="return" tabindex="-1">@return <a class="header-anchor" href="#return" aria-label="Permalink to &quot;@return&quot;">​</a></h3><p>文档化函数的返回值。</p><h3 id="constructor" tabindex="-1">@constructor <a class="header-anchor" href="#constructor" aria-label="Permalink to &quot;@constructor&quot;">​</a></h3><p>文档化类的主构造函数。</p><h3 id="receiver" tabindex="-1">@receiver <a class="header-anchor" href="#receiver" aria-label="Permalink to &quot;@receiver&quot;">​</a></h3><p>文档化扩展函数的接收者。</p><h3 id="property-name" tabindex="-1">@property <em>name</em> <a class="header-anchor" href="#property-name" aria-label="Permalink to &quot;@property _name_&quot;">​</a></h3><p>文档化具有指定名称的类的属性。此标签可用于文档化在主构造函数中声明的属性，因为直接将文档注释放在属性定义之前会显得不自然。</p><h3 id="throws-class-exception-class" tabindex="-1">@throws <em>class</em>, @exception <em>class</em> <a class="header-anchor" href="#throws-class-exception-class" aria-label="Permalink to &quot;@throws _class_, @exception _class_&quot;">​</a></h3><p>文档化方法可能抛出的异常。由于 Kotlin 没有检查型异常，因此不要求文档化所有可能抛出的异常，但当它能为类的使用者提供有用信息时，您仍然可以使用此标签。</p><h3 id="sample-identifier" tabindex="-1">@sample <em>identifier</em> <a class="header-anchor" href="#sample-identifier" aria-label="Permalink to &quot;@sample _identifier_&quot;">​</a></h3><p>将具有指定限定名称的函数的函数体嵌入当前元素的文档中，以展示如何使用该元素的示例。</p><h3 id="see-identifier" tabindex="-1">@see <em>identifier</em> <a class="header-anchor" href="#see-identifier" aria-label="Permalink to &quot;@see _identifier_&quot;">​</a></h3><p>向文档的 <strong>另请参见</strong> 块添加指向指定类或方法的链接。</p><h3 id="author" tabindex="-1">@author <a class="header-anchor" href="#author" aria-label="Permalink to &quot;@author&quot;">​</a></h3><p>指定被文档化元素的作者。</p><h3 id="since" tabindex="-1">@since <a class="header-anchor" href="#since" aria-label="Permalink to &quot;@since&quot;">​</a></h3><p>指定引入被文档化元素的软件版本。</p><h3 id="suppress" tabindex="-1">@suppress <a class="header-anchor" href="#suppress" aria-label="Permalink to &quot;@suppress&quot;">​</a></h3><p>将元素从生成的文档中排除。可用于不属于模块官方 API 的一部分但仍需在外部可见的元素。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>KDoc 不支持 <code>@deprecated</code> 标签。请改用 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin/-deprecated/" target="_blank" rel="noreferrer"><code>@Deprecated</code></a> 注解。</p></div><h2 id="内联标记" tabindex="-1">内联标记 <a class="header-anchor" href="#内联标记" aria-label="Permalink to &quot;内联标记&quot;">​</a></h2><p>对于内联标记，KDoc 使用常规的 <a href="https://daringfireball.net/projects/markdown/syntax" target="_blank" rel="noreferrer">Markdown</a> 语法，并扩展以支持链接到代码中其他元素的简写语法。</p><h3 id="元素链接" tabindex="-1">元素链接 <a class="header-anchor" href="#元素链接" aria-label="Permalink to &quot;元素链接&quot;">​</a></h3><p>要链接到另一个元素（类、方法、属性或形参），只需将其名称放在方括号中：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Use the method [foo] for this purpose.</span></span></code></pre></div><p>如果您想为链接指定自定义标签，请在元素链接之前将其添加在另一对方括号中：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Use [this method][foo] for this purpose.</span></span></code></pre></div><p>您也可以在元素链接中使用限定名称。请注意，与 Javadoc 不同的是，限定名称始终使用点字符分隔组件，即使在方法名称之前也是如此：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Use [kotlin.reflect.KClass.properties] to enumerate the properties of the class.</span></span></code></pre></div><p>元素链接中的名称使用与在被文档化元素内部使用名称相同的规则解析。特别地，这意味着如果您已将某个名称导入当前文件，则在使用 KDoc 注释时无需完全限定它。</p><p>请注意，KDoc 没有任何用于解析链接中重载成员的语法。由于 Kotlin 的文档生成工具将一个函数所有重载的文档放在同一页面，因此识别特定的重载函数对于链接起作用不是必需的。</p><h3 id="外部链接" tabindex="-1">外部链接 <a class="header-anchor" href="#外部链接" aria-label="Permalink to &quot;外部链接&quot;">​</a></h3><p>要添加外部链接，请使用典型的 Markdown 语法：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>For more information about KDoc syntax, see [KDoc](&lt;example-URL&gt;).</span></span></code></pre></div><h2 id="接下来是什么" tabindex="-1">接下来是什么？ <a class="header-anchor" href="#接下来是什么" aria-label="Permalink to &quot;接下来是什么？&quot;">​</a></h2><p>学习如何使用 Kotlin 的文档生成工具：<a href="/kotlin/dokka-introduction">Dokka</a>。</p>`,51)]))}const u=s(t,[["render",l]]);export{k as __pageData,u as default};
