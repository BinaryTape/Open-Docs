import{_ as s,c as a,o as e,ag as t}from"./chunks/framework.Bksy39di.js";const c=JSON.parse('{"title":"Kotlin 1.8.0의 새로운 기능","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/whatsnew18.md","filePath":"ko/kotlin/whatsnew18.md","lastUpdated":1754307826000}'),l={name:"ko/kotlin/whatsnew18.md"};function n(o,i,r,d,p,h){return e(),a("div",null,i[0]||(i[0]=[t(`<h1 id="kotlin-1-8-0의-새로운-기능" tabindex="-1">Kotlin 1.8.0의 새로운 기능 <a class="header-anchor" href="#kotlin-1-8-0의-새로운-기능" aria-label="Permalink to &quot;Kotlin 1.8.0의 새로운 기능&quot;">​</a></h1><p><em><a href="/ko/kotlin/releases#release-details">릴리스: 2022년 12월 28일</a></em></p><p>Kotlin 1.8.0 릴리스가 공개되었으며, 다음은 주요 하이라이트입니다:</p><ul><li><a href="#recursive-copying-or-deletion-of-directories">JVM용 새로운 실험적 함수: 디렉터리 콘텐츠 재귀적으로 복사 또는 삭제</a></li><li><a href="#improved-kotlin-reflect-performance">향상된 <code>kotlin-reflect</code> 성능</a></li><li><a href="#a-new-compiler-option-for-disabling-optimizations">더 나은 디버깅 경험을 위한 새로운 <code>-Xdebug</code> 컴파일러 옵션</a></li><li><a href="#updated-jvm-compilation-target"><code>kotlin-stdlib-jdk7</code> 및 <code>kotlin-stdlib-jdk8</code>이 <code>kotlin-stdlib</code>로 병합됨</a></li><li><a href="#improved-objective-c-swift-interoperability">향상된 Objective-C/Swift 상호 운용성</a></li><li><a href="#gradle">Gradle 7.3과의 호환성</a></li></ul><h2 id="ide-지원" tabindex="-1">IDE 지원 <a class="header-anchor" href="#ide-지원" aria-label="Permalink to &quot;IDE 지원&quot;">​</a></h2><p>1.8.0을 지원하는 Kotlin 플러그인은 다음 IDE에서 사용할 수 있습니다:</p><table tabindex="0"><thead><tr><th style="text-align:left;">IDE</th><th style="text-align:left;">지원 버전</th></tr></thead><tbody><tr><td style="text-align:left;">IntelliJ IDEA</td><td style="text-align:left;">2021.3, 2022.1, 2022.2</td></tr><tr><td style="text-align:left;">Android Studio</td><td style="text-align:left;">Electric Eel (221), Flamingo (222)</td></tr></tbody></table><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>IntelliJ IDEA 2022.3에서 IDE 플러그인을 업데이트하지 않고도 프로젝트를 Kotlin 1.8.0으로 업데이트할 수 있습니다. IntelliJ IDEA 2022.3에서 기존 프로젝트를 Kotlin 1.8.0으로 마이그레이션하려면, Kotlin 버전을 <code>1.8.0</code>으로 변경하고 Gradle 또는 Maven 프로젝트를 다시 가져오세요.</p></div><h2 id="kotlin-jvm" tabindex="-1">Kotlin/JVM <a class="header-anchor" href="#kotlin-jvm" aria-label="Permalink to &quot;Kotlin/JVM&quot;">​</a></h2><p>버전 1.8.0부터 컴파일러는 JVM 19에 해당하는 바이트코드 버전으로 클래스를 생성할 수 있습니다. 새로운 언어 버전에는 다음이 포함됩니다:</p><ul><li><a href="#ability-to-not-generate-type-use-and-type-parameter-annotation-targets">JVM 어노테이션 타겟 생성을 끄는 컴파일러 옵션</a></li><li><a href="#a-new-compiler-option-for-disabling-optimizations">최적화를 비활성화하는 새로운 <code>-Xdebug</code> 컴파일러 옵션</a></li><li><a href="#removal-of-the-old-backend">이전 백엔드 제거</a></li><li><a href="#support-for-lombok-s-builder-annotation">Lombok의 <code>@Builder</code> 어노테이션 지원</a></li></ul><h3 id="type-use-및-type-parameter-어노테이션-타겟을-생성하지-않는-기능" tabindex="-1">TYPE_USE 및 TYPE_PARAMETER 어노테이션 타겟을 생성하지 않는 기능 <a class="header-anchor" href="#type-use-및-type-parameter-어노테이션-타겟을-생성하지-않는-기능" aria-label="Permalink to &quot;TYPE_USE 및 TYPE_PARAMETER 어노테이션 타겟을 생성하지 않는 기능&quot;">​</a></h3><p>Kotlin 어노테이션이 Kotlin 타겟 중 <code>TYPE</code>을 가지고 있다면, 해당 어노테이션은 Java 어노테이션 타겟 목록에서 <code>java.lang.annotation.ElementType.TYPE_USE</code>에 매핑됩니다. 이는 <code>TYPE_PARAMETER</code> Kotlin 타겟이 <code>java.lang.annotation.ElementType.TYPE_PARAMETER</code> Java 타겟에 매핑되는 방식과 같습니다. 이는 API에 이러한 타겟이 없는 API 레벨 26 미만의 Android 클라이언트에게 문제가 됩니다.</p><p>Kotlin 1.8.0부터는 새로운 컴파일러 옵션인 <code>-Xno-new-java-annotation-targets</code>를 사용하여 <code>TYPE_USE</code> 및 <code>TYPE_PARAMETER</code> 어노테이션 타겟 생성을 피할 수 있습니다.</p><h3 id="최적화를-비활성화하는-새로운-컴파일러-옵션" tabindex="-1">최적화를 비활성화하는 새로운 컴파일러 옵션 <a class="header-anchor" href="#최적화를-비활성화하는-새로운-컴파일러-옵션" aria-label="Permalink to &quot;최적화를 비활성화하는 새로운 컴파일러 옵션&quot;">​</a></h3><p>Kotlin 1.8.0에는 더 나은 디버깅 경험을 위해 최적화를 비활성화하는 새로운 컴파일러 옵션 <code>-Xdebug</code>가 추가되었습니다. 현재로서는 이 옵션이 코루틴의 &quot;최적화 제거됨(was optimized out)&quot; 기능을 비활성화합니다. 앞으로 더 많은 최적화를 추가하면 이 옵션도 해당 최적화를 비활성화할 것입니다.</p><p>&quot;최적화 제거됨(was optimized out)&quot; 기능은 <code>suspend</code> 함수를 사용할 때 변수를 최적화합니다. 하지만 최적화된 변수는 그 값을 볼 수 없기 때문에 코드를 디버깅하기 어렵습니다.</p><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><strong>이 옵션을 프로덕션에서 절대 사용하지 마세요</strong>: <code>-Xdebug</code>를 통해 이 기능을 비활성화하면 <a href="https://youtrack.jetbrains.com/issue/KT-48678/Coroutine-debugger-disable-was-optimised-out-compiler-feature#focus=Comments-27-6015585.0-0" target="_blank" rel="noreferrer">메모리 누수</a>를 유발할 수 있습니다.</p></div><h3 id="이전-백엔드-제거" tabindex="-1">이전 백엔드 제거 <a class="header-anchor" href="#이전-백엔드-제거" aria-label="Permalink to &quot;이전 백엔드 제거&quot;">​</a></h3><p>Kotlin 1.5.0에서 우리는 IR 기반 백엔드가 <a href="/ko/kotlin/components-stability">안정화(Stable)</a>되었음을 <a href="/ko/kotlin/whatsnew15#stable-jvm-ir-backend">발표</a>했습니다. 이는 Kotlin 1.4.*의 이전 백엔드가 더 이상 사용되지 않음을 의미했습니다. Kotlin 1.8.0에서는 이전 백엔드를 완전히 제거했습니다. 따라서 컴파일러 옵션 <code>-Xuse-old-backend</code> 및 Gradle 옵션 <code>useOldBackend</code>도 제거되었습니다.</p><h3 id="lombok의-builder-어노테이션-지원" tabindex="-1">Lombok의 @Builder 어노테이션 지원 <a class="header-anchor" href="#lombok의-builder-어노테이션-지원" aria-label="Permalink to &quot;Lombok의 @Builder 어노테이션 지원&quot;">​</a></h3><p>커뮤니티에서 <a href="https://youtrack.jetbrains.com/issue/KT-46959" target="_blank" rel="noreferrer">Kotlin Lombok: 생성된 빌더 지원 (@Builder)</a> YouTrack 이슈에 너무나 많은 투표를 해주셔서 우리는 <a href="https://projectlombok.org/features/Builder" target="_blank" rel="noreferrer">@Builder 어노테이션</a>을 지원할 수밖에 없었습니다.</p><p>아직 <code>@SuperBuilder</code> 또는 <code>@Tolerate</code> 어노테이션을 지원할 계획은 없지만, <a href="https://youtrack.jetbrains.com/issue/KT-53563/Kotlin-Lombok-Support-SuperBuilder" target="_blank" rel="noreferrer">SuperBuilder</a> 및 <a href="https://youtrack.jetbrains.com/issue/KT-53564/Kotlin-Lombok-Support-Tolerate" target="_blank" rel="noreferrer">Tolerate</a> 이슈에 충분한 투표가 있다면 재고할 것입니다.</p><p><a href="/ko/kotlin/lombok#gradle">Lombok 컴파일러 플러그인을 구성하는 방법 알아보기</a>.</p><h2 id="kotlin-native" tabindex="-1">Kotlin/Native <a class="header-anchor" href="#kotlin-native" aria-label="Permalink to &quot;Kotlin/Native&quot;">​</a></h2><p>Kotlin 1.8.0에는 Objective-C 및 Swift 상호 운용성 변경 사항, Xcode 14.1 지원, CocoaPods Gradle 플러그인 개선 사항이 포함됩니다:</p><ul><li><a href="#support-for-xcode-14-1">Xcode 14.1 지원</a></li><li><a href="#improved-objective-c-swift-interoperability">향상된 Objective-C/Swift 상호 운용성</a></li><li><a href="#dynamic-frameworks-by-default-in-the-cocoapods-gradle-plugin">CocoaPods Gradle 플러그인에서 기본적으로 동적 프레임워크</a></li></ul><h3 id="xcode-14-1-지원" tabindex="-1">Xcode 14.1 지원 <a class="header-anchor" href="#xcode-14-1-지원" aria-label="Permalink to &quot;Xcode 14.1 지원&quot;">​</a></h3><p>Kotlin/Native 컴파일러는 이제 최신 안정화된 Xcode 버전인 14.1을 지원합니다. 호환성 개선 사항에는 다음 변경 사항이 포함됩니다:</p><ul><li>watchOS 타겟을 위한 새로운 <code>watchosDeviceArm64</code> 프리셋이 추가되어 ARM64 플랫폼의 Apple watchOS를 지원합니다.</li><li>Kotlin CocoaPods Gradle 플러그인은 기본적으로 Apple 프레임워크에 대한 비트코드(bitcode) 임베딩을 더 이상 포함하지 않습니다.</li><li>Apple 타겟의 Objective-C 프레임워크 변경 사항을 반영하여 플랫폼 라이브러리가 업데이트되었습니다.</li></ul><h3 id="향상된-objective-c-swift-상호-운용성" tabindex="-1">향상된 Objective-C/Swift 상호 운용성 <a class="header-anchor" href="#향상된-objective-c-swift-상호-운용성" aria-label="Permalink to &quot;향상된 Objective-C/Swift 상호 운용성&quot;">​</a></h3><p>Kotlin을 Objective-C 및 Swift와 더욱 상호 운용 가능하게 만들기 위해 세 가지 새로운 어노테이션이 추가되었습니다:</p><ul><li><p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native/-obj-c-name/" target="_blank" rel="noreferrer"><code>@ObjCName</code></a>은 Kotlin 선언의 이름을 변경하는 대신 Swift 또는 Objective-C에서 보다 관용적인 이름을 지정할 수 있도록 합니다.</p><p>이 어노테이션은 Kotlin 컴파일러에게 이 클래스, 속성, 매개변수 또는 함수에 대해 사용자 정의 Objective-C 및 Swift 이름을 사용하도록 지시합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@ObjCName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(swiftName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;MySwiftArray&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyKotlinArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @ObjCName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@ObjCName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;of&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) element: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TODO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Usage with the ObjCName annotations</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MySwiftArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(of: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;element&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div></li><li><p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native/-hidden-from-obj-c/" target="_blank" rel="noreferrer"><code>@HiddenFromObjC</code></a>는 Kotlin 선언을 Objective-C에서 숨길 수 있도록 합니다.</p><p>이 어노테이션은 Kotlin 컴파일러에게 함수나 속성을 Objective-C, 그리고 결과적으로 Swift로 내보내지 않도록 지시합니다. 이는 Kotlin 코드를 Objective-C/Swift에 더 친화적으로 만들 수 있습니다.</p></li><li><p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native/-should-refine-in-swift/" target="_blank" rel="noreferrer"><code>@ShouldRefineInSwift</code></a>는 Kotlin 선언을 Swift로 작성된 래퍼(wrapper)로 대체하는 데 유용합니다.</p><p>이 어노테이션은 Kotlin 컴파일러에게 생성된 Objective-C API에서 함수나 속성을 <code>swift_private</code>로 표시하도록 지시합니다. 이러한 선언에는 <code>__</code> 접두사가 붙어 Swift 코드에서는 보이지 않게 됩니다.</p><p>예를 들어, Swift 코드에서 이러한 선언을 사용하여 Swift 친화적인 API를 만들 수 있지만, Xcode의 자동 완성 기능에서는 제안되지 않습니다.</p><p>Swift에서 Objective-C 선언을 개선하는 방법에 대한 자세한 내용은 <a href="https://developer.apple.com/documentation/swift/improving-objective-c-api-declarations-for-swift" target="_blank" rel="noreferrer">Apple 공식 문서</a>를 참조하세요.</p></li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>새로운 어노테이션은 <a href="/ko/kotlin/opt-in-requirements">옵트인</a>이 필요합니다.</p></div><p>Kotlin 팀은 이러한 어노테이션을 구현해준 <a href="https://github.com/rickclephas" target="_blank" rel="noreferrer">Rick Clephas</a>에게 매우 감사합니다.</p><h3 id="cocoapods-gradle-플러그인에서-기본적으로-동적-프레임워크" tabindex="-1">CocoaPods Gradle 플러그인에서 기본적으로 동적 프레임워크 <a class="header-anchor" href="#cocoapods-gradle-플러그인에서-기본적으로-동적-프레임워크" aria-label="Permalink to &quot;CocoaPods Gradle 플러그인에서 기본적으로 동적 프레임워크&quot;">​</a></h3><p>Kotlin 1.8.0부터 CocoaPods Gradle 플러그인에 의해 등록된 Kotlin 프레임워크는 기본적으로 동적으로 링크됩니다. 이전의 정적 구현은 Kotlin Gradle 플러그인의 동작과 일치하지 않았습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    cocoapods</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        framework</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            baseName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;MyFramework&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            isStatic </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Now dynamic by default</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>정적 링크 유형을 사용하는 기존 프로젝트가 있고 Kotlin 1.8.0으로 업그레이드(또는 링크 유형을 명시적으로 변경)하는 경우, 프로젝트 실행 시 오류가 발생할 수 있습니다. 이를 해결하려면 Xcode 프로젝트를 닫고 Podfile 디렉터리에서 <code>pod install</code>을 실행하세요.</p><p>자세한 내용은 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-dsl-reference.html" target="_blank" rel="noreferrer">CocoaPods Gradle 플러그인 DSL 참조</a>를 참조하세요.</p><h2 id="kotlin-멀티플랫폼-새로운-android-소스-세트-레이아웃" tabindex="-1">Kotlin 멀티플랫폼: 새로운 Android 소스 세트 레이아웃 <a class="header-anchor" href="#kotlin-멀티플랫폼-새로운-android-소스-세트-레이아웃" aria-label="Permalink to &quot;Kotlin 멀티플랫폼: 새로운 Android 소스 세트 레이아웃&quot;">​</a></h2><p>Kotlin 1.8.0은 기존의 혼란스러운 디렉터리 명명 체계를 대체하는 새로운 Android 소스 세트 레이아웃을 도입합니다.</p><p>현재 레이아웃에서 생성된 두 개의 <code>androidTest</code> 디렉터리 예를 살펴보겠습니다. 하나는 <code>KotlinSourceSets</code>용이고 다른 하나는 <code>AndroidSourceSets</code>용입니다:</p><ul><li>이들은 의미론적으로 다릅니다. Kotlin의 <code>androidTest</code>는 <code>unitTest</code> 유형에 속하고, Android의 <code>androidTest</code>는 <code>integrationTest</code> 유형에 속합니다.</li><li><code>src/androidTest/kotlin</code>에는 <code>UnitTest</code>가 있고 <code>src/androidTest/java</code>에는 <code>InstrumentedTest</code>가 있어 <code>SourceDirectories</code> 레이아웃을 혼란스럽게 만듭니다.</li><li><code>KotlinSourceSets</code>와 <code>AndroidSourceSets</code> 모두 Gradle 구성에 유사한 명명 체계를 사용하므로, Kotlin과 Android 소스 세트 모두에 대한 <code>androidTest</code>의 결과 구성은 <code>androidTestImplementation</code>, <code>androidTestApi</code>, <code>androidTestRuntimeOnly</code>, <code>androidTestCompileOnly</code>로 동일합니다.</li></ul><p>이러한 문제 및 기타 기존 문제를 해결하기 위해 새로운 Android 소스 세트 레이아웃을 도입했습니다. 다음은 두 레이아웃 간의 주요 차이점입니다:</p><h4 id="kotlinsourceset-명명-체계" tabindex="-1">KotlinSourceSet 명명 체계 <a class="header-anchor" href="#kotlinsourceset-명명-체계" aria-label="Permalink to &quot;KotlinSourceSet 명명 체계&quot;">​</a></h4><table tabindex="0"><thead><tr><th style="text-align:left;">현재 소스 세트 레이아웃</th><th style="text-align:left;">새 소스 세트 레이아웃</th></tr></thead><tbody><tr><td style="text-align:left;"><code>targetName</code> + <code>AndroidSourceSet.name</code></td><td style="text-align:left;"><code>targetName</code> + <code>AndroidVariantType</code></td></tr></tbody></table><p><code>{AndroidSourceSet.name}</code>은 다음과 같이 <code>{KotlinSourceSet.name}</code>에 매핑됩니다:</p><table tabindex="0"><thead><tr><th style="text-align:left;"></th><th style="text-align:left;">현재 소스 세트 레이아웃</th><th style="text-align:left;">새 소스 세트 레이아웃</th></tr></thead><tbody><tr><td style="text-align:left;">main</td><td style="text-align:left;">androidMain</td><td style="text-align:left;">androidMain</td></tr><tr><td style="text-align:left;">test</td><td style="text-align:left;">androidTest</td><td style="text-align:left;">android<strong>Unit</strong>Test</td></tr><tr><td style="text-align:left;">androidTest</td><td style="text-align:left;">android<strong>Android</strong>Test</td><td style="text-align:left;">android<strong>Instrumented</strong>Test</td></tr></tbody></table><h4 id="소스-디렉터리" tabindex="-1">소스 디렉터리 <a class="header-anchor" href="#소스-디렉터리" aria-label="Permalink to &quot;소스 디렉터리&quot;">​</a></h4><table tabindex="0"><thead><tr><th style="text-align:left;">현재 소스 세트 레이아웃</th><th style="text-align:left;">새 소스 세트 레이아웃</th></tr></thead><tbody><tr><td style="text-align:left;">레이아웃은 추가 <code>/kotlin</code> 소스 디렉터리를 추가합니다.</td><td style="text-align:left;"><code>src/{AndroidSourceSet.name}/kotlin</code>, <code>src/{KotlinSourceSet.name}/kotlin</code></td></tr></tbody></table><p><code>{AndroidSourceSet.name}</code>은 다음과 같이 <code>{SourceDirectories included}</code>에 매핑됩니다:</p><table tabindex="0"><thead><tr><th style="text-align:left;"></th><th style="text-align:left;">현재 소스 세트 레이아웃</th><th style="text-align:left;">새 소스 세트 레이아웃</th></tr></thead><tbody><tr><td style="text-align:left;">main</td><td style="text-align:left;">src/androidMain/kotlin, src/main/kotlin, src/main/java</td><td style="text-align:left;">src/androidMain/kotlin, src/main/kotlin, src/main/java</td></tr><tr><td style="text-align:left;">test</td><td style="text-align:left;">src/androidTest/kotlin, src/test/kotlin, src/test/java</td><td style="text-align:left;">src/android<strong>Unit</strong>Test/kotlin, src/test/kotlin, src/test/java</td></tr><tr><td style="text-align:left;">androidTest</td><td style="text-align:left;">src/android<strong>Android</strong>Test/kotlin, src/androidTest/java</td><td style="text-align:left;">src/android<strong>Instrumented</strong>Test/kotlin, src/androidTest/java, <strong>src/androidTest/kotlin</strong></td></tr></tbody></table><h4 id="androidmanifest-xml-파일의-위치" tabindex="-1">AndroidManifest.xml 파일의 위치 <a class="header-anchor" href="#androidmanifest-xml-파일의-위치" aria-label="Permalink to &quot;AndroidManifest.xml 파일의 위치&quot;">​</a></h4><table tabindex="0"><thead><tr><th style="text-align:left;">현재 소스 세트 레이아웃</th><th style="text-align:left;">새 소스 세트 레이아웃</th></tr></thead><tbody><tr><td style="text-align:left;">src/<strong>Android</strong>SourceSet.name}/AndroidManifest.xml</td><td style="text-align:left;">src/<strong>Kotlin</strong>SourceSet.name}/AndroidManifest.xml</td></tr></tbody></table><p><code>{AndroidSourceSet.name}</code>은 다음과 같이 <code>{AndroidManifest.xml location}</code>에 매핑됩니다:</p><table tabindex="0"><thead><tr><th style="text-align:left;"></th><th style="text-align:left;">현재 소스 세트 레이아웃</th><th style="text-align:left;">새 소스 세트 레이아웃</th></tr></thead><tbody><tr><td style="text-align:left;">main</td><td style="text-align:left;">src/main/AndroidManifest.xml</td><td style="text-align:left;">src/<strong>android</strong>Main/AndroidManifest.xml</td></tr><tr><td style="text-align:left;">debug</td><td style="text-align:left;">src/debug/AndroidManifest.xml</td><td style="text-align:left;">src/<strong>android</strong>Debug/AndroidManifest.xml</td></tr></tbody></table><h4 id="android와-공통-테스트-간의-관계" tabindex="-1">Android와 공통 테스트 간의 관계 <a class="header-anchor" href="#android와-공통-테스트-간의-관계" aria-label="Permalink to &quot;Android와 공통 테스트 간의 관계&quot;">​</a></h4><p>새로운 Android 소스 세트 레이아웃은 Android 계측 테스트(새 레이아웃에서는 <code>androidInstrumentedTest</code>로 이름 변경)와 공통 테스트 간의 관계를 변경합니다.</p><p>이전에는 <code>androidAndroidTest</code>와 <code>commonTest</code> 사이에 기본 <code>dependsOn</code> 관계가 있었습니다. 실제로는 다음을 의미했습니다:</p><ul><li><code>commonTest</code>의 코드를 <code>androidAndroidTest</code>에서 사용할 수 있었습니다.</li><li><code>commonTest</code>의 <code>expect</code> 선언은 <code>androidAndroidTest</code>에 해당 <code>actual</code> 구현을 가져야 했습니다.</li><li><code>commonTest</code>에 선언된 테스트도 Android 계측 테스트로 실행되었습니다.</li></ul><p>새로운 Android 소스 세트 레이아웃에서는 <code>dependsOn</code> 관계가 기본적으로 추가되지 않습니다. 이전 동작을 선호하는 경우 <code>build.gradle.kts</code> 파일에 이 관계를 수동으로 선언하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sourceSets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> commonTest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> getting</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> androidInstrumentedTest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dependsOn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(commonTest)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="android-플레이버-flavor-지원" tabindex="-1">Android 플레이버(flavor) 지원 <a class="header-anchor" href="#android-플레이버-flavor-지원" aria-label="Permalink to &quot;Android 플레이버(flavor) 지원&quot;">​</a></h4><p>이전에는 Kotlin Gradle 플러그인이 <code>debug</code> 및 <code>release</code> 빌드 타입 또는 <code>demo</code> 및 <code>full</code>과 같은 사용자 정의 플레이버를 가진 Android 소스 세트에 해당하는 소스 세트를 적극적으로 생성했습니다. 이는 <code>val androidDebug by getting { ... }</code>와 같은 구문을 통해 접근 가능하게 했습니다.</p><p>새로운 Android 소스 세트 레이아웃에서는 해당 소스 세트가 <code>afterEvaluate</code> 단계에서 생성됩니다. 이로 인해 <code>org.gradle.api.UnknownDomainObjectException: KotlinSourceSet with name &#39;androidDebug&#39; not found</code>와 같은 오류가 발생하여 이러한 표현식이 유효하지 않게 됩니다.</p><p>이를 해결하려면 <code>build.gradle.kts</code> 파일에서 새로운 <code>invokeWhenCreated()</code> API를 사용하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sourceSets.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invokeWhenCreated</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;androidFreeDebug&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="구성-및-설정" tabindex="-1">구성 및 설정 <a class="header-anchor" href="#구성-및-설정" aria-label="Permalink to &quot;구성 및 설정&quot;">​</a></h3><p>새로운 레이아웃은 향후 릴리스에서 기본값이 될 것입니다. 지금 다음 Gradle 옵션으로 활성화할 수 있습니다:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.mpp.androidSourceSetLayoutVersion=2</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>새로운 레이아웃은 Android Gradle 플러그인 7.0 이상을 필요로 하며, Android Studio 2022.3 이상에서 지원됩니다.</p></div><p>이전 Android 스타일 디렉터리 사용은 이제 권장되지 않습니다. Kotlin 1.8.0은 현재 레이아웃에 대한 경고를 도입하며 사용 중단 주기의 시작을 알립니다. 다음 Gradle 속성을 사용하여 경고를 억제할 수 있습니다:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.mpp.androidSourceSetLayoutVersion1.nowarn=true</span></span></code></pre></div><h2 id="kotlin-js" tabindex="-1">Kotlin/JS <a class="header-anchor" href="#kotlin-js" aria-label="Permalink to &quot;Kotlin/JS&quot;">​</a></h2><p>Kotlin 1.8.0은 JS IR 컴파일러 백엔드를 안정화하고 JavaScript 관련 Gradle 빌드 스크립트에 새로운 기능을 제공합니다:</p><ul><li><a href="#stable-js-ir-compiler-backend">안정화된 JS IR 컴파일러 백엔드</a></li><li><a href="#new-settings-for-reporting-that-yarn-lock-has-been-updated"><code>yarn.lock</code> 파일이 업데이트되었음을 보고하는 새로운 설정</a></li><li><a href="#add-test-targets-for-browsers-via-gradle-properties">Gradle 속성을 통해 브라우저용 테스트 타겟 추가</a></li><li><a href="#new-approach-to-adding-css-support-to-your-project">프로젝트에 CSS 지원을 추가하는 새로운 접근 방식</a></li></ul><h3 id="안정화된-js-ir-컴파일러-백엔드" tabindex="-1">안정화된 JS IR 컴파일러 백엔드 <a class="header-anchor" href="#안정화된-js-ir-컴파일러-백엔드" aria-label="Permalink to &quot;안정화된 JS IR 컴파일러 백엔드&quot;">​</a></h3><p>이번 릴리스부터 <a href="/ko/kotlin/js-ir-compiler">Kotlin/JS 중간 표현(IR 기반) 컴파일러</a> 백엔드가 안정화되었습니다. 세 가지 백엔드 모두에 대한 인프라를 통합하는 데 시간이 걸렸지만, 이제 Kotlin 코드에 대해 동일한 IR로 작동합니다.</p><p>안정화된 JS IR 컴파일러 백엔드의 결과로, 이전 백엔드는 이제부터 사용이 중단됩니다.</p><p>안정화된 JS IR 컴파일러와 함께 증분 컴파일이 기본적으로 활성화됩니다.</p><p>이전 컴파일러를 계속 사용하는 경우, <a href="/ko/kotlin/js-ir-migration">마이그레이션 가이드</a>의 도움을 받아 프로젝트를 새 백엔드로 전환하세요.</p><h3 id="yarn-lock-파일이-업데이트되었음을-보고하는-새로운-설정" tabindex="-1"><code>yarn.lock</code> 파일이 업데이트되었음을 보고하는 새로운 설정 <a class="header-anchor" href="#yarn-lock-파일이-업데이트되었음을-보고하는-새로운-설정" aria-label="Permalink to &quot;\`yarn.lock\` 파일이 업데이트되었음을 보고하는 새로운 설정&quot;">​</a></h3><p><code>yarn</code> 패키지 관리자를 사용하는 경우, <code>yarn.lock</code> 파일이 업데이트되었음을 알려줄 수 있는 세 가지 새로운 특별 Gradle 설정이 있습니다. CI 빌드 프로세스 중에 <code>yarn.lock</code>이 자동으로 변경되었는지 알림을 받고 싶을 때 이 설정을 사용할 수 있습니다.</p><p>이 세 가지 새로운 Gradle 속성은 다음과 같습니다:</p><ul><li><code>YarnLockMismatchReport</code>는 <code>yarn.lock</code> 파일의 변경 사항이 보고되는 방식을 지정합니다. 다음 값 중 하나를 사용할 수 있습니다: <ul><li><code>FAIL</code>은 해당 Gradle 작업을 실패시킵니다. 이것이 기본값입니다.</li><li><code>WARNING</code>은 변경 사항에 대한 정보를 경고 로그에 기록합니다.</li><li><code>NONE</code>은 보고 기능을 비활성화합니다.</li></ul></li><li><code>reportNewYarnLock</code>은 최근에 생성된 <code>yarn.lock</code> 파일에 대해 명시적으로 보고합니다. 기본적으로 이 옵션은 비활성화되어 있습니다. 이는 첫 시작 시 새 <code>yarn.lock</code> 파일을 생성하는 것이 일반적인 관행이기 때문입니다. 이 옵션을 사용하여 파일이 리포지토리에 커밋되었는지 확인할 수 있습니다.</li><li><code>yarnLockAutoReplace</code>는 Gradle 작업이 실행될 때마다 <code>yarn.lock</code>을 자동으로 대체합니다.</li></ul><p>이 옵션을 사용하려면 <code>build.gradle.kts</code> 빌드 스크립트 파일을 다음과 같이 업데이트하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> org.jetbrains.kotlin.gradle.targets.js.yarn.YarnLockMismatchReport</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> org.jetbrains.kotlin.gradle.targets.js.yarn.YarnRootExtension</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rootProject.plugins.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(org.jetbrains.kotlin.gradle.targets.js.yarn.YarnPlugin::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.java) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rootProject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">the</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">YarnRootExtension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;().yarnLockMismatchReport </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        YarnLockMismatchReport.WARNING </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// NONE | FAIL</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rootProject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">the</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">YarnRootExtension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;().reportNewYarnLock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rootProject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">the</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">YarnRootExtension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;().yarnLockAutoReplace </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="gradle-속성을-통해-브라우저용-테스트-타겟-추가" tabindex="-1">Gradle 속성을 통해 브라우저용 테스트 타겟 추가 <a class="header-anchor" href="#gradle-속성을-통해-브라우저용-테스트-타겟-추가" aria-label="Permalink to &quot;Gradle 속성을 통해 브라우저용 테스트 타겟 추가&quot;">​</a></h3><p>Kotlin 1.8.0부터 Gradle 속성 파일에서 다양한 브라우저에 대한 테스트 타겟을 바로 설정할 수 있습니다. 이렇게 하면 <code>build.gradle.kts</code>에 모든 타겟을 작성할 필요가 없어 빌드 스크립트 파일의 크기가 줄어듭니다.</p><p>이 속성을 사용하여 모든 모듈에 대한 브라우저 목록을 정의한 다음, 특정 모듈의 빌드 스크립트에 특정 브라우저를 추가할 수 있습니다.</p><p>예를 들어, Gradle 속성 파일의 다음 줄은 모든 모듈에서 Firefox와 Safari로 테스트를 실행합니다:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.js.browser.karma.browsers=firefox,safari</span></span></code></pre></div><p>속성에 사용 가능한 전체 값 목록은 <a href="https://github.com/JetBrains/kotlin/blob/master/libraries/tools/kotlin-gradle-plugin/src/common/kotlin/org/jetbrains/kotlin/gradle/targets/js/testing/karma/KotlinKarma.kt#L106" target="_blank" rel="noreferrer">GitHub</a>에서 확인하세요.</p><p>Kotlin 팀은 이 기능을 구현해준 <a href="https://github.com/mpetuska" target="_blank" rel="noreferrer">Martynas Petuška</a>에게 매우 감사합니다.</p><h3 id="프로젝트에-css-지원을-추가하는-새로운-접근-방식" tabindex="-1">프로젝트에 CSS 지원을 추가하는 새로운 접근 방식 <a class="header-anchor" href="#프로젝트에-css-지원을-추가하는-새로운-접근-방식" aria-label="Permalink to &quot;프로젝트에 CSS 지원을 추가하는 새로운 접근 방식&quot;">​</a></h3><p>이번 릴리스에서는 프로젝트에 CSS 지원을 추가하는 새로운 접근 방식을 제공합니다. 이는 많은 프로젝트에 영향을 미칠 것으로 예상되므로, 아래 설명된 대로 Gradle 빌드 스크립트 파일을 업데이트하는 것을 잊지 마세요.</p><p>Kotlin 1.8.0 이전에는 <code>cssSupport.enabled</code> 속성이 CSS 지원을 추가하는 데 사용되었습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">browser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    commonWebpackConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        cssSupport.enabled </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이제 <code>cssSupport {}</code> 블록에서 <code>enabled.set()</code> 메서드를 사용해야 합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">browser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    commonWebpackConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        cssSupport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            enabled.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="gradle" tabindex="-1">Gradle <a class="header-anchor" href="#gradle" aria-label="Permalink to &quot;Gradle&quot;">​</a></h2><p>Kotlin 1.8.0은 Gradle 버전 7.2 및 7.3을 <strong>완전히</strong> 지원합니다. 최신 Gradle 릴리스까지도 사용할 수 있지만, 그럴 경우 사용 중단 경고가 발생하거나 일부 새로운 Gradle 기능이 작동하지 않을 수 있음을 염두에 두세요.</p><p>이 버전에는 많은 변경 사항이 포함되어 있습니다:</p><ul><li><a href="#exposing-kotlin-compiler-options-as-gradle-lazy-properties">Gradle 지연 속성(lazy properties)으로 Kotlin 컴파일러 옵션 노출</a></li><li><a href="#bumping-the-minimum-supported-versions">최소 지원 버전 상향 조정</a></li><li><a href="#ability-to-disable-the-kotlin-daemon-fallback-strategy">Kotlin 데몬 폴백(fallback) 전략 비활성화 기능</a></li><li><a href="#usage-of-the-latest-kotlin-stdlib-version-in-transitive-dependencies">전이적 종속성에서 최신 <code>kotlin-stdlib</code> 버전 사용</a></li><li><a href="#obligatory-check-for-jvm-targets-of-related-kotlin-and-java-compile-tasks">관련 Kotlin 및 Java 컴파일 작업의 JVM 타겟 호환성 일치 여부 필수 확인</a></li><li><a href="#resolution-of-kotlin-gradle-plugins-transitive-dependencies">Kotlin Gradle 플러그인의 전이적 종속성 해결</a></li><li><a href="#deprecations-and-removals">사용 중단 및 제거</a></li></ul><h3 id="gradle-지연-속성-lazy-properties-으로-kotlin-컴파일러-옵션-노출" tabindex="-1">Gradle 지연 속성(lazy properties)으로 Kotlin 컴파일러 옵션 노출 <a class="header-anchor" href="#gradle-지연-속성-lazy-properties-으로-kotlin-컴파일러-옵션-노출" aria-label="Permalink to &quot;Gradle 지연 속성(lazy properties)으로 Kotlin 컴파일러 옵션 노출&quot;">​</a></h3><p>사용 가능한 Kotlin 컴파일러 옵션을 <a href="https://docs.gradle.org/current/userguide/lazy_configuration.html" target="_blank" rel="noreferrer">Gradle 지연 속성(lazy properties)</a>으로 노출하고 Kotlin 작업에 더 잘 통합하기 위해 많은 변경 사항을 적용했습니다:</p><ul><li><p>컴파일 작업에는 기존 <code>kotlinOptions</code>와 유사하지만 반환 타입으로 Gradle Properties API의 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/Property.html" target="_blank" rel="noreferrer"><code>Property</code></a>를 사용하는 새로운 <code>compilerOptions</code> 입력이 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tasks.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">named</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;compileKotlin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, org.jetbrains.kotlin.gradle.tasks.KotlinJvmCompile::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.java) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        useK2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>Kotlin 도구 작업인 <code>KotlinJsDce</code> 및 <code>KotlinNativeLink</code>에는 기존 <code>kotlinOptions</code> 입력과 유사한 새로운 <code>toolOptions</code> 입력이 있습니다.</p></li><li><p>새로운 입력에는 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/Nested.html" target="_blank" rel="noreferrer"><code>@Nested</code> Gradle 어노테이션</a>이 있습니다. 입력 내부의 모든 속성에는 <a href="https://docs.gradle.org/current/userguide/more_about_tasks.html#sec:up_to_date_checks" target="_blank" rel="noreferrer"><code>@Input</code> 또는 <code>@Internal</code></a>와 같은 관련 Gradle 어노테이션이 있습니다.</p></li><li><p>Kotlin Gradle 플러그인 API 아티팩트에는 두 가지 새로운 인터페이스가 있습니다:</p><ul><li><code>org.jetbrains.kotlin.gradle.tasks.KotlinCompilationTask</code>는 <code>compilerOptions</code> 입력과 <code>compileOptions()</code> 메서드를 가집니다. 모든 Kotlin 컴파일 작업은 이 인터페이스를 구현합니다.</li><li><code>org.jetbrains.kotlin.gradle.tasks.KotlinToolTask</code>는 <code>toolOptions</code> 입력과 <code>toolOptions()</code> 메서드를 가집니다. 모든 Kotlin 도구 작업 — <code>KotlinJsDce</code>, <code>KotlinNativeLink</code>, <code>KotlinNativeLinkArtifactTask</code> —은 이 인터페이스를 구현합니다.</li></ul></li><li><p>일부 <code>compilerOptions</code>는 <code>String</code> 타입 대신 새로운 타입을 사용합니다:</p><ul><li><a href="https://github.com/JetBrains/kotlin/blob/1.8.0/libraries/tools/kotlin-gradle-compiler-types/src/generated/kotlin/org/jetbrains/kotlin/gradle/dsl/JvmTarget.kt" target="_blank" rel="noreferrer"><code>JvmTarget</code></a></li><li><a href="https://github.com/JetBrains/kotlin/blob/1.8.0/libraries/tools/kotlin-gradle-compiler-types/src/generated/kotlin/org/jetbrains/kotlin/gradle/dsl/KotlinVersion.kt" target="_blank" rel="noreferrer"><code>KotlinVersion</code></a> (for the <code>apiVersion</code> and the <code>languageVersion</code> inputs)</li><li><a href="https://github.com/JetBrains/kotlin/blob/1.8.0/libraries/tools/kotlin-gradle-compiler-types/src/generated/kotlin/org/jetbrains/kotlin/gradle/dsl/JsMainFunctionExecutionMode.kt" target="_blank" rel="noreferrer"><code>JsMainFunctionExecutionMode</code></a></li><li><a href="https://github.com/JetBrains/kotlin/blob/1.8.0/libraries/tools/kotlin-gradle-compiler-types/src/generated/kotlin/org/jetbrains/kotlin/gradle/dsl/JsModuleKind.kt" target="_blank" rel="noreferrer"><code>JsModuleKind</code></a></li><li><a href="https://github.com/JetBrains/kotlin/blob/1.8.0/libraries/tools/kotlin-gradle-compiler-types/src/generated/kotlin/org/jetbrains/kotlin/gradle/dsl/JsSourceMapEmbedMode.kt" target="_blank" rel="noreferrer"><code>JsSourceMapEmbedMode</code></a></li></ul><p>예를 들어, <code>kotlinOptions.jvmTarget = &quot;11&quot;</code> 대신 <code>compilerOptions.jvmTarget.set(JvmTarget.JVM_11)</code>을 사용할 수 있습니다.</p><p><code>kotlinOptions</code> 타입은 변경되지 않았으며, 내부적으로 <code>compilerOptions</code> 타입으로 변환됩니다.</p></li><li><p>Kotlin Gradle 플러그인 API는 이전 릴리스와 바이너리 호환됩니다. 하지만 <code>kotlin-gradle-plugin</code> 아티팩트에는 일부 소스 및 ABI(Application Binary Interface) 호환성을 깨는 변경 사항이 있습니다. 이러한 변경 사항 대부분은 일부 내부 타입에 추가 제네릭 매개변수를 포함합니다. 한 가지 중요한 변경 사항은 <code>KotlinNativeLink</code> 작업이 더 이상 <code>AbstractKotlinNativeCompile</code> 작업을 상속하지 않는다는 것입니다.</p></li><li><p><code>KotlinJsCompilerOptions.outputFile</code> 및 관련 <code>KotlinJsOptions.outputFile</code> 옵션은 더 이상 사용되지 않습니다. 대신 <code>Kotlin2JsCompile.outputFileProperty</code> 작업 입력을 사용하세요.</p></li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Kotlin Gradle 플러그인은 여전히 <code>KotlinJvmOptions</code> DSL을 Android 확장 기능에 추가합니다: <code>kotlin android { kotlinOptions { jvmTarget = &quot;11&quot; } } </code> 이 문제는 <code>compilerOptions</code> DSL이 모듈 레벨로 추가될 때 <a href="https://youtrack.jetbrains.com/issue/KT-15370/Gradle-DSL-add-module-level-kotlin-options" target="_blank" rel="noreferrer">이 이슈</a> 범위 내에서 변경될 것입니다.</p></div><h4 id="제한-사항" tabindex="-1">제한 사항 <a class="header-anchor" href="#제한-사항" aria-label="Permalink to &quot;제한 사항&quot;">​</a></h4><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>kotlinOptions</code> 작업 입력 및 <code>kotlinOptions{...}</code> 작업 DSL은 지원 모드이며 향후 릴리스에서 사용 중단될 예정입니다. 개선 사항은 <code>compilerOptions</code> 및 <code>toolOptions</code>에만 적용될 것입니다.</p></div><p><code>kotlinOptions</code>에 대한 setter 또는 getter를 호출하는 것은 <code>compilerOptions</code>의 관련 속성에 위임합니다. 이는 다음과 같은 제한 사항을 도입합니다:</p><ul><li><code>compilerOptions</code>와 <code>kotlinOptions</code>는 작업 실행 단계에서 변경할 수 없습니다 (아래 단락의 한 가지 예외 참조).</li><li><code>freeCompilerArgs</code>는 변경 불가능한 <code>List&lt;String&gt;</code>을 반환합니다. 이는 예를 들어 <code>kotlinOptions.freeCompilerArgs.remove(&quot;something&quot;)</code>이 실패한다는 것을 의미합니다.</li></ul><p><a href="https://developer.android.com/jetpack/compose" target="_blank" rel="noreferrer">Jetpack Compose</a>가 활성화된 <code>kotlin-dsl</code> 및 Android Gradle 플러그인(AGP)을 포함한 여러 플러그인이 작업 실행 단계에서 <code>freeCompilerArgs</code> 속성을 수정하려고 시도합니다. Kotlin 1.8.0에서는 이를 위한 해결책을 추가했습니다. 이 해결책을 통해 모든 빌드 스크립트 또는 플러그인이 실행 단계에서 <code>kotlinOptions.freeCompilerArgs</code>를 수정할 수 있지만, 빌드 로그에 경고가 생성됩니다. 이 경고를 비활성화하려면 새로운 Gradle 속성 <code>kotlin.options.suppressFreeCompilerArgsModificationWarning=true</code>를 사용하세요. Gradle은 <a href="https://github.com/gradle/gradle/issues/22091" target="_blank" rel="noreferrer"><code>kotlin-dsl</code> 플러그인</a>과 <a href="https://issuetracker.google.com/u/1/issues/247544167" target="_blank" rel="noreferrer">Jetpack Compose가 활성화된 AGP</a>에 대한 수정 사항을 추가할 예정입니다.</p><h3 id="최소-지원-버전-상향-조정" tabindex="-1">최소 지원 버전 상향 조정 <a class="header-anchor" href="#최소-지원-버전-상향-조정" aria-label="Permalink to &quot;최소 지원 버전 상향 조정&quot;">​</a></h3><p>Kotlin 1.8.0부터 최소 지원 Gradle 버전은 6.8.3이고, 최소 지원 Android Gradle 플러그인 버전은 4.1.3입니다.</p><p><a href="/ko/kotlin/gradle-configure-project#apply-the-plugin">문서에서 Kotlin Gradle 플러그인과 사용 가능한 Gradle 버전 간의 호환성</a>을 확인하세요.</p><h3 id="kotlin-데몬-폴백-fallback-전략-비활성화-기능" tabindex="-1">Kotlin 데몬 폴백(fallback) 전략 비활성화 기능 <a class="header-anchor" href="#kotlin-데몬-폴백-fallback-전략-비활성화-기능" aria-label="Permalink to &quot;Kotlin 데몬 폴백(fallback) 전략 비활성화 기능&quot;">​</a></h3><p>새로운 Gradle 속성 <code>kotlin.daemon.useFallbackStrategy</code>가 있으며, 기본값은 <code>true</code>입니다. 이 값이 <code>false</code>이면, 데몬 시작 또는 통신 문제 발생 시 빌드가 실패합니다. Kotlin 컴파일 작업에는 새로운 <code>useDaemonFallbackStrategy</code> 속성도 있으며, 둘 다 사용하는 경우 이 속성이 Gradle 속성보다 우선합니다. 컴파일을 실행할 메모리가 부족한 경우 로그에서 관련 메시지를 확인할 수 있습니다.</p><p>Kotlin 컴파일러의 폴백(fallback) 전략은 데몬이 어떤 이유로든 실패할 경우 Kotlin 데몬 외부에서 컴파일을 실행하는 것입니다. Gradle 데몬이 켜져 있으면 컴파일러는 &quot;In process&quot; 전략을 사용합니다. Gradle 데몬이 꺼져 있으면 &quot;Out of process&quot; 전략을 사용합니다. 이 <a href="/ko/kotlin/gradle-compilation-and-caches#defining-kotlin-compiler-execution-strategy">실행 전략</a>에 대한 자세한 내용은 문서에서 확인하세요. 다른 전략으로 자동 전환되는 폴백은 많은 시스템 리소스를 소모하거나 비결정적인 빌드를 초래할 수 있습니다. 자세한 내용은 <a href="https://youtrack.jetbrains.com/issue/KT-48843/Add-ability-to-disable-Kotlin-daemon-fallback-strategy" target="_blank" rel="noreferrer">YouTrack 이슈</a>를 참조하세요.</p><h3 id="전이적-종속성에서-최신-kotlin-stdlib-버전-사용" tabindex="-1">전이적 종속성에서 최신 kotlin-stdlib 버전 사용 <a class="header-anchor" href="#전이적-종속성에서-최신-kotlin-stdlib-버전-사용" aria-label="Permalink to &quot;전이적 종속성에서 최신 kotlin-stdlib 버전 사용&quot;">​</a></h3><p>종속성에 Kotlin 버전 1.8.0 이상을 명시적으로 작성하는 경우(예: <code>implementation(&quot;org.jetbrains.kotlin:kotlin-stdlib:1.8.0&quot;)</code>), Kotlin Gradle 플러그인은 전이적 <code>kotlin-stdlib-jdk7</code> 및 <code>kotlin-stdlib-jdk8</code> 종속성에 해당 Kotlin 버전을 사용합니다. 이는 다른 stdlib 버전으로 인한 클래스 중복을 방지하기 위함입니다(<a href="#updated-jvm-compilation-target"><code>kotlin-stdlib-jdk7</code> 및 <code>kotlin-stdlib-jdk8</code>이 <code>kotlin-stdlib</code>로 병합되는 내용</a>에 대해 자세히 알아보기).</p><p><code>kotlin.stdlib.jdk.variants.version.alignment</code> Gradle 속성을 사용하여 이 동작을 비활성화할 수 있습니다:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.stdlib.jdk.variants.version.alignment=false</span></span></code></pre></div><p>버전 정렬에 문제가 발생하면, 빌드 스크립트에서 <code>kotlin-bom</code>에 대한 플랫폼 종속성을 선언하여 Kotlin <a href="https://docs.gradle.org/current/userguide/platforms.html#sub:bom_import" target="_blank" rel="noreferrer">BOM</a>을 통해 모든 버전을 정렬하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">implementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">platform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org.jetbrains.kotlin:kotlin-bom:1.8.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p>다른 경우 및 권장 해결책에 대해서는 <a href="/ko/kotlin/gradle-configure-project#other-ways-to-align-versions">문서</a>에서 확인하세요.</p><h3 id="관련-kotlin-및-java-컴파일-작업의-jvm-타겟-호환성-일치-여부-필수-확인" tabindex="-1">관련 Kotlin 및 Java 컴파일 작업의 JVM 타겟 호환성 일치 여부 필수 확인 <a class="header-anchor" href="#관련-kotlin-및-java-컴파일-작업의-jvm-타겟-호환성-일치-여부-필수-확인" aria-label="Permalink to &quot;관련 Kotlin 및 Java 컴파일 작업의 JVM 타겟 호환성 일치 여부 필수 확인&quot;">​</a></h3><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>이 섹션은 소스 파일이 Kotlin으로만 되어 있고 Java를 사용하지 않는 JVM 프로젝트에도 적용됩니다.</p></div><p><a href="https://youtrack.jetbrains.com/issue/KT-54993/Raise-kotlin.jvm.target.validation.mode-check-default-level-to-error-when-build-is-running-on-Gradle-8" target="_blank" rel="noreferrer">이번 릴리스부터</a>, Gradle 8.0 이상(이 Gradle 버전은 아직 릴리스되지 않음) 프로젝트의 경우 <a href="/ko/kotlin/gradle-configure-project#check-for-jvm-target-compatibility-of-related-compile-tasks"><code>kotlin.jvm.target.validation.mode</code> 속성</a>의 기본값이 <code>error</code>로 변경되며, JVM 타겟 비호환성이 발생할 경우 플러그인이 빌드를 실패시킵니다.</p><p>기본값이 <code>warning</code>에서 <code>error</code>로 변경되는 것은 Gradle 8.0으로의 원활한 마이그레이션을 위한 준비 단계입니다. <strong>이 속성을 <code>error</code>로 설정하고</strong> <a href="/ko/kotlin/gradle-configure-project#gradle-java-toolchains-support">툴체인</a>을 구성하거나 JVM 버전을 수동으로 정렬할 것을 권장합니다.</p><p><a href="/ko/kotlin/gradle-configure-project#what-can-go-wrong-if-targets-are-incompatible">타겟 호환성을 확인하지 않으면 발생할 수 있는 문제</a>에 대해 자세히 알아보세요.</p><h3 id="kotlin-gradle-플러그인의-전이적-종속성-해결" tabindex="-1">Kotlin Gradle 플러그인의 전이적 종속성 해결 <a class="header-anchor" href="#kotlin-gradle-플러그인의-전이적-종속성-해결" aria-label="Permalink to &quot;Kotlin Gradle 플러그인의 전이적 종속성 해결&quot;">​</a></h3><p>Kotlin 1.7.0에서는 <a href="/ko/kotlin/whatsnew17#support-for-gradle-plugin-variants">Gradle 플러그인 변형 지원</a>을 도입했습니다. 이러한 플러그인 변형으로 인해 빌드 클래스패스에 일반적으로 <code>kotlin-gradle-plugin-api</code>와 같은 일부 종속성의 다른 버전에 의존하는 <a href="https://plugins.gradle.org/u/kotlin" target="_blank" rel="noreferrer">Kotlin Gradle 플러그인</a>의 다른 버전이 포함될 수 있습니다. 이는 해결 문제로 이어질 수 있으며, <code>kotlin-dsl</code> 플러그인을 예로 들어 다음 해결책을 제안합니다.</p><p>Gradle 7.6의 <code>kotlin-dsl</code> 플러그인은 <code>kotlin-gradle-plugin-api:1.7.10</code>에 의존하는 <code>org.jetbrains.kotlin.plugin.sam.with.receiver:1.7.10</code> 플러그인에 의존합니다. <code>org.jetbrains.kotlin.gradle.jvm:1.8.0</code> 플러그인을 추가하면, 이 <code>kotlin-gradle-plugin-api:1.7.10</code> 전이적 종속성은 버전(<code>1.8.0</code>과 <code>1.7.10</code>)과 변형 속성의 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/attributes/plugin/GradlePluginApiVersion.html" target="_blank" rel="noreferrer"><code>org.gradle.plugin.api-version</code></a> 값 간의 불일치로 인해 종속성 해결 오류를 유발할 수 있습니다. 해결책으로, 버전을 정렬하기 위해 이 <a href="https://docs.gradle.org/current/userguide/dependency_constraints.html#sec:adding-constraints-transitive-deps" target="_blank" rel="noreferrer">제약 조건</a>을 추가하세요. 이 해결책은 우리가 <a href="https://youtrack.jetbrains.com/issue/KT-54691/Kotlin-Gradle-Plugin-libraries-alignment-platform" target="_blank" rel="noreferrer">Kotlin Gradle 플러그인 라이브러리 정렬 플랫폼</a>을 구현할 때까지 필요할 수 있으며, 이는 계획 중입니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    constraints</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        implementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org.jetbrains.kotlin:kotlin-sam-with-receiver:1.8.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 제약 조건은 전이적 종속성에 대해 빌드 클래스패스에서 <code>org.jetbrains.kotlin:kotlin-sam-with-receiver:1.8.0</code> 버전을 강제 사용하도록 합니다. 유사한 <a href="https://github.com/gradle/gradle/issues/22510#issuecomment-1292259298" target="_blank" rel="noreferrer">Gradle 이슈 트래커의 사례</a>에 대해 자세히 알아보세요.</p><h3 id="사용-중단-및-제거" tabindex="-1">사용 중단 및 제거 <a class="header-anchor" href="#사용-중단-및-제거" aria-label="Permalink to &quot;사용 중단 및 제거&quot;">​</a></h3><p>Kotlin 1.8.0에서는 다음 속성 및 메서드에 대한 사용 중단 주기가 계속됩니다:</p><ul><li><a href="/ko/kotlin/whatsnew17#changes-in-compile-tasks">Kotlin 1.7.0 노트</a>에서 <code>KotlinCompile</code> 작업이 여전히 더 이상 사용되지 않는 Kotlin 속성 <code>classpath</code>를 가지고 있으며, 이는 향후 릴리스에서 제거될 것이라고 언급했습니다. 이제 우리는 <code>KotlinCompile</code> 작업의 <code>classpath</code> 속성에 대한 사용 중단 수준을 <code>error</code>로 변경했습니다. 모든 컴파일 작업은 컴파일에 필요한 라이브러리 목록에 <code>libraries</code> 입력을 사용합니다.</li><li>Gradle Workers API를 통해 <a href="/ko/kotlin/kapt">kapt</a>를 실행할 수 있었던 <code>kapt.use.worker.api</code> 속성을 제거했습니다. 기본적으로 <a href="/ko/kotlin/kapt#run-kapt-tasks-in-parallel">kapt는 Kotlin 1.3.70부터 Gradle 워커를 사용하고</a> 있으며, 이 방법을 고수할 것을 권장합니다.</li><li>Kotlin 1.7.0에서 우리는 <code>kotlin.compiler.execution.strategy</code> 속성의 사용 중단 주기 시작을 <a href="/ko/kotlin/whatsnew17#deprecation-of-the-kotlin-compiler-execution-strategy-system-property">발표</a>했습니다. 이번 릴리스에서는 이 속성을 제거했습니다. <a href="/ko/kotlin/gradle-compilation-and-caches#defining-kotlin-compiler-execution-strategy">다른 방법으로 Kotlin 컴파일러 실행 전략을 정의하는 방법</a>을 알아보세요.</li></ul><h2 id="표준-라이브러리" tabindex="-1">표준 라이브러리 <a class="header-anchor" href="#표준-라이브러리" aria-label="Permalink to &quot;표준 라이브러리&quot;">​</a></h2><p>Kotlin 1.8.0:</p><ul><li><a href="#updated-jvm-compilation-target">JVM 컴파일 타겟</a> 업데이트.</li><li>여러 함수 안정화 – <a href="#timeunit-conversion-between-java-and-kotlin">Java와 Kotlin 간의 TimeUnit 변환</a>, <a href="#cbrt"><code>cbrt()</code></a>, <a href="#java-optionals-extension-functions">Java <code>Optionals</code> 확장 함수</a>.</li><li>비교 및 빼기가 가능한 <code>TimeMarks</code>의 <a href="#comparable-and-subtractable-timemarks">프리뷰 제공</a>.</li><li><code>java.nio.file.path</code>에 대한 <a href="#recursive-copying-or-deletion-of-directories">실험적 확장 함수</a> 포함.</li><li><a href="#improved-kotlin-reflect-performance">향상된 <code>kotlin-reflect</code> 성능</a> 제공.</li></ul><h3 id="업데이트된-jvm-컴파일-타겟" tabindex="-1">업데이트된 JVM 컴파일 타겟 <a class="header-anchor" href="#업데이트된-jvm-컴파일-타겟" aria-label="Permalink to &quot;업데이트된 JVM 컴파일 타겟&quot;">​</a></h3><p>Kotlin 1.8.0에서는 표준 라이브러리(<code>kotlin-stdlib</code>, <code>kotlin-reflect</code>, <code>kotlin-script-*</code>)가 JVM 타겟 1.8로 컴파일됩니다. 이전에는 표준 라이브러리가 JVM 타겟 1.6으로 컴파일되었습니다.</p><p>Kotlin 1.8.0은 더 이상 JVM 타겟 1.6 및 1.7을 지원하지 않습니다. 결과적으로 <code>kotlin-stdlib-jdk7</code> 및 <code>kotlin-stdlib-jdk8</code> 아티팩트의 내용이 <code>kotlin-stdlib</code>로 병합되었기 때문에 빌드 스크립트에서 이들을 별도로 선언할 필요가 없습니다.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>빌드 스크립트에 <code>kotlin-stdlib-jdk7</code> 및 <code>kotlin-stdlib-jdk8</code>을 종속성으로 명시적으로 선언했다면, 이를 <code>kotlin-stdlib</code>로 교체해야 합니다.</p></div><p>다른 버전의 stdlib 아티팩트를 혼합하면 클래스 중복 또는 클래스 누락으로 이어질 수 있습니다. 이를 방지하기 위해 Kotlin Gradle 플러그인은 <a href="#usage-of-the-latest-kotlin-stdlib-version-in-transitive-dependencies">stdlib 버전 정렬</a>을 도울 수 있습니다.</p><h3 id="cbrt" tabindex="-1">cbrt() <a class="header-anchor" href="#cbrt" aria-label="Permalink to &quot;cbrt()&quot;">​</a></h3><p><code>double</code> 또는 <code>float</code>의 실제 세제곱근을 계산할 수 있는 <code>cbrt()</code> 함수가 이제 안정화되었습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.math.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 27</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> negNum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">num</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;The cube root of \${num.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toDouble</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()} is: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            cbrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(num.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toDouble</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;The cube root of \${negNum.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toDouble</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()} is: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            cbrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(negNum.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toDouble</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="java와-kotlin-간의-timeunit-변환" tabindex="-1">Java와 Kotlin 간의 TimeUnit 변환 <a class="header-anchor" href="#java와-kotlin-간의-timeunit-변환" aria-label="Permalink to &quot;Java와 Kotlin 간의 TimeUnit 변환&quot;">​</a></h3><p><code>kotlin.time</code>의 <code>toTimeUnit()</code> 및 <code>toDurationUnit()</code> 함수가 이제 안정화되었습니다. Kotlin 1.6.0에서 실험적으로 도입된 이 함수들은 Kotlin과 Java 간의 상호 운용성을 향상시킵니다. 이제 Java <code>java.util.concurrent.TimeUnit</code>과 Kotlin <code>kotlin.time.DurationUnit</code> 간에 쉽게 변환할 수 있습니다. 이 함수들은 JVM에서만 지원됩니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.time.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// For use from Java</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timeout: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, unit: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> duration: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Duration</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timeout.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toDuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(unit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toDurationUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="비교-및-빼기가-가능한-timemarks" tabindex="-1">비교 및 빼기가 가능한 TimeMarks <a class="header-anchor" href="#비교-및-빼기가-가능한-timemarks" aria-label="Permalink to &quot;비교 및 빼기가 가능한 TimeMarks&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>TimeMarks</code>의 새로운 기능은 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적</a>이며, 이를 사용하려면 <code>@OptIn(ExperimentalTime::class)</code> 또는 <code>@ExperimentalTime</code>을 사용하여 옵트인해야 합니다.</p></div><p>Kotlin 1.8.0 이전에는 여러 <code>TimeMark</code>와 <strong>현재 시간(now)</strong> 사이의 시간 차이를 계산하려면 한 번에 하나의 <code>TimeMark</code>에 대해서만 <code>elapsedNow()</code>를 호출할 수 있었습니다. 이는 두 <code>elapsedNow()</code> 함수 호출이 정확히 같은 시간에 실행될 수 없었기 때문에 결과를 비교하기 어렵게 만들었습니다.</p><p>이 문제를 해결하기 위해 Kotlin 1.8.0에서는 동일한 시간 소스에서 <code>TimeMark</code>를 빼고 비교할 수 있습니다. 이제 **현재 시간(now)**을 나타내는 새로운 <code>TimeMark</code> 인스턴스를 생성하고 다른 <code>TimeMark</code>를 이로부터 뺄 수 있습니다. 이렇게 하면 이러한 계산에서 수집되는 결과가 서로 상대적임이 보장됩니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.time.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timeSource </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TimeSource.Monotonic</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mark1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timeSource.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">markNow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">500</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Sleep 0.5 seconds</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mark2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timeSource.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">markNow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Before 1.8.0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elapsed1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mark1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">elapsedNow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elapsed2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mark2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">elapsedNow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Difference between elapsed1 and elapsed2 can vary depending </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // on how much time passes between the two elapsedNow() calls</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Measurement 1.\${n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}: elapsed1=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$elapsed1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">, &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                &quot;elapsed2=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$elapsed2</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">, diff=\${elapsed1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> elapsed2}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Since 1.8.0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mark3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timeSource.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">markNow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elapsed1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mark3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mark1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elapsed2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mark3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mark2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Now the elapsed times are calculated relative to mark3, </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // which is a fixed value</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Measurement 2.\${n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}: elapsed1=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$elapsed1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">, &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                &quot;elapsed2=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$elapsed2</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">, diff=\${elapsed1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> elapsed2}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // It&#39;s also possible to compare time marks with each other</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // This is true, as mark2 was captured later than mark1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mark2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mark1)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 새로운 기능은 여러 프레임을 나타내는 여러 <code>TimeMark</code> 간의 차이를 계산하거나 비교하려는 애니메이션 계산에 특히 유용합니다.</p><h3 id="디렉터리-재귀적-복사-또는-삭제" tabindex="-1">디렉터리 재귀적 복사 또는 삭제 <a class="header-anchor" href="#디렉터리-재귀적-복사-또는-삭제" aria-label="Permalink to &quot;디렉터리 재귀적 복사 또는 삭제&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>java.nio.file.Path</code>에 대한 이 새로운 함수들은 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적</a>입니다. 이를 사용하려면 <code>@OptIn(kotlin.io.path.ExperimentalPathApi::class)</code> 또는 <code>@kotlin.io.path.ExperimentalPathApi</code>를 사용하여 옵트인해야 합니다. 또는 컴파일러 옵션 <code>-opt-in=kotlin.io.path.ExperimentalPathApi</code>를 사용할 수 있습니다.</p></div><p><code>java.nio.file.Path</code>에 대해 <code>copyToRecursively()</code>와 <code>deleteRecursively()</code>라는 두 가지 새로운 확장 함수를 도입했으며, 이를 통해 다음 작업을 재귀적으로 수행할 수 있습니다:</p><ul><li>디렉터리와 그 내용을 다른 목적지로 복사합니다.</li><li>디렉터리와 그 내용을 삭제합니다.</li></ul><p>이 함수들은 백업 프로세스의 일부로 매우 유용할 수 있습니다.</p><h4 id="오류-처리" tabindex="-1">오류 처리 <a class="header-anchor" href="#오류-처리" aria-label="Permalink to &quot;오류 처리&quot;">​</a></h4><p><code>copyToRecursively()</code>를 사용하여 복사 중 예외가 발생할 경우 어떻게 처리할지 <code>onError</code> 람다 함수를 오버로드하여 정의할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sourceRoot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">copyToRecursively</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(destinationRoot, followLinks </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    onError </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { source, target, exception </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        logger.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(exception, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Failed to copy </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$source</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$target</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        OnErrorResult.TERMINATE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span></code></pre></div><p><code>deleteRecursively()</code>를 사용할 때 파일 또는 폴더를 삭제하는 동안 예외가 발생하면 해당 파일 또는 폴더는 건너뛰어집니다. 삭제가 완료되면 <code>deleteRecursively()</code>는 발생한 모든 예외를 억제된 예외(suppressed exceptions)로 포함하는 <code>IOException</code>을 던집니다.</p><h4 id="파일-덮어쓰기" tabindex="-1">파일 덮어쓰기 <a class="header-anchor" href="#파일-덮어쓰기" aria-label="Permalink to &quot;파일 덮어쓰기&quot;">​</a></h4><p><code>copyToRecursively()</code>가 대상 디렉터리에 파일이 이미 존재하는 것을 발견하면 예외가 발생합니다. 대신 파일을 덮어쓰려면 <code>overwrite</code>를 인수로 가지고 <code>true</code>로 설정된 오버로드를 사용하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setUpEnvironment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(projectDirectory: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, fixtureName: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fixturesRoot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(COMMON_FIXTURE_NAME)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">copyToRecursively</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(projectDirectory, followLinks </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fixturesRoot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fixtureName)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">copyToRecursively</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(projectDirectory, followLinks </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            overwrite </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// patches the common fixture</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="사용자-정의-복사-액션" tabindex="-1">사용자 정의 복사 액션 <a class="header-anchor" href="#사용자-정의-복사-액션" aria-label="Permalink to &quot;사용자 정의 복사 액션&quot;">​</a></h4><p>자신만의 사용자 정의 복사 로직을 정의하려면, <code>copyAction</code>을 추가 인수로 가지는 오버로드를 사용하세요. <code>copyAction</code>을 사용하면 원하는 동작을 포함하는 람다 함수를 제공할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sourceRoot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">copyToRecursively</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(destinationRoot, followLinks </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { source, target </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (source.name.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">startsWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        CopyActionResult.SKIP_SUBTREE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">copyToIgnoringExistingDirectory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, followLinks </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        CopyActionResult.CONTINUE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 확장 함수에 대한 자세한 내용은 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io.path/java.nio.file.-path/copy-to-recursively.html" target="_blank" rel="noreferrer">API 참조</a>를 참조하세요.</p><h3 id="java-optionals-확장-함수" tabindex="-1">Java Optionals 확장 함수 <a class="header-anchor" href="#java-optionals-확장-함수" aria-label="Permalink to &quot;Java Optionals 확장 함수&quot;">​</a></h3><p><a href="/ko/kotlin/whatsnew17#new-experimental-extension-functions-for-java-optionals">Kotlin 1.7.0</a>에서 도입된 확장 함수들이 이제 안정화되었습니다. 이 함수들은 Java의 Optional 클래스 작업을 단순화합니다. 이 함수들은 JVM에서 <code>Optional</code> 객체를 언랩(unwrap)하고 변환하는 데 사용될 수 있으며, Java API 작업을 더 간결하게 만듭니다. 자세한 내용은 <a href="/ko/kotlin/whatsnew17#new-experimental-extension-functions-for-java-optionals">Kotlin 1.7.0의 새로운 기능</a>을 참조하세요.</p><h3 id="향상된-kotlin-reflect-성능" tabindex="-1">향상된 kotlin-reflect 성능 <a class="header-anchor" href="#향상된-kotlin-reflect-성능" aria-label="Permalink to &quot;향상된 kotlin-reflect 성능&quot;">​</a></h3><p><code>kotlin-reflect</code>가 JVM 타겟 1.8로 컴파일된다는 이점을 활용하여, 내부 캐시 메커니즘을 Java의 <code>ClassValue</code>로 마이그레이션했습니다. 이전에는 <code>KClass</code>만 캐시했지만, 이제는 <code>KType</code>과 <code>KDeclarationContainer</code>도 캐시합니다. 이러한 변경 사항은 <code>typeOf()</code> 호출 시 상당한 성능 향상을 가져왔습니다.</p><h2 id="문서-업데이트" tabindex="-1">문서 업데이트 <a class="header-anchor" href="#문서-업데이트" aria-label="Permalink to &quot;문서 업데이트&quot;">​</a></h2><p>Kotlin 문서에 몇 가지 주목할 만한 변경 사항이 있었습니다:</p><h3 id="개편된-페이지-및-새-페이지" tabindex="-1">개편된 페이지 및 새 페이지 <a class="header-anchor" href="#개편된-페이지-및-새-페이지" aria-label="Permalink to &quot;개편된 페이지 및 새 페이지&quot;">​</a></h3><ul><li><a href="/ko/kotlin/gradle">Gradle 개요</a> – Gradle 빌드 시스템으로 Kotlin 프로젝트를 구성하고 빌드하는 방법, 사용 가능한 컴파일러 옵션, Kotlin Gradle 플러그인의 컴파일 및 캐시에 대해 알아보세요.</li><li><a href="/ko/kotlin/java-to-kotlin-nullability-guide">Java와 Kotlin의 Nullability</a> – null 가능성이 있는 변수를 처리하는 Java와 Kotlin의 접근 방식 간의 차이점을 확인하세요.</li><li><a href="/ko/kotlin/lincheck-guide">Lincheck 가이드</a> – JVM에서 동시성 알고리즘을 테스트하기 위한 Lincheck 프레임워크를 설정하고 사용하는 방법을 알아보세요.</li></ul><h3 id="새로운-및-업데이트된-튜토리얼" tabindex="-1">새로운 및 업데이트된 튜토리얼 <a class="header-anchor" href="#새로운-및-업데이트된-튜토리얼" aria-label="Permalink to &quot;새로운 및 업데이트된 튜토리얼&quot;">​</a></h3><ul><li><a href="/ko/kotlin/get-started-with-jvm-gradle-project">Gradle 및 Kotlin/JVM 시작하기</a> – IntelliJ IDEA 및 Gradle을 사용하여 콘솔 애플리케이션을 생성합니다.</li><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-ktor-sqldelight.html" target="_blank" rel="noreferrer">Ktor 및 SQLDelight를 사용하여 멀티플랫폼 앱 생성</a> – Kotlin Multiplatform Mobile을 사용하여 iOS 및 Android용 모바일 애플리케이션을 생성합니다.</li><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-create-first-app.html" target="_blank" rel="noreferrer">Kotlin 멀티플랫폼 시작하기</a> – Kotlin을 사용한 크로스 플랫폼 모바일 개발에 대해 알아보고 Android 및 iOS에서 모두 작동하는 앱을 생성합니다.</li></ul><h2 id="kotlin-1-8-0-설치" tabindex="-1">Kotlin 1.8.0 설치 <a class="header-anchor" href="#kotlin-1-8-0-설치" aria-label="Permalink to &quot;Kotlin 1.8.0 설치&quot;">​</a></h2><p><a href="https://www.jetbrains.com/idea/download/" target="_blank" rel="noreferrer">IntelliJ IDEA</a> 2021.3, 2022.1 및 2022.2는 Kotlin 플러그인을 버전 1.8.0으로 업데이트하도록 자동으로 제안합니다. IntelliJ IDEA 2022.3에는 다가오는 마이너 업데이트에서 Kotlin 플러그인 1.8.0 버전이 번들로 제공될 예정입니다.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>IntelliJ IDEA 2022.3에서 기존 프로젝트를 Kotlin 1.8.0으로 마이그레이션하려면, Kotlin 버전을 <code>1.8.0</code>으로 변경하고 Gradle 또는 Maven 프로젝트를 다시 가져오세요.</p></div><p>Android Studio Electric Eel (221) 및 Flamingo (222)의 경우, Kotlin 플러그인 버전 1.8.0은 다가오는 Android Studio 업데이트와 함께 제공될 예정입니다. 새로운 명령줄 컴파일러는 <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.8.0" target="_blank" rel="noreferrer">GitHub 릴리스 페이지</a>에서 다운로드할 수 있습니다.</p><h2 id="kotlin-1-8-0-호환성-가이드" tabindex="-1">Kotlin 1.8.0 호환성 가이드 <a class="header-anchor" href="#kotlin-1-8-0-호환성-가이드" aria-label="Permalink to &quot;Kotlin 1.8.0 호환성 가이드&quot;">​</a></h2><p>Kotlin 1.8.0은 <a href="/ko/kotlin/kotlin-evolution-principles#language-and-tooling-releases">기능 릴리스(feature release)</a>이므로, 이전 버전의 언어로 작성된 코드와 호환되지 않는 변경 사항을 포함할 수 있습니다. 이러한 변경 사항에 대한 자세한 목록은 <a href="/ko/kotlin/compatibility-guide-18">Kotlin 1.8.0 호환성 가이드</a>에서 확인할 수 있습니다.</p>`,192)]))}const g=s(l,[["render",n]]);export{c as __pageData,g as default};
