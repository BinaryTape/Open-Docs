import{_ as e,a as t,b as n,c as o,d as l,e as p,f as c,g as d,h}from"./chunks/multiplatform-executables-diagram.BuydVL0t.js";import{_ as r,c as k,o as m,ag as s,j as a,a as g}from"./chunks/framework.Bksy39di.js";const _=JSON.parse('{"title":"Kotlin 멀티플랫폼 프로젝트 구조의 기본","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kmp/multiplatform-discover-project.md","filePath":"ko/kmp/multiplatform-discover-project.md","lastUpdated":1755516278000}'),E={name:"ko/kmp/multiplatform-discover-project.md"};function u(y,i,A,v,M,f){return m(),k("div",null,i[0]||(i[0]=[s(`<h1 id="kotlin-멀티플랫폼-프로젝트-구조의-기본" tabindex="-1">Kotlin 멀티플랫폼 프로젝트 구조의 기본 <a class="header-anchor" href="#kotlin-멀티플랫폼-프로젝트-구조의-기본" aria-label="Permalink to &quot;Kotlin 멀티플랫폼 프로젝트 구조의 기본&quot;">​</a></h1><p>Kotlin Multiplatform를 사용하면 여러 플랫폼 간에 코드를 공유할 수 있습니다. 이 글에서는 공유 코드의 제약 사항, 공유 코드와 플랫폼별 코드 부분을 구별하는 방법, 그리고 이 공유 코드가 작동하는 플랫폼을 지정하는 방법을 설명합니다.</p><p>또한, 공통 코드(common code), 타겟(targets), 플랫폼별 및 중간 소스 세트(platform-specific and intermediate source sets), 테스트 통합(test integration)과 같은 Kotlin Multiplatform 프로젝트 설정의 핵심 개념을 학습하게 됩니다. 이는 향후 멀티플랫폼 프로젝트를 설정하는 데 도움이 될 것입니다.</p><p>여기서 제시하는 모델은 Kotlin에서 사용되는 모델에 비해 단순화되었습니다. 하지만 이 기본적인 모델은 대부분의 경우에 적합할 것입니다.</p><h2 id="공통-코드" tabindex="-1">공통 코드 <a class="header-anchor" href="#공통-코드" aria-label="Permalink to &quot;공통 코드&quot;">​</a></h2><p><em>공통 코드(Common code)</em> 는 여러 플랫폼 간에 공유되는 Kotlin 코드입니다.</p><p>간단한 &quot;Hello, World&quot; 예시를 살펴보겠습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greeting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, Kotlin Multiplatform!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>플랫폼 간에 공유되는 Kotlin 코드는 일반적으로 <code>commonMain</code> 디렉터리에 위치합니다. 코드 파일의 위치는 이 코드가 컴파일되는 플랫폼 목록에 영향을 미치므로 중요합니다.</p><p>Kotlin 컴파일러(Kotlin compiler)는 소스 코드를 입력으로 받아 플랫폼별 바이너리(platform-specific binaries) 세트를 결과물로 생성합니다. 멀티플랫폼 프로젝트를 컴파일할 때, 동일한 코드에서 여러 바이너리를 생성할 수 있습니다. 예를 들어, 컴파일러는 동일한 Kotlin 파일에서 JVM <code>.class</code> 파일과 네이티브 실행 파일(native executable files)을 생성할 수 있습니다.</p><p><img src="`+e+'" alt="Common code" width="700"></p><p>모든 Kotlin 코드가 모든 플랫폼으로 컴파일될 수 있는 것은 아닙니다. Kotlin 컴파일러는 공통 코드에서 플랫폼별 함수나 클래스를 사용하는 것을 방지합니다. 왜냐하면 이 코드는 다른 플랫폼으로 컴파일될 수 없기 때문입니다.</p><p>예를 들어, 공통 코드에서 <code>java.io.File</code> 종속성(dependency)을 사용할 수 없습니다. 이것은 JDK의 일부이지만, 공통 코드는 네이티브 코드(native code)로도 컴파일되며, 네이티브 코드에서는 JDK 클래스를 사용할 수 없기 때문입니다.</p><p><img src="'+t+`" alt="Unresolved Java reference" width="500"></p><p>공통 코드에서는 Kotlin Multiplatform 라이브러리를 사용할 수 있습니다. 이러한 라이브러리는 여러 플랫폼에서 다르게 구현될 수 있는 공통 API를 제공합니다. 이 경우, 플랫폼별 API는 추가적인 부분으로 작용하며, 공통 코드에서 이러한 API를 사용하려고 하면 오류가 발생합니다.</p><p>예를 들어, <code>kotlinx.coroutines</code>는 모든 타겟을 지원하는 Kotlin Multiplatform 라이브러리이지만, <code>fun CoroutinesDispatcher.asExecutor(): Executor</code>와 같이 <code>kotlinx.coroutines</code>의 동시성 프리미티브(concurrent primitives)를 JDK 동시성 프리미티브로 변환하는 플랫폼별 부분도 가지고 있습니다. 이 추가 API 부분은 <code>commonMain</code>에서 사용할 수 없습니다.</p><h2 id="타겟" tabindex="-1">타겟 <a class="header-anchor" href="#타겟" aria-label="Permalink to &quot;타겟&quot;">​</a></h2><p>타겟(Targets)은 Kotlin이 공통 코드를 컴파일하는 플랫폼을 정의합니다. 예를 들어, JVM, JS, Android, iOS 또는 Linux가 될 수 있습니다. 이전 예시는 공통 코드를 JVM 및 네이티브 타겟으로 컴파일했습니다.</p><p><em>Kotlin 타겟(Kotlin target)</em> 은 컴파일 타겟을 설명하는 식별자(identifier)입니다. 이는 생성된 바이너리의 형식, 사용 가능한 언어 구성(language constructions) 및 허용되는 종속성을 정의합니다.</p><blockquote><p>타겟은 플랫폼(platforms)으로도 지칭될 수 있습니다. 지원되는 타겟의 전체 목록은 <a href="./multiplatform-dsl-reference#targets">여기</a>에서 확인할 수 있습니다.</p><p style=""></p></blockquote><p>Kotlin이 특정 타겟에 대한 코드를 컴파일하도록 지시하려면 먼저 타겟을 _선언_해야 합니다. Gradle에서는 <code>kotlin {}</code> 블록 내에서 사전 정의된 DSL 호출을 사용하여 타겟을 선언합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Declares a JVM target</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Declares a target that corresponds to 64-bit iPhones</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이러한 방식으로 각 멀티플랫폼 프로젝트는 지원되는 타겟 세트를 정의합니다. 빌드 스크립트에서 타겟을 선언하는 방법에 대한 자세한 내용은 <a href="./multiplatform-hierarchy">계층적 프로젝트 구조(Hierarchical project structure)</a> 섹션을 참조하세요.</p><p><code>jvm</code> 및 <code>iosArm64</code> 타겟이 선언되면, <code>commonMain</code>의 공통 코드는 이 타겟들로 컴파일됩니다.</p><p><img src="`+n+'" alt="Targets" width="700"></p><p>특정 타겟으로 어떤 코드가 컴파일될지 이해하려면, 타겟을 Kotlin 소스 파일에 첨부된 레이블로 생각할 수 있습니다. Kotlin은 이 레이블을 사용하여 코드를 컴파일하는 방법, 생성할 바이너리, 그리고 해당 코드에서 허용되는 언어 구성 및 종속성을 결정합니다.</p><p><code>greeting.kt</code> 파일을 <code>.js</code>로도 컴파일하려면 JS 타겟을 선언하기만 하면 됩니다. 그러면 <code>commonMain</code>의 코드는 JS 타겟에 해당하는 추가 <code>js</code> 레이블을 받아, Kotlin이 <code>.js</code> 파일을 생성하도록 지시합니다.</p><p><img src="'+o+'" alt="Target labels" width="700"></p><p>이것이 Kotlin 컴파일러가 선언된 모든 타겟으로 컴파일된 공통 코드와 작동하는 방식입니다. 플랫폼별 코드를 작성하는 방법을 배우려면 <a href="#source-sets">소스 세트</a>를 참조하세요.</p><h2 id="소스-세트" tabindex="-1">소스 세트 <a class="header-anchor" href="#소스-세트" aria-label="Permalink to &quot;소스 세트&quot;">​</a></h2><p><em>Kotlin 소스 세트(Kotlin source set)</em> 는 자체 타겟, 종속성 및 컴파일러 옵션을 가진 소스 파일의 집합입니다. 이는 멀티플랫폼 프로젝트에서 코드를 공유하는 주요 방법입니다.</p><p>멀티플랫폼 프로젝트의 각 소스 세트는 다음을 가집니다.</p><ul><li>주어진 프로젝트에서 고유한 이름을 가집니다.</li><li>일반적으로 소스 세트의 이름을 가진 디렉터리에 저장되는 소스 파일 및 리소스 집합을 포함합니다.</li><li>이 소스 세트의 코드가 컴파일되는 타겟 집합을 지정합니다. 이 타겟들은 이 소스 세트에서 사용 가능한 언어 구성 및 종속성에 영향을 미칩니다.</li><li>자체 종속성 및 컴파일러 옵션을 정의합니다.</li></ul><p>Kotlin은 여러 개의 사전 정의된 소스 세트를 제공합니다. 그중 하나는 <code>commonMain</code>으로, 모든 멀티플랫폼 프로젝트에 존재하며 선언된 모든 타겟으로 컴파일됩니다.</p><p>Kotlin Multiplatform 프로젝트에서는 <code>src</code> 내부의 디렉터리 형태로 소스 세트와 상호 작용합니다. 예를 들어, <code>commonMain</code>, <code>iosMain</code>, <code>jvmMain</code> 소스 세트를 가진 프로젝트는 다음과 같은 구조를 가집니다.</p><p><img src="'+l+`" alt="Shared sources" width="350"></p><p>Gradle 스크립트에서는 <code>kotlin.sourceSets {}</code> 블록 내부에서 이름으로 소스 세트에 접근합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Targets declaration:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // …</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Source set declaration:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sourceSets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        commonMain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Configure the commonMain source set</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>commonMain</code> 외에 다른 소스 세트는 플랫폼별 소스 세트 또는 중간 소스 세트가 될 수 있습니다.</p><h3 id="플랫폼별-소스-세트" tabindex="-1">플랫폼별 소스 세트 <a class="header-anchor" href="#플랫폼별-소스-세트" aria-label="Permalink to &quot;플랫폼별 소스 세트&quot;">​</a></h3><p>공통 코드만 사용하는 것이 편리하더라도, 항상 가능한 것은 아닙니다. <code>commonMain</code>의 코드는 선언된 모든 타겟으로 컴파일되며, Kotlin은 그곳에서 플랫폼별 API를 사용하는 것을 허용하지 않습니다.</p><p>네이티브(native) 및 JS 타겟을 가진 멀티플랫폼 프로젝트에서 <code>commonMain</code>의 다음 코드는 컴파일되지 않습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// commonMain/kotlin/common.kt</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 공통 코드에서는 컴파일되지 않음</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greeting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    java.io.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">File</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;greeting.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, Multiplatform!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>해결책으로, Kotlin은 플랫폼별 소스 세트(platform-specific source sets)를 생성하며, 이는 플랫폼 소스 세트(platform source sets)라고도 불립니다. 각 타겟은 해당 타겟만을 위해 컴파일되는 해당 플랫폼 소스 세트를 가집니다. 예를 들어, <code>jvm</code> 타겟은 JVM으로만 컴파일되는 해당 <code>jvmMain</code> 소스 세트를 가집니다. Kotlin은 이러한 소스 세트에서 플랫폼별 종속성(platform-specific dependencies)을 사용하는 것을 허용합니다. 예를 들어, <code>jvmMain</code>에서는 JDK를 사용할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// jvmMain/kotlin/jvm.kt</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// \`jvmMain\` 소스 세트에서 Java 종속성을 사용할 수 있습니다</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> jvmGreeting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    java.io.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">File</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;greeting.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, Multiplatform!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="특정-타겟으로의-컴파일" tabindex="-1">특정 타겟으로의 컴파일 <a class="header-anchor" href="#특정-타겟으로의-컴파일" aria-label="Permalink to &quot;특정 타겟으로의 컴파일&quot;">​</a></h3><p>특정 타겟으로의 컴파일은 여러 소스 세트와 함께 작동합니다. Kotlin이 멀티플랫폼 프로젝트를 특정 타겟으로 컴파일할 때, 해당 타겟으로 레이블이 지정된 모든 소스 세트를 수집하여 이들로부터 바이너리를 생성합니다.</p><p><code>jvm</code>, <code>iosArm64</code>, <code>js</code> 타겟을 포함하는 예시를 살펴보겠습니다. Kotlin은 공통 코드를 위한 <code>commonMain</code> 소스 세트와 특정 타겟을 위한 해당 <code>jvmMain</code>, <code>iosArm64Main</code>, <code>jsMain</code> 소스 세트를 생성합니다.</p><p><img src="`+p+'" alt="Compilation to a specific target" width="700"></p><p>JVM으로 컴파일하는 동안, Kotlin은 &quot;JVM&quot;으로 레이블이 지정된 모든 소스 세트, 즉 <code>jvmMain</code>과 <code>commonMain</code>을 선택합니다. 그런 다음 이들을 함께 JVM 클래스 파일로 컴파일합니다.</p><p><img src="'+c+`" alt="Compilation to JVM" width="700"></p><p>Kotlin이 <code>commonMain</code>과 <code>jvmMain</code>을 함께 컴파일하기 때문에, 결과 바이너리에는 <code>commonMain</code>과 <code>jvmMain</code> 모두의 선언이 포함됩니다.</p><p>멀티플랫폼 프로젝트를 사용할 때 다음 사항을 기억하세요.</p><ul><li>Kotlin이 코드를 특정 플랫폼으로 컴파일하도록 하려면, 해당 타겟을 선언하세요.</li><li>코드를 저장할 디렉터리 또는 소스 파일을 선택하려면, 먼저 어떤 타겟 간에 코드를 공유할지 결정하세요. <ul><li>코드가 모든 타겟 간에 공유되는 경우, <code>commonMain</code>에 선언해야 합니다.</li><li>코드가 하나의 타겟에만 사용되는 경우, 해당 타겟의 플랫폼별 소스 세트(예: JVM의 경우 <code>jvmMain</code>)에 정의해야 합니다.</li></ul></li><li>플랫폼별 소스 세트에 작성된 코드는 공통 소스 세트의 선언에 접근할 수 있습니다. 예를 들어, <code>jvmMain</code>의 코드는 <code>commonMain</code>의 코드를 사용할 수 있습니다. 그러나 그 반대는 성립하지 않습니다: <code>commonMain</code>은 <code>jvmMain</code>의 코드를 사용할 수 없습니다.</li><li>플랫폼별 소스 세트에 작성된 코드는 해당 플랫폼 종속성을 사용할 수 있습니다. 예를 들어, <code>jvmMain</code>의 코드는 <a href="https://github.com/google/guava" target="_blank" rel="noreferrer">Guava</a> 또는 <a href="https://spring.io/" target="_blank" rel="noreferrer">Spring</a>과 같은 Java 전용 라이브러리를 사용할 수 있습니다.</li></ul><h3 id="중간-소스-세트" tabindex="-1">중간 소스 세트 <a class="header-anchor" href="#중간-소스-세트" aria-label="Permalink to &quot;중간 소스 세트&quot;">​</a></h3><p>간단한 멀티플랫폼 프로젝트는 일반적으로 공통 코드와 플랫폼별 코드만 가집니다. <code>commonMain</code> 소스 세트는 선언된 모든 타겟 간에 공유되는 공통 코드를 나타냅니다. <code>jvmMain</code>과 같은 플랫폼별 소스 세트는 해당 타겟으로만 컴파일되는 플랫폼별 코드를 나타냅니다.</p><p>실제로, 더 세분화된 코드 공유가 필요한 경우가 많습니다.</p><p>모든 최신 Apple 기기와 Android 기기를 타겟팅해야 하는 예시를 살펴보겠습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    androidTarget</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 64비트 iPhone 기기</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    macosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 최신 Apple Silicon 기반 Mac</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    watchosX64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 최신 64비트 Apple Watch 기기</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    tvosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 최신 Apple TV 기기  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>그리고 모든 Apple 기기를 위한 UUID를 생성하는 함수를 추가할 소스 세트가 필요하다고 가정해 봅시다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> platform.Foundation.NSUUID</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> randomUuidString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Apple별 API에 접근하려 합니다</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NSUUID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UUIDString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 함수를 <code>commonMain</code>에 추가할 수 없습니다. <code>commonMain</code>은 Android를 포함한 모든 선언된 타겟으로 컴파일되지만, <code>platform.Foundation.NSUUID</code>는 Android에서는 사용할 수 없는 Apple별 API입니다. <code>commonMain</code>에서 <code>NSUUID</code>를 참조하려고 하면 Kotlin이 오류를 표시합니다.</p><p>이 코드를 각 Apple별 소스 세트인 <code>iosArm64Main</code>, <code>macosArm64Main</code>, <code>watchosX64Main</code>, <code>tvosArm64Main</code>에 복사하여 붙여넣을 수도 있습니다. 하지만 이와 같이 코드를 중복하는 것은 오류가 발생하기 쉬우므로 권장되지 않습니다.</p><p>이 문제를 해결하기 위해 <em>중간 소스 세트(intermediate source sets)</em> 를 사용할 수 있습니다. 중간 소스 세트는 프로젝트의 모든 타겟은 아니지만 일부 타겟으로 컴파일되는 Kotlin 소스 세트입니다. 중간 소스 세트는 계층적 소스 세트(hierarchical source sets) 또는 단순히 계층(hierarchies)이라고도 불립니다.</p><p>Kotlin은 기본적으로 일부 중간 소스 세트를 생성합니다. 이 특정 경우에, 결과 프로젝트 구조는 다음과 같습니다.</p><p><img src="`+d+'" alt="Intermediate source sets" width="700"></p><p>여기서 하단의 여러 색 블록은 플랫폼별 소스 세트입니다. 명확성을 위해 타겟 레이블은 생략되었습니다.</p><p><code>appleMain</code> 블록은 Apple별 타겟으로 컴파일된 코드를 공유하기 위해 Kotlin이 생성한 중간 소스 세트입니다. <code>appleMain</code> 소스 세트는 Apple 타겟으로만 컴파일됩니다. 따라서 Kotlin은 <code>appleMain</code>에서 Apple별 API 사용을 허용하며, 여기에 <code>randomUUID()</code> 함수를 추가할 수 있습니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Kotlin이 기본적으로 생성하고 설정하는 모든 중간 소스 세트를 찾고, Kotlin이 기본적으로 필요한 중간 소스 세트를 제공하지 않는 경우 어떻게 해야 하는지에 대한 자세한 내용은 <a href="./multiplatform-hierarchy">계층적 프로젝트 구조</a>를 참조하세요.</p></div><p>특정 타겟으로 컴파일하는 동안, Kotlin은 해당 타겟으로 레이블이 지정된 모든 소스 세트(중간 소스 세트 포함)를 가져옵니다. 따라서 <code>iosArm64</code> 플랫폼 타겟으로 컴파일하는 동안 <code>commonMain</code>, <code>appleMain</code>, <code>iosArm64Main</code> 소스 세트에 작성된 모든 코드가 결합됩니다.</p><p><img src="'+h+'" alt="Native executables" width="700"></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>일부 소스 세트에 소스가 없어도 괜찮습니다. 예를 들어, iOS 개발에서는 일반적으로 iOS 기기에는 특화되지만 iOS 시뮬레이터에는 특화되지 않은 코드를 제공할 필요가 없습니다. 따라서 <code>iosArm64Main</code>은 거의 사용되지 않습니다.</p></div>',72),a("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"apple-기기-및-시뮬레이터-타겟",tabindex:"-1"},[g("Apple 기기 및 시뮬레이터 타겟 "),a("a",{class:"header-anchor",href:"#apple-기기-및-시뮬레이터-타겟","aria-label":'Permalink to "Apple 기기 및 시뮬레이터 타겟 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1),s('<p>Kotlin Multiplatform를 사용하여 iOS 모바일 애플리케이션을 개발할 때, 일반적으로 <code>iosMain</code> 소스 세트와 함께 작업합니다. 일반적으로 <code>ios</code> 타겟의 플랫폼별 소스 세트라고 생각할 수 있지만, 단일 <code>ios</code> 타겟은 존재하지 않습니다. 대부분의 모바일 프로젝트는 최소 두 가지 타겟이 필요합니다.</p><ul><li><strong>기기 타겟(Device target)</strong> 은 iOS 기기에서 실행될 수 있는 바이너리를 생성하는 데 사용됩니다. 현재 iOS용 기기 타겟은 <code>iosArm64</code> 하나뿐입니다.</li><li><strong>시뮬레이터 타겟(Simulator target)</strong> 은 컴퓨터에서 실행되는 iOS 시뮬레이터용 바이너리를 생성하는 데 사용됩니다. Apple silicon Mac 컴퓨터를 사용한다면, 시뮬레이터 타겟으로 <code>iosSimulatorArm64</code>를 선택하세요. Intel 기반 Mac 컴퓨터를 사용한다면 <code>iosX64</code>를 사용하세요.</li></ul><p><code>iosArm64</code> 기기 타겟만 선언하면 로컬 머신에서 애플리케이션과 테스트를 실행하고 디버그할 수 없습니다.</p><p><code>iosArm64Main</code>, <code>iosSimulatorArm64Main</code>, <code>iosX64Main</code>과 같은 플랫폼별 소스 세트는 일반적으로 비어 있습니다. iOS 기기와 시뮬레이터를 위한 Kotlin 코드는 대개 동일하기 때문입니다. 이들 모두 간에 코드를 공유하려면 <code>iosMain</code> 중간 소스 세트만 사용해도 됩니다.</p><p>동일한 원리가 Mac 이외의 다른 Apple 타겟에도 적용됩니다. 예를 들어, Apple TV용 <code>tvosArm64</code> 기기 타겟과 Apple silicon 및 Intel 기반 기기의 Apple TV 시뮬레이터용 <code>tvosSimulatorArm64</code>, <code>tvosX64</code> 시뮬레이터 타겟이 있다면, 이들 모두를 위해 <code>tvosMain</code> 중간 소스 세트를 사용할 수 있습니다.</p><h2 id="테스트-통합" tabindex="-1">테스트 통합 <a class="header-anchor" href="#테스트-통합" aria-label="Permalink to &quot;테스트 통합&quot;">​</a></h2><p>실제 프로젝트에서는 주요 프로덕션 코드와 함께 테스트도 필요합니다. 이것이 기본적으로 생성되는 모든 소스 세트에 <code>Main</code> 및 <code>Test</code> 접미사가 붙는 이유입니다. <code>Main</code>은 프로덕션 코드를 포함하고, <code>Test</code>는 이 코드에 대한 테스트를 포함합니다. 둘 사이의 연결은 자동으로 설정되며, 테스트는 추가 구성 없이 <code>Main</code> 코드가 제공하는 API를 사용할 수 있습니다.</p><p><code>Test</code>에 해당하는 소스 세트 역시 <code>Main</code>과 유사한 소스 세트입니다. 예를 들어, <code>commonTest</code>는 <code>commonMain</code>에 해당하는 소스 세트이며 선언된 모든 타겟으로 컴파일되어 공통 테스트를 작성할 수 있도록 합니다. <code>jvmTest</code>와 같은 플랫폼별 테스트 소스 세트는 플랫폼별 테스트(예: JVM별 테스트 또는 JVM API가 필요한 테스트)를 작성하는 데 사용됩니다.</p><p>공통 테스트를 작성할 소스 세트 외에도, 멀티플랫폼 테스트 프레임워크가 필요합니다. Kotlin은 <code>@kotlin.Test</code> 어노테이션과 <code>assertEquals</code>, <code>assertTrue</code>와 같은 다양한 검증 메서드를 제공하는 기본 <a href="https://kotlinlang.org/api/latest/kotlin.test/" target="_blank" rel="noreferrer"><code>kotlin.test</code></a> 라이브러리를 제공합니다.</p><p>각 플랫폼의 해당 소스 세트에서 일반적인 테스트처럼 플랫폼별 테스트를 작성할 수 있습니다. 주요 코드와 마찬가지로, 각 소스 세트별로 플랫폼별 종속성을 가질 수 있습니다. 예를 들어, JVM용 <code>JUnit</code>과 iOS용 <code>XCTest</code>가 있습니다. 특정 타겟에 대한 테스트를 실행하려면 <code>&lt;targetName&gt;Test</code> 태스크를 사용하세요.</p><p><a href="./multiplatform-run-tests">멀티플랫폼 앱 테스트 튜토리얼</a>에서 멀티플랫폼 테스트를 생성하고 실행하는 방법을 알아보세요.</p><h2 id="다음-단계" tabindex="-1">다음 단계 <a class="header-anchor" href="#다음-단계" aria-label="Permalink to &quot;다음 단계&quot;">​</a></h2><ul><li><a href="./multiplatform-hierarchy">Gradle 스크립트에서 사전 정의된 소스 세트를 선언하고 사용하는 방법에 대해 자세히 알아보기</a></li><li><a href="./multiplatform-advanced-project-structure">멀티플랫폼 프로젝트 구조의 고급 개념 탐색하기</a></li><li><a href="./multiplatform-configure-compilations">타겟 컴파일 및 사용자 정의 컴파일 생성에 대해 자세히 알아보기</a></li></ul>',13)]))}const D=r(E,[["render",u]]);export{_ as __pageData,D as default};
