import{_ as t,c as n,o,ag as r}from"./chunks/framework.Bksy39di.js";const m=JSON.parse('{"title":"核心概念","description":"","frontmatter":{},"headers":[],"relativePath":"koog/key-concepts.md","filePath":"koog/key-concepts.md","lastUpdated":1754431054000}'),a={name:"koog/key-concepts.md"};function l(s,e,g,i,p,h){return o(),n("div",null,e[0]||(e[0]=[r('<h1 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h1><h2 id="agent" tabindex="-1">Agent <a class="header-anchor" href="#agent" aria-label="Permalink to &quot;Agent&quot;">​</a></h2><ul><li><p><strong>Agent</strong>：一个 AI 实体，可以与工具交互、处理复杂工作流并与用户通信。</p></li><li><p><strong>LLM (Large Language Model)</strong>：为 Agent 能力提供支持的底层 AI 模型。</p></li><li><p><strong>Message</strong>：Agent 系统中的一个通信单元，表示从用户、助手或系统传递的数据。</p></li><li><p><strong>Prompt</strong>：提供给 LLM 的对话历史，由用户、助手和系统消息组成。</p></li><li><p><strong>System prompt</strong>：提供给 Agent 的指令，用于指导其行为、定义其角色并提供其任务所需的关键信息。</p></li><li><p><strong>Context</strong>：LLM 交互发生的环境，可访问对话历史和工具。</p></li><li><p><strong>LLM session</strong>：与 LLM 交互的结构化方式，包括对话历史、可用工具以及发起请求的方法。</p></li></ul><h2 id="agent-工作流" tabindex="-1">Agent 工作流 <a class="header-anchor" href="#agent-工作流" aria-label="Permalink to &quot;Agent 工作流&quot;">​</a></h2><ul><li><strong>Strategy</strong>：为 Agent 定义的工作流，由顺序子图组成。 该策略定义了 Agent 如何处理输入、与工具交互并生成输出。 策略图由通过边连接的节点组成，这些边表示节点之间的转换。</li></ul><h3 id="策略图" tabindex="-1">策略图 <a class="header-anchor" href="#策略图" aria-label="Permalink to &quot;策略图&quot;">​</a></h3><ul><li><p><strong>Graph</strong>：由通过边连接的节点组成的结构，定义了 Agent 策略工作流。</p></li><li><p><strong>Node</strong>：Agent 策略工作流的基本构建块，表示特定的操作或转换。</p></li><li><p><strong>Edge</strong>：Agent 图中节点之间的连接，定义了操作流，通常带有条件，用于指定何时沿着每条边行进。</p></li><li><p><strong>Conditions</strong>：决定何时沿着特定边行进的规则。</p></li><li><p><strong>Subgraph</strong>：Agent 策略中自包含的处理单元，拥有自己的一组工具、上下文和职责。关于子图操作的信息可以封装在子图内部，也可以使用 AgentMemory 特性在子图之间传递。</p></li></ul><h2 id="工具" tabindex="-1">工具 <a class="header-anchor" href="#工具" aria-label="Permalink to &quot;工具&quot;">​</a></h2><ul><li><p><strong>Tool</strong>：Agent 可用于执行特定任务或访问外部系统的函数。Agent 了解可用的工具及其实参，但不知道它们的实现细节。</p></li><li><p><strong>Tool call</strong>：LLM 发出的请求，用于使用提供的实参运行特定工具。其功能类似于函数调用。</p></li><li><p><strong>Tool descriptor</strong>：工具元数据，包括其名称、描述和形参。</p></li><li><p><strong>Tool registry</strong>：Agent 可用工具的 list。该注册表告知 Agent 可用的工具。</p></li><li><p><strong>Tool result</strong>：运行工具产生的输出。例如，如果工具是一个方法，结果将是其返回值。</p></li></ul><h2 id="历史压缩" tabindex="-1">历史压缩 <a class="header-anchor" href="#历史压缩" aria-label="Permalink to &quot;历史压缩&quot;">​</a></h2><ul><li><strong>History compression</strong>：通过应用各种压缩策略来减少对话历史的大小以管理 token 用量的过程。 关于详情，请参见 <a href="./history-compression">历史压缩</a>。</li></ul><h2 id="特性" tabindex="-1">特性 <a class="header-anchor" href="#特性" aria-label="Permalink to &quot;特性&quot;">​</a></h2><ul><li><strong>Feature</strong>：扩展和增强 AI Agent 功能的组件。</li></ul><h3 id="eventhandler-特性" tabindex="-1">EventHandler 特性 <a class="header-anchor" href="#eventhandler-特性" aria-label="Permalink to &quot;EventHandler 特性&quot;">​</a></h3><ul><li><strong>EventHandler</strong>：一种特性，能够监控和响应各种 Agent 事件，提供用于跟踪 Agent 生命周期、处理错误以及在整个工作流中处理工具调用的挂钩。</li></ul><h3 id="agentmemory-特性" tabindex="-1">AgentMemory 特性 <a class="header-anchor" href="#agentmemory-特性" aria-label="Permalink to &quot;AgentMemory 特性&quot;">​</a></h3><ul><li><p><strong>AgentMemory</strong>：一种特性，使 AI Agent 能够在对话中存储、检索和使用信息。关于详情，请参见 <a href="./agent-memory">AgentMemory</a>。</p></li><li><p><strong>Concept</strong>：AgentMemory 特性中关联元数据的信息类别，包括关键词、描述和事实类型。概念是 AgentMemory 系统的基本构建块，Agent 可以记住和回忆它们。 关于详情，请参见 <a href="./agent-memory">AgentMemory</a>。</p></li><li><p><strong>Fact</strong>：存储在 AgentMemory 系统中的独立信息片段。 事实与概念关联，可以具有单个值或多个值。 关于详情，请参见 <a href="./agent-memory">AgentMemory</a>。</p></li><li><p><strong>Memory scope</strong>：事实相关的上下文。关于详情，请参见 <a href="./agent-memory">AgentMemory</a>。</p></li></ul>',17)]))}const c=t(a,[["render",l]]);export{m as __pageData,c as default};
