import{_ as e,c as t,o as r,ag as n}from"./chunks/framework.Bksy39di.js";const u=JSON.parse('{"title":"Kotlin 1.4 호환성 가이드","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/compatibility-guide-14.md","filePath":"ko/kotlin/compatibility-guide-14.md","lastUpdated":1754307826000}'),a={name:"ko/kotlin/compatibility-guide-14.md"};function l(s,o,i,c,p,d){return r(),t("div",null,o[0]||(o[0]=[n('<h1 id="kotlin-1-4-호환성-가이드" tabindex="-1">Kotlin 1.4 호환성 가이드 <a class="header-anchor" href="#kotlin-1-4-호환성-가이드" aria-label="Permalink to &quot;Kotlin 1.4 호환성 가이드&quot;">​</a></h1><p><em><a href="/ko/kotlin/kotlin-evolution-principles">언어의 현대성 유지</a></em> 및 _<a href="/ko/kotlin/kotlin-evolution-principles">편안한 업데이트</a>_는 Kotlin 언어 설계의 근본적인 원칙 중 하나입니다. 전자는 언어 발전을 방해하는 구문은 제거해야 한다고 말하며, 후자는 코드 마이그레이션을 최대한 원활하게 하기 위해 이러한 제거는 사전에 잘 고지되어야 한다고 말합니다.</p><p>대부분의 언어 변경 사항은 이미 업데이트 변경 로그나 컴파일러 경고와 같은 다른 채널을 통해 발표되었지만, 이 문서는 모든 변경 사항을 요약하여 Kotlin 1.3에서 Kotlin 1.4로 마이그레이션하기 위한 완벽한 참고 자료를 제공합니다.</p><h2 id="기본-용어" tabindex="-1">기본 용어 <a class="header-anchor" href="#기본-용어" aria-label="Permalink to &quot;기본 용어&quot;">​</a></h2><p>이 문서에서는 여러 종류의 호환성을 소개합니다.</p><ul><li><em>소스</em>: 소스 비호환(source-incompatible) 변경은 이전에 (오류나 경고 없이) 잘 컴파일되던 코드가 더 이상 컴파일되지 않도록 합니다.</li><li><em>바이너리</em>: 두 바이너리 아티팩트는 서로 교환해도 로딩 또는 링크 오류가 발생하지 않으면 바이너리 호환(binary-compatible)된다고 말합니다.</li><li><em>동작</em>: 변경 사항이 적용되기 전과 후에 동일한 프로그램이 다른 동작을 보이면 동작 비호환(behavioral-incompatible)이라고 말합니다.</li></ul><p>이러한 정의는 순수 Kotlin에 대해서만 주어진 것임을 기억하십시오. 다른 언어 관점(예: Java)에서의 Kotlin 코드 호환성은 이 문서의 범위를 벗어납니다.</p><h2 id="언어-및-표준-라이브러리" tabindex="-1">언어 및 표준 라이브러리 <a class="header-anchor" href="#언어-및-표준-라이브러리" aria-label="Permalink to &quot;언어 및 표준 라이브러리&quot;">​</a></h2><h3 id="in-중위-연산자-및-concurrenthashmap과의-예기치-않은-동작" tabindex="-1"><code>in</code> 중위 연산자 및 <code>ConcurrentHashMap</code>과의 예기치 않은 동작 <a class="header-anchor" href="#in-중위-연산자-및-concurrenthashmap과의-예기치-않은-동작" aria-label="Permalink to &quot;`in` 중위 연산자 및 `ConcurrentHashMap`과의 예기치 않은 동작&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-18053" target="_blank" rel="noreferrer">KT-18053</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4는 Java로 작성된 <code>java.util.Map</code> 구현체에서 오는 자동 연산자 <code>contains</code>를 금지합니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 호출 위치에서 문제가 있는 연산자에 대한 경고 도입</li><li><code>&gt;=</code> 1.4: 이 경고를 오류로 상향 조정 <code>-XXLanguage:-ProhibitConcurrentHashMapContains</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="public-inline-멤버-내부에서-protected-멤버에-대한-접근-금지" tabindex="-1">public inline 멤버 내부에서 protected 멤버에 대한 접근 금지 <a class="header-anchor" href="#public-inline-멤버-내부에서-protected-멤버에-대한-접근-금지" aria-label="Permalink to &quot;public inline 멤버 내부에서 protected 멤버에 대한 접근 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-21178" target="_blank" rel="noreferrer">KT-21178</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4는 public inline 멤버에서 protected 멤버에 대한 접근을 금지합니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 문제가 있는 경우 호출 위치에서 경고 도입</li><li>1.4: 이 경고를 오류로 상향 조정 <code>-XXLanguage:-ProhibitProtectedCallFromInline</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="암묵적-리시버를-사용하는-호출의-계약" tabindex="-1">암묵적 리시버를 사용하는 호출의 계약 <a class="header-anchor" href="#암묵적-리시버를-사용하는-호출의-계약" aria-label="Permalink to &quot;암묵적 리시버를 사용하는 호출의 계약&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-28672" target="_blank" rel="noreferrer">KT-28672</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: 1.4에서는 암묵적 리시버를 사용하는 호출에 계약(contracts)을 통한 스마트 캐스트를 사용할 수 있습니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-ContractsOnCallsWithImplicitReceiver</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="부동-소수점-숫자-비교의-일관성-없는-동작" tabindex="-1">부동 소수점 숫자 비교의 일관성 없는 동작 <a class="header-anchor" href="#부동-소수점-숫자-비교의-일관성-없는-동작" aria-label="Permalink to &quot;부동 소수점 숫자 비교의 일관성 없는 동작&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-22723" target="_blank" rel="noreferrer">KT-22723</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: Kotlin 1.4부터 Kotlin 컴파일러는 부동 소수점 숫자를 비교하기 위해 IEEE 754 표준을 사용합니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-ProperIeee754Comparisons</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="제네릭-람다의-마지막-표현식에-스마트-캐스트-없음" tabindex="-1">제네릭 람다의 마지막 표현식에 스마트 캐스트 없음 <a class="header-anchor" href="#제네릭-람다의-마지막-표현식에-스마트-캐스트-없음" aria-label="Permalink to &quot;제네릭 람다의 마지막 표현식에 스마트 캐스트 없음&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-15020" target="_blank" rel="noreferrer">KT-15020</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: 1.4부터 람다의 마지막 표현식에 대한 스마트 캐스트가 올바르게 적용됩니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-NewInference</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다. 이 플래그는 여러 새로운 언어 기능도 비활성화합니다.</li></ul></blockquote><h3 id="결과를-unit으로-강제-변환하기-위해-람다-인수의-순서에-의존하지-않음" tabindex="-1">결과를 Unit으로 강제 변환하기 위해 람다 인수의 순서에 의존하지 않음 <a class="header-anchor" href="#결과를-unit으로-강제-변환하기-위해-람다-인수의-순서에-의존하지-않음" aria-label="Permalink to &quot;결과를 Unit으로 강제 변환하기 위해 람다 인수의 순서에 의존하지 않음&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-36045" target="_blank" rel="noreferrer">KT-36045</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 람다 인수는 <code>Unit</code>으로의 암시적 강제 변환 없이 독립적으로 해결됩니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-NewInference</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다. 이 플래그는 여러 새로운 언어 기능도 비활성화합니다.</li></ul></blockquote><h3 id="raw-타입과-정수-리터럴-타입-간의-잘못된-공통-상위-타입으로-인해-불안정한-코드-발생" tabindex="-1">Raw 타입과 정수 리터럴 타입 간의 잘못된 공통 상위 타입으로 인해 불안정한 코드 발생 <a class="header-anchor" href="#raw-타입과-정수-리터럴-타입-간의-잘못된-공통-상위-타입으로-인해-불안정한-코드-발생" aria-label="Permalink to &quot;Raw 타입과 정수 리터럴 타입 간의 잘못된 공통 상위 타입으로 인해 불안정한 코드 발생&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-35681" target="_blank" rel="noreferrer">KT-35681</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 raw <code>Comparable</code> 타입과 정수 리터럴 타입 간의 공통 상위 타입이 더 구체적입니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-NewInference</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다. 이 플래그는 여러 새로운 언어 기능도 비활성화합니다.</li></ul></blockquote><h3 id="동일한-타입-변수가-다른-타입으로-인스턴스화되어-발생하는-타입-안정성-문제" tabindex="-1">동일한 타입 변수가 다른 타입으로 인스턴스화되어 발생하는 타입 안정성 문제 <a class="header-anchor" href="#동일한-타입-변수가-다른-타입으로-인스턴스화되어-발생하는-타입-안정성-문제" aria-label="Permalink to &quot;동일한 타입 변수가 다른 타입으로 인스턴스화되어 발생하는 타입 안정성 문제&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-35679" target="_blank" rel="noreferrer">KT-35679</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 Kotlin 컴파일러는 동일한 타입 변수를 다른 타입으로 인스턴스화하는 것을 금지합니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-NewInference</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다. 이 플래그는 여러 새로운 언어 기능도 비활성화합니다.</li></ul></blockquote><h3 id="교차-타입에-대한-부정확한-서브타이핑으로-인한-타입-안전성-문제" tabindex="-1">교차 타입에 대한 부정확한 서브타이핑으로 인한 타입 안전성 문제 <a class="header-anchor" href="#교차-타입에-대한-부정확한-서브타이핑으로-인한-타입-안전성-문제" aria-label="Permalink to &quot;교차 타입에 대한 부정확한 서브타이핑으로 인한 타입 안전성 문제&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-22474" target="_blank" rel="noreferrer">KT-22474</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4에서는 교차 타입에 대한 서브타이핑이 더 정확하게 작동하도록 개선됩니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-NewInference</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다. 이 플래그는 여러 새로운 언어 기능도 비활성화합니다.</li></ul></blockquote><h3 id="람다-내-빈-when-표현식에서-타입-불일치-없음" tabindex="-1">람다 내 빈 <code>when</code> 표현식에서 타입 불일치 없음 <a class="header-anchor" href="#람다-내-빈-when-표현식에서-타입-불일치-없음" aria-label="Permalink to &quot;람다 내 빈 `when` 표현식에서 타입 불일치 없음&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-17995" target="_blank" rel="noreferrer">KT-17995</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 빈 <code>when</code> 표현식이 람다의 마지막 표현식으로 사용되면 타입 불일치가 발생합니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-NewInference</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다. 이 플래그는 여러 새로운 언어 기능도 비활성화합니다.</li></ul></blockquote><h3 id="가능한-반환-값-중-하나에-정수-리터럴이-있는-조기-반환-람다에-대해-any로-타입-추론" tabindex="-1">가능한 반환 값 중 하나에 정수 리터럴이 있는 조기 반환 람다에 대해 Any로 타입 추론 <a class="header-anchor" href="#가능한-반환-값-중-하나에-정수-리터럴이-있는-조기-반환-람다에-대해-any로-타입-추론" aria-label="Permalink to &quot;가능한 반환 값 중 하나에 정수 리터럴이 있는 조기 반환 람다에 대해 Any로 타입 추론&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-20226" target="_blank" rel="noreferrer">KT-20226</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 조기 반환이 있는 경우 람다에서 반환되는 정수 타입이 더 구체적입니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-NewInference</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다. 이 플래그는 여러 새로운 언어 기능도 비활성화합니다.</li></ul></blockquote><h3 id="재귀-타입이-있는-스타-프로젝션의-올바른-캡처" tabindex="-1">재귀 타입이 있는 스타 프로젝션의 올바른 캡처 <a class="header-anchor" href="#재귀-타입이-있는-스타-프로젝션의-올바른-캡처" aria-label="Permalink to &quot;재귀 타입이 있는 스타 프로젝션의 올바른 캡처&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-33012" target="_blank" rel="noreferrer">KT-33012</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 재귀 타입에 대한 캡처가 더 정확하게 작동하여 더 많은 후보가 적용 가능해집니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-NewInference</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다. 이 플래그는 여러 새로운 언어 기능도 비활성화합니다.</li></ul></blockquote><h3 id="부적절한-타입과-유연한-타입-간의-공통-상위-타입-계산이-부정확한-결과를-초래합니다" tabindex="-1">부적절한 타입과 유연한 타입 간의 공통 상위 타입 계산이 부정확한 결과를 초래합니다 <a class="header-anchor" href="#부적절한-타입과-유연한-타입-간의-공통-상위-타입-계산이-부정확한-결과를-초래합니다" aria-label="Permalink to &quot;부적절한 타입과 유연한 타입 간의 공통 상위 타입 계산이 부정확한 결과를 초래합니다&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-37054" target="_blank" rel="noreferrer">KT-37054</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: Kotlin 1.4부터 유연한 타입 간의 공통 상위 타입이 런타임 오류로부터 보호하기 위해 더 구체적입니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-NewInference</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다. 이 플래그는 여러 새로운 언어 기능도 비활성화합니다.</li></ul></blockquote><h3 id="널러블-타입-인수에-대한-캡처된-변환-부족으로-인한-타입-안정성-문제" tabindex="-1">널러블 타입 인수에 대한 캡처된 변환 부족으로 인한 타입 안정성 문제 <a class="header-anchor" href="#널러블-타입-인수에-대한-캡처된-변환-부족으로-인한-타입-안정성-문제" aria-label="Permalink to &quot;널러블 타입 인수에 대한 캡처된 변환 부족으로 인한 타입 안정성 문제&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-35487" target="_blank" rel="noreferrer">KT-35487</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 캡처된 타입과 널러블 타입 간의 서브타이핑이 런타임 오류로부터 보호하기 위해 더 정확해집니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-NewInference</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다. 이 플래그는 여러 새로운 언어 기능도 비활성화합니다.</li></ul></blockquote><h3 id="검사되지-않은-캐스트-후-공변-타입에-대한-교차-타입-유지" tabindex="-1">검사되지 않은 캐스트 후 공변 타입에 대한 교차 타입 유지 <a class="header-anchor" href="#검사되지-않은-캐스트-후-공변-타입에-대한-교차-타입-유지" aria-label="Permalink to &quot;검사되지 않은 캐스트 후 공변 타입에 대한 교차 타입 유지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-37280" target="_blank" rel="noreferrer">KT-37280</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 공변 타입의 검사되지 않은 캐스트는 검사되지 않은 캐스트의 타입이 아닌, 스마트 캐스트를 위해 교차 타입을 생성합니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-NewInference</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다. 이 플래그는 여러 새로운 언어 기능도 비활성화합니다.</li></ul></blockquote><h3 id="this-표현식-사용으로-인한-빌더-추론에서-타입-변수-누출" tabindex="-1"><code>this</code> 표현식 사용으로 인한 빌더 추론에서 타입 변수 누출 <a class="header-anchor" href="#this-표현식-사용으로-인한-빌더-추론에서-타입-변수-누출" aria-label="Permalink to &quot;`this` 표현식 사용으로 인한 빌더 추론에서 타입 변수 누출&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-32126" target="_blank" rel="noreferrer">KT-32126</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 <code>sequence {}</code>와 같은 빌더 함수 내에서 <code>this</code>를 사용하는 것은 다른 적절한 제약 조건이 없는 경우 금지됩니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-NewInference</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다. 이 플래그는 여러 새로운 언어 기능도 비활성화합니다.</li></ul></blockquote><h3 id="널러블-타입-인수가-있는-반공변-타입에-대한-잘못된-오버로드-확인" tabindex="-1">널러블 타입 인수가 있는 반공변 타입에 대한 잘못된 오버로드 확인 <a class="header-anchor" href="#널러블-타입-인수가-있는-반공변-타입에-대한-잘못된-오버로드-확인" aria-label="Permalink to &quot;널러블 타입 인수가 있는 반공변 타입에 대한 잘못된 오버로드 확인&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-31670" target="_blank" rel="noreferrer">KT-31670</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 반공변 타입 인수를 받는 함수의 두 오버로드 함수가 타입의 널러블 여부(예: <code>In&lt;T&gt;</code> 및 <code>In&lt;T?&gt;</code>)에 의해서만 다른 경우, 널러블 타입이 더 구체적인 것으로 간주됩니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-NewInference</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다. 이 플래그는 여러 새로운 언어 기능도 비활성화합니다.</li></ul></blockquote><h3 id="중첩되지-않은-재귀-제약-조건이-있는-빌더-추론" tabindex="-1">중첩되지 않은 재귀 제약 조건이 있는 빌더 추론 <a class="header-anchor" href="#중첩되지-않은-재귀-제약-조건이-있는-빌더-추론" aria-label="Permalink to &quot;중첩되지 않은 재귀 제약 조건이 있는 빌더 추론&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-34975" target="_blank" rel="noreferrer">KT-34975</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 전달된 람다 내에 재귀 제약 조건에 의존하는 타입을 가진 <code>sequence {}</code>와 같은 빌더 함수는 컴파일러 오류를 발생시킵니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-NewInference</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다. 이 플래그는 여러 새로운 언어 기능도 비활성화합니다.</li></ul></blockquote><h3 id="성급한-타입-변수-고정으로-인해-모순된-제약-조건-시스템-발생" tabindex="-1">성급한 타입 변수 고정으로 인해 모순된 제약 조건 시스템 발생 <a class="header-anchor" href="#성급한-타입-변수-고정으로-인해-모순된-제약-조건-시스템-발생" aria-label="Permalink to &quot;성급한 타입 변수 고정으로 인해 모순된 제약 조건 시스템 발생&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-25175" target="_blank" rel="noreferrer">KT-25175</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 특정 경우에 타입 추론이 덜 성급하게 작동하여 모순되지 않는 제약 조건 시스템을 찾을 수 있습니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-NewInference</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다. 이 플래그는 여러 새로운 언어 기능도 비활성화합니다.</li></ul></blockquote><h3 id="open-함수에-tailrec-수정자-금지" tabindex="-1">open 함수에 <code>tailrec</code> 수정자 금지 <a class="header-anchor" href="#open-함수에-tailrec-수정자-금지" aria-label="Permalink to &quot;open 함수에 `tailrec` 수정자 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-18541" target="_blank" rel="noreferrer">KT-18541</a></p><p><strong>구성 요소</strong>: 핵심 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 함수는 <code>open</code> 및 <code>tailrec</code> 수정자를 동시에 가질 수 없습니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: <code>open</code> 및 <code>tailrec</code> 수정자를 함께 가진 함수에 대해 경고 보고 (프로그레시브 모드에서는 오류).</li><li><code>&gt;=</code> 1.4: 이 경고를 오류로 상향 조정.</li></ul></blockquote><h3 id="동반-객체-클래스-자체보다-동반-객체의-instance-필드가-더-가시적임" tabindex="-1">동반 객체 클래스 자체보다 동반 객체의 <code>INSTANCE</code> 필드가 더 가시적임 <a class="header-anchor" href="#동반-객체-클래스-자체보다-동반-객체의-instance-필드가-더-가시적임" aria-label="Permalink to &quot;동반 객체 클래스 자체보다 동반 객체의 `INSTANCE` 필드가 더 가시적임&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-11567" target="_blank" rel="noreferrer">KT-11567</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 동반 객체가 private인 경우 해당 <code>INSTANCE</code> 필드도 private이 됩니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 컴파일러가 지원 중단(deprecated) 플래그가 있는 <code>INSTANCE</code> 객체를 생성</li><li><code>&gt;=</code> 1.4: 동반 객체 <code>INSTANCE</code> 필드에 적절한 가시성 적용</li></ul></blockquote><h3 id="반환-전에-삽입된-외부-finally-블록이-finally가-없는-내부-try-블록의-catch-간격에서-제외되지-않음" tabindex="-1">반환 전에 삽입된 외부 finally 블록이 finally가 없는 내부 try 블록의 catch 간격에서 제외되지 않음 <a class="header-anchor" href="#반환-전에-삽입된-외부-finally-블록이-finally가-없는-내부-try-블록의-catch-간격에서-제외되지-않음" aria-label="Permalink to &quot;반환 전에 삽입된 외부 finally 블록이 finally가 없는 내부 try 블록의 catch 간격에서 제외되지 않음&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-31923" target="_blank" rel="noreferrer">KT-31923</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: Kotlin 1.4부터 중첩된 <code>try/catch</code> 블록에 대해 catch 간격이 올바르게 계산됩니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-ProperFinally</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="공변-및-제네릭-특수화된-오버라이드를-위해-반환-타입-위치에서-인라인-클래스의-박싱된-버전-사용" tabindex="-1">공변 및 제네릭 특수화된 오버라이드를 위해 반환 타입 위치에서 인라인 클래스의 박싱된 버전 사용 <a class="header-anchor" href="#공변-및-제네릭-특수화된-오버라이드를-위해-반환-타입-위치에서-인라인-클래스의-박싱된-버전-사용" aria-label="Permalink to &quot;공변 및 제네릭 특수화된 오버라이드를 위해 반환 타입 위치에서 인라인 클래스의 박싱된 버전 사용&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-30419" target="_blank" rel="noreferrer">KT-30419</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: Kotlin 1.4부터 공변 및 제네릭 특수화된 오버라이드를 사용하는 함수는 인라인 클래스의 박싱된 값을 반환합니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경</li></ul></blockquote><h3 id="kotlin-인터페이스에-위임할-때-jvm-바이트코드에서-확인된-예외를-선언하지-마십시오" tabindex="-1">Kotlin 인터페이스에 위임할 때 JVM 바이트코드에서 확인된 예외를 선언하지 마십시오 <a class="header-anchor" href="#kotlin-인터페이스에-위임할-때-jvm-바이트코드에서-확인된-예외를-선언하지-마십시오" aria-label="Permalink to &quot;Kotlin 인터페이스에 위임할 때 JVM 바이트코드에서 확인된 예외를 선언하지 마십시오&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-35834" target="_blank" rel="noreferrer">KT-35834</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4는 Kotlin 인터페이스에 대한 인터페이스 위임 시 확인된 예외를 생성하지 않습니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-DoNotGenerateThrowsForDelegatedKotlinMembers</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="단일-가변-인자-vararg-매개변수를-사용하는-메서드에-대한-시그니처-다형성-호출의-동작-변경-인수를-다른-배열로-래핑하는-것을-방지하기-위해" tabindex="-1">단일 가변 인자(vararg) 매개변수를 사용하는 메서드에 대한 시그니처 다형성 호출의 동작 변경 (인수를 다른 배열로 래핑하는 것을 방지하기 위해) <a class="header-anchor" href="#단일-가변-인자-vararg-매개변수를-사용하는-메서드에-대한-시그니처-다형성-호출의-동작-변경-인수를-다른-배열로-래핑하는-것을-방지하기-위해" aria-label="Permalink to &quot;단일 가변 인자(vararg) 매개변수를 사용하는 메서드에 대한 시그니처 다형성 호출의 동작 변경 (인수를 다른 배열로 래핑하는 것을 방지하기 위해)&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-35469" target="_blank" rel="noreferrer">KT-35469</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4는 시그니처 다형성 호출에서 인수를 다른 배열로 래핑하지 않습니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경</li></ul></blockquote><h3 id="kclass가-제네릭-매개변수로-사용될-때-어노테이션의-잘못된-제네릭-시그니처" tabindex="-1">KClass가 제네릭 매개변수로 사용될 때 어노테이션의 잘못된 제네릭 시그니처 <a class="header-anchor" href="#kclass가-제네릭-매개변수로-사용될-때-어노테이션의-잘못된-제네릭-시그니처" aria-label="Permalink to &quot;KClass가 제네릭 매개변수로 사용될 때 어노테이션의 잘못된 제네릭 시그니처&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-35207" target="_blank" rel="noreferrer">KT-35207</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4는 KClass가 제네릭 매개변수로 사용될 때 어노테이션의 잘못된 타입 매핑을 수정합니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경</li></ul></blockquote><h3 id="시그니처-다형성-호출에서-spread-연산자-금지" tabindex="-1">시그니처 다형성 호출에서 spread 연산자 금지 <a class="header-anchor" href="#시그니처-다형성-호출에서-spread-연산자-금지" aria-label="Permalink to &quot;시그니처 다형성 호출에서 spread 연산자 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-35226" target="_blank" rel="noreferrer">KT-35226</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4는 시그니처 다형성 호출에서 spread 연산자(<code>*</code>)의 사용을 금지합니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 시그니처 다형성 호출에서 spread 연산자 사용 시 경고 보고</li><li><code>&gt;=</code> 1.5: 이 경고를 오류로 상향 조정 <code>-XXLanguage:-ProhibitSpreadOnSignaturePolymorphicCall</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="꼬리-재귀-최적화-함수의-기본값-초기화-순서-변경" tabindex="-1">꼬리 재귀 최적화 함수의 기본값 초기화 순서 변경 <a class="header-anchor" href="#꼬리-재귀-최적화-함수의-기본값-초기화-순서-변경" aria-label="Permalink to &quot;꼬리 재귀 최적화 함수의 기본값 초기화 순서 변경&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-31540" target="_blank" rel="noreferrer">KT-31540</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: Kotlin 1.4부터 꼬리 재귀 함수의 초기화 순서는 일반 함수와 동일합니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 문제가 있는 함수에 대해 선언 위치에서 경고 보고</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-ProperComputationOrderOfTailrecDefaultParameters</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="const가-아닌-val에-대해-constantvalue-속성을-생성하지-마십시오" tabindex="-1"><code>const</code>가 아닌 <code>val</code>에 대해 ConstantValue 속성을 생성하지 마십시오 <a class="header-anchor" href="#const가-아닌-val에-대해-constantvalue-속성을-생성하지-마십시오" aria-label="Permalink to &quot;`const`가 아닌 `val`에 대해 ConstantValue 속성을 생성하지 마십시오&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-16615" target="_blank" rel="noreferrer">KT-16615</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: Kotlin 1.4부터 컴파일러는 <code>const</code>가 아닌 <code>val</code>에 대해 <code>ConstantValue</code> 속성을 생성하지 않습니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: IntelliJ IDEA 검사를 통해 경고 보고</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-NoConstantValueAttributeForNonConstVals</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="open-메서드의-jvmoverloads에-대한-생성된-오버로드-함수는-final이어야-합니다" tabindex="-1">open 메서드의 <code>@JvmOverloads</code>에 대한 생성된 오버로드 함수는 <code>final</code>이어야 합니다 <a class="header-anchor" href="#open-메서드의-jvmoverloads에-대한-생성된-오버로드-함수는-final이어야-합니다" aria-label="Permalink to &quot;open 메서드의 `@JvmOverloads`에 대한 생성된 오버로드 함수는 `final`이어야 합니다&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-33240" target="_blank" rel="noreferrer">KT-33240</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: <code>@JvmOverloads</code>가 적용된 함수의 오버로드 함수는 <code>final</code>로 생성됩니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경 <code>-XXLanguage:-GenerateJvmOverloadsAsFinal</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="kotlin-result를-반환하는-람다는-이제-언박싱된-값-대신-박싱된-값을-반환합니다" tabindex="-1"><code>kotlin.Result</code>를 반환하는 람다는 이제 언박싱된 값 대신 박싱된 값을 반환합니다 <a class="header-anchor" href="#kotlin-result를-반환하는-람다는-이제-언박싱된-값-대신-박싱된-값을-반환합니다" aria-label="Permalink to &quot;`kotlin.Result`를 반환하는 람다는 이제 언박싱된 값 대신 박싱된 값을 반환합니다&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-39198" target="_blank" rel="noreferrer">KT-39198</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: Kotlin 1.4부터 <code>kotlin.Result</code> 타입의 값을 반환하는 람다는 언박싱된 값 대신 박싱된 값을 반환합니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경</li></ul></blockquote><h3 id="널-체크-예외-통합" tabindex="-1">널 체크 예외 통합 <a class="header-anchor" href="#널-체크-예외-통합" aria-label="Permalink to &quot;널 체크 예외 통합&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-22275" target="_blank" rel="noreferrer">KT-22275</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: Kotlin 1.4부터 모든 런타임 널 체크는 <code>java.lang.NullPointerException</code>을 throw합니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 런타임 널 체크는 <code>KotlinNullPointerException</code>, <code>IllegalStateException</code>, <code>IllegalArgumentException</code>, <code>TypeCastException</code> 등과 같은 다른 예외를 throw합니다.</li><li><code>&gt;=</code> 1.4: 모든 런타임 널 체크는 <code>java.lang.NullPointerException</code>을 throw합니다. <code>-Xno-unified-null-checks</code> 플래그를 사용하여 1.4 이전 동작으로 일시적으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="배열-리스트-연산-contains-indexof-lastindexof에서-부동-소수점-값-비교-ieee-754-또는-전체-순서" tabindex="-1">배열/리스트 연산 <code>contains</code>, <code>indexOf</code>, <code>lastIndexOf</code>에서 부동 소수점 값 비교: IEEE 754 또는 전체 순서 <a class="header-anchor" href="#배열-리스트-연산-contains-indexof-lastindexof에서-부동-소수점-값-비교-ieee-754-또는-전체-순서" aria-label="Permalink to &quot;배열/리스트 연산 `contains`, `indexOf`, `lastIndexOf`에서 부동 소수점 값 비교: IEEE 754 또는 전체 순서&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-28753" target="_blank" rel="noreferrer">KT-28753</a></p><p><strong>구성 요소</strong>: kotlin-stdlib (JVM)</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: <code>Double/FloatArray.asList()</code>에서 반환되는 <code>List</code> 구현은 <code>contains</code>, <code>indexOf</code>, <code>lastIndexOf</code>를 구현하여 전체 순서 동등성(total order equality)을 사용합니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경</li></ul></blockquote><h3 id="컬렉션-min-및-max-함수의-반환-타입을-점진적으로-널러블이-아닌-것으로-변경" tabindex="-1">컬렉션 <code>min</code> 및 <code>max</code> 함수의 반환 타입을 점진적으로 널러블이 아닌 것으로 변경 <a class="header-anchor" href="#컬렉션-min-및-max-함수의-반환-타입을-점진적으로-널러블이-아닌-것으로-변경" aria-label="Permalink to &quot;컬렉션 `min` 및 `max` 함수의 반환 타입을 점진적으로 널러블이 아닌 것으로 변경&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-38854" target="_blank" rel="noreferrer">KT-38854</a></p><p><strong>구성 요소</strong>: kotlin-stdlib (JVM)</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: 컬렉션 <code>min</code> 및 <code>max</code> 함수의 반환 타입은 1.6에서 널러블이 아닌 것으로 변경됩니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>1.4: <code>...OrNull</code> 함수를 동의어로 도입하고 영향을 받는 API를 비권장(deprecate)합니다 (이슈에서 자세한 내용 참조).</li><li>1.5.x: 영향을 받는 API의 비권장 수준을 오류로 상향 조정</li><li><code>&gt;=</code>1.6: 영향을 받는 API를 널러블이 아닌 반환 타입으로 재도입합니다.</li></ul></blockquote><h3 id="appendline을-선호하여-appendln-비권장" tabindex="-1"><code>appendLine</code>을 선호하여 <code>appendln</code> 비권장 <a class="header-anchor" href="#appendline을-선호하여-appendln-비권장" aria-label="Permalink to &quot;`appendLine`을 선호하여 `appendln` 비권장&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-38754" target="_blank" rel="noreferrer">KT-38754</a></p><p><strong>구성 요소</strong>: kotlin-stdlib (JVM)</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: <code>StringBuilder.appendln()</code>은 <code>StringBuilder.appendLine()</code>을 선호하여 비권장(deprecated)됩니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>1.4: <code>appendln</code>의 대체 함수로 <code>appendLine</code>을 도입하고 <code>appendln</code>을 비권장합니다.</li><li><code>&gt;=</code>1.5: 비권장 수준을 오류로 상향 조정</li></ul></blockquote><h3 id="부동-소수점-타입을-short-및-byte로-변환하는-것-비권장" tabindex="-1">부동 소수점 타입을 Short 및 Byte로 변환하는 것 비권장 <a class="header-anchor" href="#부동-소수점-타입을-short-및-byte로-변환하는-것-비권장" aria-label="Permalink to &quot;부동 소수점 타입을 Short 및 Byte로 변환하는 것 비권장&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-30360" target="_blank" rel="noreferrer">KT-30360</a></p><p><strong>구성 요소</strong>: kotlin-stdlib (JVM)</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 부동 소수점 타입을 <code>Short</code> 및 <code>Byte</code>로 변환하는 것이 비권장됩니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>1.4: <code>Double.toShort()/toByte()</code> 및 <code>Float.toShort()/toByte()</code>를 비권장하고 대체를 제안합니다.</li><li><code>&gt;=</code>1.5: 비권장 수준을 오류로 상향 조정</li></ul></blockquote><h3 id="유효하지-않은-startindex에서-regex-findall-빠르게-실패" tabindex="-1">유효하지 않은 <code>startIndex</code>에서 <code>Regex.findAll</code> 빠르게 실패 <a class="header-anchor" href="#유효하지-않은-startindex에서-regex-findall-빠르게-실패" aria-label="Permalink to &quot;유효하지 않은 `startIndex`에서 `Regex.findAll` 빠르게 실패&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-28356" target="_blank" rel="noreferrer">KT-28356</a></p><p><strong>구성 요소</strong>: kotlin-stdlib</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: Kotlin 1.4부터 <code>findAll</code>은 <code>findAll</code> 진입 시점에 <code>startIndex</code>가 입력 문자 시퀀스의 유효한 위치 인덱스 범위에 있는지 확인하도록 개선되며, 그렇지 않은 경우 <code>IndexOutOfBoundsException</code>을 throw합니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경</li></ul></blockquote><h3 id="비권장된-kotlin-coroutines-experimental-제거" tabindex="-1">비권장된 <code>kotlin.coroutines.experimental</code> 제거 <a class="header-anchor" href="#비권장된-kotlin-coroutines-experimental-제거" aria-label="Permalink to &quot;비권장된 `kotlin.coroutines.experimental` 제거&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-36083" target="_blank" rel="noreferrer">KT-36083</a></p><p><strong>구성 요소</strong>: kotlin-stdlib</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 비권장된 <code>kotlin.coroutines.experimental</code> API가 표준 라이브러리에서 제거됩니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: <code>kotlin.coroutines.experimental</code>은 <code>ERROR</code> 수준으로 비권장됩니다.</li><li><code>&gt;=</code> 1.4: <code>kotlin.coroutines.experimental</code>은 표준 라이브러리에서 제거됩니다. JVM에서는 별도의 호환성 아티팩트가 제공됩니다 (이슈에서 자세한 내용 참조).</li></ul></blockquote><h3 id="비권장된-mod-연산자-제거" tabindex="-1">비권장된 <code>mod</code> 연산자 제거 <a class="header-anchor" href="#비권장된-mod-연산자-제거" aria-label="Permalink to &quot;비권장된 `mod` 연산자 제거&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-26654" target="_blank" rel="noreferrer">KT-26654</a></p><p><strong>구성 요소</strong>: kotlin-stdlib</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.4부터 숫자 타입에 대한 <code>mod</code> 연산자가 표준 라이브러리에서 제거됩니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: <code>mod</code>는 <code>ERROR</code> 수준으로 비권장됩니다.</li><li><code>&gt;=</code> 1.4: <code>mod</code>는 표준 라이브러리에서 제거됩니다.</li></ul></blockquote><h3 id="throwable-addsuppressed-멤버-숨기기-및-대신-확장-함수-선호" tabindex="-1"><code>Throwable.addSuppressed</code> 멤버 숨기기 및 대신 확장 함수 선호 <a class="header-anchor" href="#throwable-addsuppressed-멤버-숨기기-및-대신-확장-함수-선호" aria-label="Permalink to &quot;`Throwable.addSuppressed` 멤버 숨기기 및 대신 확장 함수 선호&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-38777" target="_blank" rel="noreferrer">KT-38777</a></p><p><strong>구성 요소</strong>: kotlin-stdlib</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: <code>Throwable.addSuppressed()</code> 확장 함수가 이제 <code>Throwable.addSuppressed()</code> 멤버 함수보다 선호됩니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이전 동작 (이슈에서 자세한 내용 참조)</li><li><code>&gt;=</code> 1.4: 동작 변경</li></ul></blockquote><h3 id="capitalize는-이중음자를-제목-대소문자로-변환해야-합니다" tabindex="-1"><code>capitalize</code>는 이중음자를 제목 대소문자로 변환해야 합니다 <a class="header-anchor" href="#capitalize는-이중음자를-제목-대소문자로-변환해야-합니다" aria-label="Permalink to &quot;`capitalize`는 이중음자를 제목 대소문자로 변환해야 합니다&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-38817" target="_blank" rel="noreferrer">KT-38817</a></p><p><strong>구성 요소</strong>: kotlin-stdlib</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: <code>String.capitalize()</code> 함수는 이제 <a href="https://en.wikipedia.org/wiki/Gaj%27s_Latin_alphabet" target="_blank" rel="noreferrer">세르보크로아티아 가이 라틴 알파벳</a>의 이중음자를 제목 대소문자(<code>ǅ</code> 대신 <code>Ǆ</code>)로 대문자화합니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 이중음자는 대문자(<code>Ǆ</code>)로 대문자화됩니다.</li><li><code>&gt;=</code> 1.4: 이중음자는 제목 대소문자(<code>ǅ</code>)로 대문자화됩니다.</li></ul></blockquote><h2 id="도구" tabindex="-1">도구 <a class="header-anchor" href="#도구" aria-label="Permalink to &quot;도구&quot;">​</a></h2><h3 id="windows에서-구분-문자가-포함된-컴파일러-인수는-큰따옴표로-전달해야-합니다" tabindex="-1">Windows에서 구분 문자가 포함된 컴파일러 인수는 큰따옴표로 전달해야 합니다 <a class="header-anchor" href="#windows에서-구분-문자가-포함된-컴파일러-인수는-큰따옴표로-전달해야-합니다" aria-label="Permalink to &quot;Windows에서 구분 문자가 포함된 컴파일러 인수는 큰따옴표로 전달해야 합니다&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-41309" target="_blank" rel="noreferrer">KT-41309</a></p><p><strong>구성 요소</strong>: CLI</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: Windows에서 구분 문자(공백, <code>=</code>, <code>;</code>, <code>,</code>)를 포함하는 <code>kotlinc.bat</code> 인수는 이제 큰따옴표(<code>&quot;</code>)가 필요합니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 모든 컴파일러 인수는 따옴표 없이 전달됩니다.</li><li><code>&gt;=</code> 1.4: 구분 문자(공백, <code>=</code>, <code>;</code>, <code>,</code>)를 포함하는 컴파일러 인수는 큰따옴표(<code>&quot;</code>)가 필요합니다.</li></ul></blockquote><h3 id="kapt-속성에-대한-합성-annotations-메서드-이름이-변경됨" tabindex="-1">KAPT: 속성에 대한 합성 <code>$annotations()</code> 메서드 이름이 변경됨 <a class="header-anchor" href="#kapt-속성에-대한-합성-annotations-메서드-이름이-변경됨" aria-label="Permalink to &quot;KAPT: 속성에 대한 합성 `$annotations()` 메서드 이름이 변경됨&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-36926" target="_blank" rel="noreferrer">KT-36926</a></p><p><strong>구성 요소</strong>: KAPT</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: KAPT가 속성에 대해 생성하는 합성 <code>$annotations()</code> 메서드 이름이 1.4에서 변경되었습니다.</p><p><strong>지원 중단 주기</strong>:</p><ul><li>&lt; 1.4: 속성에 대한 합성 <code>$annotations()</code> 메서드 이름은 <code>&lt;propertyName&gt;@annotations()</code> 템플릿을 따릅니다.</li><li><code>&gt;=</code> 1.4: 속성에 대한 합성 <code>$annotations()</code> 메서드 이름은 <code>get</code> 접두사를 포함합니다: <code>get&lt;PropertyName&gt;@annotations()</code></li></ul></blockquote>',95)]))}const h=e(a,[["render",l]]);export{u as __pageData,h as default};
