import{_ as c,a as p,b as r}from"./chunks/tutorial_persistence_database_tool_window.CIMhXNzI.js";import{_ as h,C as t,c as k,o as u,j as e,G as i,ag as g,a as s,w as o}from"./chunks/framework.Bksy39di.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/ktor/db-persistence.md","filePath":"zh-Hant/ktor/db-persistence.md","lastUpdated":1755457140000}'),b={name:"zh-Hant/ktor/db-persistence.md"};function m(v,a,E,y,q,C){const d=t("show-structure"),l=t("tldr"),n=t("link-summary");return u(),k("div",null,[a[2]||(a[2]=e("h1",{id:"使用-exposed-實現資料庫持久性",tabindex:"-1"},[s("使用 Exposed 實現資料庫持久性 "),e("a",{class:"header-anchor",href:"#使用-exposed-實現資料庫持久性","aria-label":'Permalink to "使用 Exposed 實現資料庫持久性"'},"​")],-1)),i(d,{for:"chapter",depth:"2"}),i(l,null,{default:o(()=>a[0]||(a[0]=[e("p",null,[e("b",null,"程式碼範例"),s(": "),e("a",{href:"https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/tutorial-website-interactive-persistence"}," tutorial-website-interactive-persistence ")],-1),e("p",null,[e("b",null,"使用的函式庫"),s(": "),e("a",{href:"https://github.com/JetBrains/Exposed"},"Exposed"),s(", "),e("a",{href:"https://github.com/h2database/h2database"},"h2database")],-1)])),_:1}),i(n,null,{default:o(()=>a[1]||(a[1]=[s("學習如何使用 Exposed ORM 框架為網站新增持久性。")])),_:1}),a[3]||(a[3]=g(`<p>在本系列教程中，我們將向您展示如何在 Ktor 中建立一個簡單的部落格應用程式：</p><ul><li>在第一個教程中，我們展示了如何託管靜態內容，如圖片和 HTML 頁面。</li><li>在第二個教程中，我們使用 FreeMarker 模板引擎為應用程式新增了互動性。</li><li>在<strong>本教程</strong>中，我們將使用 Exposed 框架為網站新增持久性。我們將使用 H2 本地資料庫來儲存文章。</li><li>在<a href="./db-connection-pooling-caching">下一個教程</a>中，我們將探討如何分別使用 HikariCP 和 Ehcache 函式庫實現資料庫連線池化和快取。</li></ul><h2 id="add-dependencies" tabindex="-1">新增依賴項 <a class="header-anchor" href="#add-dependencies" aria-label="Permalink to &quot;新增依賴項 {id=&quot;add-dependencies&quot;}&quot;">​</a></h2><p>首先，您需要新增 Exposed 和 H2 函式庫的依賴項。開啟 <code>gradle.properties</code> 檔案並指定函式庫版本：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">exposed_version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.53</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">h2_version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">232</span></span></code></pre></div><p>然後，開啟 <code>build.gradle.kts</code> 並新增以下依賴項：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>點擊 <code>build.gradle.kts</code> 檔案右上角的 <strong>載入 Gradle 變更</strong> 圖示，以安裝新新增的依賴項。</p><h2 id="model" tabindex="-1">更新模型 <a class="header-anchor" href="#model" aria-label="Permalink to &quot;更新模型 {id=&quot;model&quot;}&quot;">​</a></h2><p>Exposed 使用 <code>org.jetbrains.exposed.sql.Table</code> 類別作為資料庫表格。要更新 <code>Article</code> 模型，開啟 <code>models/Article.kt</code> 檔案並用以下程式碼替換現有程式碼：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p><code>id</code>、<code>title</code> 和 <code>body</code> 欄位將儲存我們文章的資訊。<code>id</code> 欄位將作為主鍵。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如果您<a href="https://www.jetbrains.com/help/idea/viewing-reference-information.html#type-info" target="_blank" rel="noreferrer">檢查</a> <code>Articles</code> 物件中屬性的類型，您會發現它們具有 <code>Column</code> 類型以及必要的類型引數：<code>id</code> 具有 <code>Column&lt;Int&gt;</code> 類型，而 <code>title</code> 和 <code>body</code> 都具有 <code>Column&lt;String&gt;</code> 類型。</p></div><h2 id="connect_db" tabindex="-1">連線到資料庫 <a class="header-anchor" href="#connect_db" aria-label="Permalink to &quot;連線到資料庫 {id=&quot;connect_db&quot;}&quot;">​</a></h2><p><a href="https://en.wikipedia.org/wiki/Data_access_object" target="_blank" rel="noreferrer">資料存取物件</a> (DAO) 是一種模式，提供資料庫介面而不會暴露特定資料庫的細節。我們稍後將定義一個 <code>DAOFacade</code> 介面，以抽象化我們對資料庫的特定請求。</p><p>每次使用 Exposed 存取資料庫都始於取得資料庫連線。為此，您將 JDBC URL 和驅動程式類別名稱傳遞給 <code>Database.connect</code> 函數。在 <code>com.example</code> 內部建立 <code>dao</code> 套件並新增一個 <code>DatabaseSingleton.kt</code> 檔案。然後，插入這段程式碼：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><blockquote><p>請注意，<code>driverClassName</code> 和 <code>jdbcURL</code> 在此處是硬編碼的。Ktor 允許您將此類設定提取到<a href="./server-configuration-file">自訂設定組</a>。</p></blockquote><h3 id="create_table" tabindex="-1">建立表格 <a class="header-anchor" href="#create_table" aria-label="Permalink to &quot;建立表格 {id=&quot;create_table&quot;}&quot;">​</a></h3><p>取得連線後，所有 SQL 語句都應該放在事務中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> database </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Database.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jdbcURL, driverClassName)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transaction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(database) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Statements here</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在此程式碼範例中，預設資料庫被明確傳遞給 <code>transaction</code> 函數。如果您只有一個資料庫，可以省略它。在這種情況下，Exposed 會自動使用最後連線的資料庫進行事務。</p><blockquote><p>請注意，<code>Database.connect</code> 函數直到您呼叫事務才會建立實際的資料庫連線 — 它只為未來的連線建立一個描述符。</p></blockquote><p>鑑於 <code>Articles</code> 表格已經宣告，我們可以將 <code>SchemaUtils.create(Articles)</code> 呼叫包裹在 <code>transaction</code> 呼叫中，放在 <code>init</code> 函數底部，以指示資料庫在該表格不存在時建立它：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> database </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Database.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jdbcURL, driverClassName)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transaction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(database) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        SchemaUtils.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Articles)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="queries" tabindex="-1">執行查詢 <a class="header-anchor" href="#queries" aria-label="Permalink to &quot;執行查詢 {id=&quot;queries&quot;}&quot;">​</a></h3><p>為方便起見，讓我們在 <code>DatabaseSingleton</code> 物件中建立一個實用函數 <code>dbQuery</code>，我們將在所有未來對資料庫的請求中使用它。我們不使用事務以阻塞方式存取它，而是利用協程並在每個查詢的獨立協程中啟動它：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>最終的 <code>DatabaseSingleton.kt</code> 檔案應如下所示：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h3 id="startup" tabindex="-1">在啟動時載入資料庫設定 <a class="header-anchor" href="#startup" aria-label="Permalink to &quot;在啟動時載入資料庫設定 {id=&quot;startup&quot;}&quot;">​</a></h3><p>最後，我們需要在應用程式啟動時載入建立的設定。開啟 <code>Application.kt</code> 並從 <code>Application.module</code> 主體呼叫 <code>DatabaseSingleton.init</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h2 id="persistence_logic" tabindex="-1">實現持久性邏輯 <a class="header-anchor" href="#persistence_logic" aria-label="Permalink to &quot;實現持久性邏輯 {id=&quot;persistence_logic&quot;}&quot;">​</a></h2><p>現在讓我們建立一個介面來抽象化更新文章所需的操作。在 <code>dao</code> 套件中建立 <code>DAOFacade.kt</code> 檔案並填入以下程式碼：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>我們需要列出所有文章、按 ID 查看文章、新增文章、編輯或刪除文章。由於所有這些函數在底層執行資料庫查詢，因此它們被定義為掛起函數。</p><p>要實現 <code>DAOFacade</code> 介面，請將游標放在其名稱上，點擊該介面旁邊的黃色燈泡圖示並選擇 <strong>Implement interface</strong>。在彈出的對話框中，保留預設設定並點擊 <strong>OK</strong>。</p><p>在 <strong>Implement Members</strong> 對話框中，選擇所有函數並點擊 <strong>OK</strong>。</p><p><img src="`+c+'" alt="Implement Members" width="451"></p><p>IntelliJ IDEA 會在 <code>dao</code> 套件中建立 <code>DAOFacadeImpl.kt</code> 檔案。讓我們使用 Exposed DSL 實現所有函數。</p><h3 id="get_all" tabindex="-1">獲取所有文章 <a class="header-anchor" href="#get_all" aria-label="Permalink to &quot;獲取所有文章 {id=&quot;get_all&quot;}&quot;">​</a></h3><p>讓我們從一個返回所有條目的函數開始。我們的請求被包裝在 <code>dbQuery</code> 呼叫中。我們呼叫 <code>Table.selectAll</code> 擴充函數以從資料庫中獲取所有資料。<code>Articles</code> 物件是 <code>Table</code> 的子類別，因此我們使用 Exposed DSL 方法來操作它。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p><code>Table.selectAll</code> 返回一個 <code>Query</code> 實例，因此要獲取 <code>Article</code> 實例列表，我們需要手動提取每行的資料並將其轉換為我們的資料類別。我們使用輔助函數 <code>resultRowToArticle</code> 來完成此操作，該函數從 <code>ResultRow</code> 構建一個 <code>Article</code>。</p><p><code>ResultRow</code> 提供了一種使用簡潔的 <code>get</code> 運算符獲取指定 <code>Column</code> 中儲存資料的方法，允許我們使用類似於陣列或映射的方括號語法。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>Articles.id</code> 的類型是 <code>Column&lt;Int&gt;</code>，它實現了 <code>Expression</code> 介面。這就是為什麼我們可以將任何欄位作為表達式傳遞的原因。</p></div><h3 id="get_article" tabindex="-1">獲取一篇文章 <a class="header-anchor" href="#get_article" aria-label="Permalink to &quot;獲取一篇文章 {id=&quot;get_article&quot;}&quot;">​</a></h3><p>現在讓我們實現一個返回一篇文章的函數：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p><code>select</code> 函數接受一個擴充 lambda 作為引數。此 lambda 內的隱式接收器類型為 <code>SqlExpressionBuilder</code>。您不需要顯式使用此類型，但它定義了許多對欄位有用的操作，您可以使用這些操作來建構查詢。您可以使用比較 (<code>eq</code>、<code>less</code>、<code>greater</code>)、算術運算 (<code>plus</code>、<code>times</code>)、檢查值是否屬於或不屬於提供的清單 (<code>inList</code>、<code>notInList</code>)、檢查值是否為 null 或非 null，以及更多。</p><p><code>select</code> 返回一個 <code>Query</code> 值列表。像以前一樣，我們將它們轉換為文章。在我們的情況下，它應該是一篇文章，所以我們將其作為結果返回。</p><h3 id="add_article" tabindex="-1">新增文章 <a class="header-anchor" href="#add_article" aria-label="Permalink to &quot;新增文章 {id=&quot;add_article&quot;}&quot;">​</a></h3><p>要將新文章插入表格，請使用 <code>Table.insert</code> 函數，它接受一個 lambda 引數：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>在這個 lambda 內部，我們指定哪個值應該設定給哪個欄位。<code>it</code> 引數的類型是 <code>InsertStatement</code>，我們可以在其上呼叫 <code>set</code> 運算符，該運算符接受欄位和值作為引數。</p><h3 id="edit_article" tabindex="-1">編輯文章 <a class="header-anchor" href="#edit_article" aria-label="Permalink to &quot;編輯文章 {id=&quot;edit_article&quot;}&quot;">​</a></h3><p>要更新現有文章，請使用 <code>Table.update</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h3 id="delete_article" tabindex="-1">刪除文章 <a class="header-anchor" href="#delete_article" aria-label="Permalink to &quot;刪除文章 {id=&quot;delete_article&quot;}&quot;">​</a></h3><p>最後，使用 <code>Table.deleteWhere</code> 從資料庫中移除一篇文章：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h3 id="init-dao-facade" tabindex="-1">初始化 DAOFacade <a class="header-anchor" href="#init-dao-facade" aria-label="Permalink to &quot;初始化 DAOFacade {id=&quot;init-dao-facade&quot;}&quot;">​</a></h3><p>讓我們建立一個 <code>DAOFacade</code> 實例，並在應用程式啟動前將一篇範例文章插入資料庫。 在 <code>DAOFacadeImpl.kt</code> 底部新增以下程式碼：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h2 id="update_routes" tabindex="-1">更新路由 <a class="header-anchor" href="#update_routes" aria-label="Permalink to &quot;更新路由 {id=&quot;update_routes&quot;}&quot;">​</a></h2><p>現在我們已準備好在路由處理器內部使用已實現的資料庫操作。 開啟 <code>plugins/Routing.kt</code> 檔案。 要顯示所有文章，請在 <code>get</code> 處理器內部呼叫 <code>dao.allArticles</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>要發佈新文章，請在 <code>post</code> 內部呼叫 <code>dao.addNewArticle</code> 函數：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>要獲取用於顯示和編輯的文章，請分別在 <code>get(&quot;{id}&quot;)</code> 和 <code>get(&quot;{id}/edit&quot;)</code> 內部使用 <code>dao.article</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>最後，前往 <code>post(&quot;{id}&quot;)</code> 處理器並使用 <code>dao.editArticle</code> 更新文章，使用 <code>dao.deleteArticle</code> 刪除文章：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><blockquote><p>您可以在此處找到本教學課程的最終專案：<a href="https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/tutorial-website-interactive-persistence" target="_blank" rel="noreferrer">tutorial-website-interactive-persistence</a>。</p></blockquote><h2 id="run_app" tabindex="-1">執行應用程式 <a class="header-anchor" href="#run_app" aria-label="Permalink to &quot;執行應用程式 {id=&quot;run_app&quot;}&quot;">​</a></h2><p>讓我們看看我們的日誌應用程式是否按預期執行。我們可以透過點擊 <code>Application.kt</code> 中 <code>fun main(...)</code> 旁邊的 <strong>執行</strong> 按鈕來執行我們的應用程式：</p><p><img src="'+p+'" alt="Run Server" width="706"></p><p>IntelliJ IDEA 將啟動應用程式，幾秒鐘後，我們應該會看到應用程式正在執行的確認訊息：</p><div class="language-Bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[main] INFO  Application - Responding at http://0.0.0.0:8080</span></span></code></pre></div><p>在瀏覽器中開啟 <a href="http://localhost:8080/" target="_blank" rel="noreferrer"><code>http://localhost:8080/</code></a> 並嘗試建立、編輯和刪除文章。文章將儲存到 <code>build/db.mv.db</code> 檔案中。在 IntelliJ IDEA 中，您可以在<a href="https://www.jetbrains.com/help/idea/database-tool-window.html" target="_blank" rel="noreferrer">資料庫工具視窗</a>中查看此檔案的內容。</p><p><img src="'+r+'" alt="Database tool window" width="706"></p>',82))])}const A=h(b,[["render",m]]);export{f as __pageData,A as default};
