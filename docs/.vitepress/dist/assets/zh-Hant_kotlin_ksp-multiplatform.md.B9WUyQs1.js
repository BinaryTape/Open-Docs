import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.Bksy39di.js";const E=JSON.parse('{"title":"KSP 與 Kotlin 多平台","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/ksp-multiplatform.md","filePath":"zh-Hant/kotlin/ksp-multiplatform.md","lastUpdated":1754307826000}'),e={name:"zh-Hant/kotlin/ksp-multiplatform.md"};function l(p,s,k,h,o,d){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="ksp-與-kotlin-多平台" tabindex="-1">KSP 與 Kotlin 多平台 <a class="header-anchor" href="#ksp-與-kotlin-多平台" aria-label="Permalink to &quot;KSP 與 Kotlin 多平台&quot;">​</a></h1><p>如需快速入門，請參閱一個定義了 KSP 處理器的<a href="https://github.com/google/ksp/tree/main/examples/multiplatform" target="_blank" rel="noreferrer">Kotlin 多平台專案範例</a>。</p><p>從 KSP 1.0.1 開始，在多平台專案上套用 KSP 的方式與在單一平台、JVM 專案上的方式類似。主要差異在於，不再是將 <code>ksp(...)</code> 配置寫在依賴項中，而是使用 <code>add(ksp&lt;Target&gt;)</code> 或 <code>add(ksp&lt;SourceSet&gt;)</code> 來指定哪些編譯目標需要在編譯前進行符號處理。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">plugins</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;multiplatform&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;com.google.devtools.ksp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    linuxX64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        binaries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            executable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;kspCommonMainMetadata&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">project</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;:test-processor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;kspJvm&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">project</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;:test-processor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;kspJvmTest&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">project</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;:test-processor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 由於 JVM 沒有測試原始碼集，所以不起作用</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Linux x64 main 原始碼集沒有處理，因為未指定 kspLinuxX64</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // add(&quot;kspLinuxX64Test&quot;, project(&quot;:test-processor&quot;))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="編譯與處理" tabindex="-1">編譯與處理 <a class="header-anchor" href="#編譯與處理" aria-label="Permalink to &quot;編譯與處理&quot;">​</a></h2><p>在多平台專案中，Kotlin 編譯可能會針對每個平台發生多次（<code>main</code>、<code>test</code> 或其他建置變體）。符號處理亦是如此。每當存在 Kotlin 編譯任務且指定了對應的 <code>ksp&lt;Target&gt;</code> 或 <code>ksp&lt;SourceSet&gt;</code> 配置時，就會建立一個符號處理任務。</p><p>例如，在上述的 <code>build.gradle.kts</code> 中，有 4 個編譯任務：<code>common/metadata</code>、JVM <code>main</code>、Linux x64 <code>main</code>、Linux x64 <code>test</code>，以及 3 個符號處理任務：<code>common/metadata</code>、JVM <code>main</code>、Linux x64 <code>test</code>。</p><h2 id="避免在-ksp-1-0-1-中使用-ksp-配置" tabindex="-1">避免在 KSP 1.0.1+ 中使用 <code>ksp(...)</code> 配置 <a class="header-anchor" href="#避免在-ksp-1-0-1-中使用-ksp-配置" aria-label="Permalink to &quot;避免在 KSP 1.0.1+ 中使用 \`ksp(...)\` 配置&quot;">​</a></h2><p>在 KSP 1.0.1 之前，只有一個統一的 <code>ksp(...)</code> 配置可用。因此，處理器要麼適用於所有編譯目標，要麼完全不適用。請注意，<code>ksp(...)</code> 配置不僅適用於 <code>main</code> 原始碼集，如果存在的話，也適用於 <code>test</code> 原始碼集，即使在傳統的非多平台專案上也是如此。這給建置時間帶來了不必要的開銷。</p><p>從 KSP 1.0.1 開始，提供了針對每個目標的配置，如上述範例所示。未來：</p><ol><li>對於多平台專案，<code>ksp(...)</code> 配置將被棄用並移除。</li><li>對於單一平台專案，<code>ksp(...)</code> 配置將只適用於 <code>main</code>、預設編譯。其他目標，例如 <code>test</code>，將需要指定 <code>kspTest(...)</code> 才能套用處理器。</li></ol><p>從 KSP 1.0.1 開始，有一個早期存取旗標 <code>-DallowAllTargetConfiguration=false</code> 用於切換到更高效的行為。如果目前的行為導致效能問題，請嘗試使用它。該旗標的預設值將在 KSP 2.0 中從 <code>true</code> 翻轉為 <code>false</code>。</p>`,12)]))}const c=i(e,[["render",l]]);export{E as __pageData,c as default};
