import{_ as a,c as i,o as e,ag as s}from"./chunks/framework.Bksy39di.js";const k=JSON.parse('{"title":"運算子多載","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/operator-overloading.md","filePath":"zh-Hant/kotlin/operator-overloading.md","lastUpdated":1754307826000}'),d={name:"zh-Hant/kotlin/operator-overloading.md"};function o(n,t,l,h,c,r){return e(),i("div",null,t[0]||(t[0]=[s(`<h1 id="運算子多載" tabindex="-1">運算子多載 <a class="header-anchor" href="#運算子多載" aria-label="Permalink to &quot;運算子多載&quot;">​</a></h1><p>Kotlin 允許您為預定義的型別運算子提供自訂實作。這些運算子具有預定義的符號表示法（例如 <code>+</code> 或 <code>*</code>）和優先順序。若要實作運算子，請為對應的型別提供一個<a href="/zh-Hant/kotlin/functions#member-functions">成員函數</a>或<a href="/zh-Hant/kotlin/extensions">擴充函數</a>，並指定其名稱。此型別會成為二元運算的左側型別，以及一元運算的引數型別。</p><p>若要多載運算子，請使用 <code>operator</code> 修飾符標記對應的函數：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IndexedContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    operator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="/zh-Hant/kotlin/inheritance#overriding-methods">覆寫</a>您的運算子多載時，您可以省略 <code>operator</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OrdersList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IndexedContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*...*/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="一元運算" tabindex="-1">一元運算 <a class="header-anchor" href="#一元運算" aria-label="Permalink to &quot;一元運算&quot;">​</a></h2><h3 id="一元前綴運算子" tabindex="-1">一元前綴運算子 <a class="header-anchor" href="#一元前綴運算子" aria-label="Permalink to &quot;一元前綴運算子&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表達式</th><th>轉換為</th></tr></thead><tbody><tr><td><code>+a</code></td><td><code>a.unaryPlus()</code></td></tr><tr><td><code>-a</code></td><td><code>a.unaryMinus()</code></td></tr><tr><td><code>!a</code></td><td><code>a.not()</code></td></tr></tbody></table><p>此表格表示，當編譯器處理例如表達式 <code>+a</code> 時，它會執行以下步驟：</p><ul><li>決定 <code>a</code> 的型別，假設為 <code>T</code>。</li><li>尋找一個帶有 <code>operator</code> 修飾符且沒有參數的 <code>unaryPlus()</code> 函數，適用於接收者 <code>T</code>，這表示一個成員函數或一個擴充函數。</li><li>如果函數不存在或模稜兩可，則為編譯錯誤。</li><li>如果函數存在且其回傳型別為 <code>R</code>，則表達式 <code>+a</code> 的型別為 <code>R</code>。</li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>這些運算，以及所有其他運算，都針對<a href="/zh-Hant/kotlin/basic-types">基本型別</a>進行了優化，並且不會引入函數呼叫的額外開銷。</p></div><p>作為範例，以下說明如何多載一元負號運算子：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">operator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unaryMinus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">y)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> point </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">point)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// prints &quot;Point(x=-10, y=-20)&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="遞增與遞減" tabindex="-1">遞增與遞減 <a class="header-anchor" href="#遞增與遞減" aria-label="Permalink to &quot;遞增與遞減&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表達式</th><th>轉換為</th></tr></thead><tbody><tr><td><code>a++</code></td><td><code>a.inc()</code> + 見下方</td></tr><tr><td><code>a--</code></td><td><code>a.dec()</code> + 見下方</td></tr></tbody></table><p><code>inc()</code> 和 <code>dec()</code> 函數必須回傳一個值，該值將被指派給使用 <code>++</code> 或 <code>--</code> 運算的變數。它們不應修改被呼叫 <code>inc</code> 或 <code>dec</code> 的物件。</p><p>編譯器執行以下步驟來解析<em>後綴</em>形式的運算子，例如 <code>a++</code>：</p><ul><li>決定 <code>a</code> 的型別，假設為 <code>T</code>。</li><li>尋找一個帶有 <code>operator</code> 修飾符且沒有參數的 <code>inc()</code> 函數，適用於型別 <code>T</code> 的接收者。</li><li>檢查函數的回傳型別是否為 <code>T</code> 的子型別。</li></ul><p>計算表達式的效果是：</p><ul><li>將 <code>a</code> 的初始值儲存到暫存儲存區 <code>a0</code>。</li><li>將 <code>a0.inc()</code> 的結果指派給 <code>a</code>。</li><li>回傳 <code>a0</code> 作為表達式的結果。</li></ul><p>對於 <code>a--</code>，步驟完全相似。</p><p>對於<em>前綴</em>形式 <code>++a</code> 和 <code>--a</code>，解析方式相同，其效果是：</p><ul><li>將 <code>a.inc()</code> 的結果指派給 <code>a</code>。</li><li>回傳 <code>a</code> 的新值作為表達式的結果。</li></ul><h2 id="二元運算" tabindex="-1">二元運算 <a class="header-anchor" href="#二元運算" aria-label="Permalink to &quot;二元運算&quot;">​</a></h2><h3 id="算術運算子" tabindex="-1">算術運算子 <a class="header-anchor" href="#算術運算子" aria-label="Permalink to &quot;算術運算子&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表達式</th><th>轉換為</th></tr></thead><tbody><tr><td><code>a + b</code></td><td><code>a.plus(b)</code></td></tr><tr><td><code>a - b</code></td><td><code>a.minus(b)</code></td></tr><tr><td><code>a * b</code></td><td><code>a.times(b)</code></td></tr><tr><td><code>a / b</code></td><td><code>a.div(b)</code></td></tr><tr><td><code>a % b</code></td><td><code>a.rem(b)</code></td></tr><tr><td><code>a..b</code></td><td><code>a.rangeTo(b)</code></td></tr><tr><td><code>a..&lt;b</code></td><td><code>a.rangeUntil(b)</code></td></tr></tbody></table><p>對於此表格中的運算，編譯器僅解析<em>轉換為</em>欄位中的表達式。</p><p>以下是 <code>Counter</code> 類別的範例，它以給定值開始，並可以使用多載的 <code>+</code> 運算子進行遞增：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dayIndex: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    operator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> plus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(increment: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dayIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> increment)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="in-運算子" tabindex="-1"><code>in</code> 運算子 <a class="header-anchor" href="#in-運算子" aria-label="Permalink to &quot;\`in\` 運算子&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表達式</th><th>轉換為</th></tr></thead><tbody><tr><td><code>a in b</code></td><td><code>b.contains(a)</code></td></tr><tr><td><code>a !in b</code></td><td><code>!b.contains(a)</code></td></tr></tbody></table><p>對於 <code>in</code> 和 <code>!in</code>，過程相同，但引數順序相反。</p><h3 id="索引存取運算子" tabindex="-1">索引存取運算子 <a class="header-anchor" href="#索引存取運算子" aria-label="Permalink to &quot;索引存取運算子&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表達式</th><th>轉換為</th></tr></thead><tbody><tr><td><code>a[i]</code></td><td><code>a.get(i)</code></td></tr><tr><td><code>a[i, j]</code></td><td><code>a.get(i, j)</code></td></tr><tr><td><code>a[i_1, ..., i_n]</code></td><td><code>a.get(i_1, ..., i_n)</code></td></tr><tr><td><code>a[i] = b</code></td><td><code>a.set(i, b)</code></td></tr><tr><td><code>a[i, j] = b</code></td><td><code>a.set(i, j, b)</code></td></tr><tr><td><code>a[i_1, ..., i_n] = b</code></td><td><code>a.set(i_1, ..., i_n, b)</code></td></tr></tbody></table><p>方括號會轉換為對 <code>get</code> 和 <code>set</code> 的呼叫，並帶有適當數量的引數。</p><h3 id="invoke-運算子" tabindex="-1"><code>invoke</code> 運算子 <a class="header-anchor" href="#invoke-運算子" aria-label="Permalink to &quot;\`invoke\` 運算子&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表達式</th><th>轉換為</th></tr></thead><tbody><tr><td><code>a()</code></td><td><code>a.invoke()</code></td></tr><tr><td><code>a(i)</code></td><td><code>a.invoke(i)</code></td></tr><tr><td><code>a(i, j)</code></td><td><code>a.invoke(i, j)</code></td></tr><tr><td><code>a(i_1, ..., i_n)</code></td><td><code>a.invoke(i_1, ..., i_n)</code></td></tr></tbody></table><p>圓括號會轉換為對 <code>invoke</code> 的呼叫，並帶有適當數量的引數。</p><h3 id="複合指派運算" tabindex="-1">複合指派運算 <a class="header-anchor" href="#複合指派運算" aria-label="Permalink to &quot;複合指派運算&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表達式</th><th>轉換為</th></tr></thead><tbody><tr><td><code>a += b</code></td><td><code>a.plusAssign(b)</code></td></tr><tr><td><code>a -= b</code></td><td><code>a.minusAssign(b)</code></td></tr><tr><td><code>a *= b</code></td><td><code>a.timesAssign(b)</code></td></tr><tr><td><code>a /= b</code></td><td><code>a.divAssign(b)</code></td></tr><tr><td><code>a %= b</code></td><td><code>a.remAssign(b)</code></td></tr></tbody></table><p>對於指派運算，例如 <code>a += b</code>，編譯器執行以下步驟：</p><ul><li>如果右欄中的函數可用： <ul><li>如果對應的二元函數（即 <code>plusAssign()</code> 對應 <code>plus()</code>）也可用，<code>a</code> 是一個可變變數，並且 <code>plus</code> 的回傳型別是 <code>a</code> 型別的子型別，則回報錯誤（歧義）。</li><li>確保其回傳型別為 <code>Unit</code>，否則回報錯誤。</li><li>為 <code>a.plusAssign(b)</code> 產生程式碼。</li></ul></li><li>否則，嘗試為 <code>a = a + b</code> 產生程式碼（這包括型別檢查：<code>a + b</code> 的型別必須是 <code>a</code> 的子型別）。</li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>在 Kotlin 中，指派<em>不是</em>表達式。</p></div><h3 id="等式與不等式運算子" tabindex="-1">等式與不等式運算子 <a class="header-anchor" href="#等式與不等式運算子" aria-label="Permalink to &quot;等式與不等式運算子&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表達式</th><th>轉換為</th></tr></thead><tbody><tr><td><code>a == b</code></td><td><code>a?.equals(b) ?: (b === null)</code></td></tr><tr><td><code>a != b</code></td><td><code>!(a?.equals(b) ?: (b === null))</code></td></tr></tbody></table><p>這些運算子僅適用於函數 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/equals.html" target="_blank" rel="noreferrer"><code>equals(other: Any?): Boolean</code></a>，該函數可以被覆寫以提供自訂等式檢查實作。任何其他同名函數（例如 <code>equals(other: Foo)</code>）將不會被呼叫。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p><code>===</code> 和 <code>!==</code> (身份檢查) 無法多載，因此沒有為它們定義慣例。</p></div><p><code>==</code> 運算很特殊：它會轉換為一個複雜的表達式，用於篩選 <code>null</code> 值。 <code>null == null</code> 始終為 true，對於非 <code>null</code> 的 <code>x</code> 來說，<code>x == null</code> 始終為 false 且不會呼叫 <code>x.equals()</code>。</p><h3 id="比較運算子" tabindex="-1">比較運算子 <a class="header-anchor" href="#比較運算子" aria-label="Permalink to &quot;比較運算子&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表達式</th><th>轉換為</th></tr></thead><tbody><tr><td><code>a &gt; b</code></td><td><code>a.compareTo(b) &gt; 0</code></td></tr><tr><td><code>a &lt; b</code></td><td><code>a.compareTo(b) &lt; 0</code></td></tr><tr><td><code>a &gt;= b</code></td><td><code>a.compareTo(b) &gt;= 0</code></td></tr><tr><td><code>a &lt;= b</code></td><td><code>a.compareTo(b) &lt;= 0</code></td></tr></tbody></table><p>所有比較都會轉換為對 <code>compareTo</code> 的呼叫，該函數必須回傳 <code>Int</code>。</p><h3 id="屬性委託運算子" tabindex="-1">屬性委託運算子 <a class="header-anchor" href="#屬性委託運算子" aria-label="Permalink to &quot;屬性委託運算子&quot;">​</a></h3><p><code>provideDelegate</code>、<code>getValue</code> 和 <code>setValue</code> 運算子函數在<a href="/zh-Hant/kotlin/delegated-properties">委託屬性</a>中進行了描述。</p><h2 id="具名函數的中綴呼叫" tabindex="-1">具名函數的中綴呼叫 <a class="header-anchor" href="#具名函數的中綴呼叫" aria-label="Permalink to &quot;具名函數的中綴呼叫&quot;">​</a></h2><p>您可以透過使用<a href="/zh-Hant/kotlin/functions#infix-notation">中綴函數呼叫</a>來模擬自訂中綴運算。</p>`,56)]))}const E=a(d,[["render",o]]);export{k as __pageData,E as default};
