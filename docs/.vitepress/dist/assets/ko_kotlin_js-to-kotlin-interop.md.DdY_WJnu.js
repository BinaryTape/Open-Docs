import{_ as i,c as a,o as t,ag as e}from"./chunks/framework.Bksy39di.js";const c=JSON.parse('{"title":"JavaScript에서 Kotlin 코드 사용하기","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/js-to-kotlin-interop.md","filePath":"ko/kotlin/js-to-kotlin-interop.md","lastUpdated":1754307826000}'),n={name:"ko/kotlin/js-to-kotlin-interop.md"};function l(p,s,d,h,o,k){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="javascript에서-kotlin-코드-사용하기" tabindex="-1">JavaScript에서 Kotlin 코드 사용하기 <a class="header-anchor" href="#javascript에서-kotlin-코드-사용하기" aria-label="Permalink to &quot;JavaScript에서 Kotlin 코드 사용하기&quot;">​</a></h1><p>선택한 <a href="/ko/kotlin/js-modules">JavaScript 모듈</a> 시스템에 따라 Kotlin/JS 컴파일러는 다른 출력을 생성합니다. 하지만 일반적으로 Kotlin 컴파일러는 일반 JavaScript 클래스, 함수 및 속성을 생성하며, 이를 JavaScript 코드에서 자유롭게 사용할 수 있습니다. 단, 몇 가지 세부 사항을 기억해야 합니다.</p><h2 id="plain-모드에서-별도의-javascript-객체로-선언-격리" tabindex="-1">plain 모드에서 별도의 JavaScript 객체로 선언 격리 <a class="header-anchor" href="#plain-모드에서-별도의-javascript-객체로-선언-격리" aria-label="Permalink to &quot;plain 모드에서 별도의 JavaScript 객체로 선언 격리&quot;">​</a></h2><p>모듈 종류를 명시적으로 <code>plain</code>으로 설정한 경우, Kotlin은 현재 모듈의 모든 Kotlin 선언을 포함하는 객체를 생성합니다. 이는 전역 객체를 오염시키는 것을 방지하기 위해 수행됩니다. 즉, <code>myModule</code> 모듈의 경우 모든 선언은 <code>myModule</code> 객체를 통해 JavaScript에서 사용 가능합니다. 예를 들면 다음과 같습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello&quot;</span></span></code></pre></div><p>다음과 같이 JavaScript에서 호출할 수 있습니다:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myModule.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><p>이는 Kotlin 모듈을 UMD(<code>browser</code> 및 <code>nodejs</code> 타겟의 기본 설정), CommonJS 또는 AMD와 같은 JavaScript 모듈로 컴파일할 경우에는 해당되지 않습니다. 이 경우, 선언은 선택한 JavaScript 모듈 시스템에서 지정한 형식으로 노출됩니다. 예를 들어 UMD 또는 CommonJS를 사용하는 경우, 호출 지점은 다음과 같을 수 있습니다:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;myModule&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><p>JavaScript 모듈 시스템에 대한 자세한 내용은 <a href="/ko/kotlin/js-modules">JavaScript 모듈</a> 문서를 확인하세요.</p><h2 id="패키지-구조" tabindex="-1">패키지 구조 <a class="header-anchor" href="#패키지-구조" aria-label="Permalink to &quot;패키지 구조&quot;">​</a></h2><p>Kotlin은 패키지 구조를 JavaScript에 노출하므로, 선언을 루트 패키지에 정의하지 않는 한 JavaScript에서 정규화된 이름(fully qualified name)을 사용해야 합니다. 예를 들면 다음과 같습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> my.qualified.packagename</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello&quot;</span></span></code></pre></div><p>예를 들어 UMD 또는 CommonJS를 사용하는 경우, 호출 지점은 다음과 같을 수 있습니다:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;myModule&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).my.qualified.packagename.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>또는 <code>plain</code>을 모듈 시스템 설정으로 사용하는 경우:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myModule.my.qualified.packagename.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><h3 id="jsname-어노테이션" tabindex="-1">@JsName 어노테이션 <a class="header-anchor" href="#jsname-어노테이션" aria-label="Permalink to &quot;@JsName 어노테이션&quot;">​</a></h3><p>어떤 경우에는 (예: 오버로드 지원을 위해) Kotlin 컴파일러가 JavaScript 코드에서 생성된 함수 및 속성의 이름을 변형합니다(mangling). 생성된 이름을 제어하려면 <code>@JsName</code> 어노테이션을 사용할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Module &#39;kjs&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @JsName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;helloWithGreeting&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(greeting: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$greeting</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이제 다음 방법으로 JavaScript에서 이 클래스를 사용할 수 있습니다:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// If necessary, import &#39;kjs&#39; according to chosen module system</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kjs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Dmitry&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// refers to module &#39;kjs&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">person.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();                          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// prints &quot;Hello Dmitry!&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">person.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">helloWithGreeting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Servus&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// prints &quot;Servus Dmitry!&quot;</span></span></code></pre></div><p><code>@JsName</code> 어노테이션을 지정하지 않았다면, 해당 함수의 이름에는 함수 시그니처에서 계산된 접미사가 포함되었을 것입니다. 예를 들어 <code>hello_61zpoe</code>와 같이 됩니다.</p><p>Kotlin 컴파일러가 이름 변형(mangling)을 적용하지 않는 경우가 있습니다:</p><ul><li><code>external</code> 선언은 변형되지 않습니다.</li><li><code>external</code>이 아닌 클래스에서 <code>external</code> 클래스를 상속받는 오버라이드된 함수는 변형되지 않습니다.</li></ul><p><code>@JsName</code>의 매개변수는 유효한 식별자(identifier)인 상수 문자열 리터럴이어야 합니다. 컴파일러는 <code>@JsName</code>에 식별자가 아닌 문자열을 전달하려고 시도할 경우 오류를 보고합니다. 다음 예제는 컴파일 타임 오류를 발생시킵니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JsName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;new C()&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// error here</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> newC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h3 id="jsexport-어노테이션" tabindex="-1">@JsExport 어노테이션 <a class="header-anchor" href="#jsexport-어노테이션" aria-label="Permalink to &quot;@JsExport 어노테이션&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>이 기능은 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적</a>입니다. 향후 버전에서 디자인이 변경될 수 있습니다.</p></div><p><code>@JsExport</code> 어노테이션을 최상위 선언(예: 클래스 또는 함수)에 적용하면 Kotlin 선언을 JavaScript에서 사용할 수 있게 됩니다. 이 어노테이션은 Kotlin에서 주어진 이름으로 모든 중첩 선언을 내보냅니다. <code>@file:JsExport</code>를 사용하여 파일 수준에서도 적용할 수 있습니다.</p><p>내보내기 시 모호성을 해결하려면 (예: 같은 이름을 가진 함수의 오버로드) <code>@JsExport</code> 어노테이션을 <code>@JsName</code>과 함께 사용하여 생성되고 내보내진 함수의 이름을 지정할 수 있습니다.</p><p>현재 <a href="/ko/kotlin/js-ir-compiler">IR 컴파일러 백엔드</a>에서는 <code>@JsExport</code> 어노테이션이 함수를 Kotlin에서 볼 수 있도록 하는 유일한 방법입니다.</p><p>멀티플랫폼 프로젝트의 경우, <code>@JsExport</code>는 공통 코드에서도 사용할 수 있습니다. 이는 JavaScript 타겟으로 컴파일할 때만 효과가 있으며, 플랫폼에 특화되지 않은 Kotlin 선언도 내보낼 수 있도록 합니다.</p><h3 id="jsstatic" tabindex="-1">@JsStatic <a class="header-anchor" href="#jsstatic" aria-label="Permalink to &quot;@JsStatic&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>이 기능은 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적</a>입니다. 언제든지 삭제되거나 변경될 수 있습니다. 평가 목적으로만 사용하십시오. <a href="https://youtrack.jetbrains.com/issue/KT-18891/JS-provide-a-way-to-declare-static-members-JsStatic" target="_blank" rel="noreferrer">YouTrack</a>에 대한 피드백을 주시면 감사하겠습니다.</p></div><p><code>@JsStatic</code> 어노테이션은 컴파일러에게 대상 선언에 대한 추가 정적 메서드를 생성하도록 지시합니다. 이를 통해 Kotlin 코드의 정적 멤버를 JavaScript에서 직접 사용할 수 있습니다.</p><p><code>@JsStatic</code> 어노테이션은 명명된 객체(named objects)에 정의된 함수와 클래스 및 인터페이스 내부에 선언된 컴패니언 객체(companion objects)에 적용할 수 있습니다. 이 어노테이션을 사용하면 컴파일러는 객체의 정적 메서드와 객체 자체의 인스턴스 메서드를 모두 생성합니다. 예를 들면 다음과 같습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    companion</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @JsStatic</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callNonStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이제 <code>callStatic()</code> 함수는 JavaScript에서 정적이지만 <code>callNonStatic()</code> 함수는 그렇지 않습니다:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JavaScript</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Works, accessing the static function</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callNonStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();           </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Error, not a static function in the generated JavaScript</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.Companion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Instance method remains</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.Companion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callNonStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// The only way it works</span></span></code></pre></div><p><code>@JsStatic</code> 어노테이션은 객체 또는 컴패니언 객체의 속성에도 적용할 수 있으며, 해당 객체 또는 컴패니언 객체를 포함하는 클래스에서 해당 속성의 getter 및 setter 메서드를 정적 멤버로 만듭니다.</p><h2 id="javascript의-kotlin-타입" tabindex="-1">JavaScript의 Kotlin 타입 <a class="header-anchor" href="#javascript의-kotlin-타입" aria-label="Permalink to &quot;JavaScript의 Kotlin 타입&quot;">​</a></h2><p>Kotlin 타입이 JavaScript 타입에 어떻게 매핑되는지 확인하세요.</p><table tabindex="0"><thead><tr><th>Kotlin</th><th>JavaScript</th><th>설명</th></tr></thead><tbody><tr><td><code>Byte</code>, <code>Short</code>, <code>Int</code>, <code>Float</code>, <code>Double</code></td><td><code>Number</code></td><td></td></tr><tr><td><code>Char</code></td><td><code>Number</code></td><td>숫자는 문자의 코드를 나타냅니다.</td></tr><tr><td><code>Long</code></td><td>Not supported</td><td>JavaScript에는 64비트 정수 타입이 없으므로 Kotlin 클래스로 에뮬레이션됩니다.</td></tr><tr><td><code>Boolean</code></td><td><code>Boolean</code></td><td></td></tr><tr><td><code>String</code></td><td><code>String</code></td><td></td></tr><tr><td><code>Array</code></td><td><code>Array</code></td><td></td></tr><tr><td><code>ByteArray</code></td><td><code>Int8Array</code></td><td></td></tr><tr><td><code>ShortArray</code></td><td><code>Int16Array</code></td><td></td></tr><tr><td><code>IntArray</code></td><td><code>Int32Array</code></td><td></td></tr><tr><td><code>CharArray</code></td><td><code>UInt16Array</code></td><td><code>&#39;$type$ == &quot;CharArray&quot;</code> 속성을 가집니다.</td></tr><tr><td><code>FloatArray</code></td><td><code>Float32Array</code></td><td></td></tr><tr><td><code>DoubleArray</code></td><td><code>Float64Array</code></td><td></td></tr><tr><td><code>LongArray</code></td><td><code>Array&lt;kotlin.Long&gt;</code></td><td><code>&#39;$type$ == &quot;LongArray&quot;</code> 속성을 가집니다. Kotlin의 Long 타입 설명도 참조하세요.</td></tr><tr><td><code>BooleanArray</code></td><td><code>Int8Array</code></td><td><code>&#39;$type$ == &quot;BooleanArray&quot;</code> 속성을 가집니다.</td></tr><tr><td><code>List</code>, <code>MutableList</code></td><td><code>KtList</code>, <code>KtMutableList</code></td><td><code>KtList.asJsReadonlyArrayView</code> 또는 <code>KtMutableList.asJsArrayView</code>를 통해 <code>Array</code>를 노출합니다.</td></tr><tr><td><code>Map</code>, <code>MutableMap</code></td><td><code>KtMap</code>, <code>KtMutableMap</code></td><td><code>KtMap.asJsReadonlyMapView</code> 또는 <code>KtMutableMap.asJsMapView</code>를 통해 ES2015 <code>Map</code>을 노출합니다.</td></tr><tr><td><code>Set</code>, <code>MutableSet</code></td><td><code>KtSet</code>, <code>KtMutableSet</code></td><td><code>KtSet.asJsReadonlySetView</code> 또는 <code>KtMutableSet.asJsSetView</code>를 통해 ES2015 <code>Set</code>을 노출합니다.</td></tr><tr><td><code>Unit</code></td><td>Undefined</td><td>반환 타입으로 사용될 때는 내보낼 수 있지만, 매개변수 타입으로 사용될 때는 그렇지 않습니다.</td></tr><tr><td><code>Any</code></td><td><code>Object</code></td><td></td></tr><tr><td><code>Throwable</code></td><td><code>Error</code></td><td></td></tr><tr><td><code>enum class Type</code></td><td><code>Type</code></td><td>Enum 엔트리는 정적 클래스 속성(<code>Type.ENTRY</code>)으로 노출됩니다.</td></tr><tr><td>Nullable <code>Type?</code></td><td>\`Type</td><td>null</td></tr><tr><td><code>@JsExport</code>로 표시된 타입을 제외한 다른 모든 Kotlin 타입</td><td>Not supported</td><td>Kotlin의 <a href="/ko/kotlin/unsigned-integer-types">부호 없는 정수 타입</a>을 포함합니다.</td></tr></tbody></table><p>또한 다음 사항을 아는 것이 중요합니다:</p><ul><li><p>Kotlin은 <code>kotlin.Int</code>, <code>kotlin.Byte</code>, <code>kotlin.Short</code>, <code>kotlin.Char</code>, <code>kotlin.Long</code>에 대한 오버플로우 시맨틱을 유지합니다.</p></li><li><p>Kotlin은 런타임에 숫자 타입을 구별할 수 없으므로 (<code>kotlin.Long</code> 제외) 다음 코드는 작동합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 23</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>Kotlin은 JavaScript에서 지연 객체 초기화를 유지합니다.</p></li><li><p>Kotlin은 JavaScript에서 최상위 속성의 지연 초기화를 구현하지 않습니다.</p></li></ul>`,46)]))}const E=i(n,[["render",l]]);export{c as __pageData,E as default};
