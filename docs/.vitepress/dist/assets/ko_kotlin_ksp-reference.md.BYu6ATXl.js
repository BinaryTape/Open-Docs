import{_ as e,c as d,o as a,ag as o}from"./chunks/framework.Bksy39di.js";const k=JSON.parse('{"title":"Java 어노테이션 프로세싱에서 KSP 참조로","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/ksp-reference.md","filePath":"ko/kotlin/ksp-reference.md","lastUpdated":1754307826000}'),r={name:"ko/kotlin/ksp-reference.md"};function s(i,t,n,c,l,h){return a(),d("div",null,t[0]||(t[0]=[o(`<h1 id="java-어노테이션-프로세싱에서-ksp-참조로" tabindex="-1">Java 어노테이션 프로세싱에서 KSP 참조로 <a class="header-anchor" href="#java-어노테이션-프로세싱에서-ksp-참조로" aria-label="Permalink to &quot;Java 어노테이션 프로세싱에서 KSP 참조로&quot;">​</a></h1><h2 id="프로그램-요소" tabindex="-1">프로그램 요소 <a class="header-anchor" href="#프로그램-요소" aria-label="Permalink to &quot;프로그램 요소&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP의 상응하는 기능</strong></th><th><strong>참고</strong></th></tr></thead><tbody><tr><td><code>AnnotationMirror</code></td><td><code>KSAnnotation</code></td><td></td></tr><tr><td><code>AnnotationValue</code></td><td><code>KSValueArguments</code></td><td></td></tr><tr><td><code>Element</code></td><td><code>KSDeclaration</code> / <code>KSDeclarationContainer</code></td><td></td></tr><tr><td><code>ExecutableElement</code></td><td><code>KSFunctionDeclaration</code></td><td></td></tr><tr><td><code>PackageElement</code></td><td><code>KSFile</code></td><td>KSP는 패키지를 프로그램 요소로 모델링하지 않습니다.</td></tr><tr><td><code>Parameterizable</code></td><td><code>KSDeclaration</code></td><td></td></tr><tr><td><code>QualifiedNameable</code></td><td><code>KSDeclaration</code></td><td></td></tr><tr><td><code>TypeElement</code></td><td><code>KSClassDeclaration</code></td><td></td></tr><tr><td><code>TypeParameterElement</code></td><td><code>KSTypeParameter</code></td><td></td></tr><tr><td><code>VariableElement</code></td><td><code>KSValueParameter</code> / <code>KSPropertyDeclaration</code></td><td></td></tr></tbody></table><h2 id="타입" tabindex="-1">타입 <a class="header-anchor" href="#타입" aria-label="Permalink to &quot;타입&quot;">​</a></h2><p>KSP는 명시적인 타입 해석(type resolution)을 요구하므로, Java의 일부 기능은 <code>KSType</code> 및 해석 전의 상응하는 요소들에 의해서만 수행될 수 있습니다.</p><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP의 상응하는 기능</strong></th><th><strong>참고</strong></th></tr></thead><tbody><tr><td><code>ArrayType</code></td><td><code>KSBuiltIns.arrayType</code></td><td></td></tr><tr><td><code>DeclaredType</code></td><td><code>KSType</code> / <code>KSClassifierReference</code></td><td></td></tr><tr><td><code>ErrorType</code></td><td><code>KSType.isError</code></td><td></td></tr><tr><td><code>ExecutableType</code></td><td><code>KSType</code> / <code>KSCallableReference</code></td><td></td></tr><tr><td><code>IntersectionType</code></td><td><code>KSType</code> / <code>KSTypeParameter</code></td><td></td></tr><tr><td><code>NoType</code></td><td><code>KSType.isError</code></td><td>KSP에서는 해당 없음</td></tr><tr><td><code>NullType</code></td><td></td><td>KSP에서는 해당 없음</td></tr><tr><td><code>PrimitiveType</code></td><td><code>KSBuiltIns</code></td><td>Java의 primitive 타입과 정확히 같지는 않습니다.</td></tr><tr><td><code>ReferenceType</code></td><td><code>KSTypeReference</code></td><td></td></tr><tr><td><code>TypeMirror</code></td><td><code>KSType</code></td><td></td></tr><tr><td><code>TypeVariable</code></td><td><code>KSTypeParameter</code></td><td></td></tr><tr><td><code>UnionType</code></td><td>N/A</td><td>Kotlin은 catch 블록당 하나의 타입만 가집니다. <code>UnionType</code>은 Java 어노테이션 프로세서로도 관찰할 수 없습니다.</td></tr><tr><td><code>WildcardType</code></td><td><code>KSType</code> / <code>KSTypeArgument</code></td><td></td></tr></tbody></table><h2 id="기타" tabindex="-1">기타 <a class="header-anchor" href="#기타" aria-label="Permalink to &quot;기타&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP의 상응하는 기능</strong></th><th><strong>참고</strong></th></tr></thead><tbody><tr><td><code>Name</code></td><td><code>KSName</code></td><td></td></tr><tr><td><code>ElementKind</code></td><td><code>ClassKind</code> / <code>FunctionKind</code></td><td></td></tr><tr><td><code>Modifier</code></td><td><code>Modifier</code></td><td></td></tr><tr><td><code>NestingKind</code></td><td><code>ClassKind</code> / <code>FunctionKind</code></td><td></td></tr><tr><td><code>AnnotationValueVisitor</code></td><td></td><td></td></tr><tr><td><code>ElementVisitor</code></td><td><code>KSVisitor</code></td><td></td></tr><tr><td><code>AnnotatedConstruct</code></td><td><code>KSAnnotated</code></td><td></td></tr><tr><td><code>TypeVisitor</code></td><td></td><td></td></tr><tr><td><code>TypeKind</code></td><td><code>KSBuiltIns</code></td><td>일부는 빌트인(built-in)에서 찾을 수 있으며, 그렇지 않으면 <code>DeclaredType</code>에 대해 <code>KSClassDeclaration</code>을 확인하십시오.</td></tr><tr><td><code>ElementFilter</code></td><td><code>Collection.filterIsInstance</code></td><td></td></tr><tr><td><code>ElementKindVisitor</code></td><td><code>KSVisitor</code></td><td></td></tr><tr><td><code>ElementScanner</code></td><td><code>KSTopDownVisitor</code></td><td></td></tr><tr><td><code>SimpleAnnotationValueVisitor</code></td><td></td><td>KSP에서는 필요하지 않습니다.</td></tr><tr><td><code>SimpleElementVisitor</code></td><td><code>KSVisitor</code></td><td></td></tr><tr><td><code>SimpleTypeVisitor</code></td><td></td><td></td></tr><tr><td><code>TypeKindVisitor</code></td><td></td><td></td></tr><tr><td><code>Types</code></td><td><code>Resolver</code> / <code>utils</code></td><td>일부 유틸리티(utils)는 심볼 인터페이스에 통합되어 있습니다.</td></tr><tr><td><code>Elements</code></td><td><code>Resolver</code> / <code>utils</code></td><td></td></tr></tbody></table><h2 id="상세-내용" tabindex="-1">상세 내용 <a class="header-anchor" href="#상세-내용" aria-label="Permalink to &quot;상세 내용&quot;">​</a></h2><p>Java 어노테이션 프로세싱 API의 기능들이 KSP에 의해 어떻게 수행될 수 있는지 확인하십시오.</p><h3 id="annotationmirror" tabindex="-1">AnnotationMirror <a class="header-anchor" href="#annotationmirror" aria-label="Permalink to &quot;AnnotationMirror&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 상응 항목</strong></th></tr></thead><tbody><tr><td><code>getAnnotationType</code></td><td><code>ksAnnotation.annotationType</code></td></tr><tr><td><code>getElementValues</code></td><td><code>ksAnnotation.arguments</code></td></tr></tbody></table><h3 id="annotationvalue" tabindex="-1">AnnotationValue <a class="header-anchor" href="#annotationvalue" aria-label="Permalink to &quot;AnnotationValue&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 상응 항목</strong></th></tr></thead><tbody><tr><td><code>getValue</code></td><td><code>ksValueArgument.value</code></td></tr></tbody></table><h3 id="element" tabindex="-1">Element <a class="header-anchor" href="#element" aria-label="Permalink to &quot;Element&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 상응 항목</strong></th></tr></thead><tbody><tr><td><code>asType</code></td><td><code>ksClassDeclaration.asType(...)</code>는 <code>KSClassDeclaration</code>에만 사용 가능합니다. 타입 인자(type arguments)를 제공해야 합니다.</td></tr><tr><td><code>getAnnotation</code></td><td>구현 예정</td></tr><tr><td><code>getAnnotationMirrors</code></td><td><code>ksDeclaration.annotations</code></td></tr><tr><td><code>getEnclosedElements</code></td><td><code>ksDeclarationContainer.declarations</code></td></tr><tr><td><code>getEnclosingElements</code></td><td><code>ksDeclaration.parentDeclaration</code></td></tr><tr><td><code>getKind</code></td><td><code>ClassKind</code> 또는 <code>FunctionKind</code>에 따라 타입 검사 및 캐스팅(casting)을 수행합니다.</td></tr><tr><td><code>getModifiers</code></td><td><code>ksDeclaration.modifiers</code></td></tr><tr><td><code>getSimpleName</code></td><td><code>ksDeclaration.simpleName</code></td></tr></tbody></table><h3 id="executableelement" tabindex="-1">ExecutableElement <a class="header-anchor" href="#executableelement" aria-label="Permalink to &quot;ExecutableElement&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 상응 항목</strong></th></tr></thead><tbody><tr><td><code>getDefaultValue</code></td><td>구현 예정</td></tr><tr><td><code>getParameters</code></td><td><code>ksFunctionDeclaration.parameters</code></td></tr><tr><td><code>getReceiverType</code></td><td><code>ksFunctionDeclaration.parentDeclaration</code></td></tr><tr><td><code>getReturnType</code></td><td><code>ksFunctionDeclaration.returnType</code></td></tr><tr><td><code>getSimpleName</code></td><td><code>ksFunctionDeclaration.simpleName</code></td></tr><tr><td><code>getThrownTypes</code></td><td>Kotlin에서는 필요하지 않습니다.</td></tr><tr><td><code>getTypeParameters</code></td><td><code>ksFunctionDeclaration.typeParameters</code></td></tr><tr><td><code>isDefault</code></td><td>부모 선언(parent declaration)이 인터페이스인지 확인합니다.</td></tr><tr><td><code>isVarArgs</code></td><td><code>ksFunctionDeclaration.parameters.any { it.isVarArg }</code></td></tr></tbody></table><h3 id="parameterizable" tabindex="-1">Parameterizable <a class="header-anchor" href="#parameterizable" aria-label="Permalink to &quot;Parameterizable&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 상응 항목</strong></th></tr></thead><tbody><tr><td><code>getTypeParameters</code></td><td><code>ksFunctionDeclaration.typeParameters</code></td></tr></tbody></table><h3 id="qualifiednameable" tabindex="-1">QualifiedNameable <a class="header-anchor" href="#qualifiednameable" aria-label="Permalink to &quot;QualifiedNameable&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 상응 항목</strong></th></tr></thead><tbody><tr><td><code>getQualifiedName</code></td><td><code>ksDeclaration.qualifiedName</code></td></tr></tbody></table><h3 id="typeelement" tabindex="-1">TypeElement <a class="header-anchor" href="#typeelement" aria-label="Permalink to &quot;TypeElement&quot;">​</a></h3><table><tr><td><b>Java</b></td><td><b>KSP 상응 항목</b></td></tr><tr><td><code>getEnclosedElements</code></td><td><code>ksClassDeclaration.declarations</code></td></tr><tr><td><code>getEnclosingElement</code></td><td><code>ksClassDeclaration.parentDeclaration</code></td></tr><tr><td><code>getInterfaces</code></td><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 해석(resolution) 없이도 수행할 수 있어야 합니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ksClassDeclaration.superTypes</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { (it?.declaration </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? KSClassDeclaration)?.classKind </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ClassKind.INTERFACE }</span></span></code></pre></div></td></tr><tr><td><code>getNestingKind</code></td><td><code>KSClassDeclaration.parentDeclaration</code> 및 <code>inner</code> 변경자(modifier)를 확인합니다.</td></tr><tr><td><code>getQualifiedName</code></td><td><code>ksClassDeclaration.qualifiedName</code></td></tr><tr><td><code>getSimpleName</code></td><td><code>ksClassDeclaration.simpleName</code></td></tr><tr><td><code>getSuperclass</code></td><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 해석(resolution) 없이도 수행할 수 있어야 합니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ksClassDeclaration.superTypes</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { (it?.declaration </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? KSClassDeclaration)?.classKind </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ClassKind.CLASS }</span></span></code></pre></div></td></tr><tr><td><code>getTypeParameters</code></td><td><code>ksClassDeclaration.typeParameters</code></td></tr></table><h3 id="typeparameterelement" tabindex="-1">TypeParameterElement <a class="header-anchor" href="#typeparameterelement" aria-label="Permalink to &quot;TypeParameterElement&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 상응 항목</strong></th></tr></thead><tbody><tr><td><code>getBounds</code></td><td><code>ksTypeParameter.bounds</code></td></tr><tr><td><code>getEnclosingElement</code></td><td><code>ksTypeParameter.parentDeclaration</code></td></tr><tr><td><code>getGenericElement</code></td><td><code>ksTypeParameter.parentDeclaration</code></td></tr></tbody></table><h3 id="variableelement" tabindex="-1">VariableElement <a class="header-anchor" href="#variableelement" aria-label="Permalink to &quot;VariableElement&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 상응 항목</strong></th></tr></thead><tbody><tr><td><code>getConstantValue</code></td><td>구현 예정</td></tr><tr><td><code>getEnclosingElement</code></td><td><code>ksValueParameter.parentDeclaration</code></td></tr><tr><td><code>getSimpleName</code></td><td><code>ksValueParameter.simpleName</code></td></tr></tbody></table><h3 id="arraytype" tabindex="-1">ArrayType <a class="header-anchor" href="#arraytype" aria-label="Permalink to &quot;ArrayType&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 상응 항목</strong></th></tr></thead><tbody><tr><td><code>getComponentType</code></td><td><code>ksType.arguments.first()</code></td></tr></tbody></table><h3 id="declaredtype" tabindex="-1">DeclaredType <a class="header-anchor" href="#declaredtype" aria-label="Permalink to &quot;DeclaredType&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 상응 항목</strong></th></tr></thead><tbody><tr><td><code>asElement</code></td><td><code>ksType.declaration</code></td></tr><tr><td><code>getEnclosingType</code></td><td><code>ksType.declaration.parentDeclaration</code></td></tr><tr><td><code>getTypeArguments</code></td><td><code>ksType.arguments</code></td></tr></tbody></table><h3 id="executabletype" tabindex="-1">ExecutableType <a class="header-anchor" href="#executabletype" aria-label="Permalink to &quot;ExecutableType&quot;">​</a></h3><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>함수에 대한 <code>KSType</code>은 <code>FunctionN&lt;R, T1, T2, ..., TN&gt;</code> 계열로 표현되는 시그니처(signature)일 뿐입니다.</p></div><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 상응 항목</strong></th></tr></thead><tbody><tr><td><code>getParameterTypes</code></td><td><code>ksType.declaration.typeParameters</code>, <code>ksFunctionDeclaration.parameters.map { it.type }</code></td></tr><tr><td><code>getReceiverType</code></td><td><code>ksFunctionDeclaration.parentDeclaration.asType(...)</code></td></tr><tr><td><code>getReturnType</code></td><td><code>ksType.declaration.typeParameters.last()</code></td></tr><tr><td><code>getThrownTypes</code></td><td>Kotlin에서는 필요하지 않습니다.</td></tr><tr><td><code>getTypeVariables</code></td><td><code>ksFunctionDeclaration.typeParameters</code></td></tr></tbody></table><h3 id="intersectiontype" tabindex="-1">IntersectionType <a class="header-anchor" href="#intersectiontype" aria-label="Permalink to &quot;IntersectionType&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 상응 항목</strong></th></tr></thead><tbody><tr><td><code>getBounds</code></td><td><code>ksTypeParameter.bounds</code></td></tr></tbody></table><h3 id="typemirror" tabindex="-1">TypeMirror <a class="header-anchor" href="#typemirror" aria-label="Permalink to &quot;TypeMirror&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 상응 항목</strong></th></tr></thead><tbody><tr><td><code>getKind</code></td><td>primitive 타입 및 <code>Unit</code> 타입에 대해서는 <code>KSBuiltIns</code>의 타입과 비교하고, 그렇지 않으면 선언된 타입(declared types)을 확인합니다.</td></tr></tbody></table><h3 id="typevariable" tabindex="-1">TypeVariable <a class="header-anchor" href="#typevariable" aria-label="Permalink to &quot;TypeVariable&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 상응 항목</strong></th></tr></thead><tbody><tr><td><code>asElement</code></td><td><code>ksType.declaration</code></td></tr><tr><td><code>getLowerBound</code></td><td>미정. 캡처(capture)가 제공되고 명시적인 바운드(bound) 검사가 필요한 경우에만 필요합니다.</td></tr><tr><td><code>getUpperBound</code></td><td><code>ksTypeParameter.bounds</code></td></tr></tbody></table><h3 id="wildcardtype" tabindex="-1">WildcardType <a class="header-anchor" href="#wildcardtype" aria-label="Permalink to &quot;WildcardType&quot;">​</a></h3><table><tr><td><b>Java</b></td><td><b>KSP 상응 항목</b></td></tr><tr><td><code>getExtendsBound</code></td><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ksTypeArgument.variance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Variance.COVARIANT) ksTypeArgument.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span></code></pre></div></td></tr><tr><td><code>getSuperBound</code></td><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ksTypeArgument.variance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Variance.CONTRAVARIANT) ksTypeArgument.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span></code></pre></div></td></tr></table><h3 id="elements" tabindex="-1">Elements <a class="header-anchor" href="#elements" aria-label="Permalink to &quot;Elements&quot;">​</a></h3><table><tr><td><b>Java</b></td><td><b>KSP 상응 항목</b></td></tr><tr><td><code>getAllAnnotationMirrors</code></td><td><code>KSDeclarations.annotations</code></td></tr><tr><td><code>getAllMembers</code></td><td><code>getAllFunctions</code>, <code>getAllProperties</code>는 구현 예정입니다.</td></tr><tr><td><code>getBinaryName</code></td><td>미정, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-13.html#jls-13.1">Java Specification</a>을 참조하십시오.</td></tr><tr><td><code>getConstantExpression</code></td><td>상수 값(constant value)은 있지만 표현식(expression)은 없습니다.</td></tr><tr><td><code>getDocComment</code></td><td>구현 예정</td></tr><tr><td><code>getElementValuesWithDefaults</code></td><td>구현 예정</td></tr><tr><td><code>getName</code></td><td><code>resolver.getKSNameFromString</code></td></tr><tr><td><code>getPackageElement</code></td><td>패키지는 지원되지 않지만, 패키지 정보를 검색할 수는 있습니다. KSP에서는 패키지에 대한 작업이 불가능합니다.</td></tr><tr><td><code>getPackageOf</code></td><td>패키지는 지원되지 않습니다.</td></tr><tr><td><code>getTypeElement</code></td><td><code>Resolver.getClassDeclarationByName</code></td></tr><tr><td><code>hides</code></td><td>구현 예정</td></tr><tr><td><code>isDeprecated</code></td><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">KsDeclaration.annotations.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    it.annotationType.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.declaration.qualifiedName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Deprecated::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.qualifiedName</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></td></tr><tr><td><code>overrides</code></td><td><code>KSFunctionDeclaration.overrides</code> / <code>KSPropertyDeclaration.overrides</code> (해당 클래스의 멤버 함수)</td></tr><tr><td><code>printElements</code></td><td>KSP는 대부분의 클래스에 기본 <code>toString()</code> 구현을 가지고 있습니다.</td></tr></table><h3 id="types" tabindex="-1">Types <a class="header-anchor" href="#types" aria-label="Permalink to &quot;Types&quot;">​</a></h3><p id="type-operations"></p><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 상응 항목</strong></th></tr></thead><tbody><tr><td><code>asElement</code></td><td><code>ksType.declaration</code></td></tr><tr><td><code>asMemberOf</code></td><td><code>resolver.asMemberOf</code></td></tr><tr><td><code>boxedClass</code></td><td>필요하지 않습니다.</td></tr><tr><td><code>capture</code></td><td>미정</td></tr><tr><td><code>contains</code></td><td><code>KSType.isAssignableFrom</code></td></tr><tr><td><code>directSuperTypes</code></td><td><code>(ksType.declaration as KSClassDeclaration).superTypes</code></td></tr><tr><td><code>erasure</code></td><td><code>ksType.starProjection()</code></td></tr><tr><td><code>getArrayType</code></td><td><code>ksBuiltIns.arrayType.replace(...)</code></td></tr><tr><td><code>getDeclaredType</code></td><td><code>ksClassDeclaration.asType</code></td></tr><tr><td><code>getNoType</code></td><td><code>ksBuiltIns.nothingType</code> / <code>null</code></td></tr><tr><td><code>getNullType</code></td><td>컨텍스트(context)에 따라 <code>KSType.markNullable</code>이 유용할 수 있습니다.</td></tr><tr><td><code>getPrimitiveType</code></td><td>필요하지 않습니다. <code>KSBuiltins</code>를 확인하십시오.</td></tr><tr><td><code>getWildcardType</code></td><td><code>KSTypeArgument</code>를 예상하는 곳에서는 <code>Variance</code>를 사용하십시오.</td></tr><tr><td><code>isAssignable</code></td><td><code>ksType.isAssignableFrom</code></td></tr><tr><td><code>isSameType</code></td><td><code>ksType.equals</code></td></tr><tr><td><code>isSubsignature</code></td><td><code>functionTypeA == functionTypeB</code> / <code>functionTypeA == functionTypeB.starProjection()</code></td></tr><tr><td><code>isSubtype</code></td><td><code>ksType.isAssignableFrom</code></td></tr><tr><td><code>unboxedType</code></td><td>필요하지 않습니다.</td></tr></tbody></table>`,48)]))}const y=e(r,[["render",s]]);export{k as __pageData,y as default};
