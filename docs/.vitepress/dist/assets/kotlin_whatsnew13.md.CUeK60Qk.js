import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.Bksy39di.js";const o=JSON.parse('{"title":"Kotlin 1.3 中的新特性","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/whatsnew13.md","filePath":"kotlin/whatsnew13.md","lastUpdated":1754307826000}'),l={name:"kotlin/whatsnew13.md"};function h(k,s,p,e,r,d){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="kotlin-1-3-中的新特性" tabindex="-1">Kotlin 1.3 中的新特性 <a class="header-anchor" href="#kotlin-1-3-中的新特性" aria-label="Permalink to &quot;Kotlin 1.3 中的新特性&quot;">​</a></h1><p><em>发布时间：2018 年 10 月 29 日</em></p><h2 id="协程正式发布" tabindex="-1">协程正式发布 <a class="header-anchor" href="#协程正式发布" aria-label="Permalink to &quot;协程正式发布&quot;">​</a></h2><p>经过漫长而广泛的实战测试，协程现已正式发布！这意味着从 Kotlin 1.3 开始，语言支持和 API 都已 <a href="/kotlin/components-stability">完全稳定</a>。请查看新的 <a href="/kotlin/coroutines-overview">协程概览</a> 页面。</p><p>Kotlin 1.3 引入了挂起函数的<strong>可调用引用</strong>，并在反射 API 中增加了对协程的支持。</p><h2 id="kotlin-native" tabindex="-1">Kotlin/Native <a class="header-anchor" href="#kotlin-native" aria-label="Permalink to &quot;Kotlin/Native&quot;">​</a></h2><p>Kotlin 1.3 继续改进和完善 Native 目标平台。有关详细信息，请参见 <a href="/kotlin/native-overview">Kotlin/Native 概览</a>。</p><h2 id="多平台项目" tabindex="-1">多平台项目 <a class="header-anchor" href="#多平台项目" aria-label="Permalink to &quot;多平台项目&quot;">​</a></h2><p>在 1.3 版本中，我们彻底重做了多平台项目的模型，以提高表达能力和灵活性，并使公共代码共享变得更容易。此外，Kotlin/Native 现在已作为其中一个目标平台受支持！</p><p>与旧模型的主要区别在于：</p><ul><li>在旧模型中，公共代码和平台特有的代码需要放置在单独的模块中，并通过 <code>expectedBy</code> 依赖项链接。现在，公共代码和平台特有的代码放置在同一个模块的不同源代码根目录中，从而使项目配置更加简单。</li><li>现在为各种受支持的平台提供了大量的 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-dsl-reference.html#targets" target="_blank" rel="noreferrer">预设平台配置</a>。</li><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-add-dependencies.html" target="_blank" rel="noreferrer">依赖项配置</a> 已更改；现在为每个源代码根目录单独指定依赖项。</li><li>源代码集现在可以在任意平台子集之间共享（例如，在一个面向 JS、Android 和 iOS 的模块中，您可以拥有一个仅在 Android 和 iOS 之间共享的源代码集）。</li><li>现在支持 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-publish-lib-setup.html" target="_blank" rel="noreferrer">发布多平台库</a>。</li></ul><p>有关更多信息，请参考 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/get-started.html" target="_blank" rel="noreferrer">多平台编程文档</a>。</p><h2 id="契约" tabindex="-1">契约 <a class="header-anchor" href="#契约" aria-label="Permalink to &quot;契约&quot;">​</a></h2><p>Kotlin 编译器会进行广泛的静态分析，以提供警告并减少样板代码。其中最显著的特性之一是智能类型转换——它能够根据执行的类型检测自动执行类型转换：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) s.length </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译器自动将 &#39;s&#39; 转换为 &#39;String&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>然而，一旦这些检测被提取到一个单独的函数中，所有的智能类型转换会立即消失：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isNotNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isNotNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) s.length </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 没有智能类型转换 :(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>为了改善这种情况下的行为，Kotlin 1.3 引入了一种实验性机制，称为 <em>契约</em>。</p><p><em>契约</em> 允许函数以编译器可理解的方式<strong>显式</strong>描述其行为。目前，支持两大类用例：</p><ul><li>通过声明函数调用结果与传入实参值之间的关系来改进智能类型转换分析：</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(condition: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 这种语法形式告诉编译器：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // “如果此函数成功返回，则传入的 &#39;condition&#39; 为 true”</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    contract</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">returns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() implies condition }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">condition) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throw</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IllegalArgumentException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // &#39;s&#39; 在这里被智能类型转换为 &#39;String&#39;，因为否则</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // &#39;require&#39; 会抛出异常</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>改进存在高阶函数时的变量初始化分析：</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> synchronize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lock: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?, block: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Unit) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 它告诉编译器：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // “此函数将立即在此处调用 &#39;block&#39;，且仅调用一次”</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    contract</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callsInPlace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, EXACTLY_ONCE) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    synchronize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lock) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 编译器知道传递给 &#39;synchronize&#39; 的 lambda 仅被调用一次，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // 因此不会报告重复赋值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译器知道 lambda 会被明确调用并执行初始化，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // 因此 &#39;x&#39; 在此处被视为已初始化</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="标准库中的契约" tabindex="-1">标准库中的契约 <a class="header-anchor" href="#标准库中的契约" aria-label="Permalink to &quot;标准库中的契约&quot;">​</a></h3><p><code>stdlib</code> 已经使用了契约，这使得上述分析得到了改进。契约的这一部分是<strong>稳定</strong>的，这意味着您现在就可以从改进的分析中受益，而无需任何额外的选择加入：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isNullOrEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;length of &#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$x</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; is \${x.length}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 耶，智能类型转换为非空类型！</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;42&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="自定义契约" tabindex="-1">自定义契约 <a class="header-anchor" href="#自定义契约" aria-label="Permalink to &quot;自定义契约&quot;">​</a></h3><p>您可以为自己的函数<strong>声明</strong>契约，但此<strong>特性</strong>是<strong>实验性的</strong>，因为当前语法处于早期原型阶段，很可能会更改。另请注意，目前 Kotlin 编译器不验证契约，因此编写正确且健全的契约是程序员的责任。</p><p>自定义契约通过调用 <code>contract</code> 标准库函数引入，该函数提供 DSL <strong>作用域</strong>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isNullOrEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    contract</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        returns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">implies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this@isNullOrEmpty</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>有关语法详情以及兼容性说明，请参见 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/kotlin-contracts.md" target="_blank" rel="noreferrer">KEEP</a>。</p><h2 id="在变量中捕获-when-主体" tabindex="-1">在变量中捕获 when 主体 <a class="header-anchor" href="#在变量中捕获-when-主体" aria-label="Permalink to &quot;在变量中捕获 when 主体&quot;">​</a></h2><p>在 Kotlin 1.3 中，现在可以将 <code>when</code> 主体捕获到变量中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getBody</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> executeRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Success </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response.body</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HttpError </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> throw</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HttpException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(response.status)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span></code></pre></div><p>虽然之前也可以在 <code>when</code> 之前提取此变量，但 <code>when</code> 中的 <code>val</code> 将其<strong>作用域</strong>正确限制在 <code>when</code> <strong>代码块</strong>内，从而防止命名空间污染。<a href="/kotlin/control-flow#when-expressions-and-statements">有关 <code>when</code> 的完整文档请参见此处</a>。</p><h2 id="接口伴生对象中的-jvmstatic-和-jvmfield" tabindex="-1">接口伴生对象中的 @JvmStatic 和 @JvmField <a class="header-anchor" href="#接口伴生对象中的-jvmstatic-和-jvmfield" aria-label="Permalink to &quot;接口伴生对象中的 @JvmStatic 和 @JvmField&quot;">​</a></h2><p>借助 Kotlin 1.3，现在可以为接口的 <code>companion</code> 对象成员标记 <code>@JvmStatic</code> 和 <code>@JvmField</code> 注解。在类文件中，这些成员将被提升到相应的接口并标记为 <code>static</code>。</p><p>例如，以下 Kotlin 代码：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    companion</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @JvmField</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> answer: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @JvmStatic</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sayHello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, world!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>它等效于以下 Java 代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> answer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sayHello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="注解类中的嵌套声明" tabindex="-1">注解类中的嵌套声明 <a class="header-anchor" href="#注解类中的嵌套声明" aria-label="Permalink to &quot;注解类中的嵌套声明&quot;">​</a></h2><p>在 Kotlin 1.3 中，注解可以拥有嵌套类、接口、对象和伴生对象：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">annotation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    enum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Direction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { UP, DOWN, LEFT, RIGHT }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    annotation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Bar</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    companion</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bar: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="无参数-main-函数" tabindex="-1">无参数 main 函数 <a class="header-anchor" href="#无参数-main-函数" aria-label="Permalink to &quot;无参数 main 函数&quot;">​</a></h2><p>按照惯例，Kotlin 程序的入口点是一个签名类似 <code>main(args: Array&lt;String&gt;)</code> 的函数，其中 <code>args</code> 表示传递给程序的命令行<strong>实参</strong>。然而，并非每个<strong>应用程序</strong>都支持命令行<strong>实参</strong>，因此这个<strong>形参</strong>通常最终未被使用。</p><p>Kotlin 1.3 引入了一种更简单的 <code>main</code> 形式，它不带任何<strong>形参</strong>。现在 Kotlin 中的“Hello, World”短了 19 个字符！</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, world!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="大参数量函数" tabindex="-1">大参数量函数 <a class="header-anchor" href="#大参数量函数" aria-label="Permalink to &quot;大参数量函数&quot;">​</a></h2><p>在 Kotlin 中，函数类型表示为接受不同数量<strong>形参</strong>的泛型类：<code>Function0&lt;R&gt;</code>、<code>Function1&lt;P0, R&gt;</code>、<code>Function2&lt;P0, P1, R&gt;</code> 等。这种方法存在一个问题，即此列表是有限的，目前以 <code>Function22</code> 结束。</p><p>Kotlin 1.3 放宽了这一限制，并增加了对<strong>大参数量函数</strong>的支持：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> trueEnterpriseComesToKotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ... /* </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">42</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> more</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> */, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">., </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="渐进模式" tabindex="-1">渐进模式 <a class="header-anchor" href="#渐进模式" aria-label="Permalink to &quot;渐进模式&quot;">​</a></h2><p>Kotlin 非常重视代码的稳定性<strong>和向后兼容性</strong>：Kotlin 兼容性策略规定，破坏性更改（例如，使原本可以正常编译的代码不再编译的更改）只能在<strong>主要版本</strong>（<strong>1.2</strong>、<strong>1.3</strong> 等）中引入。</p><p>我们认为许多用户可以受益于更快的周期，其中关键的<strong>编译器 Bug 修复</strong>可立即生效，从而使代码更安全、更正确。因此，Kotlin 1.3 引入了 <em>渐进式</em> 编译器模式，可以通过向编译器传递<strong>实参</strong> <code>-progressive</code> 来启用。</p><p>在渐进模式下，语言语义中的一些修复可以立即生效。所有这些修复都具有两个重要属性：</p><ul><li>它们<strong>保留</strong>了源代码与旧版本编译器的<strong>向后兼容性</strong>，这意味着所有可以通过渐进式编译器编译的代码都可以被非渐进式编译器正常编译。</li><li>它们只会从某种意义上使代码更<em>安全</em>——例如，某些不健全的智能类型转换可能被禁止，生成的代码的行为可能会变得更可预测/稳定，等等。</li></ul><p>启用渐进模式可能需要您重写部分代码，但工作量不应太大——渐进模式下启用的所有修复都经过精心挑选、<strong>审阅</strong>，并提供了工具迁移协助。我们预计渐进模式将是任何活跃维护且快速更新到最新语言版本的代码库的不错选择。</p><h2 id="内联类" tabindex="-1">内联类 <a class="header-anchor" href="#内联类" aria-label="Permalink to &quot;内联类&quot;">​</a></h2><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>内联类处于 <a href="/kotlin/components-stability">Alpha</a> 阶段。它们未来可能会发生不兼容的更改，并需要手动迁移。我们非常感谢您在 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 上提供反馈。有关详细信息，请参见 <a href="/kotlin/inline-classes">参考</a>。</p></div><p>Kotlin 1.3 引入了一种新型<strong>声明</strong>——<code>inline class</code>。内联类可以被视为普通类的一种受限版本，特别是，内联类必须只包含一个属性：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Kotlin 编译器将利用此限制来积极<strong>优化</strong>内联类的<strong>运行时表示</strong>，并尽可能用底层属性的值替换其<strong>实例</strong>，从而消除<strong>构造函数调用</strong>、GC 压力并启用其他<strong>优化</strong>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在下一行不会发生构造函数调用，并且</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在运行时 &#39;name&#39; 仅包含字符串 &quot;Kotlin&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Kotlin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name.s) </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>有关内联类的详细信息，请参见 <a href="/kotlin/inline-classes">参考</a>。</p><h2 id="无符号整数" tabindex="-1">无符号整数 <a class="header-anchor" href="#无符号整数" aria-label="Permalink to &quot;无符号整数&quot;">​</a></h2><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>无符号整数处于 <a href="/kotlin/components-stability">Beta</a> 阶段。它们的实现已接近稳定，但未来可能需要迁移步骤。我们将尽力将您需要进行的任何更改降至最低。</p></div><p>Kotlin 1.3 引入了无符号整数类型：</p><ul><li><code>kotlin.UByte</code>：一个无符号 8 位整数，范围从 0 到 255</li><li><code>kotlin.UShort</code>：一个无符号 16 位整数，范围从 0 到 65535</li><li><code>kotlin.UInt</code>：一个无符号 32 位整数，范围从 0 到 2^32 - 1</li><li><code>kotlin.ULong</code>：一个无符号 64 位整数，范围从 0 到 2^64 - 1</li></ul><p>有符号类型的大多数<strong>功能</strong>也支持其无符号对应项：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 您可以使用字面量后缀定义无符号类型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uint </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42u</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ulong </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42uL</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ubyte: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UByte</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 255u</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 您可以通过标准库扩展将有符号类型转换为无符号类型，反之亦然：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uint.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> byte </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ubyte.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toByte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ulong2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> byte.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toULong</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 无符号类型支持类似的操作符：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 22u</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1u</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> shl </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> z </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;128&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toUByte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> range </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5u</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ubyte: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$ubyte</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">, byte: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$byte</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">, ulong2: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$ulong2</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;x: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$x</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">, y: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$y</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">, z: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$z</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">, range: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$range</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>有关详细信息，请参见 <a href="/kotlin/unsigned-integer-types">参考</a>。</p><h2 id="jvmdefault" tabindex="-1">@JvmDefault <a class="header-anchor" href="#jvmdefault" aria-label="Permalink to &quot;@JvmDefault&quot;">​</a></h2><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>@JvmDefault</code> 处于 <a href="/kotlin/components-stability">实验性</a> 阶段。它可能随时被移除或更改。请仅将其用于评估目的。我们非常感谢您在 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 上提供反馈。</p></div><p>Kotlin 面向广泛的 Java 版本，包括 Java 6 和 Java 7，这些版本中接口不允许使用默认方法。为了您的方便，Kotlin 编译器<strong>变通解决了</strong>这一限制，但这种<strong>变通方法</strong>与 Java 8 中引入的 <code>default</code> 方法不兼容。</p><p>这可能是 Java 互操作性的一个问题，因此 Kotlin 1.3 引入了 <code>@JvmDefault</code> 注解。使用此注解标记的方法将被生成为 JVM 的 <code>default</code> 方法：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 将生成为 &#39;default&#39; 方法</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @JvmDefault</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>警告！使用 <code>@JvmDefault</code> 注解您的 API 对二进制兼容性有严重影响。在使用 <code>@JvmDefault</code> 于生产环境之前，请务必仔细阅读 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index.html" target="_blank" rel="noreferrer">参考页面</a>。</p></div><h2 id="标准库" tabindex="-1">标准库 <a class="header-anchor" href="#标准库" aria-label="Permalink to &quot;标准库&quot;">​</a></h2><h3 id="多平台随机数" tabindex="-1">多平台随机数 <a class="header-anchor" href="#多平台随机数" aria-label="Permalink to &quot;多平台随机数&quot;">​</a></h3><p>在 Kotlin 1.3 之前，无法在所有<strong>平台</strong>上统一生成随机数——我们必须求助于诸如 JVM 上的 <code>java.util.Random</code> 等<strong>平台特有的解决方案</strong>。此版本通过引入 <code>kotlin.random.Random</code> 类解决了这个问题，该类在所有<strong>平台</strong>上均可用：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.random.Random</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Random.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// number is in range [0, limit)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(number)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="isnullorempty-和-orempty-扩展" tabindex="-1">isNullOrEmpty 和 orEmpty 扩展 <a class="header-anchor" href="#isnullorempty-和-orempty-扩展" aria-label="Permalink to &quot;isNullOrEmpty 和 orEmpty 扩展&quot;">​</a></h3><p><code>isNullOrEmpty</code> 和 <code>orEmpty</code> <strong>扩展</strong>对于某些类型已存在于标准库中。第一个在<strong>接收者</strong>为 <code>null</code> 或空时返回 <code>true</code>，第二个在<strong>接收者</strong>为 <code>null</code> 时回退到空<strong>实例</strong>。Kotlin 1.3 为<strong>集合</strong>、<code>map</code> 和<strong>对象数组</strong>提供了类似的<strong>扩展</strong>。</p><h3 id="在两个现有数组之间复制元素" tabindex="-1">在两个现有数组之间复制元素 <a class="header-anchor" href="#在两个现有数组之间复制元素" aria-label="Permalink to &quot;在两个现有数组之间复制元素&quot;">​</a></h3><p><code>array.copyInto(targetArray, targetOffset, startIndex, endIndex)</code> 函数适用于现有数组类型（包括无符号数组），这使得在纯 Kotlin 中实现基于数组的容器变得更加容易。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sourceArr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;k&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;o&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;t&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;l&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;i&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;n&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> targetArr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sourceArr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">copyInto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">arrayOfNulls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, startIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, endIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(targetArr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contentToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sourceArr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">copyInto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(targetArr, startIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, endIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(targetArr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contentToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="associatewith" tabindex="-1">associateWith <a class="header-anchor" href="#associatewith" aria-label="Permalink to &quot;associateWith&quot;">​</a></h3><p>拥有一个键列表并希望通过将每个键与某个值关联来构建 <code>map</code> 是一种非常常见的情况。以前可以通过 <code>associate { it to getValue(it) }</code> 函数实现，但现在我们引入了一种更高效且易于探索的替代方案：<code>keys.associateWith { getValue(it) }</code>。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> keys </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;a&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;f&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> map </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> keys.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">associateWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">capitalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="ifempty-和-ifblank-函数" tabindex="-1">ifEmpty 和 ifBlank 函数 <a class="header-anchor" href="#ifempty-和-ifblank-函数" aria-label="Permalink to &quot;ifEmpty 和 ifBlank 函数&quot;">​</a></h3><p><strong>集合</strong>、<code>map</code>、<strong>对象数组</strong>、字符序列和序列现在都具有 <code>ifEmpty</code> 函数，该函数允许指定一个回退值，如果<strong>接收者</strong>为空，则将使用该值代替<strong>接收者</strong>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printAllUppercase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> data</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isUpperCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() } }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ifEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&lt;no uppercase&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        result.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printAllUppercase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printAllUppercase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;FOO&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;BAR&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此外，字符序列和字符串还具有 <code>ifBlank</code> <strong>扩展</strong>，其作用与 <code>ifEmpty</code> 相同，但它检查字符串是否全部为空白字符而非空。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;    </span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ifBlank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&lt;blank&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ifBlank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="反射中的密封类" tabindex="-1">反射中的密封类 <a class="header-anchor" href="#反射中的密封类" aria-label="Permalink to &quot;反射中的密封类&quot;">​</a></h3><p>我们为 <code>kotlin-reflect</code> 添加了一个新的 API，可用于<strong>枚举</strong> <code>sealed</code> 类的所有直接子类型，即 <code>KClass.sealedSubclasses</code>。</p><h3 id="较小的改动" tabindex="-1">较小的改动 <a class="header-anchor" href="#较小的改动" aria-label="Permalink to &quot;较小的改动&quot;">​</a></h3><ul><li><code>Boolean</code> 类型现在拥有<strong>伴生对象</strong>。</li><li><code>Any?.hashCode()</code> <strong>扩展</strong>，对 <code>null</code> 返回 0。</li><li><code>Char</code> 现在提供 <code>MIN_VALUE</code> 和 <code>MAX_VALUE</code> 常量。</li><li>原生类型<strong>伴生对象</strong>中的 <code>SIZE_BYTES</code> 和 <code>SIZE_BITS</code> 常量。</li></ul><h2 id="工具" tabindex="-1">工具 <a class="header-anchor" href="#工具" aria-label="Permalink to &quot;工具&quot;">​</a></h2><h3 id="ide-中的代码风格支持" tabindex="-1">IDE 中的代码风格支持 <a class="header-anchor" href="#ide-中的代码风格支持" aria-label="Permalink to &quot;IDE 中的代码风格支持&quot;">​</a></h3><p>Kotlin 1.3 引入了在 IntelliJ IDEA 中对 <a href="/kotlin/coding-conventions">推荐代码风格</a> 的支持。请查看 <a href="/kotlin/code-style-migration-guide">此页面</a> 以获取迁移指南。</p><h3 id="kotlinx-serialization" tabindex="-1">kotlinx.serialization <a class="header-anchor" href="#kotlinx-serialization" aria-label="Permalink to &quot;kotlinx.serialization&quot;">​</a></h3><p><a href="https://github.com/Kotlin/kotlinx.serialization" target="_blank" rel="noreferrer">kotlinx.serialization</a> 是一个库，它为 Kotlin 中的对象**（反）序列化<strong>提供了多平台支持。以前它是一个独立的</strong>项目**，但自 Kotlin 1.3 起，它随 Kotlin 编译器发行版一起提供，与其它编译器插件地位相同。主要区别在于您无需手动关注 Serialization IDE 插件与您正在使用的 Kotlin IDE 插件版本是否兼容：现在 Kotlin IDE 插件已经包含序列化！</p><p>有关 <a href="https://github.com/Kotlin/kotlinx.serialization#current-project-status" target="_blank" rel="noreferrer">详细信息</a>，请参见此处。</p><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>尽管 kotlinx.serialization 现在随 Kotlin 编译器发行版一起提供，但它在 Kotlin 1.3 中仍被视为一项实验性特性。</p></div><h3 id="脚本更新" tabindex="-1">脚本更新 <a class="header-anchor" href="#脚本更新" aria-label="Permalink to &quot;脚本更新&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>脚本目前处于 <a href="/kotlin/components-stability">实验性</a> 阶段。它可能随时被移除或更改。请仅将其用于评估目的。我们非常感谢您在 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 上提供反馈。</p></div><p>Kotlin 1.3 继续发展和改进脚本 API，引入了一些针对脚本定制的实验性支持，例如添加<strong>外部属性</strong>、提供<strong>静态或动态依赖项</strong>等。</p><p>有关其他详细信息，请查阅 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/scripting-support.md" target="_blank" rel="noreferrer">KEEP-75</a>。</p><h3 id="scratches-支持" tabindex="-1">Scratches 支持 <a class="header-anchor" href="#scratches-支持" aria-label="Permalink to &quot;Scratches 支持&quot;">​</a></h3><p>Kotlin 1.3 引入了对可运行的 Kotlin <em>scratch 文件</em>的支持。<em>Scratch 文件</em> 是一个带有 .kts 扩展名的 Kotlin 脚本文件，您可以直接在编辑器中运行并获得<strong>求值结果</strong>。</p><p>有关详细信息，请查阅通用的 <a href="https://www.jetbrains.com/help/idea/scratches.html" target="_blank" rel="noreferrer">Scratches 文档</a>。</p>`,113)]))}const g=i(l,[["render",h]]);export{o as __pageData,g as default};
