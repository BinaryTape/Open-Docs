import{_ as s,c as e,o as a,ag as n}from"./chunks/framework.Bksy39di.js";const c=JSON.parse('{"title":"一致性","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/api-guidelines-consistency.md","filePath":"kotlin/api-guidelines-consistency.md","lastUpdated":1754307826000}'),t={name:"kotlin/api-guidelines-consistency.md"};function l(o,i,h,p,r,d){return a(),e("div",null,i[0]||(i[0]=[n(`<h1 id="一致性" tabindex="-1">一致性 <a class="header-anchor" href="#一致性" aria-label="Permalink to &quot;一致性&quot;">​</a></h1><p>一致性在 API 设计中至关重要，能确保易用性。通过保持形参顺序、命名约定和错误处理机制的一致性，您的库将对用户更直观、更可靠。遵循这些最佳实践有助于避免混淆和误用，从而带来更好的开发者体验和更健壮的应用程序。</p><h2 id="保持形参顺序、命名和用法一致" tabindex="-1">保持形参顺序、命名和用法一致 <a class="header-anchor" href="#保持形参顺序、命名和用法一致" aria-label="Permalink to &quot;保持形参顺序、命名和用法一致&quot;">​</a></h2><p>在设计库时，请保持实参的顺序、命名方案和重载使用的一致性。例如，如果您现有方法具有 <code>offset</code> 和 <code>length</code> 形参，则不应为新方法切换到 <code>startIndex</code> 和 <code>endIndex</code> 等替代方案，除非有充分的理由。</p><p>库提供的重载函数应行为相同。用户期望在他们更改传递给库的值类型时，其行为保持一致。例如，这些调用都创建了相同的实例，因为输入在语义上是相同的：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BigDecimal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BigDecimal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BigDecimal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;200&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>避免混用 <code>startIndex</code> 和 <code>stopIndex</code> 等形参名称与 <code>beginIndex</code> 和 <code>endIndex</code> 等同义词。同样，为集合中的值选择一个术语，例如 <code>element</code>、<code>item</code>、<code>entry</code> 或 <code>entity</code>，并坚持使用它。</p><p>以一致且可预测的方式命名相关方法。例如，Kotlin 标准库包含 <code>first</code> 和 <code>firstOrNull</code>、<code>single</code> 或 <code>singleOrNull</code> 等配对。这些配对清晰地表明某些可能返回 <code>null</code>，而另一些可能抛出异常。形参应按从一般到具体的顺序声明，因此必要输入出现在前面，可选输入出现在最后。例如，在 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/find-any-of.html" target="_blank" rel="noreferrer"><code>CharSequence.findAnyOf</code></a> 中，<code>strings</code> 集合在前，接着是 <code>startIndex</code>，最后是 <code>ignoreCase</code> 标志。</p><p>考虑一个管理员工记录的库，它提供以下 API 来搜索员工：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> findStaffBySeniority</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    startIndex: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    minYearsServiceExclusive: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> findStaffByAge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    minAgeInclusive: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    startIndex: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>此 API 将极其难以正确使用。存在多个相同类型的形参，它们以不一致的顺序呈现，并以不一致的方式使用。您的库用户很可能会根据他们使用现有函数的经验，对新函数做出不正确的假设。</p><h2 id="将面向对象设计用于数据和状态" tabindex="-1">将面向对象设计用于数据和状态 <a class="header-anchor" href="#将面向对象设计用于数据和状态" aria-label="Permalink to &quot;将面向对象设计用于数据和状态&quot;">​</a></h2><p>Kotlin 同时支持面向对象和函数式编程风格。在您的 API 中使用类来表示数据和状态。当数据和状态具有层次结构时，考虑使用继承。</p><p>如果所有所需状态都可以作为形参传递，则优先使用顶层函数。当对这些函数的调用将要进行链式操作时，考虑将它们编写为扩展函数以提高可读性。</p><h2 id="选择合适的错误处理机制" tabindex="-1">选择合适的错误处理机制 <a class="header-anchor" href="#选择合适的错误处理机制" aria-label="Permalink to &quot;选择合适的错误处理机制&quot;">​</a></h2><p>Kotlin 提供了几种错误处理机制。您的 API 可以抛出异常、返回 <code>null</code> 值、使用自定义结果类型，或使用内置的 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-result/" target="_blank" rel="noreferrer"><code>Result</code></a> 类型。确保您的库一致且适当地使用这些选项。</p><p>当无法获取或计算数据时，使用可空的返回类型并返回 <code>null</code> 以指示数据缺失。在其他情况下，抛出异常或返回 <code>Result</code> 类型。</p><p>考虑提供函数的重载版本，其中一个抛出异常，而另一个则将其包装在结果类型中。在这些情况下，使用 <code>Catching</code> 后缀来表示函数中捕获了异常。例如，标准库有使用此约定的 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html" target="_blank" rel="noreferrer"><code>run</code></a> 和 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run-catching.html" target="_blank" rel="noreferrer"><code>runCatching</code></a> 函数，并且协程库有用于通道的 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html" target="_blank" rel="noreferrer"><code>receive</code></a> 和 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive-catching.html" target="_blank" rel="noreferrer"><code>receiveCatching</code></a> 方法。</p><p>避免将异常用于正常的控制流。设计您的 API，允许在尝试操作之前进行条件检测，从而防止不必要的错误处理。命令/查询分离 (Command / Query Separation) 是一种可在此处应用的有用模式。</p><h2 id="保持约定和质量" tabindex="-1">保持约定和质量 <a class="header-anchor" href="#保持约定和质量" aria-label="Permalink to &quot;保持约定和质量&quot;">​</a></h2><p>一致性的最后一个方面与库本身的设计无关，而是与保持高质量水平有关。</p><p>您应该使用自动化工具（代码检查工具）进行静态分析，以确保您的代码遵循通用的 Kotlin 约定和项目特有的约定。</p><p>Kotlin 库还应提供一套单元测试和集成测试，涵盖所有 API 入口点的所有文档化行为。测试应包含广泛的输入，特别是已知的边界情况和边缘情况。任何未经测试的行为都应被假定为（充其量）不可靠。</p><p>在开发期间使用这套测试来验证更改不会破坏现有行为。在每次发布时，作为标准化构建和发布流水线的一部分，运行这些测试。像 <a href="https://github.com/Kotlin/kotlinx-kover" target="_blank" rel="noreferrer">Kover</a> 这样的工具可以集成到您的构建过程中，以测量覆盖率并生成报告。</p><h2 id="下一步" tabindex="-1">下一步 <a class="header-anchor" href="#下一步" aria-label="Permalink to &quot;下一步&quot;">​</a></h2><p>本指南的下一部分将介绍可预测性。</p><p><a href="/kotlin/api-guidelines-predictability">继续阅读下一部分</a></p>`,27)]))}const g=s(t,[["render",l]]);export{c as __pageData,g as default};
