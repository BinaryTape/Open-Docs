import{_ as l,c as t,o as r,ag as e}from"./chunks/framework.Bksy39di.js";const d=JSON.parse('{"title":"Google Summer of Code 與 Kotlin 2023","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/gsoc-2023.md","filePath":"zh-Hant/kotlin/gsoc-2023.md","lastUpdated":1754307826000}'),i={name:"zh-Hant/kotlin/gsoc-2023.md"};function n(a,o,s,p,c,u){return r(),t("div",null,o[0]||(o[0]=[e('<h1 id="google-summer-of-code-與-kotlin-2023" tabindex="-1">Google Summer of Code 與 Kotlin 2023 <a class="header-anchor" href="#google-summer-of-code-與-kotlin-2023" aria-label="Permalink to &quot;Google Summer of Code 與 Kotlin 2023&quot;">​</a></h1><p>本文包含 Google Summer of Code 與 Kotlin 2023 的 <a href="#project-ideas">專案構想清單</a>。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Google Summer of Code 2023 已結束。 如果您想參與 GSoC 2024，請查看 <a href="/zh-Hant/kotlin/gsoc-2024#project-ideas">這份專案構想清單</a>。</p></div><h2 id="專案構想" tabindex="-1">專案構想 <a class="header-anchor" href="#專案構想" aria-label="Permalink to &quot;專案構想&quot;">​</a></h2><h3 id="kotlin-multiplatform-protobufs-難-350-小時" tabindex="-1">Kotlin Multiplatform protobufs [難, 350 小時] <a class="header-anchor" href="#kotlin-multiplatform-protobufs-難-350-小時" aria-label="Permalink to &quot;Kotlin Multiplatform protobufs [難, 350 小時]&quot;">​</a></h3><p><strong>描述</strong></p><p>為 protoc 新增對 Kotlin/Common protos 的支援，並提供 Kotlin/Native (iOS) 執行時環境與 Objective-C 互通功能。</p><p><strong>動機</strong></p><p>儘管 protobufs 有許多平台實作，但在 Kotlin Multiplatform 專案中尚無使用它們的方法。</p><p><strong>預期成果</strong></p><p>設計並建構 Kotlin Multiplatform Protobuf 支援，最終貢獻至：</p><ul><li><a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noreferrer">GitHub – protocolbuffers/protobuf: Protocol Buffers – Google 的資料交換格式</a></li><li><a href="https://github.com/google/protobuf-gradle-plugin" target="_blank" rel="noreferrer">GitHub – google/protobuf-gradle-plugin</a></li><li><a href="https://plugins.gradle.org/plugin/org.jetbrains.kotlin.multiplatform" target="_blank" rel="noreferrer">Kotlin Multiplatform Gradle Plugin</a></li></ul><p><strong>所需技能 (優先)</strong></p><ul><li>Kotlin</li><li>Objective-C</li><li>C++</li></ul><h3 id="kotlin-編譯器錯誤訊息-難-350-小時" tabindex="-1">Kotlin 編譯器錯誤訊息 [難, 350 小時] <a class="header-anchor" href="#kotlin-編譯器錯誤訊息-難-350-小時" aria-label="Permalink to &quot;Kotlin 編譯器錯誤訊息 [難, 350 小時]&quot;">​</a></h3><p><strong>描述</strong></p><p>為 K2 Kotlin 編譯器新增改進後的編譯器錯誤訊息：提供更多可操作且詳細的資訊 (如 Rust)。</p><p><strong>動機</strong></p><p>Rust 編譯器錯誤訊息通常被認為是所有編譯器中最有幫助的。 Kotlin K2 編譯器為 Kotlin 中更好的編譯器錯誤提供了一個堅實的基礎，但這項潛力尚未完全發揮。</p><p><strong>預期成果</strong></p><p>利用 StackOverflow 及其他資料來源，發掘對使用者具有顯著價值的常見編譯器錯誤。 對編譯器做出貢獻，以改進這些錯誤訊息。</p><p><strong>所需技能 (優先)</strong></p><ul><li>Kotlin</li><li>編譯器架構</li></ul><h3 id="kotlin-multiplatform-程式庫-易或中-175-或-350-小時" tabindex="-1">Kotlin Multiplatform 程式庫 [易或中, 175 或 350 小時] <a class="header-anchor" href="#kotlin-multiplatform-程式庫-易或中-175-或-350-小時" aria-label="Permalink to &quot;Kotlin Multiplatform 程式庫 [易或中, 175 或 350 小時]&quot;">​</a></h3><p><strong>描述</strong></p><p>建立並發佈 (至 Maven Central) 常用於 Kotlin Multiplatform 的程式庫。 例如：壓縮、加密。</p><p><strong>動機</strong></p><p>Kotlin Multiplatform 仍相對較新，需要一些額外的程式庫，這些程式庫可以是平台獨立的 (Kotlin/Common) 和/或具有平台實作的 (<code>expect</code>/<code>actual</code>)。</p><p><strong>預期成果</strong></p><p>設計並交付至少一個 Kotlin Multiplatform 程式庫，其中 JVM/Android 和 Kotlin/Native (iOS) 的優先順序高於其他目標 (Kotlin/JS)。</p><p><strong>所需技能 (優先)</strong></p><ul><li>Kotlin</li><li>Objective-C</li></ul><h3 id="groovy-轉-kotlin-gradle-dsl-轉換器-中-350-小時" tabindex="-1">Groovy 轉 Kotlin Gradle DSL 轉換器 [中, 350 小時] <a class="header-anchor" href="#groovy-轉-kotlin-gradle-dsl-轉換器-中-350-小時" aria-label="Permalink to &quot;Groovy 轉 Kotlin Gradle DSL 轉換器 [中, 350 小時]&quot;">​</a></h3><p><strong>描述</strong></p><p>此專案旨在建立一個 Groovy 轉 Kotlin 轉換器，主要專注於 Gradle 腳本。 我們將從基本的使用案例開始，例如使用者希望將 Groovy 風格的依賴宣告貼到 Kotlin 腳本中，並且 IDE 自動轉換它們。 之後，我們將開始支援更複雜的程式碼結構和完整檔案的轉換。</p><p><strong>動機</strong></p><p>Kotlin Gradle DSL 的普及度不斷提高，甚至很快就會成為使用 Gradle 建構專案的預設選擇。 然而，許多關於 Gradle 的文件和資源仍然參考 Groovy，並且將 Groovy 範例貼到 <code>build.gradle.kts</code> 中需要手動編輯。 此外，許多關於 Gradle 的新功能將會首先在 Kotlin 中提供，因此使用者將從 Groovy DSL 遷移到 Kotlin DSL。 因此，建構設定的自動程式碼轉換將大大簡化此遷移過程，節省大量時間。</p><p><strong>預期成果</strong></p><p>一個適用於 IntelliJ IDEA 的外掛程式，能夠將 Groovy 程式碼轉換為 Kotlin，主要專注於 Gradle DSL。</p><p><strong>所需技能 (優先)</strong></p><ul><li>Gradle 基本知識</li><li>解析器與編譯器運作原理的基本知識</li><li>Kotlin 基本知識</li></ul><h3 id="eclipse-gradle-kts-編輯-中-350-小時" tabindex="-1">Eclipse Gradle KTS 編輯 [中, 350 小時] <a class="header-anchor" href="#eclipse-gradle-kts-編輯-中-350-小時" aria-label="Permalink to &quot;Eclipse Gradle KTS 編輯 [中, 350 小時]&quot;">​</a></h3><div class="note custom-block"><p class="custom-block-title">NOTE</p><p><a href="https://kotlinfoundation.org/news/gsoc-2023-eclipse-gradle-kotlin/" target="_blank" rel="noreferrer">閱讀有關此專案的部落格文章</a></p></div><p><strong>描述</strong></p><p>改進在 Eclipse 中編輯 Gradle Kotlin Script (KTS) 的體驗。</p><p><strong>動機</strong></p><p>IntelliJ IDEA 和 Android Studio 對於編輯 KTS Gradle 建構腳本有很好的支援，但 Eclipse 的支援則有所欠缺。 Ctrl-點擊至定義、程式碼補齊、程式碼錯誤高亮顯示都可以改進。</p><p><strong>預期成果</strong></p><p>對 Gradle Eclipse 外掛程式做出貢獻，以改進編輯 KTS 的開發者體驗。</p><p><strong>所需技能 (優先)</strong></p><ul><li>Kotlin</li><li>Gradle</li><li>Eclipse 平台和外掛程式</li></ul><h3 id="改進-intellij-idea-的-kotlin-外掛程式中參數轉發的支援-中-350-小時" tabindex="-1">改進 IntelliJ IDEA 的 Kotlin 外掛程式中參數轉發的支援 [中, 350 小時] <a class="header-anchor" href="#改進-intellij-idea-的-kotlin-外掛程式中參數轉發的支援-中-350-小時" aria-label="Permalink to &quot;改進 IntelliJ IDEA 的 Kotlin 外掛程式中參數轉發的支援 [中, 350 小時]&quot;">​</a></h3><p><strong>描述與動機</strong></p><p><a href="https://github.com/JetBrains/intellij-community/tree/master/plugins/kotlin" target="_blank" rel="noreferrer">Kotlin 外掛程式</a> 在 IntelliJ IDEA 和 Android Studio 中提供 Kotlin 語言支援。 在此專案的範圍內，您將改進外掛程式的參數轉發支援。</p><p>傾向組合而非繼承是一個廣為人知的原則。 IntelliJ IDEA 為使用繼承的程式碼 (IDE 建議的補齊和快速修復) 提供很好的支援，但對使用組合而非繼承的程式碼支援尚未實作。</p><p>處理大量使用組合的程式碼時，主要問題是參數轉發。 特別是：</p><ul><li>IDE 不會建議補齊可以轉發為參數的引數宣告，這些參數目前使用預設參數值。</li><li>IDE 不會重新命名轉發參數的鏈條。</li><li>IDE 不提供任何快速修復，可以將所有必需的引數填入可轉發的參數。</li></ul><p>一個值得注意的例子，這種支援將會受到高度讚賞的是 Jetpack Compose。 Android 用於建構 UI 的現代工具包 Jetpack Compose 大量使用函數組合和參數轉發。 處理 <code>@Composable</code> 函數很快就會變得乏味，因為它們有許多參數。 例如，<code>androidx.compose.material.TextField</code> 有 19 個參數。</p><p><strong>預期成果</strong></p><ul><li>改進 IntelliJ IDEA 中的參數和引數補齊建議。</li><li>實作 IDE 快速修復，建議將所有必需的引數填入名稱和類型相同的參數。</li><li><strong>重新命名 (Rename)</strong> 重構功能會重新命名轉發參數的鏈條。</li><li>關於參數轉發和具有大量參數的函數的所有其他 IDE 改進。</li></ul><p><strong>所需技能 (優先)</strong></p><ul><li>Kotlin 和 Java 知識</li><li>在大型程式碼庫中導航的能力</li></ul><h3 id="增強-kotlinx-benchmark-程式庫的-api-和使用者體驗-易-175-小時" tabindex="-1">增強 kotlinx-benchmark 程式庫的 API 和使用者體驗 [易, 175 小時] <a class="header-anchor" href="#增強-kotlinx-benchmark-程式庫的-api-和使用者體驗-易-175-小時" aria-label="Permalink to &quot;增強 kotlinx-benchmark 程式庫的 API 和使用者體驗 [易, 175 小時]&quot;">​</a></h3><div class="note custom-block"><p class="custom-block-title">NOTE</p><p><a href="https://kotlinfoundation.org/news/gsoc-2023-kotlinx-benchmark/" target="_blank" rel="noreferrer">閱讀有關此專案的部落格文章</a></p></div><p><strong>描述</strong></p><p><code>kotlinx-benchmark</code> 是一個用於基準測試 Kotlin 編寫的多平台程式碼的開源程式庫。 它只有一個基本骨架，但缺乏改善使用體驗的功能，例如細粒度基準測試設定 (如時間單位、模式)、JVM 與 Kotlin/Native 基準測試之間的特性對等、命令列 API，以及現代 Gradle 支援。 其文件、整合測試和範例也滯後。</p><p><strong>動機</strong></p><p>該程式庫已經實作，但有時難以正確使用，並使一些使用者感到困惑。 改進程式庫的使用者體驗將極大地幫助 Kotlin 社群。</p><p><strong>預期成果</strong></p><ul><li>該程式庫擁有清晰且包含使用範例的文件。</li><li>該程式庫的 API 簡單易用。</li><li>用於基準測試 Kotlin/JVM 程式碼的選項也適用於基準測試其他平台上的程式碼。</li></ul><p><strong>所需技能 (優先)</strong></p><ul><li>Kotlin</li><li>Gradle 內部原理</li></ul><h3 id="偵錯器中-kotlin-coroutines-的-parallel-stacks-難-350-小時" tabindex="-1">偵錯器中 Kotlin Coroutines 的 Parallel Stacks [難, 350 小時] <a class="header-anchor" href="#偵錯器中-kotlin-coroutines-的-parallel-stacks-難-350-小時" aria-label="Permalink to &quot;偵錯器中 Kotlin Coroutines 的 Parallel Stacks [難, 350 小時]&quot;">​</a></h3><div class="note custom-block"><p class="custom-block-title">NOTE</p><p><a href="https://kotlinfoundation.org/news/gsoc-2023-parallel-stacks/" target="_blank" rel="noreferrer">閱讀有關此專案的部落格文章</a></p></div><p><strong>描述</strong></p><p>實作 Kotlin coroutines 的 <a href="https://www.jetbrains.com/help/rider/Debugging_Multithreaded_Applications.html#parallel-stacks" target="_blank" rel="noreferrer">Parallel Stacks</a> 視圖，以改進 coroutine 偵錯體驗。</p><p><strong>動機</strong></p><p>目前，IntelliJ IDEA 中對 coroutines 偵錯的支援非常有限。 Kotlin 偵錯器有 <a href="/zh-Hant/kotlin/debug-coroutines-with-idea#debug-coroutines"><strong>Coroutines 面板</strong></a>，允許使用者查看所有 coroutines 及其狀態，但在偵錯包含大量 coroutines 的應用程式時，它並不是很實用。 JetBrains Rider 具有 <a href="https://www.jetbrains.com/help/rider/Debugging_Multithreaded_Applications.html#parallel-stacks" target="_blank" rel="noreferrer">Parallel Stacks</a> 功能，允許使用者在圖形視圖中檢查執行緒及其堆疊追蹤，這可能是檢查 coroutines 的好方法。</p><p><strong>預期成果</strong></p><p>利用 Kotlin coroutines 偵錯器 API，開發 IntelliJ IDEA 外掛程式，將 coroutines 的 Parallel Stacks 視圖新增到偵錯器中。 尋找改進 coroutines 圖形表示的方法。</p><p><strong>所需技能 (優先)</strong></p><ul><li>Kotlin</li><li>Kotlin coroutines</li><li>IntelliJ IDEA 外掛程式開發</li></ul>',82)]))}const h=l(i,[["render",n]]);export{d as __pageData,h as default};
