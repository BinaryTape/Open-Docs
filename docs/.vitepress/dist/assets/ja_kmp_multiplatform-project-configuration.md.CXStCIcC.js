import{_ as p,a as e,b as d,c as u,d as s,e as m,f,g as S,h as O,i as b}from"./chunks/remote-artifact-distribution.DrML6DzP.js";import{_ as h,C as K,c as g,o as M,ag as n,j as l,G as o,w as r,a}from"./chunks/framework.Bksy39di.js";const c=JSON.parse('{"title":"Kotlin Multiplatformプロジェクトの構成を選択する","description":"","frontmatter":{},"headers":[],"relativePath":"ja/kmp/multiplatform-project-configuration.md","filePath":"ja/kmp/multiplatform-project-configuration.md","lastUpdated":1755516278000}'),k={name:"ja/kmp/multiplatform-project-configuration.md"};function P(A,t,_,T,w,C){const i=K("list");return M(),g("div",null,[t[15]||(t[15]=n('<h1 id="kotlin-multiplatformプロジェクトの構成を選択する" tabindex="-1">Kotlin Multiplatformプロジェクトの構成を選択する <a class="header-anchor" href="#kotlin-multiplatformプロジェクトの構成を選択する" aria-label="Permalink to &quot;Kotlin Multiplatformプロジェクトの構成を選択する&quot;">​</a></h1><p>既存のプロジェクトにKotlin Multiplatformを追加する場合や、新規プロジェクトを開始する場合、コードの構造化にはさまざまな方法があります。一般的に、1つ以上のKotlin Multiplatform共有モジュールを作成し、それらをAndroidおよびiOSアプリから利用します。</p><p>特定のケースに最適なアプローチを選択するには、以下の質問を考慮してください。</p><ul><li><a href="#connect-a-kotlin-multiplatform-module-to-an-ios-app">Kotlin Multiplatformモジュールによって生成されたiOSフレームワークをiOSアプリからどのように利用しますか？</a> 直接統合しますか、CocoaPods経由ですか、それともSwift Package Manager (SPM)を使用しますか？</li><li><a href="#module-configurations">Kotlin Multiplatform共有モジュールは1つですか、それとも複数ですか？</a> 複数の共有モジュールに対するアンブレラモジュールはどのようにすべきですか？</li><li><a href="#repository-configurations">すべてのコードをモノレポに格納しますか、それとも異なるリポジトリに格納しますか？</a></li><li><a href="#code-sharing-workflow">Kotlin Multiplatformモジュールのフレームワークをローカル依存関係として利用しますか、それともリモート依存関係として利用しますか？</a></li></ul><p>これらの質問に答えることで、プロジェクトに最適な構成を選択できます。</p><h2 id="kotlin-multiplatformモジュールをiosアプリに接続する" tabindex="-1">Kotlin MultiplatformモジュールをiOSアプリに接続する <a class="header-anchor" href="#kotlin-multiplatformモジュールをiosアプリに接続する" aria-label="Permalink to &quot;Kotlin MultiplatformモジュールをiOSアプリに接続する&quot;">​</a></h2><p>iOSアプリからKotlin Multiplatform共有モジュールを使用するには、まずこの共有モジュールから<a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/WhatAreFrameworks.html" target="_blank" rel="noreferrer">iOSフレームワーク</a>を生成する必要があります。その後、それをiOSプロジェクトへの依存関係として追加します。</p><p><img src="'+e+'" alt="Kotlin Multiplatform shared module" width="700"></p><p>このフレームワークは、ローカルまたはリモートの依存関係として利用できます。</p><p>iOSプロジェクトにKotlin Multiplatformモジュールのフレームワークへの依存関係を追加するには、以下のいずれかの方法があります。</p><ul><li><p><strong>直接統合 (Direct integration)</strong>。iOSアプリのビルドに新しい「スクリプト実行フェーズ (run script phase)」を追加することで、フレームワークを直接接続します。<a href="./multiplatform-integrate-in-existing-app#configure-the-ios-project-to-use-a-kmp-framework">Connect the framework to your iOS project</a>でXcodeでの設定方法を確認してください。</p><p>Android Studioウィザードでプロジェクトを作成する際に、この設定を自動的に生成するには<strong>Regular framework</strong>オプションを選択します。</p></li><li><p><strong>CocoaPods統合 (CocoaPods integration)</strong>。<a href="https://cocoapods.org/" target="_blank" rel="noreferrer">CocoaPods</a>を介してフレームワークを接続します。CocoaPodsは、SwiftおよびObjective-Cプロジェクトで広く利用されている依存関係マネージャーです。これはローカル依存関係またはリモート依存関係のどちらでも構いません。詳細は、<a href="./multiplatform-cocoapods-xcode">Use a Kotlin Gradle project as a CocoaPods dependency</a>を参照してください。</p><p>ローカルのCocoaPods依存関係を持つワークフローを設定するには、ウィザードでプロジェクトを生成するか、スクリプトを手動で編集できます。</p></li><li><p><strong>SPMの使用 (Using SPM)</strong>。Swiftコードの配布を管理するためのAppleのツールであるSwift Package Manager (SPM)を使用してフレームワークを接続します。JetBrainsは<a href="https://youtrack.jetbrains.com/issue/KT-53877" target="_blank" rel="noreferrer">SPMの公式サポートに取り組んでいます</a>。現在、XCFrameworksを使用してSwiftパッケージへの依存関係を設定できます。詳細は、<a href="./multiplatform-spm-export">Swift package export setup</a>を参照してください。</p></li></ul><h2 id="モジュール構成" tabindex="-1">モジュール構成 <a class="header-anchor" href="#モジュール構成" aria-label="Permalink to &quot;モジュール構成&quot;">​</a></h2><p>Kotlin Multiplatformプロジェクトで使用できるモジュール構成オプションは2つあります。単一モジュールまたは複数の共有モジュールです。</p><h3 id="単一共有モジュール" tabindex="-1">単一共有モジュール <a class="header-anchor" href="#単一共有モジュール" aria-label="Permalink to &quot;単一共有モジュール&quot;">​</a></h3><p>最もシンプルなモジュール構成は、プロジェクト内に単一のKotlin Multiplatform共有モジュールのみを含みます。</p><p><img src="'+d+'" alt="Single shared module" width="700"></p><p>Androidアプリは、通常のKotlinモジュールとしてKotlin Multiplatform共有モジュールに依存できます。しかし、iOSはKotlinを直接使用できないため、iOSアプリはKotlin Multiplatformモジュールによって生成されたiOSフレームワークに依存する必要があります。</p>',17)),l("table",null,[t[2]||(t[2]=l("tr",null,[l("th",null,"メリット"),l("th",null,"デメリット")],-1)),l("tr",null,[l("td",null,[o(i,null,{default:r(()=>t[0]||(t[0]=[l("li",null,"単一モジュールによるシンプルな設計は、認知負荷を軽減します。機能をどこに配置するか、どのように論理的に分割するかを考える必要がありません。",-1),l("li",null,"開始点として最適です。",-1)])),_:1})]),l("td",null,[o(i,null,{default:r(()=>t[1]||(t[1]=[l("li",null,"共有モジュールが大きくなるにつれて、コンパイル時間が増加します。",-1),l("li",null,"この設計では、機能を分離したり、アプリが必要とする機能のみに依存したりすることができません。",-1)])),_:1})])])]),t[16]||(t[16]=l("h3",{id:"複数の共有モジュール",tabindex:"-1"},[a("複数の共有モジュール "),l("a",{class:"header-anchor",href:"#複数の共有モジュール","aria-label":'Permalink to "複数の共有モジュール"'},"​")],-1)),t[17]||(t[17]=l("p",null,"共有モジュールが大きくなるにつれて、それをフィーチャーモジュールに分割することをお勧めします。これにより、単一モジュールを持つことに関連するスケーラビリティの問題を回避できます。",-1)),t[18]||(t[18]=l("p",null,"Androidアプリは、すべてのフィーチャーモジュールに直接依存することも、必要に応じてその一部のみに依存することもできます。",-1)),t[19]||(t[19]=l("p",null,"iOSアプリは、Kotlin Multiplatformモジュールによって生成された1つのフレームワークに依存できます。複数のモジュールを使用する場合、使用しているすべてのモジュールに依存する追加のモジュール（_アンブレラモジュール_と呼ばれる）を追加し、その後、すべてのモジュールを含むフレームワーク（_アンブレラフレームワーク_と呼ばれる）を構成する必要があります。",-1)),t[20]||(t[20]=l("div",{class:"tip custom-block"},[l("p",{class:"custom-block-title"},"TIP"),l("p",null,"アンブレラフレームワークバンドルには、プロジェクトのすべての共有モジュールが含まれており、iOSアプリにインポートされます。")],-1)),l("table",null,[t[5]||(t[5]=l("tr",null,[l("th",null,"メリット"),l("th",null,"デメリット")],-1)),l("tr",null,[l("td",null,[o(i,null,{default:r(()=>t[3]||(t[3]=[l("li",null,"共有コードの関心の分離。",-1),l("li",null,"より良いスケーラビリティ。",-1)])),_:1})]),l("td",null,[o(i,null,{default:r(()=>t[4]||(t[4]=[l("li",null,"アンブレラフレームワークの設定を含む、より複雑なセットアップ。",-1),l("li",null,"モジュール間の依存関係管理がより複雑になる。",-1)])),_:1})])])]),t[21]||(t[21]=n('<p>アンブレラモジュールを設定するには、すべてのフィーチャーモジュールに依存する別のモジュールを追加し、このモジュールからフレームワークを生成します。</p><p><img src="'+u+'" alt="Umbrella framework" width="700"></p><p>Androidアプリは、一貫性のためにアンブレラモジュールに依存することも、個別のフィーチャーモジュールに依存することもできます。アンブレラモジュールには、しばしば有用なユーティリティ関数や依存性注入のセットアップコードが含まれています。</p><p>アンブレラフレームワークには、一部のモジュールのみをエクスポートできます。これは通常、フレームワークのアーティファクトがリモート依存関係として利用される場合に当てはまります。その主な理由は、自動生成されたコードが除外されるようにすることで、最終的なアーティファクトのサイズを抑えるためです。</p><p>アンブレラフレームワークアプローチの既知の制約として、iOSアプリがフィーチャーモジュールの一部のみを使用することはできず、すべてを自動的に利用するという点があります。この機能の改善案については、<a href="https://youtrack.jetbrains.com/issue/KT-42247" target="_blank" rel="noreferrer">KT-42247</a>および<a href="https://youtrack.jetbrains.com/issue/KT-42250" target="_blank" rel="noreferrer">KT-42250</a>であなたのケースを記述してください。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>以下の例でiOSアプリがアンブレラモジュールに依存していると示されている場合、それはこのモジュールから生成されたアンブレラフレームワークにも依存していることを意味します。</p></div>',6)),t[22]||(t[22]=l("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"アンブレラフレームワークが必要な理由",tabindex:"-1"},[a("アンブレラフレームワークが必要な理由 "),l("a",{class:"header-anchor",href:"#アンブレラフレームワークが必要な理由","aria-label":'Permalink to "アンブレラフレームワークが必要な理由 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),t[23]||(t[23]=n('<p>異なるKotlin Multiplatform共有モジュールから生成された複数のフレームワークをiOSアプリに含めることは可能ですが、このアプローチは推奨しません。Kotlin Multiplatformモジュールがフレームワークにコンパイルされると、結果のフレームワークはそのすべての依存関係を含みます。2つ以上のモジュールが同じ依存関係を使用し、別々のフレームワークとしてiOSに公開されると、Kotlin/Nativeコンパイラは依存関係を複製します。</p><p>この重複は、いくつかの問題を引き起こします。まず、iOSアプリのサイズが不必要に肥大化します。次に、依存関係のコード構造が、重複した依存関係のコード構造と互換性がありません。これは、iOSアプリケーション内で同じ依存関係を持つ2つのモジュールを統合しようとすると問題を引き起こします。たとえば、異なるモジュールが同じ依存関係を介して渡す状態は、接続されません。これにより、予期しない動作やバグにつながる可能性があります。正確な制限の詳細については、<a href="https://touchlab.co/multiple-kotlin-frameworks-in-application/" target="_blank" rel="noreferrer">TouchLabのドキュメント</a>を参照してください。</p><p>Kotlinは共通のフレームワーク依存関係を生成しません。なぜなら、そうしないと重複が発生し、アプリに追加するすべてのKotlinバイナリは可能な限り小さくする必要があるからです。Kotlinランタイム全体とすべての依存関係からのすべてのコードを含めることは無駄です。Kotlinコンパイラは、特定のビルドに必要なものだけをバイナリから正確にトリムできます。しかし、他のビルドが何を必要とするかを知らないため、依存関係を共有しようとすることは実現不可能です。この問題の影響を最小限に抑えるための様々なオプションを検討しています。</p><p>この問題の解決策は、アンブレラフレームワークを使用することです。これにより、iOSアプリが重複した依存関係で肥大化するのを防ぎ、結果として得られるアーティファクトの最適化に役立ち、依存関係間の非互換性によって引き起こされる不満を解消します。</p><h2 id="リポジトリ構成" tabindex="-1">リポジトリ構成 <a class="header-anchor" href="#リポジトリ構成" aria-label="Permalink to &quot;リポジトリ構成&quot;">​</a></h2><p>新規および既存のKotlin Multiplatformプロジェクトで使用できるリポジトリ構成オプションは多数あり、単一のリポジトリを使用したり、複数のリポジトリを組み合わせたりすることができます。</p><h3 id="モノレポ-すべてを1つのリポジトリに" tabindex="-1">モノレポ：すべてを1つのリポジトリに <a class="header-anchor" href="#モノレポ-すべてを1つのリポジトリに" aria-label="Permalink to &quot;モノレポ：すべてを1つのリポジトリに&quot;">​</a></h3><p>一般的なリポジトリ構成は、モノレポ構成と呼ばれます。このアプローチは、Kotlin Multiplatformのサンプルやチュートリアルで使用されています。この場合、リポジトリにはAndroidアプリとiOSアプリの両方、および共有モジュール（アンブレラモジュールを含む複数のモジュールの場合もあり）が含まれます。</p><p><img src="'+s+'" alt="Monorepo configuration" width="700"></p><p><img src="'+m+'" alt="Monorepo configuration" width="700"></p><p>通常、iOSアプリは、直接統合またはCocoaPods統合を使用して、Kotlin Multiplatform共有モジュールを通常のフレームワークとして利用します。詳細およびチュートリアルへのリンクについては、<a href="#connect-a-kotlin-multiplatform-module-to-an-ios-app">Kotlin MultiplatformモジュールをiOSアプリに接続する</a>を参照してください。</p><p>リポジトリがバージョン管理下にある場合、アプリと共有モジュールは同じバージョンを持ちます。</p>',12)),l("table",null,[t[8]||(t[8]=l("tr",null,[l("th",null,"メリット"),l("th",null,"デメリット")],-1)),l("tr",null,[l("td",null,[o(i,null,{default:r(()=>t[6]||(t[6]=[l("li",null,"ウィザードの助けを借りて簡単にセットアップできます。",-1),l("li",null,"すべてのコードが同じリポジトリにあるため、iOS開発者はKotlin Multiplatformコードを簡単に扱えます。",-1)])),_:1})]),l("td",null,[o(i,null,{default:r(()=>t[7]||(t[7]=[l("li",null,"iOS開発者は、慣れないツールをセットアップして構成する必要があります。",-1),l("li",null,"このアプローチは、すでに異なるリポジトリに格納されている既存のアプリにはしばしば適用できません。",-1)])),_:1})])])]),t[24]||(t[24]=n('<p>既存のAndroidおよびiOSアプリがすでに異なるリポジトリに格納されている場合、それらをマージするのではなく、Kotlin Multiplatform部分をAndroidリポジトリに追加するか、別のリポジトリに追加できます。</p><h3 id="_2つのリポジトリ-android-共有-ios" tabindex="-1">2つのリポジトリ：Android + 共有 | iOS <a class="header-anchor" href="#_2つのリポジトリ-android-共有-ios" aria-label="Permalink to &quot;2つのリポジトリ：Android + 共有 | iOS&quot;">​</a></h3><p>別のプロジェクト構成は、2つのリポジトリを持つことです。この場合、Kotlin MultiplatformのリポジトリにはAndroidアプリと共有モジュール（アンブレラモジュールを含む）の両方が含まれ、XcodeプロジェクトにはiOSアプリが含まれます。</p><p><img src="'+f+'" alt="Two repository configuration" width="700"></p><p>AndroidアプリとiOSアプリは個別にバージョン管理でき、共有モジュールはAndroidアプリと一緒にバージョン管理されます。</p><h3 id="_3つのリポジトリ-android-ios-共有" tabindex="-1">3つのリポジトリ：Android | iOS | 共有 <a class="header-anchor" href="#_3つのリポジトリ-android-ios-共有" aria-label="Permalink to &quot;3つのリポジトリ：Android | iOS | 共有&quot;">​</a></h3><p>もう1つのオプションは、Kotlin Multiplatformモジュール用に独立したリポジトリを持つことです。この場合、AndroidアプリとiOSアプリは個別のリポジトリに格納され、プロジェクトの共有コードには複数のフィーチャーモジュールとiOS用のアンブレラモジュールを含めることができます。</p><p><img src="'+S+'" alt="Three repository configuration" width="700"></p><p>各プロジェクトは個別にバージョン管理できます。Kotlin Multiplatformモジュールも、AndroidまたはJVMプラットフォーム用にバージョン管理され、公開される必要があります。フィーチャーモジュールを個別に公開するか、アンブレラモジュールのみを公開してAndroidアプリがそれに依存するようにすることができます。</p><p>Androidアーティファクトを個別に公開することは、Kotlin MultiplatformモジュールがAndroidプロジェクトの一部であるシナリオと比較して、Android開発者にとって追加の複雑さをもたらす可能性があります。</p><p>AndroidチームとiOSチームの両方が同じバージョン管理されたアーティファクトを利用する場合、それらはバージョンパリティ（バージョン同等性）で動作します。チームの観点から見ると、これは共有されたKotlin MultiplatformコードがAndroid開発者によって「所有されている」という印象を避けます。フィーチャー開発のためにすでにバージョン管理された内部KotlinおよびSwiftパッケージを公開している大規模プロジェクトでは、共有Kotlinアーティファクトの公開は既存のワークフローの一部となります。</p><h3 id="多数のリポジトリ-android-ios-複数のライブラリ" tabindex="-1">多数のリポジトリ：Android | iOS | 複数のライブラリ <a class="header-anchor" href="#多数のリポジトリ-android-ios-複数のライブラリ" aria-label="Permalink to &quot;多数のリポジトリ：Android | iOS | 複数のライブラリ&quot;">​</a></h3><p>複数のプラットフォーム上の複数のアプリ間で機能を共有する必要がある場合、Kotlin Multiplatformコードを含む多数のリポジトリを持つことを好むかもしれません。例えば、製品全体で共通のロギングライブラリを、独自のバージョン管理を持つ別のリポジトリに格納することができます。</p><p>この場合、複数のKotlin Multiplatformライブラリリポジトリを持つことになります。複数のiOSアプリが「ライブラリプロジェクト」の異なるサブセットを使用する場合、各アプリは、ライブラリプロジェクトに必要な依存関係を持つアンブレラモジュールを含む追加のリポジトリを持つことができます。</p><p><img src="'+O+'" alt="Many repository configuration" width="700"></p><p>ここでは、各ライブラリもAndroidまたはJVMプラットフォーム用にバージョン管理され、公開される必要があります。アプリと各ライブラリは個別にバージョン管理できます。</p><h2 id="コード共有ワークフロー" tabindex="-1">コード共有ワークフロー <a class="header-anchor" href="#コード共有ワークフロー" aria-label="Permalink to &quot;コード共有ワークフロー&quot;">​</a></h2><p>iOSアプリは、Kotlin Multiplatform共有モジュールから生成されたフレームワークを_ローカル_または_リモート_依存関係として利用できます。ローカル依存関係を使用するには、iOSビルドでフレームワークへのローカルパスを提供します。この場合、フレームワークを公開する必要はありません。あるいは、フレームワークを含むアーティファクトをどこかに公開し、iOSアプリが他のサードパーティ依存関係と同様にリモート依存関係として利用するようにすることもできます。</p><h3 id="ローカル-ソース配布" tabindex="-1">ローカル：ソース配布 <a class="header-anchor" href="#ローカル-ソース配布" aria-label="Permalink to &quot;ローカル：ソース配布&quot;">​</a></h3><p>ローカル配布とは、iOSアプリがKotlin Multiplatformモジュールのフレームワークを公開することなく利用する形式です。iOSアプリは、フレームワークを直接統合するか、CocoaPodsを使用できます。</p><p>このワークフローは、通常、AndroidおよびiOSチームのメンバーが共有のKotlin Multiplatformコードを編集したい場合に使用されます。iOS開発者はAndroid Studioをインストールし、KotlinとGradleの基本的な知識が必要です。</p><p>ローカル配布方式では、iOSアプリのビルドがiOSフレームワークの生成をトリガーします。これにより、iOS開発者はKotlin Multiplatformコードへの変更をすぐに確認できます。</p><p><img src="'+b+'" alt="Local source distribution" width="700"></p><p>このシナリオは通常、2つのケースで使用されます。1つ目は、アーティファクトを公開する必要がないため、モノレポプロジェクト構成のデフォルトのワークフローとして使用できます。2つ目は、リモートワークフローに加えて、ローカル開発用に使用できます。詳細については、<a href="#setting-up-a-local-dependency-for-local-development">ローカル開発のためのローカル依存関係のセットアップ</a>を参照してください。</p><p>このワークフローは、すべてのチームメンバーがプロジェクト全体のコードを編集する準備ができている場合に最も効果的です。これには、共通部分への変更を行った後、AndroidとiOSの両方の部分が含まれます。理想的には、すべてのチームメンバーがAndroid StudioとXcodeをインストールし、共通コードに変更を加えた後に両方のアプリを開いて実行できるようにすることです。</p>',25)),l("table",null,[t[11]||(t[11]=l("tr",null,[l("th",null,"メリット"),l("th",null,"デメリット")],-1)),l("tr",null,[l("td",null,[o(i,null,{default:r(()=>t[9]||(t[9]=[l("li",null,"AndroidとiOSの両方のチームメンバーがKotlin Multiplatformコードを簡単に編集でき、共有コードの作成と保守が共有責任であることを保証します。これにより、チームの孤立を防ぎ、コラボレーションを促進します。",-1),l("li",null,"このアプローチでは、共有コードの個別のバージョン管理と公開は必要ありません。",-1),l("li",null,"iOSチームメンバーがアーティファクトの作成と公開を待つ必要がないため、開発ワークフローが迅速になります。",-1)])),_:1})]),l("td",null,[o(i,null,{default:r(()=>t[10]||(t[10]=[l("li",null,"チームメンバーは、自分のマシンに完全な開発環境をセットアップする必要があります。",-1),l("li",null,"iOS開発者は、Android StudioとGradleの使用方法を学ぶ必要があります。",-1),l("li",null,"共有コードが増え、チームが成長するにつれて、変更の管理が難しくなります。",-1)])),_:1})])])]),t[25]||(t[25]=l("h3",{id:"リモート-アーティファクト配布",tabindex:"-1"},[a("リモート：アーティファクト配布 "),l("a",{class:"header-anchor",href:"#リモート-アーティファクト配布","aria-label":'Permalink to "リモート：アーティファクト配布"'},"​")],-1)),t[26]||(t[26]=l("p",null,"リモート配布とは、フレームワークアーティファクトがCocoaPodまたはSPMを使用してSwiftパッケージとして公開され、iOSアプリによって利用されることを意味します。Androidアプリはバイナリ依存関係をローカルまたはリモートで利用できます。",-1)),t[27]||(t[27]=l("p",null,"リモート配布は、既存のプロジェクトにテクノロジーを徐々に導入するためによく使用されます。これはiOS開発者のワークフローやビルドプロセスを大きく変えません。2つ以上のリポジトリを持つチームは、主にプロジェクトコードを格納するためにリモート配布を使用します。",-1)),t[28]||(t[28]=l("p",null,[a("まず、リモート配布ワークフローを大幅に簡素化する一連のビルドツールである"),l("a",{href:"https://touchlab.co/trykmmbridge",target:"_blank",rel:"noreferrer"},"KMMBridge"),a("を使用することをお勧めします。あるいは、同様のワークフローを自分でセットアップすることも常に可能です。")],-1)),t[29]||(t[29]=l("p",null,[l("img",{src:p,alt:"Remote artifact distribution",width:"700"})],-1)),l("table",null,[t[14]||(t[14]=l("tr",null,[l("th",null,"メリット"),l("th",null,"デメリット")],-1)),l("tr",null,[t[13]||(t[13]=l("td",null,"参加していないiOSチームメンバーは、Kotlinでコーディングしたり、Android StudioやGradleのようなツールの使用方法を学ぶ必要がありません。これにより、チームへの参入障壁が大幅に下がります。",-1)),l("td",null,[o(i,null,{default:r(()=>t[12]||(t[12]=[l("li",null,"共有コードの編集とビルドのプロセスには公開とバージョン管理が含まれるため、iOS開発者にとってワークフローが遅くなります。",-1),l("li",null,"iOSでの共有Kotlinコードのデバッグは困難です。",-1),l("li",null,"iOSチームメンバーが共有コードに貢献する可能性が著しく低下します。",-1),l("li",null,"共有コードのメンテナンスは、参加しているチームメンバーに完全に依存します。",-1)])),_:1})])])]),t[30]||(t[30]=l("h4",{id:"ローカル開発のためのローカル依存関係のセットアップ",tabindex:"-1"},[a("ローカル開発のためのローカル依存関係のセットアップ "),l("a",{class:"header-anchor",href:"#ローカル開発のためのローカル依存関係のセットアップ","aria-label":'Permalink to "ローカル開発のためのローカル依存関係のセットアップ"'},"​")],-1)),t[31]||(t[31]=l("p",null,"多くのチームは、Kotlin Multiplatformテクノロジーを採用する際、iOS開発者にとって開発プロセスを同じに保つためにリモート配布ワークフローを選択します。しかし、このワークフローではKotlin Multiplatformコードの変更が困難です。",-1)),t[32]||(t[32]=l("p",null,"Kotlin Multiplatformモジュールから生成されたフレームワークへのローカル依存関係を持つ追加の「ローカル開発」ワークフローをセットアップすることをお勧めします。",-1)),t[33]||(t[33]=l("p",null,"開発者が新しい機能を追加する際には、Kotlin Multiplatformモジュールをローカル依存関係として利用するように切り替えます。これにより、共通のKotlinコードに変更を加え、iOSからその動作をすぐに確認し、Kotlinコードをデバッグすることができます。機能が準備できたら、リモート依存関係に戻し、それに応じて変更を公開できます。まず共有モジュールへの変更を公開し、その後でアプリに変更を加えます。",-1)),t[34]||(t[34]=l("p",null,"リモート配布ワークフローではCocoaPods統合またはSPMを使用し、ローカル配布ワークフローではフレームワークを直接統合します。",-1)),t[35]||(t[35]=l("p",null,[a("CocoaPodsを使用している場合、代わりにローカル配布ワークフローにCocoaPodsを使用することもできます。"),l("a",{href:"https://touchlab.co/kmmbridgecocoapodslocal",target:"_blank",rel:"noreferrer"},"TouchLabのドキュメント"),a("に記載されている環境変数を変更することで、それらを切り替えることができます。")],-1))])}const j=h(k,[["render",P]]);export{c as __pageData,j as default};
