import{_ as i}from"./chunks/basic-strategy-graph.DHaXnO2A.js";import{_ as a,c as n,o as l,ag as t}from"./chunks/framework.Bksy39di.js";const y=JSON.parse('{"title":"カスタム戦略グラフ","description":"","frontmatter":{},"headers":[],"relativePath":"ja/koog/custom-strategy-graphs.md","filePath":"ja/koog/custom-strategy-graphs.md","lastUpdated":1755146406000}'),h={name:"ja/koog/custom-strategy-graphs.md"};function e(p,s,k,d,r,E){return l(),n("div",null,s[0]||(s[0]=[t(`<h1 id="カスタム戦略グラフ" tabindex="-1">カスタム戦略グラフ <a class="header-anchor" href="#カスタム戦略グラフ" aria-label="Permalink to &quot;カスタム戦略グラフ&quot;">​</a></h1><p>戦略グラフは、Koogフレームワークにおけるエージェントのワークフローの根幹をなすものです。これらは、エージェントがどのように入力を処理し、ツールと対話し、出力を生成するかを定義します。戦略グラフは、エッジで接続されたノードで構成され、条件によって実行フローが決定されます。</p><p>戦略グラフを作成することで、シンプルなチャットボット、複雑なデータ処理パイプライン、あるいはその中間にあるものなど、特定のニーズに合わせてエージェントの動作を調整できます。</p><h2 id="戦略グラフのアーキテクチャ" tabindex="-1">戦略グラフのアーキテクチャ <a class="header-anchor" href="#戦略グラフのアーキテクチャ" aria-label="Permalink to &quot;戦略グラフのアーキテクチャ&quot;">​</a></h2><p>大まかに見て、戦略グラフは以下のコンポーネントで構成されています。</p><ul><li><strong>Strategy</strong>: ジェネリックパラメータを使用して指定された入力および出力型で<code>strategy</code>関数を使って作成される、グラフのトップレベルのコンテナ。</li><li><strong>Subgraphs</strong>: 独自のツールセットとコンテキストを持つことができるグラフのセクション。</li><li><strong>Nodes</strong>: ワークフロー内の個々の操作または変換。</li><li><strong>Edges</strong>: ノード間の接続で、遷移条件と変換を定義します。</li></ul><p>戦略グラフは<code>nodeStart</code>という特別なノードから始まり、<code>nodeFinish</code>で終わります。これらノード間のパスは、グラフで指定されたエッジと条件によって決定されます。</p><h2 id="戦略グラフのコンポーネント" tabindex="-1">戦略グラフのコンポーネント <a class="header-anchor" href="#戦略グラフのコンポーネント" aria-label="Permalink to &quot;戦略グラフのコンポーネント&quot;">​</a></h2><h3 id="ノード" tabindex="-1">ノード <a class="header-anchor" href="#ノード" aria-label="Permalink to &quot;ノード&quot;">​</a></h3><p>ノードは戦略グラフの構成要素です。各ノードは特定の操作を表します。</p><p>Koogフレームワークは事前定義されたノードを提供しており、<code>node</code>関数を使用してカスタムノードを作成することもできます。</p><p>詳細については、<a href="./nodes-and-components">事前定義ノードとコンポーネント</a>および<a href="./custom-nodes">カスタムノード</a>を参照してください。</p><h3 id="エッジ" tabindex="-1">エッジ <a class="header-anchor" href="#エッジ" aria-label="Permalink to &quot;エッジ&quot;">​</a></h3><p>エッジはノードを接続し、戦略グラフにおける操作のフローを定義します。 エッジは<code>edge</code>関数と<code>forwardTo</code>中置関数を使用して作成されます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sourceNode forwardTo targetNode)</span></span></code></pre></div><h4 id="条件" tabindex="-1">条件 <a class="header-anchor" href="#条件" aria-label="Permalink to &quot;条件&quot;">​</a></h4><p>条件は、戦略グラフで特定のエッジをたどるタイミングを決定します。いくつかの種類の条件があり、一般的なものをいくつか紹介します。</p><table tabindex="0"><thead><tr><th style="text-align:left;">条件の種類</th><th style="text-align:left;">説明</th></tr></thead><tbody><tr><td style="text-align:left;">onCondition</td><td style="text-align:left;">真偽値を返すラムダ式を受け取る汎用条件。</td></tr><tr><td style="text-align:left;">onToolCall</td><td style="text-align:left;">LLMがツールを呼び出したときに一致する条件。</td></tr><tr><td style="text-align:left;">onAssistantMessage</td><td style="text-align:left;">LLMがメッセージで応答したときに一致する条件。</td></tr><tr><td style="text-align:left;">onMultipleToolCalls</td><td style="text-align:left;">LLMが複数のツールを呼び出したときに一致する条件。</td></tr><tr><td style="text-align:left;">onToolNotCalled</td><td style="text-align:left;">LLMがツールを呼び出さなかったときに一致する条件。</td></tr></tbody></table><p><code>transformed</code>関数を使用すると、出力をターゲットノードに渡す前に変換できます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sourceNode forwardTo targetNode </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        onCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input.length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        transformed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">uppercase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="サブグラフ" tabindex="-1">サブグラフ <a class="header-anchor" href="#サブグラフ" aria-label="Permalink to &quot;サブグラフ&quot;">​</a></h3><p>サブグラフは、独自のツールセットとコンテキストで動作する戦略グラフのセクションです。 戦略グラフは複数のサブグラフを含むことができます。各サブグラフは<code>subgraph</code>関数を使用して定義されます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strategy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> strategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;strategy-name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> firstSubgraph </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> subgraph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FirstInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FirstOutput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;first&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Define nodes and edges for this subgraph</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> secondSubgraph </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> subgraph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SecondInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SecondOutput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;second&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Define nodes and edges for this subgraph</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>サブグラフはツールレジストリから任意のツールを使用できます。 ただし、そのレジストリからサブグラフで使用できるツールのサブセットを指定し、<code>subgraph</code>関数の引数として渡すこともできます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strategy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> strategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;strategy-name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> firstSubgraph </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> subgraph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FirstInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FirstOutput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;first&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        tools </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(someTool)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Define nodes and edges for this subgraph</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // Define other subgraphs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="基本的な戦略グラフの作成" tabindex="-1">基本的な戦略グラフの作成 <a class="header-anchor" href="#基本的な戦略グラフの作成" aria-label="Permalink to &quot;基本的な戦略グラフの作成&quot;">​</a></h2><p>基本的な戦略グラフは次のように動作します。</p><ol><li>入力をLLMに送信します。</li><li>LLMがメッセージで応答した場合、プロセスを終了します。</li><li>LLMがツールを呼び出した場合、ツールを実行します。</li><li>ツールの結果をLLMに送り返します。</li><li>LLMがメッセージで応答した場合、プロセスを終了します。</li><li>LLMが別のツールを呼び出した場合、ツールを実行し、プロセスはステップ4から繰り返されます。</li></ol><p><img src="`+i+`" alt="basic-strategy-graph"></p><p>以下は基本的な戦略グラフの例です。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myStrategy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> strategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;my-strategy&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodeCallLLM </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeLLMRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> executeToolCall </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeExecuteTool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sendToolResult </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeLLMSendToolResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodeStart forwardTo nodeCallLLM)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodeCallLLM forwardTo nodeFinish </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onAssistantMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodeCallLLM forwardTo executeToolCall </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onToolCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(executeToolCall forwardTo sendToolResult)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sendToolResult forwardTo nodeFinish </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onAssistantMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sendToolResult forwardTo executeToolCall </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onToolCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="高度な戦略テクニック" tabindex="-1">高度な戦略テクニック <a class="header-anchor" href="#高度な戦略テクニック" aria-label="Permalink to &quot;高度な戦略テクニック&quot;">​</a></h2><h3 id="履歴圧縮" tabindex="-1">履歴圧縮 <a class="header-anchor" href="#履歴圧縮" aria-label="Permalink to &quot;履歴圧縮&quot;">​</a></h3><p>長期にわたる会話では、履歴が肥大化し、多くのトークンを消費する可能性があります。履歴を圧縮する方法については、<a href="./history-compression">履歴圧縮</a>を参照してください。</p><h3 id="ツール並列実行" tabindex="-1">ツール並列実行 <a class="header-anchor" href="#ツール並列実行" aria-label="Permalink to &quot;ツール並列実行&quot;">​</a></h3><p>複数のツールを並列で実行する必要があるワークフローでは、<code>nodeExecuteMultipleTools</code>ノードを使用できます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> executeMultipleTools </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeExecuteMultipleTools</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> processMultipleResults </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeLLMSendMultipleToolResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(someNode forwardTo executeMultipleTools)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(executeMultipleTools forwardTo processMultipleResults)</span></span></code></pre></div><p>ストリーミングデータには、<code>toParallelToolCallsRaw</code>拡張関数も使用できます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parseMarkdownStreamToBooks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(markdownStream).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toParallelToolCallsRaw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(BookTool::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">collect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>詳細については、<a href="./tools-overview#parallel-tool-calls">ツール</a>を参照してください。</p><h3 id="ノード並列実行" tabindex="-1">ノード並列実行 <a class="header-anchor" href="#ノード並列実行" aria-label="Permalink to &quot;ノード並列実行&quot;">​</a></h3><p>ノード並列実行を使用すると、複数のノードを並行して実行できるため、パフォーマンスが向上し、複雑なワークフローが可能になります。</p><p>並行ノード実行を開始するには、<code>parallel</code>メソッドを使用します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> calc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> parallel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nodeCalcTokens, nodeCalcSymbols, nodeCalcWords,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    selectByMax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>上記のコードは、<code>nodeCalcTokens</code>、<code>nodeCalcSymbols</code>、<code>nodeCalcWords</code>の各ノードを並行して実行し、結果を<code>AsyncParallelResult</code>のインスタンスとして返す<code>calc</code>という名前のノードを作成します。</p><p>ノード並列実行および詳細なリファレンスについては、<a href="./parallel-node-execution">ノード並列実行</a>を参照してください。</p><h3 id="条件分岐" tabindex="-1">条件分岐 <a class="header-anchor" href="#条件分岐" aria-label="Permalink to &quot;条件分岐&quot;">​</a></h3><p>特定の条件に基づいて異なるパスを必要とする複雑なワークフローでは、条件分岐を使用できます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> branchA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; { input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Logic for branch A</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Branch A: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$input</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> branchB </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; { input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Logic for branch B</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Branch B: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$input</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (someNode forwardTo branchA)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            onCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (someNode forwardTo branchB)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            onCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;B&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h2 id="ベストプラクティス" tabindex="-1">ベストプラクティス <a class="header-anchor" href="#ベストプラクティス" aria-label="Permalink to &quot;ベストプラクティス&quot;">​</a></h2><p>カスタム戦略グラフを作成する際は、以下のベストプラクティスに従ってください。</p><ul><li>シンプルに保つ。シンプルなグラフから始め、必要に応じて複雑さを追加します。</li><li>グラフを理解しやすくするために、ノードとエッジにわかりやすい名前を付けます。</li><li>考えられるすべてのパスとエッジケースを処理します。</li><li>さまざまな入力でグラフをテストし、期待どおりに動作することを確認します。</li><li>将来の参照のために、グラフの目的と動作を文書化します。</li><li>事前定義された戦略や一般的なパターンを起点として使用します。</li><li>長期にわたる会話では、トークン使用量を削減するために履歴圧縮を使用します。</li><li>グラフを整理し、ツールアクセスを管理するためにサブグラフを使用します。</li></ul><h2 id="使用例" tabindex="-1">使用例 <a class="header-anchor" href="#使用例" aria-label="Permalink to &quot;使用例&quot;">​</a></h2><h3 id="トーン分析戦略" tabindex="-1">トーン分析戦略 <a class="header-anchor" href="#トーン分析戦略" aria-label="Permalink to &quot;トーン分析戦略&quot;">​</a></h3><p>トーン分析戦略は、履歴圧縮を含むツールベースの戦略の良い例です。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toneStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, toolRegistry: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ToolRegistry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AIAgentStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> strategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodeSendInput </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeLLMRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodeExecuteTool </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeExecuteTool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodeSendToolResult </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeLLMSendToolResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodeCompressHistory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeLLMCompressHistory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ReceivedToolResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Define the flow of the agent</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodeStart forwardTo nodeSendInput)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // If the LLM responds with a message, finish</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            (nodeSendInput forwardTo nodeFinish)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    onAssistantMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // If the LLM calls a tool, execute it</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            (nodeSendInput forwardTo nodeExecuteTool)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    onToolCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // If the history gets too large, compress it</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            (nodeExecuteTool forwardTo nodeCompressHistory)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    onCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { prompt.messages.size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodeCompressHistory forwardTo nodeSendToolResult)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Otherwise, send the tool result directly</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            (nodeExecuteTool forwardTo nodeSendToolResult)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    onCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { prompt.messages.size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // If the LLM calls another tool, execute it</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            (nodeSendToolResult forwardTo nodeExecuteTool)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    onToolCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // If the LLM responds with a message, finish</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            (nodeSendToolResult forwardTo nodeFinish)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    onAssistantMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>この戦略は以下のことを行います。</p><ol><li>入力をLLMに送信します。</li><li>LLMがメッセージで応答した場合、戦略はプロセスを終了します。</li><li>LLMがツールを呼び出した場合、戦略はそのツールを実行します。</li><li>履歴が大きすぎる（100メッセージを超える）場合、戦略はツールの結果を送信する前に圧縮します。</li><li>それ以外の場合、戦略はツールの結果を直接送信します。</li><li>LLMが別のツールを呼び出した場合、戦略はそれを実行します。</li><li>LLMがメッセージで応答した場合、戦略はプロセスを終了します。</li></ol><h2 id="トラブルシューティング" tabindex="-1">トラブルシューティング <a class="header-anchor" href="#トラブルシューティング" aria-label="Permalink to &quot;トラブルシューティング&quot;">​</a></h2><p>カスタム戦略グラフを作成する際に、いくつかの一般的な問題に遭遇する可能性があります。以下に、トラブルシューティングのヒントをいくつか示します。</p><h3 id="グラフが終了ノードに到達しない" tabindex="-1">グラフが終了ノードに到達しない <a class="header-anchor" href="#グラフが終了ノードに到達しない" aria-label="Permalink to &quot;グラフが終了ノードに到達しない&quot;">​</a></h3><p>グラフが終了ノードに到達しない場合は、以下を確認してください。</p><ul><li>開始ノードからのすべてのパスが最終的に終了ノードにつながっていること。</li><li>条件が厳しすぎず、エッジがたどれないようにしていないこと。</li><li>グラフ内に終了条件を持たないサイクルがないこと。</li></ul><h3 id="ツール呼び出しが実行されない" tabindex="-1">ツール呼び出しが実行されない <a class="header-anchor" href="#ツール呼び出しが実行されない" aria-label="Permalink to &quot;ツール呼び出しが実行されない&quot;">​</a></h3><p>ツール呼び出しが実行されない場合は、以下を確認してください。</p><ul><li>ツールがツールレジストリに適切に登録されていること。</li><li>LLMノードからツール実行ノードへのエッジに正しい条件 (<code>onToolCall { true }</code>) が設定されていること。</li></ul><h3 id="履歴が大きくなりすぎる" tabindex="-1">履歴が大きくなりすぎる <a class="header-anchor" href="#履歴が大きくなりすぎる" aria-label="Permalink to &quot;履歴が大きくなりすぎる&quot;">​</a></h3><p>履歴が大きくなりすぎ、多くのトークンを消費する場合は、以下を検討してください。</p><ul><li>履歴圧縮ノードを追加します。</li><li>履歴のサイズをチェックし、大きすぎる場合に圧縮する条件を使用します。</li><li>より積極的な圧縮戦略（例: <code>FromLastNMessages</code>で小さいN値）を使用します。</li></ul><h3 id="グラフが予期せぬ分岐をする" tabindex="-1">グラフが予期せぬ分岐をする <a class="header-anchor" href="#グラフが予期せぬ分岐をする" aria-label="Permalink to &quot;グラフが予期せぬ分岐をする&quot;">​</a></h3><p>グラフが予期せぬ分岐をする場合は、以下を確認してください。</p><ul><li>条件が正しく定義されていること。</li><li>条件が期待される順序で評価されていること（エッジは定義された順序でチェックされます）。</li><li>より一般的な条件で誤って条件を上書きしていないこと。</li></ul><h3 id="パフォーマンスの問題が発生する" tabindex="-1">パフォーマンスの問題が発生する <a class="header-anchor" href="#パフォーマンスの問題が発生する" aria-label="Permalink to &quot;パフォーマンスの問題が発生する&quot;">​</a></h3><p>グラフにパフォーマンスの問題がある場合は、以下を検討してください。</p><ul><li>不要なノードやエッジを削除してグラフを簡素化します。</li><li>独立した操作にはツール並列実行を使用します。</li><li>履歴を圧縮します。</li><li>より効率的なノードと操作を使用します。</li></ul>`,75)]))}const c=a(h,[["render",e]]);export{y as __pageData,c as default};
