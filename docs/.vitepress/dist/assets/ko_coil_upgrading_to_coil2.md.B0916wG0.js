import{_ as s,c as a,o as e,ag as n}from"./chunks/framework.Bksy39di.js";const r=JSON.parse('{"title":"Coil 2.x로 업그레이드","description":"","frontmatter":{},"headers":[],"relativePath":"ko/coil/upgrading_to_coil2.md","filePath":"ko/coil/upgrading_to_coil2.md","lastUpdated":1753369988000}'),l={name:"ko/coil/upgrading_to_coil2.md"};function t(h,i,p,k,d,o){return e(),a("div",null,i[0]||(i[0]=[n(`<h1 id="coil-2-x로-업그레이드" tabindex="-1">Coil 2.x로 업그레이드 <a class="header-anchor" href="#coil-2-x로-업그레이드" aria-label="Permalink to &quot;Coil 2.x로 업그레이드&quot;">​</a></h1><p>이 문서는 Coil 1.x에서 2.x로 업그레이드할 때의 주요 변경 사항과 해당 변경 사항을 처리하는 방법을 요약한 짧은 가이드입니다. 이 업그레이드 가이드는 모든 바이너리 또는 소스 비호환 변경 사항을 다루지는 않지만, 가장 중요한 변경 사항들을 다룹니다.</p><h2 id="최소-api-21" tabindex="-1">최소 API 21 <a class="header-anchor" href="#최소-api-21" aria-label="Permalink to &quot;최소 API 21&quot;">​</a></h2><p>Coil 2.x는 최소 API 21을 요구합니다. 이는 Compose와 OkHttp 4.x에도 필요한 최소 API 버전입니다.</p><h2 id="imagerequest-기본-스케일" tabindex="-1">ImageRequest 기본 스케일 <a class="header-anchor" href="#imagerequest-기본-스케일" aria-label="Permalink to &quot;ImageRequest 기본 스케일&quot;">​</a></h2><p>Coil 2.x는 <code>ImageRequest</code>의 기본 스케일을 <code>Scale.FILL</code>에서 <code>Scale.FIT</code>으로 변경합니다. 이 변경은 <code>ImageView</code>의 기본 <code>ScaleType</code> 및 <code>Image</code>의 기본 <code>ContentScale</code>과의 일관성을 유지하기 위해 이루어졌습니다. <code>ImageView</code>를 <code>ImageRequest.target</code>으로 설정하면 스케일은 여전히 자동으로 감지됩니다.</p><h2 id="size-리팩터링" tabindex="-1">Size 리팩터링 <a class="header-anchor" href="#size-리팩터링" aria-label="Permalink to &quot;Size 리팩터링&quot;">​</a></h2><p><code>Size</code>의 <code>width</code>와 <code>height</code>는 이제 <code>Int</code> 픽셀 값 대신 두 개의 <code>Dimension</code> 타입입니다. <code>Dimension</code>은 픽셀 값이거나 <code>Dimension.Undefined</code>일 수 있으며, 이는 정의되지 않거나(unbounded) 제한되지 않은 제약 조건을 나타냅니다. 예를 들어, 크기가 <code>Size(400, Dimension.Undefined)</code>라면 이는 이미지의 높이와 관계없이 너비를 400픽셀로 스케일링해야 함을 의미합니다. 픽셀 값(있는 경우)을 가져오려면 <code>pxOrElse</code> 확장 함수를 사용할 수 있습니다. 없는 경우에는 대체 값을 사용합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size.width.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pxOrElse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Use the pixel value.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 변경은 타겟이 하나의 제한 없는 차원을 가질 경우(예: <code>View</code>의 <code>ViewGroup.LayoutParams.WRAP_CONTENT</code> 또는 Compose의 <code>Constraints.Infinity</code>와 같이 한 차원이 무제한인 경우)에 대한 지원을 개선하기 위해 이루어졌습니다.</p><h2 id="compose" tabindex="-1">Compose <a class="header-anchor" href="#compose" aria-label="Permalink to &quot;Compose&quot;">​</a></h2><p>Coil 2.x는 Compose 통합을 대폭 재작업하여 기능을 추가하고 안정성 및 성능을 향상시켰습니다.</p><p>Coil 1.x에서는 이미지를 로드하기 위해 <code>rememberImagePainter</code>를 사용했습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> painter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rememberImagePainter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://example.com/image.jpg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    crossfade</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    painter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> painter,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    contentDescription </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    contentScale </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ContentScale.Crop</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Coil 2.x에서는 <code>rememberImagePainter</code>가 다음과 같은 변경 사항과 함께 <code>rememberAsyncImagePainter</code>로 변경되었습니다.</p><ul><li><code>ImageRequest</code>를 구성하는 후행 람다(trailing lambda) 인자가 제거되었습니다.</li><li>Coil 2.x에서 <code>rememberAsyncImagePainter</code>는 <code>Image</code>와 일관성을 유지하기 위해 기본적으로 <code>ContentScale.Fit</code>을 사용합니다. 반면 Coil 1.x에서는 기본값이 <code>ContentScale.Crop</code>이었습니다. 따라서 <code>Image</code>에 사용자 지정 <code>ContentScale</code>을 설정하는 경우, 이제 <code>rememberAsyncImagePainter</code>에도 이를 전달해야 합니다.</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> painter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rememberAsyncImagePainter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    model </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ImageRequest.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Builder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(LocalContext.current)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://example.com/image.jpg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">crossfade</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    contentScale </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ContentScale.Crop</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    painter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> painter,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    contentDescription </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    contentScale </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ContentScale.Crop</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>또한 Coil은 이제 <code>AsyncImage</code> 및 <code>SubcomposeAsyncImage</code> 컴포저블 함수를 제공하여 새로운 기능을 추가하고 <code>rememberAsyncImagePainter</code>의 일부 디자인 제약을 해결합니다. 전체 Compose 문서는 <a href="./compose">여기</a>에서 확인하세요.</p><h2 id="디스크-캐시" tabindex="-1">디스크 캐시 <a class="header-anchor" href="#디스크-캐시" aria-label="Permalink to &quot;디스크 캐시&quot;">​</a></h2><p>Coil 2.x는 <code>imageLoader.diskCache</code>를 통해 접근할 수 있는 자체 공개 디스크 캐시 클래스를 가집니다. Coil 1.x는 OkHttp의 디스크 캐시에 의존했지만, 이제 더 이상 필요하지 않습니다.</p><p>1.x에서 디스크 캐시를 구성하려면 <code>CoilUtils.createDefaultCache</code>를 사용했습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ImageLoader.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Builder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">okHttpClient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        OkHttpClient.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Builder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CoilUtils.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createDefaultCache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Coil 2.x에서는 <code>ImageLoader</code>와 함께 사용할 때 <code>OkHttpClient</code>에 <code>Cache</code> 객체를 설정해서는 안 됩니다. 대신 다음과 같이 디스크 캐시 객체를 구성합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ImageLoader.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Builder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">diskCache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        DiskCache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Builder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">directory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context.cacheDir.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;image_cache&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>이 변경은 기능 추가 및 성능 향상을 위해 이루어졌습니다.</p><ul><li>이미지 디코딩 중 스레드 인터럽션(thread interruption)을 지원합니다. <ul><li>스레드 인터럽션은 디코딩 작업을 빠르게 취소할 수 있도록 합니다. 이는 리스트를 빠르게 스크롤할 때 특히 중요합니다.</li><li>Coil은 사용자 지정 디스크 캐시를 사용하여 디코딩하기 전에 네트워크 소스가 디스크에 완전히 읽혔는지 확인할 수 있습니다. 데이터를 디스크에 쓰는 작업은 중단될 수 없으므로 이는 필수적입니다. 오직 디코딩 단계만 중단될 수 있습니다. OkHttp의 <code>Cache</code>는 디코딩 전에 모든 데이터가 디스크에 기록되었음을 보장할 수 없으므로 Coil 2.0과 함께 사용해서는 안 됩니다.</li></ul></li><li><code>InputStream</code>을 지원하지 않거나 <code>File</code>에 직접 접근해야 하는 디코딩 API(예: <code>ImageDecoder</code>, <code>MediaMetadataRetriever</code>)를 위한 버퍼링/임시 파일 생성을 방지합니다.</li><li>공개 읽기/쓰기 <code>DiskCache</code> API를 추가합니다.</li></ul><p>Coil 2.x에서는 <code>Cache-Control</code> 및 기타 캐시 헤더가 여전히 지원됩니다. 단, 캐시는 URL 일치 여부만 확인하므로 <code>Vary</code> 헤더는 예외입니다. 또한, 응답 코드가 [200..300) 범위인 응답만 캐시됩니다.</p><p>Coil 1.x에서 2.x로 업그레이드할 때, 내부 형식이 변경되었으므로 기존 디스크 캐시는 모두 지워집니다.</p><h2 id="이미지-파이프라인-리팩터링" tabindex="-1">이미지 파이프라인 리팩터링 <a class="header-anchor" href="#이미지-파이프라인-리팩터링" aria-label="Permalink to &quot;이미지 파이프라인 리팩터링&quot;">​</a></h2><p>Coil 2.x는 이미지 파이프라인 클래스를 재구성하여 더 유연하게 만들었습니다. 다음은 변경 사항의 개략적인 목록입니다.</p><ul><li>요청에 대한 메모리 캐시 키를 계산하는 새로운 클래스인 <code>Keyer</code>가 도입되었습니다. 이는 <code>Fetcher.key</code>를 대체합니다.</li><li><code>Mapper</code>, <code>Keyer</code>, <code>Fetcher</code>, 및 <code>Decoder</code>는 <code>null</code>을 반환하여 컴포넌트 목록의 다음 요소로 위임할 수 있습니다.</li><li><code>Mapper.map</code>의 시그니처에 <code>Options</code>가 추가되었습니다.</li><li><code>Fetcher.Factory</code>와 <code>Decoder.Factory</code>가 도입되었습니다. 특정 <code>Fetcher</code>/<code>Decoder</code>가 적용 가능한지 여부를 확인하기 위해 팩토리를 사용합니다. 해당 <code>Fetcher</code>/<code>Decoder</code>가 적용 불가능한 경우 <code>null</code>을 반환합니다.</li></ul><h2 id="비트맵-풀링-bitmap-pooling-제거" tabindex="-1">비트맵 풀링(bitmap pooling) 제거 <a class="header-anchor" href="#비트맵-풀링-bitmap-pooling-제거" aria-label="Permalink to &quot;비트맵 풀링(bitmap pooling) 제거&quot;">​</a></h2><p>Coil 2.x는 비트맵 풀링과 관련 클래스(<code>BitmapPool</code>, <code>PoolableViewTarget</code>)를 제거했습니다. 제거 이유에 대해서는 <a href="https://github.com/coil-kt/coil/discussions/1186#discussioncomment-2305528" target="_blank" rel="noreferrer">여기</a>를 참조하세요.</p>`,33)]))}const E=s(l,[["render",t]]);export{r as __pageData,E as default};
