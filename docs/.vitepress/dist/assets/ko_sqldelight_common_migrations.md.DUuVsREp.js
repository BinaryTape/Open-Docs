import{_ as a,c as i,o as e,ag as n}from"./chunks/framework.Bksy39di.js";const r=JSON.parse('{"title":"마이그레이션","description":"","frontmatter":{},"headers":[],"relativePath":"ko/sqldelight/common/migrations.md","filePath":"ko/sqldelight/common/migrations.md","lastUpdated":1748435462000}'),t={name:"ko/sqldelight/common/migrations.md"};function l(p,s,h,d,k,o){return e(),i("div",null,s[0]||(s[0]=[n(`<h1 id="마이그레이션" tabindex="-1">마이그레이션 <a class="header-anchor" href="#마이그레이션" aria-label="Permalink to &quot;마이그레이션&quot;">​</a></h1><p><code>.sq</code> 파일은 빈 데이터베이스에서 최신 스키마를 생성하는 방법을 항상 설명합니다. 데이터베이스가 현재 이전 버전에 있는 경우, 마이그레이션 파일은 해당 데이터베이스를 최신 상태로 만듭니다. 마이그레이션 파일은 <code>.sq</code> 파일과 동일한 <code>sqldelight</code> 폴더에 저장됩니다.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>src</span></span>
<span class="line"><span>└─ main</span></span>
<span class="line"><span>   └─ sqdelight</span></span>
<span class="line"><span>      ├─ com/example/hockey</span></span>
<span class="line"><span>      |  ├─ Team.sq</span></span>
<span class="line"><span>      |  └─ Player.sq</span></span>
<span class="line"><span>      └─ migrations</span></span>
<span class="line"><span>         ├─ 1.sqm</span></span>
<span class="line"><span>         └─ 2.sqm</span></span></code></pre></div><p>드라이버가 지원하는 경우, 마이그레이션은 트랜잭션 내에서 실행됩니다. 일부 드라이버에서는 충돌을 일으킬 수 있으므로 마이그레이션을 <code>BEGIN/END TRANSACTION</code>으로 둘러싸지 않아야 합니다.</p><h2 id="버전-관리" tabindex="-1">버전 관리 <a class="header-anchor" href="#버전-관리" aria-label="Permalink to &quot;버전 관리&quot;">​</a></h2><p>스키마의 첫 번째 버전은 1입니다. 마이그레이션 파일은 <code>&lt;업그레이드할 이전 버전&gt;.sqm</code> 형식으로 이름이 지정됩니다. 버전 2로 마이그레이션하려면 <code>1.sqm</code>에 마이그레이션 구문을 넣으세요.</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ALTER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hockeyPlayer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ADD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> COLUMN draft_year </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INTEGER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ALTER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hockeyPlayer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ADD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> COLUMN draft_order </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INTEGER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>이러한 SQL 구문은 <code>Database.Schema.migrate()</code> 메서드에 의해 실행됩니다. 마이그레이션 파일은 <code>.sq</code> 파일과 동일한 소스 세트에 있습니다.</p><h2 id="마이그레이션-확인" tabindex="-1">마이그레이션 확인 <a class="header-anchor" href="#마이그레이션-확인" aria-label="Permalink to &quot;마이그레이션 확인&quot;">​</a></h2><p><code>verifySqlDelightMigration</code> 태스크가 Gradle 프로젝트에 추가되며, <code>check</code> 태스크의 일부로 실행됩니다. SqlDelight 소스 세트(예: <code>src/main/sqldelight</code>)에 있는 <code>&lt;버전 번호&gt;.db</code>라는 이름의 <code>.db</code> 파일에 대해, <code>&lt;버전 번호&gt;.sqm</code>부터 시작하는 모든 마이그레이션을 적용하고 마이그레이션이 최신 스키마를 가진 데이터베이스를 생성하는지 확인합니다.</p><p>최신 스키마에서 <code>.db</code> 파일을 생성하려면 <a href="/ko/sqldelight/common/gradle.md">gradle.md</a>에 설명된 대로 <code>schemaOutputDirectory</code>를 지정하면 사용할 수 있는 <code>generate&lt;소스 세트 이름&gt;&lt;데이터베이스 이름&gt;Schema</code> 태스크를 실행하세요. 첫 번째 마이그레이션을 생성하기 전에 이를 수행하는 것이 좋습니다. 예를 들어, 프로젝트가 <code>&quot;MyDatabase&quot;</code>라는 사용자 지정 이름을 가진 <code>main</code> 소스 세트를 사용하는 경우, <code>generateMainMyDatabaseSchema</code> 태스크를 실행해야 합니다.</p><p>대부분의 사용 사례에서는 데이터베이스 초기 버전의 스키마를 나타내는 <code>1.db</code> 파일만 사용하는 것이 좋습니다. 여러 개의 <code>.db</code> 파일을 가지는 것은 허용되지만, 이는 각 <code>.db</code> 파일에 모든 마이그레이션이 적용되는 결과를 초래하여 많은 불필요한 작업을 야기합니다.</p><h2 id="코드-마이그레이션" tabindex="-1">코드 마이그레이션 <a class="header-anchor" href="#코드-마이그레이션" aria-label="Permalink to &quot;코드 마이그레이션&quot;">​</a></h2><p>코드에서 마이그레이션을 실행하고 데이터 마이그레이션을 수행하고 싶다면 <code>Database.Schema.migrate</code> API를 사용할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Database.Schema.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">migrate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    driver </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> database,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    oldVersion </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    newVersion </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Database.Schema.version,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    AfterVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { driver </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> driver.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;INSERT INTO test (value) VALUES(&#39;hello&#39;)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>다음 예시에서, 마이그레이션으로 1.sqm, 2.sqm, 3.sqm, 4.sqm, 5.sqm이 있다면, 위의 콜백은 데이터베이스가 버전 4일 때 3.sqm이 완료된 후에 발생합니다. 콜백 후에는 4.sqm에서 재개되어 남은 마이그레이션(이 경우 4.sqm과 5.sqm)을 완료하며, 이는 최종 데이터베이스 버전이 6이 됨을 의미합니다.</p>`,16)]))}const E=a(t,[["render",l]]);export{r as __pageData,E as default};
