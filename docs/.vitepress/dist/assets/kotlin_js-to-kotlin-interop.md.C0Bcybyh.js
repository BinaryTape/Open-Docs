import{_ as i,c as a,o as t,ag as e}from"./chunks/framework.Bksy39di.js";const c=JSON.parse('{"title":"在 JavaScript 中使用 Kotlin 代码","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/js-to-kotlin-interop.md","filePath":"kotlin/js-to-kotlin-interop.md","lastUpdated":1754307826000}'),n={name:"kotlin/js-to-kotlin-interop.md"};function l(p,s,d,h,o,k){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="在-javascript-中使用-kotlin-代码" tabindex="-1">在 JavaScript 中使用 Kotlin 代码 <a class="header-anchor" href="#在-javascript-中使用-kotlin-代码" aria-label="Permalink to &quot;在 JavaScript 中使用 Kotlin 代码&quot;">​</a></h1><p>根据所选的 <a href="/kotlin/js-modules">JavaScript Module</a> 系统，Kotlin/JS 编译器会生成不同的输出。但通常情况下，Kotlin 编译器会生成正常的 JavaScript 类、函数和属性，你可以从 JavaScript 代码中自由使用它们。不过，有些微妙之处你需要记住。</p><h2 id="plain-模式下在单独的-javascript-对象中隔离声明" tabindex="-1">plain 模式下在单独的 JavaScript 对象中隔离声明 <a class="header-anchor" href="#plain-模式下在单独的-javascript-对象中隔离声明" aria-label="Permalink to &quot;plain 模式下在单独的 JavaScript 对象中隔离声明&quot;">​</a></h2><p>如果你已将模块类型显式设置为 <code>plain</code>，Kotlin 会创建一个对象，其中包含当前模块的所有 Kotlin 声明。这样做是为了防止污染全局对象。这意味着对于 <code>myModule</code> 模块，所有声明都可以通过 <code>myModule</code> 对象在 JavaScript 中访问。例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello&quot;</span></span></code></pre></div><p>可以像这样从 JavaScript 中调用：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myModule.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><p>当你将 Kotlin 模块编译为 UMD（<code>browser</code> 和 <code>nodejs</code> 目标平台的默认设置）、CommonJS 或 AMD 等 JavaScript 模块时，此规则不适用。在这种情况下，你的声明将以你所选的 JavaScript 模块系统指定的格式暴露。例如，当使用 UMD 或 CommonJS 时，你的调用处可能如下所示：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;myModule&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><p>关于 JavaScript 模块系统的主题，请参见 <a href="/kotlin/js-modules">JavaScript Modules</a> 一文以获取更多信息。</p><h2 id="包结构" tabindex="-1">包结构 <a class="header-anchor" href="#包结构" aria-label="Permalink to &quot;包结构&quot;">​</a></h2><p>Kotlin 将其包结构暴露给 JavaScript，因此除非你在根包中定义声明，否则你必须在 JavaScript 中使用完全限定名。例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> my.qualified.packagename</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello&quot;</span></span></code></pre></div><p>例如，当使用 UMD 或 CommonJS 时，你的调用处可能如下所示：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;myModule&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).my.qualified.packagename.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>或者，在将 <code>plain</code> 用作模块系统设置的情况下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myModule.my.qualified.packagename.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><h3 id="jsname-注解" tabindex="-1">@JsName 注解 <a class="header-anchor" href="#jsname-注解" aria-label="Permalink to &quot;@JsName 注解&quot;">​</a></h3><p>在某些情况下（例如，为了支持重载），Kotlin 编译器会修饰生成到 JavaScript 代码中的函数和属性的名称。要控制生成的名称，你可以使用 <code>@JsName</code> 注解：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Module &#39;kjs&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @JsName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;helloWithGreeting&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(greeting: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$greeting</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>现在你可以通过以下方式从 JavaScript 中使用此类别：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// If necessary, import &#39;kjs&#39; according to chosen module system</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kjs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Dmitry&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// refers to module &#39;kjs&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">person.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();                          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// prints &quot;Hello Dmitry!&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">person.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">helloWithGreeting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Servus&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// prints &quot;Servus Dmitry!&quot;</span></span></code></pre></div><p>如果我们没有指定 <code>@JsName</code> 注解，则对应函数的名称将包含根据函数签名计算出的后缀，例如 <code>hello_61zpoe</code>。</p><p>请注意，在某些情况下 Kotlin 编译器不会进行名字修饰：</p><ul><li><code>external</code> 声明不会被修饰。</li><li>继承自 <code>external</code> 类的非 <code>external</code> 类中的任何覆盖函数都不会被修饰。</li></ul><p><code>@JsName</code> 的形参必须是常量字符串字面量，且该字面量必须是有效的标识符。编译器会报告任何尝试向 <code>@JsName</code> 传递非标识符字符串的错误。以下示例会产生编译期错误：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JsName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;new C()&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// error here</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> newC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h3 id="jsexport-注解" tabindex="-1">@JsExport 注解 <a class="header-anchor" href="#jsexport-注解" aria-label="Permalink to &quot;@JsExport 注解&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>这是一个<a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>特性。 其设计在未来版本中可能会改变。</p></div><p>通过将 <code>@JsExport</code> 注解应用于顶层声明（例如类或函数），你可以使 Kotlin 声明在 JavaScript 中可用。该注解会导出所有嵌套声明，并使用在 Kotlin 中给定的名称。它也可以使用 <code>@file:JsExport</code> 在文件级别应用。</p><p>为了解决导出中的歧义（例如同名函数的重载），你可以将 <code>@JsExport</code> 注解与 <code>@JsName</code> 结合使用，以指定生成和导出的函数的名称。</p><p>在当前的 <a href="/kotlin/js-ir-compiler">IR 编译器后端</a>中，<code>@JsExport</code> 注解是使你的函数在 JavaScript 中可见的唯一方式。</p><p>对于多平台项目，<code>@JsExport</code> 在公共代码中也可用。它仅在编译面向 JavaScript 目标平台时生效，并允许你导出非平台特有的 Kotlin 声明。</p><h3 id="jsstatic" tabindex="-1">@JsStatic <a class="header-anchor" href="#jsstatic" aria-label="Permalink to &quot;@JsStatic&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>这是一个<a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>特性。它可能随时被弃用或更改。 仅将其用于求值目的。如果你对此有任何反馈，请在 <a href="https://youtrack.jetbrains.com/issue/KT-18891/JS-provide-a-way-to-declare-static-members-JsStatic" target="_blank" rel="noreferrer">YouTrack</a> 中提出，我们将不胜感激。</p></div><p><code>@JsStatic</code> 注解指示编译器为目标声明生成额外的静态方法。这有助于你直接在 JavaScript 中使用 Kotlin 代码中的静态成员。</p><p>你可以将 <code>@JsStatic</code> 注解应用于在具名对象中定义的函数，以及在类和接口内部声明的伴生对象中的函数。如果你使用此注解，编译器将既生成该对象的静态方法，也会生成该对象本身的实例方法。例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    companion</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @JsStatic</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callNonStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>现在，<code>callStatic()</code> 函数在 JavaScript 中是静态的，而 <code>callNonStatic()</code> 函数则不是：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JavaScript</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Works, accessing the static function</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callNonStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();           </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Error, not a static function in the generated JavaScript</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.Companion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Instance method remains</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.Companion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callNonStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// The only way it works</span></span></code></pre></div><p>还可以将 <code>@JsStatic</code> 注解应用于对象或伴生对象的属性，使其 getter 和 setter 方法成为该对象或包含伴生对象的类中的静态成员。</p><h2 id="javascript-中的-kotlin-类型" tabindex="-1">JavaScript 中的 Kotlin 类型 <a class="header-anchor" href="#javascript-中的-kotlin-类型" aria-label="Permalink to &quot;JavaScript 中的 Kotlin 类型&quot;">​</a></h2><p>请查看 Kotlin 类型如何映射到 JavaScript 类型：</p><table tabindex="0"><thead><tr><th>Kotlin</th><th>JavaScript</th><th>Comments</th></tr></thead><tbody><tr><td><code>Byte</code>, <code>Short</code>, <code>Int</code>, <code>Float</code>, <code>Double</code></td><td><code>Number</code></td><td></td></tr><tr><td><code>Char</code></td><td><code>Number</code></td><td>数字表示字符的代码。</td></tr><tr><td><code>Long</code></td><td>Not supported</td><td>JavaScript 中没有 64 位整型数字类型，因此它由 Kotlin 类模拟。</td></tr><tr><td><code>Boolean</code></td><td><code>Boolean</code></td><td></td></tr><tr><td><code>String</code></td><td><code>String</code></td><td></td></tr><tr><td><code>Array</code></td><td><code>Array</code></td><td></td></tr><tr><td><code>ByteArray</code></td><td><code>Int8Array</code></td><td></td></tr><tr><td><code>ShortArray</code></td><td><code>Int16Array</code></td><td></td></tr><tr><td><code>IntArray</code></td><td><code>Int32Array</code></td><td></td></tr><tr><td><code>CharArray</code></td><td><code>UInt16Array</code></td><td>带有属性 <code>$type$ == &quot;CharArray&quot;</code>。</td></tr><tr><td><code>FloatArray</code></td><td><code>Float32Array</code></td><td></td></tr><tr><td><code>DoubleArray</code></td><td><code>Float64Array</code></td><td></td></tr><tr><td><code>LongArray</code></td><td><code>Array&lt;kotlin.Long&gt;</code></td><td>带有属性 <code>$type$ == &quot;LongArray&quot;</code>。另请参见 Kotlin 的 <code>Long</code> 类型注释。</td></tr><tr><td><code>BooleanArray</code></td><td><code>Int8Array</code></td><td>带有属性 <code>$type$ == &quot;BooleanArray&quot;</code>。</td></tr><tr><td><code>List</code>, <code>MutableList</code></td><td><code>KtList</code>, <code>KtMutableList</code></td><td>通过 <code>KtList.asJsReadonlyArrayView</code> 或 <code>KtMutableList.asJsArrayView</code> 暴露一个 <code>Array</code>。</td></tr><tr><td><code>Map</code>, <code>MutableMap</code></td><td><code>KtMap</code>, <code>KtMutableMap</code></td><td>通过 <code>KtMap.asJsReadonlyMapView</code> 或 <code>KtMutableMap.asJsMapView</code> 暴露一个 ES2015 <code>Map</code>。</td></tr><tr><td><code>Set</code>, <code>MutableSet</code></td><td><code>KtSet</code>, <code>KtMutableSet</code></td><td>通过 <code>KtSet.asJsReadonlySetView</code> 或 <code>KtMutableSet.asJsSetView</code> 暴露一个 ES2015 <code>Set</code>。</td></tr><tr><td><code>Unit</code></td><td>Undefined</td><td>当用作返回类型时可导出，但当用作形参类型时不可导出。</td></tr><tr><td><code>Any</code></td><td><code>Object</code></td><td></td></tr><tr><td><code>Throwable</code></td><td><code>Error</code></td><td></td></tr><tr><td><code>enum class Type</code></td><td><code>Type</code></td><td>枚举条目以静态类属性的形式暴露（<code>Type.ENTRY</code>）。</td></tr><tr><td>Nullable <code>Type?</code></td><td>\`Type</td><td>null</td></tr><tr><td>All other Kotlin types, except for those marked with <code>@JsExport</code></td><td>Not supported</td><td>包括 Kotlin 的<a href="/kotlin/unsigned-integer-types">无符号整型</a>。</td></tr></tbody></table><p>此外，重要的是要了解：</p><ul><li><p>Kotlin 为 <code>kotlin.Int</code>、<code>kotlin.Byte</code>、<code>kotlin.Short</code>、<code>kotlin.Char</code> 和 <code>kotlin.Long</code> 保留溢出语义。</p></li><li><p>Kotlin 在运行时无法区分数值类型（<code>kotlin.Long</code> 除外），因此以下代码有效：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 23</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>Kotlin 在 JavaScript 中保留惰性对象初始化。</p></li><li><p>Kotlin 不在 JavaScript 中实现顶层属性的惰性初始化。</p></li></ul>`,46)]))}const E=i(n,[["render",l]]);export{c as __pageData,E as default};
