import{_ as r,C as l,c as o,o as d,ag as h,j as i,G as t,w as n,a}from"./chunks/framework.Bksy39di.js";const C=JSON.parse('{"title":"Kotlin 1.6.0의 새로운 기능","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/whatsnew16.md","filePath":"ko/kotlin/whatsnew16.md","lastUpdated":1754307826000}'),E={name:"ko/kotlin/whatsnew16.md"};function g(c,s,y,F,u,b){const e=l("tab"),k=l("tabs"),p=l("YouTubeVideo");return d(),o("div",null,[s[6]||(s[6]=h(`<h1 id="kotlin-1-6-0의-새로운-기능" tabindex="-1">Kotlin 1.6.0의 새로운 기능 <a class="header-anchor" href="#kotlin-1-6-0의-새로운-기능" aria-label="Permalink to &quot;Kotlin 1.6.0의 새로운 기능&quot;">​</a></h1><p><em><a href="/ko/kotlin/releases#release-details">릴리스: 2021년 11월 16일</a></em></p><p>Kotlin 1.6.0은 새로운 언어 기능, 기존 기능에 대한 최적화 및 개선 사항, 그리고 Kotlin 표준 라이브러리에 대한 많은 개선 사항을 도입합니다.</p><p>변경 사항에 대한 개요는 <a href="https://blog.jetbrains.com/kotlin/2021/11/kotlin-1-6-0-is-released/" target="_blank" rel="noreferrer">릴리스 블로그 게시물</a>에서도 확인할 수 있습니다.</p><h2 id="언어" tabindex="-1">언어 <a class="header-anchor" href="#언어" aria-label="Permalink to &quot;언어&quot;">​</a></h2><p>Kotlin 1.6.0은 이전 1.5.30 릴리스에서 미리보기로 도입되었던 여러 언어 기능에 대한 안정화를 제공합니다:</p><ul><li><a href="#stable-exhaustive-when-statements-for-enum-sealed-and-boolean-subjects">enum, sealed, Boolean 주제에 대한 완전한 when 구문 안정화</a></li><li><a href="#stable-suspending-functions-as-supertypes">슈퍼타입으로서의 정지 함수 안정화</a></li><li><a href="#stable-suspend-conversions">정지 변환 안정화</a></li><li><a href="#stable-instantiation-of-annotation-classes">어노테이션 클래스 인스턴스화 안정화</a></li></ul><p>또한 다양한 타입 추론 개선 사항과 클래스 타입 파라미터에 대한 어노테이션 지원을 포함합니다:</p><ul><li><a href="#improved-type-inference-for-recursive-generic-types">재귀 제네릭 타입에 대한 타입 추론 개선</a></li><li><a href="#changes-to-builder-inference">빌더 추론 변경 사항</a></li><li><a href="#support-for-annotations-on-class-type-parameters">클래스 타입 파라미터에 대한 어노테이션 지원</a></li></ul><h3 id="enum-sealed-boolean-주제에-대한-완전한-when-구문-안정화" tabindex="-1">enum, sealed, Boolean 주제에 대한 완전한 when 구문 안정화 <a class="header-anchor" href="#enum-sealed-boolean-주제에-대한-완전한-when-구문-안정화" aria-label="Permalink to &quot;enum, sealed, Boolean 주제에 대한 완전한 when 구문 안정화&quot;">​</a></h3><p><em>완전한</em> <a href="/ko/kotlin/control-flow#when-expressions-and-statements"><code>when</code></a> 구문은 주제의 모든 가능한 타입 또는 값에 대한 브랜치, 또는 일부 타입에 <code>else</code> 브랜치를 포함합니다. 이는 가능한 모든 경우를 커버하여 코드를 더 안전하게 만듭니다.</p><p><code>when</code> 표현식과의 동작 일관성을 위해 곧 불완전한 <code>when</code> 구문을 금지할 예정입니다. 원활한 마이그레이션을 위해 Kotlin 1.6.0은 enum, sealed 또는 Boolean 주제를 갖는 불완전한 <code>when</code> 구문에 대해 경고를 보고합니다. 이 경고는 향후 릴리스에서 오류로 바뀔 것입니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Contact</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PhoneCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Contact</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TextMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Contact</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Contact</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">messageCost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Error: &#39;when&#39; expression must be exhaustive</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Contact.PhoneCall </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sendMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(contact: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Contact</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, message: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Starting with 1.6.0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Warning: Non exhaustive &#39;when&#39; statements on Boolean will be</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // prohibited in 1.7, add &#39;false&#39; branch or &#39;else&#39; branch instead </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Warning: Non exhaustive &#39;when&#39; statements on sealed class/interface will be</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // prohibited in 1.7, add &#39;is TextMessage&#39; branch or &#39;else&#39; branch instead</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(contact) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Contact.PhoneCall </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TODO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>변경 사항 및 그 효과에 대한 자세한 설명은 <a href="https://youtrack.jetbrains.com/issue/KT-47709" target="_blank" rel="noreferrer">이 YouTrack 티켓</a>을 참조하세요.</p><h3 id="슈퍼타입으로서의-정지-함수-안정화" tabindex="-1">슈퍼타입으로서의 정지 함수 안정화 <a class="header-anchor" href="#슈퍼타입으로서의-정지-함수-안정화" aria-label="Permalink to &quot;슈퍼타입으로서의 정지 함수 안정화&quot;">​</a></h3><p>정지 함수 타입 구현은 Kotlin 1.6.0에서 <a href="/ko/kotlin/components-stability">안정화</a>되었습니다. <a href="/ko/kotlin/whatsnew1530#suspending-functions-as-supertypes">1.5.30에서</a> 미리보기가 가능했습니다.</p><p>이 기능은 Kotlin 코루틴을 사용하고 정지 함수 타입을 허용하는 API를 설계할 때 유용할 수 있습니다. 이제 원하는 동작을 정지 함수 타입을 구현하는 별도의 클래스에 캡슐화하여 코드를 간소화할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClickAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">suspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TODO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> launchOnClick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(action: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">suspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Unit) {}</span></span></code></pre></div><p>이전에는 람다와 정지 함수 참조만 허용되던 곳에서 이 클래스의 인스턴스를 사용할 수 있습니다: <code>launchOnClick(MyClickAction())</code>.</p><p>현재 구현 세부 사항에서 오는 두 가지 제한 사항이 있습니다:</p><ul><li>일반 함수 타입과 정지 함수 타입을 슈퍼타입 목록에서 혼합할 수 없습니다.</li><li>여러 정지 함수 슈퍼타입을 사용할 수 없습니다.</li></ul><h3 id="정지-변환-안정화" tabindex="-1">정지 변환 안정화 <a class="header-anchor" href="#정지-변환-안정화" aria-label="Permalink to &quot;정지 변환 안정화&quot;">​</a></h3><p>Kotlin 1.6.0은 일반 함수 타입에서 정지 함수 타입으로의 <a href="/ko/kotlin/components-stability">안정적인</a> 변환을 도입합니다. 1.4.0부터 이 기능은 함수 리터럴과 호출 가능한 참조를 지원했습니다. 1.6.0부터는 모든 형태의 표현식에서 작동합니다. 호출 인수로, 이제 정지가 예상되는 곳에 적합한 일반 함수 타입의 어떤 표현식이라도 전달할 수 있습니다. 컴파일러는 암묵적인 변환을 자동으로 수행합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getSuspending</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(suspending: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">suspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Unit) {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> suspending</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(regular: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Unit) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    getSuspending</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { }           </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    getSuspending</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">suspending</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    getSuspending</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(regular)      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="어노테이션-클래스-인스턴스화-안정화" tabindex="-1">어노테이션 클래스 인스턴스화 안정화 <a class="header-anchor" href="#어노테이션-클래스-인스턴스화-안정화" aria-label="Permalink to &quot;어노테이션 클래스 인스턴스화 안정화&quot;">​</a></h3><p>Kotlin 1.5.30은 JVM 플랫폼에서 어노테이션 클래스 인스턴스화에 대한 실험적 지원을 <a href="/ko/kotlin/whatsnew1530#instantiation-of-annotation-classes">도입했습니다</a>. 1.6.0부터 이 기능은 Kotlin/JVM 및 Kotlin/JS 모두에서 기본적으로 사용할 수 있습니다.</p><p>어노테이션 클래스 인스턴스화에 대한 자세한 내용은 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/annotation-instantiation.md" target="_blank" rel="noreferrer">이 KEEP</a>에서 확인하세요.</p><h3 id="재귀-제네릭-타입에-대한-타입-추론-개선" tabindex="-1">재귀 제네릭 타입에 대한 타입 추론 개선 <a class="header-anchor" href="#재귀-제네릭-타입에-대한-타입-추론-개선" aria-label="Permalink to &quot;재귀 제네릭 타입에 대한 타입 추론 개선&quot;">​</a></h3><p>Kotlin 1.5.30은 재귀 제네릭 타입에 대한 타입 추론을 개선하여 해당 타입 파라미터의 상위 바운드에만 기반하여 타입 인수를 추론할 수 있도록 했습니다. 이 개선 사항은 컴파일러 옵션과 함께 사용할 수 있었습니다. 버전 1.6.0부터는 기본적으로 활성화됩니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Before 1.5.30</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> containerA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PostgreSQLContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(DockerImageName.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;postgres:13-alpine&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  withDatabaseName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;db&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  withUsername</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;user&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  withPassword</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;password&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  withInitScript</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sql/schema.sql&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// With compiler option in 1.5.30 or by default starting with 1.6.0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> containerB </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PostgreSQLContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(DockerImageName.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;postgres:13-alpine&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withDatabaseName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;db&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withUsername</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;user&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withPassword</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;password&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withInitScript</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sql/schema.sql&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="빌더-추론-변경-사항" tabindex="-1">빌더 추론 변경 사항 <a class="header-anchor" href="#빌더-추론-변경-사항" aria-label="Permalink to &quot;빌더 추론 변경 사항&quot;">​</a></h3><p>빌더 추론은 제네릭 빌더 함수를 호출할 때 유용한 타입 추론 방식입니다. 람다 인수 내부의 호출에서 얻은 타입 정보를 사용하여 호출의 타입 인수를 추론할 수 있습니다.</p><p>완전히 안정적인 빌더 추론에 더 가까워지는 여러 변경 사항을 적용하고 있습니다. 1.6.0부터:</p><ul><li><p><a href="/ko/kotlin/whatsnew1530#eliminating-builder-inference-restrictions">1.5.30에서 도입된</a> <code>-Xunrestricted-builder-inference</code> 컴파일러 옵션을 지정하지 않고도 빌더 람다 내에서 아직 추론되지 않은 타입의 인스턴스를 반환하는 호출을 할 수 있습니다.</p></li><li><p><code>-Xenable-builder-inference</code>를 사용하면 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-builder-inference/" target="_blank" rel="noreferrer"><code>@BuilderInference</code></a> 어노테이션을 적용하지 않고도 자신만의 빌더를 작성할 수 있습니다.</p><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>참고: 이러한 빌더의 클라이언트는 동일한 <code>-Xenable-builder-inference</code> 컴파일러 옵션을 지정해야 합니다.</p></div></li><li><p><code>-Xenable-builder-inference</code>를 사용하면 일반 타입 추론이 타입에 대한 충분한 정보를 얻을 수 없을 때 빌더 추론이 자동으로 활성화됩니다.</p></li></ul><p><a href="/ko/kotlin/using-builders-with-builder-inference">커스텀 제네릭 빌더 작성 방법</a>에 대해 자세히 알아보세요.</p><h3 id="클래스-타입-파라미터에-대한-어노테이션-지원" tabindex="-1">클래스 타입 파라미터에 대한 어노테이션 지원 <a class="header-anchor" href="#클래스-타입-파라미터에-대한-어노테이션-지원" aria-label="Permalink to &quot;클래스 타입 파라미터에 대한 어노테이션 지원&quot;">​</a></h3><p>클래스 타입 파라미터에 대한 어노테이션 지원은 다음과 같습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(AnnotationTarget.TYPE_PARAMETER)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">annotation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BoxContent</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BoxContent</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p>모든 타입 파라미터에 대한 어노테이션은 JVM 바이트코드로 출력되므로 어노테이션 프로세서가 이를 사용할 수 있습니다.</p><p>주요 사용 사례에 대해서는 <a href="https://youtrack.jetbrains.com/issue/KT-43714" target="_blank" rel="noreferrer">이 YouTrack 티켓</a>을 읽어보세요.</p><p><a href="/ko/kotlin/annotations">어노테이션</a>에 대해 자세히 알아보세요.</p><h2 id="더-긴-기간-동안-이전-api-버전-지원" tabindex="-1">더 긴 기간 동안 이전 API 버전 지원 <a class="header-anchor" href="#더-긴-기간-동안-이전-api-버전-지원" aria-label="Permalink to &quot;더 긴 기간 동안 이전 API 버전 지원&quot;">​</a></h2><p>Kotlin 1.6.0부터는 현재 안정적인 버전 외에 세 가지 이전 API 버전을 지원합니다(기존 두 가지 버전 대신). 현재 버전 1.3, 1.4, 1.5, 1.6을 지원합니다.</p><h2 id="kotlin-jvm" tabindex="-1">Kotlin/JVM <a class="header-anchor" href="#kotlin-jvm" aria-label="Permalink to &quot;Kotlin/JVM&quot;">​</a></h2><p>Kotlin/JVM의 경우, 1.6.0부터 컴파일러는 JVM 17에 해당하는 바이트코드 버전으로 클래스를 생성할 수 있습니다. 새로운 언어 버전에는 또한 로드맵에 있던 최적화된 위임된 프로퍼티 및 반복 가능한 어노테이션이 포함됩니다:</p><ul><li><a href="#repeatable-annotations-with-runtime-retention-for-1-8-jvm-target">1.8 JVM 타겟에 대한 런타임 보존 반복 가능한 어노테이션</a></li><li><a href="#optimize-delegated-properties-which-call-get-set-on-the-given-kproperty-instance">주어진 KProperty 인스턴스에 대한 get/set을 호출하는 위임된 프로퍼티 최적화</a></li></ul><h3 id="_1-8-jvm-타겟에-대한-런타임-보존-반복-가능한-어노테이션" tabindex="-1">1.8 JVM 타겟에 대한 런타임 보존 반복 가능한 어노테이션 <a class="header-anchor" href="#_1-8-jvm-타겟에-대한-런타임-보존-반복-가능한-어노테이션" aria-label="Permalink to &quot;1.8 JVM 타겟에 대한 런타임 보존 반복 가능한 어노테이션&quot;">​</a></h3><p>Java 8은 단일 코드 요소에 여러 번 적용할 수 있는 <a href="https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html" target="_blank" rel="noreferrer">반복 가능한 어노테이션</a>을 도입했습니다. 이 기능은 Java 코드에 두 가지 선언이 있어야 합니다: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Repeatable.html" target="_blank" rel="noreferrer"><code>@java.lang.annotation.Repeatable</code></a>로 표시된 반복 가능한 어노테이션 자체와 그 값을 담을 포함 어노테이션.</p><p>Kotlin 또한 반복 가능한 어노테이션을 가지고 있지만, 어노테이션 선언에 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-repeatable/" target="_blank" rel="noreferrer"><code>@kotlin.annotation.Repeatable</code></a>만 있으면 반복 가능하게 만들 수 있습니다. 1.6.0 이전에는 이 기능이 <code>SOURCE</code> 보존만 지원했으며 Java의 반복 가능한 어노테이션과 호환되지 않았습니다. Kotlin 1.6.0은 이러한 제한을 제거합니다. <code>@kotlin.annotation.Repeatable</code>은 이제 모든 보존을 허용하며 Kotlin과 Java 모두에서 어노테이션을 반복 가능하게 만듭니다. Java의 반복 가능한 어노테이션도 이제 Kotlin 측면에서 지원됩니다.</p><p>포함 어노테이션을 선언할 수 있지만 필수는 아닙니다. 예를 들어:</p><ul><li><p>어노테이션 <code>@Tag</code>가 <code>@kotlin.annotation.Repeatable</code>로 표시되면, Kotlin 컴파일러는 <code>@Tag.Container</code>라는 이름으로 포함 어노테이션 클래스를 자동으로 생성합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Repeatable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">annotation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// The compiler generates @Tag.Container containing annotation</span></span></code></pre></div></li><li><p>포함 어노테이션의 사용자 정의 이름을 설정하려면 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvmrepeatable/" target="_blank" rel="noreferrer"><code>@kotlin.jvm.JvmRepeatable</code></a> 메타 어노테이션을 적용하고 명시적으로 선언된 포함 어노테이션 클래스를 인수로 전달합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmRepeatable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Tags::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">annotation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">annotation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Tags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;)</span></span></code></pre></div></li></ul><p>Kotlin 리플렉션은 이제 새로운 함수인 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect.full/find-annotations.html" target="_blank" rel="noreferrer"><code>KAnnotatedElement.findAnnotations()</code></a>를 통해 Kotlin과 Java의 반복 가능한 어노테이션을 모두 지원합니다.</p><p>Kotlin 반복 가능한 어노테이션에 대한 자세한 내용은 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/repeatable-annotations.md" target="_blank" rel="noreferrer">이 KEEP</a>에서 확인하세요.</p><h3 id="주어진-kproperty-인스턴스에-대한-get-set을-호출하는-위임된-프로퍼티-최적화" tabindex="-1">주어진 KProperty 인스턴스에 대한 get/set을 호출하는 위임된 프로퍼티 최적화 <a class="header-anchor" href="#주어진-kproperty-인스턴스에-대한-get-set을-호출하는-위임된-프로퍼티-최적화" aria-label="Permalink to &quot;주어진 KProperty 인스턴스에 대한 get/set을 호출하는 위임된 프로퍼티 최적화&quot;">​</a></h3><p><code>$delegate</code> 필드를 생략하고 참조된 프로퍼티에 대한 즉각적인 접근을 생성함으로써 생성된 JVM 바이트코드를 최적화했습니다.</p><p>예를 들어 다음 코드에서</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> impl: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> content: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">impl</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Kotlin은 더 이상 <code>content$delegate</code> 필드를 생성하지 않습니다. <code>content</code> 변수의 프로퍼티 접근자는 <code>impl</code> 변수를 직접 호출하여 위임된 프로퍼티의 <code>getValue</code>/<code>setValue</code> 연산자를 건너뛰고 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/index.html" target="_blank" rel="noreferrer"><code>KProperty</code></a> 타입의 프로퍼티 참조 객체가 필요 없게 됩니다.</p><p>구현에 기여해준 Google 동료들에게 감사드립니다!</p><p><a href="/ko/kotlin/delegated-properties">위임된 프로퍼티</a>에 대해 자세히 알아보세요.</p><h2 id="kotlin-native" tabindex="-1">Kotlin/Native <a class="header-anchor" href="#kotlin-native" aria-label="Permalink to &quot;Kotlin/Native&quot;">​</a></h2><p>Kotlin/Native는 여러 개선 사항과 구성 요소 업데이트를 받고 있으며, 일부는 미리보기 상태입니다:</p><ul><li><a href="#preview-of-the-new-memory-manager">새로운 메모리 관리자 미리보기</a></li><li><a href="#support-for-xcode-13">Xcode 13 지원</a></li><li><a href="#compilation-of-windows-targets-on-any-host">모든 호스트에서 Windows 타겟 컴파일</a></li><li><a href="#llvm-and-linker-updates">LLVM 및 링커 업데이트</a></li><li><a href="#performance-improvements">성능 개선</a></li><li><a href="#unified-compiler-plugin-abi-with-jvm-and-js-ir-backends">JVM 및 JS IR 백엔드와의 통합 컴파일러 플러그인 ABI</a></li><li><a href="#detailed-error-messages-for-klib-linkage-failures">klib 연결 실패에 대한 상세 오류 메시지</a></li><li><a href="#reworked-unhandled-exception-handling-api">재작업된 처리되지 않은 예외 처리 API</a></li></ul><h3 id="새로운-메모리-관리자-미리보기" tabindex="-1">새로운 메모리 관리자 미리보기 <a class="header-anchor" href="#새로운-메모리-관리자-미리보기" aria-label="Permalink to &quot;새로운 메모리 관리자 미리보기&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>새로운 Kotlin/Native 메모리 관리자는 <a href="/ko/kotlin/components-stability">실험적</a>입니다. 언제든지 삭제되거나 변경될 수 있습니다. 옵트인(자세한 내용은 아래 참조)이 필요하며, 평가 목적으로만 사용해야 합니다. <a href="https://youtrack.jetbrains.com/issue/KT-48525" target="_blank" rel="noreferrer">YouTrack</a>을 통해 피드백을 주시면 감사하겠습니다.</p></div><p>Kotlin 1.6.0부터 새로운 Kotlin/Native 메모리 관리자의 개발 미리보기를 시도해 볼 수 있습니다. 이는 JVM과 Native 플랫폼 간의 차이를 없애 멀티플랫폼 프로젝트에서 일관된 개발자 경험을 제공하는 데 한 걸음 더 다가섰습니다.</p><p>주목할 만한 변경 사항 중 하나는 Kotlin/JVM에서와 같이 최상위 프로퍼티의 지연 초기화입니다. 최상위 프로퍼티는 같은 파일의 최상위 프로퍼티나 함수가 처음 접근될 때 초기화됩니다. 이 모드에는 전역 프로세스 간 최적화(릴리스 바이너리에만 활성화됨)도 포함되어 불필요한 초기화 검사를 제거합니다.</p><p>최근 새로운 메모리 관리자에 대한 <a href="https://blog.jetbrains.com/kotlin/2021/08/try-the-new-kotlin-native-memory-manager-development-preview/" target="_blank" rel="noreferrer">블로그 게시물</a>을 발행했습니다. 새로운 메모리 관리자의 현재 상태에 대해 알아보고 데모 프로젝트를 찾으려면 해당 게시물을 읽어보거나, 직접 시도해 보려면 바로 <a href="https://github.com/JetBrains/kotlin/blob/master/kotlin-native/NEW_MM.md" target="_blank" rel="noreferrer">마이그레이션 지침</a>으로 이동하세요. 새로운 메모리 관리자가 프로젝트에서 어떻게 작동하는지 확인하고, 문제 추적기인 <a href="https://youtrack.jetbrains.com/issue/KT-48525" target="_blank" rel="noreferrer">YouTrack</a>을 통해 피드백을 공유해 주세요.</p><h3 id="xcode-13-지원" tabindex="-1">Xcode 13 지원 <a class="header-anchor" href="#xcode-13-지원" aria-label="Permalink to &quot;Xcode 13 지원&quot;">​</a></h3><p>Kotlin/Native 1.6.0은 Xcode의 최신 버전인 Xcode 13을 지원합니다. Xcode를 업데이트하고 Apple 운영 체제용 Kotlin 프로젝트 작업을 계속 진행하세요.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Xcode 13에 추가된 새로운 라이브러리는 Kotlin 1.6.0에서 사용할 수 없지만, 향후 버전에 대한 지원을 추가할 예정입니다.</p></div><h3 id="모든-호스트에서-windows-타겟-컴파일" tabindex="-1">모든 호스트에서 Windows 타겟 컴파일 <a class="header-anchor" href="#모든-호스트에서-windows-타겟-컴파일" aria-label="Permalink to &quot;모든 호스트에서 Windows 타겟 컴파일&quot;">​</a></h3><p>1.6.0부터 <code>mingwX64</code> 및 <code>mingwX86</code> Windows 타겟을 컴파일하기 위해 Windows 호스트가 필요하지 않습니다. Kotlin/Native를 지원하는 모든 호스트에서 컴파일할 수 있습니다.</p><h3 id="llvm-및-링커-업데이트" tabindex="-1">LLVM 및 링커 업데이트 <a class="header-anchor" href="#llvm-및-링커-업데이트" aria-label="Permalink to &quot;LLVM 및 링커 업데이트&quot;">​</a></h3><p>Kotlin/Native가 내부적으로 사용하는 LLVM 의존성을 재작업했습니다. 이는 다음과 같은 다양한 이점을 제공합니다:</p><ul><li>LLVM 버전이 11.1.0으로 업데이트되었습니다.</li><li>의존성 크기가 감소했습니다. 예를 들어, macOS에서는 이전 버전의 1200MB에서 약 300MB로 줄었습니다.</li><li><a href="https://youtrack.jetbrains.com/issue/KT-42693" target="_blank" rel="noreferrer">최신 Linux 배포판에서 사용할 수 없는 <code>ncurses5</code> 라이브러리에 대한 의존성이 제외되었습니다</a>.</li></ul><p>LLVM 업데이트 외에도 Kotlin/Native는 이제 MingGW 타겟에 <a href="https://lld.llvm.org/" target="_blank" rel="noreferrer">LLD</a> 링커(LLVM 프로젝트의 링커)를 사용합니다. 이는 이전에 사용했던 ld.bfd 링커보다 다양한 이점을 제공하며, 생성된 바이너리의 런타임 성능을 개선하고 MinGW 타겟에 대한 컴파일러 캐시를 지원할 수 있게 합니다. LLD는 <a href="/ko/kotlin/whatsnew1530#deprecation-of-linkage-against-dlls-without-import-libraries-for-mingw-targets">DLL 연결을 위한 임포트 라이브러리가 필요합니다</a>. 자세한 내용은 <a href="https://stackoverflow.com/questions/3573475/how-does-the-import-library-work-details/3573527/#3573527" target="_blank" rel="noreferrer">이 Stack Overflow 스레드</a>에서 확인하세요.</p><h3 id="성능-개선" tabindex="-1">성능 개선 <a class="header-anchor" href="#성능-개선" aria-label="Permalink to &quot;성능 개선&quot;">​</a></h3><p>Kotlin/Native 1.6.0은 다음과 같은 성능 개선을 제공합니다:</p><ul><li>컴파일 시간: <code>linuxX64</code> 및 <code>iosArm64</code> 타겟에 대해 컴파일러 캐시가 기본적으로 활성화됩니다. 이는 디버그 모드에서 대부분의 컴파일(첫 번째 컴파일 제외) 속도를 높입니다. 측정 결과 테스트 프로젝트에서 약 200%의 속도 증가를 보였습니다. 이러한 타겟에 대한 컴파일러 캐시는 Kotlin 1.5.0부터 <a href="/ko/kotlin/whatsnew15#performance-improvements">추가 Gradle 프로퍼티</a>와 함께 사용할 수 있었습니다. 이제 해당 프로퍼티를 제거할 수 있습니다.</li><li>런타임: 생성된 LLVM 코드의 최적화 덕분에 <code>for</code> 루프를 사용한 배열 반복이 이제 최대 12% 더 빨라졌습니다.</li></ul><h3 id="jvm-및-js-ir-백엔드와의-통합-컴파일러-플러그인-abi" tabindex="-1">JVM 및 JS IR 백엔드와의 통합 컴파일러 플러그인 ABI <a class="header-anchor" href="#jvm-및-js-ir-백엔드와의-통합-컴파일러-플러그인-abi" aria-label="Permalink to &quot;JVM 및 JS IR 백엔드와의 통합 컴파일러 플러그인 ABI&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>Kotlin/Native용 공통 IR 컴파일러 플러그인 ABI를 사용하는 옵션은 <a href="/ko/kotlin/components-stability">실험적</a>입니다. 언제든지 삭제되거나 변경될 수 있습니다. 옵트인(자세한 내용은 아래 참조)이 필요하며, 평가 목적으로만 사용해야 합니다. <a href="https://youtrack.jetbrains.com/issue/KT-48595" target="_blank" rel="noreferrer">YouTrack</a>을 통해 피드백을 주시면 감사하겠습니다.</p></div><p>이전 버전에서는 컴파일러 플러그인 작성자가 ABI의 차이 때문에 Kotlin/Native용 별도의 아티팩트를 제공해야 했습니다.</p><p>1.6.0부터 Kotlin 멀티플랫폼 Gradle 플러그인은 Kotlin/Native에 대해 임베더블 컴파일러 jar(JVM 및 JS IR 백엔드에 사용되는 것)를 사용할 수 있습니다. 이는 컴파일러 플러그인 개발 경험을 통합하는 한 걸음으로, 이제 Native 및 기타 지원되는 플랫폼에 대해 동일한 컴파일러 플러그인 아티팩트를 사용할 수 있습니다.</p><p>이는 이러한 지원의 미리보기 버전이며, 옵트인이 필요합니다. Kotlin/Native용 일반 컴파일러 플러그인 아티팩트를 사용하려면 <code>gradle.properties</code>에 <code>kotlin.native.useEmbeddableCompilerJar=true</code> 라인을 추가하세요.</p><p>향후 Kotlin/Native에 임베더블 컴파일러 jar를 기본적으로 사용할 계획이므로, 미리보기가 어떻게 작동하는지에 대한 여러분의 의견을 듣는 것이 매우 중요합니다.</p><p>컴파일러 플러그인 작성자라면 이 모드를 시도해보고 플러그인이 작동하는지 확인해 주세요. 플러그인의 구조에 따라 마이그레이션 단계가 필요할 수 있습니다. 마이그레이션 지침 및 피드백은 <a href="https://youtrack.jetbrains.com/issue/KT-48595" target="_blank" rel="noreferrer">이 YouTrack 이슈</a>를 참조하세요.</p><h3 id="klib-연결-실패에-대한-상세-오류-메시지" tabindex="-1">klib 연결 실패에 대한 상세 오류 메시지 <a class="header-anchor" href="#klib-연결-실패에-대한-상세-오류-메시지" aria-label="Permalink to &quot;klib 연결 실패에 대한 상세 오류 메시지&quot;">​</a></h3><p>Kotlin/Native 컴파일러는 이제 klib 연결 오류에 대한 상세 오류 메시지를 제공합니다. 이제 메시지에는 명확한 오류 설명이 포함되어 있으며, 가능한 원인 및 해결 방법에 대한 정보도 포함됩니다.</p><p>예시:</p><ul><li><p>1.5.30:</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>e: java.lang.IllegalStateException: IrTypeAliasSymbol expected: Unbound public symbol for public kotlinx.coroutines/CancellationException|null[0]</span></span>
<span class="line"><span>&lt;stack trace&gt;</span></span></code></pre></div></li><li><p>1.6.0:</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>e: IR 역직렬화 중 예상치 못한 타입의 심볼이 발견되었습니다: IrClassPublicSymbolImpl, kotlinx.coroutines/CancellationException|null[0].</span></span>
<span class="line"><span>IrTypeAliasSymbol이 예상됩니다.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>이는 두 개의 라이브러리가 있을 때, 한 라이브러리가 현재 프로젝트에서 사용되는 다른 라이브러리 버전과 다른 버전으로 컴파일된 경우 발생할 수 있습니다.</span></span>
<span class="line"><span>프로젝트 구성이 올바르고 종속성의 버전이 일관적인지 확인하십시오.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core (org.jetbrains.kotlinx:kotlinx-coroutines-core-macosx64)&quot;에 의존하며 충돌을 일으킬 수 있는 라이브러리 목록:</span></span>
<span class="line"><span>&lt;list of libraries and potential version mismatches&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>프로젝트 종속성:</span></span>
<span class="line"><span>&lt;dependencies tree&gt;</span></span></code></pre></div></li></ul><h3 id="재작업된-처리되지-않은-예외-처리-api" tabindex="-1">재작업된 처리되지 않은 예외 처리 API <a class="header-anchor" href="#재작업된-처리되지-않은-예외-처리-api" aria-label="Permalink to &quot;재작업된 처리되지 않은 예외 처리 API&quot;">​</a></h3><p>Kotlin/Native 런타임 전체에 걸쳐 처리되지 않은 예외 처리를 통합했으며, <code>processUnhandledException(throwable: Throwable)</code> 함수로 기본 처리를 노출하여 <code>kotlinx.coroutines</code>와 같은 사용자 정의 실행 환경에서 사용할 수 있도록 했습니다. 이 처리는 <code>Worker.executeAfter()</code>의 작업에서 벗어나는 예외에도 적용되지만, 이는 새로운 <a href="#preview-of-the-new-memory-manager">메모리 관리자</a>에 대해서만 해당됩니다.</p><p>API 개선 사항은 <code>setUnhandledExceptionHook()</code>으로 설정된 훅에도 영향을 미쳤습니다. 이전에는 Kotlin/Native 런타임이 처리되지 않은 예외로 훅을 호출한 후 이러한 훅이 재설정되었고, 프로그램은 항상 바로 종료되었습니다. 이제 이러한 훅은 여러 번 사용될 수 있으며, 처리되지 않은 예외 발생 시 프로그램이 항상 종료되도록 하려면 처리되지 않은 예외 훅을 설정하지 않거나(<code>setUnhandledExceptionHook()</code>), 훅 끝에서 <code>terminateWithUnhandledException()</code>을 호출해야 합니다. 이는 예외를 Firebase Crashlytics와 같은 서드파티 충돌 보고 서비스로 전송한 다음 프로그램을 종료하는 데 도움이 됩니다. <code>main()</code>에서 벗어나는 예외 및 상호 운용 경계를 넘는 예외는 훅이 <code>terminateWithUnhandledException()</code>을 호출하지 않았더라도 항상 프로그램을 종료시킬 것입니다.</p><h2 id="kotlin-js" tabindex="-1">Kotlin/JS <a class="header-anchor" href="#kotlin-js" aria-label="Permalink to &quot;Kotlin/JS&quot;">​</a></h2><p>Kotlin/JS 컴파일러를 위한 IR 백엔드 안정화를 위해 계속 노력하고 있습니다. Kotlin/JS는 이제 <a href="#option-to-use-pre-installed-node-js-and-yarn">Node.js 및 Yarn 다운로드를 비활성화하는 옵션</a>을 제공합니다.</p><h3 id="사전-설치된-node-js-및-yarn을-사용하는-옵션" tabindex="-1">사전 설치된 Node.js 및 Yarn을 사용하는 옵션 <a class="header-anchor" href="#사전-설치된-node-js-및-yarn을-사용하는-옵션" aria-label="Permalink to &quot;사전 설치된 Node.js 및 Yarn을 사용하는 옵션&quot;">​</a></h3><p>이제 Kotlin/JS 프로젝트 빌드 시 Node.js 및 Yarn 다운로드를 비활성화하고 호스트에 이미 설치된 인스턴스를 사용할 수 있습니다. 이는 CI 서버와 같이 인터넷 연결 없이 서버에서 빌드할 때 유용합니다.</p><p>외부 구성 요소 다운로드를 비활성화하려면 <code>build.gradle(.kts)</code>에 다음 줄을 추가하세요:</p>`,99)),i("ul",null,[i("li",null,[s[2]||(s[2]=i("p",null,"Yarn:",-1)),t(k,{group:"build-script"},{default:n(()=>[t(e,{title:"Kotlin","group-key":"kotlin"},{default:n(()=>s[0]||(s[0]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"rootProject.plugins."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"withType"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"org"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"jetbrains"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"gradle"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"targets"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"js"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"yarn"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"YarnPlugin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"> {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    rootProject."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"the"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"org"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"jetbrains"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"gradle"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"targets"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"js"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"yarn"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"YarnRootExtension"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},">().download "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," false"),i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}}," // or true for default behavior")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),t(e,{title:"Groovy","group-key":"groovy"},{default:n(()=>s[1]||(s[1]=[i("div",{class:"language-groovy vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"groovy"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"rootProject"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"plugins"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"withType("),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"org.jetbrains.kotlin.gradle.targets.js.yarn.YarnPlugin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    rootProject"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"extensions"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"getByType("),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"org.jetbrains.kotlin.gradle.targets.js.yarn.YarnRootExtension"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"download "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," false")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1})]),i("li",null,[s[5]||(s[5]=i("p",null,"Node.js:",-1)),t(k,{group:"build-script"},{default:n(()=>[t(e,{title:"Kotlin","group-key":"kotlin"},{default:n(()=>s[3]||(s[3]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"rootProject.plugins."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"withType"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"org"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"jetbrains"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"gradle"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"targets"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"js"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"nodejs"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"NodeJsRootPlugin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"> {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    rootProject."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"the"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"org"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"jetbrains"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"gradle"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"targets"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"js"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"nodejs"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"NodeJsRootExtension"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},">().download "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," false"),i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}}," // or true for default behavior")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),t(e,{title:"Groovy","group-key":"groovy"},{default:n(()=>s[4]||(s[4]=[i("div",{class:"language-groovy vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"groovy"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"rootProject"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"plugins"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"withType("),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsRootPlugin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    rootProject"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"extensions"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"getByType("),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsRootExtension"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"download "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," false")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1})])]),s[7]||(s[7]=h(`<h2 id="kotlin-gradle-플러그인" tabindex="-1">Kotlin Gradle 플러그인 <a class="header-anchor" href="#kotlin-gradle-플러그인" aria-label="Permalink to &quot;Kotlin Gradle 플러그인&quot;">​</a></h2><p>Kotlin 1.6.0에서는 <code>KotlinGradleSubplugin</code> 클래스의 사용 중단 수준을 &#39;ERROR&#39;로 변경했습니다. 이 클래스는 컴파일러 플러그인 작성을 위해 사용되었습니다. 다음 릴리스에서는 이 클래스를 제거할 예정입니다. 대신 <code>KotlinCompilerPluginSupportPlugin</code> 클래스를 사용하세요.</p><p><code>kotlin.useFallbackCompilerSearch</code> 빌드 옵션과 <code>noReflect</code>, <code>includeRuntime</code> 컴파일러 옵션을 제거했습니다. <code>useIR</code> 컴파일러 옵션은 숨겨졌으며 향후 릴리스에서 제거될 예정입니다.</p><p>Kotlin Gradle 플러그인에서 <a href="/ko/kotlin/gradle-compiler-options">현재 지원되는 컴파일러 옵션</a>에 대해 자세히 알아보세요.</p><h2 id="표준-라이브러리" tabindex="-1">표준 라이브러리 <a class="header-anchor" href="#표준-라이브러리" aria-label="Permalink to &quot;표준 라이브러리&quot;">​</a></h2><p>새로운 표준 라이브러리 버전 1.6.0은 실험적 기능을 안정화하고, 새로운 기능을 도입하며, 플랫폼 전반에 걸쳐 동작을 통합합니다:</p><ul><li><a href="#new-readline-functions">새로운 readline 함수</a></li><li><a href="#stable-typeof">typeOf() 안정화</a></li><li><a href="#stable-collection-builders">컬렉션 빌더 안정화</a></li><li><a href="#stable-duration-api">Duration API 안정화</a></li><li><a href="#splitting-regex-into-a-sequence">정규식(Regex)을 시퀀스로 분할</a></li><li><a href="#bit-rotation-operations-on-integers">정수에 대한 비트 회전 연산</a></li><li><a href="#changes-for-replace-and-replacefirst-in-js">JS의 replace() 및 replaceFirst() 변경 사항</a></li><li><a href="#improvements-to-the-existing-api">기존 API 개선 사항</a></li><li><a href="#deprecations">사용 중단 예정</a></li></ul><h3 id="새로운-readline-함수" tabindex="-1">새로운 readline 함수 <a class="header-anchor" href="#새로운-readline-함수" aria-label="Permalink to &quot;새로운 readline 함수&quot;">​</a></h3><p>Kotlin 1.6.0은 표준 입력을 처리하기 위한 새로운 함수인 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/readln.html" target="_blank" rel="noreferrer"><code>readln()</code></a>와 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/readln-or-null.html" target="_blank" rel="noreferrer"><code>readlnOrNull()</code></a>을 제공합니다.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>현재, 새로운 함수는 JVM 및 Native 대상 플랫폼에서만 사용할 수 있습니다.</p></div><table tabindex="0"><thead><tr><th><strong>이전 버전</strong></th><th><strong>1.6.0 대체</strong></th><th><strong>사용법</strong></th></tr></thead><tbody><tr><td><code>readLine()!!</code></td><td><code>readln()</code></td><td>표준 입력(stdin)에서 한 줄을 읽어 반환하거나, EOF에 도달하면 <code>RuntimeException</code>을 throw합니다.</td></tr><tr><td><code>readLine()</code></td><td><code>readlnOrNull()</code></td><td>표준 입력(stdin)에서 한 줄을 읽어 반환하거나, EOF에 도달하면 <code>null</code>을 반환합니다.</td></tr></tbody></table><p>한 줄을 읽을 때 <code>!!</code>를 사용할 필요가 없어지는 것이 초보자에게 더 나은 경험을 제공하고 Kotlin 교육을 간소화할 것이라고 믿습니다. 읽기-라인 연산 이름이 <code>println()</code>과의 일관성을 유지하도록, 새로운 함수의 이름을 &#39;ln&#39;으로 줄이기로 결정했습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;What is your nickname?&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nickname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readln</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$nickname</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nextLine </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readlnOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">takeUnless</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isNullOrEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } ?: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">break</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nextLine.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sum)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>기존 <code>readLine()</code> 함수는 IDE 코드 완성에서 <code>readln()</code> 및 <code>readlnOrNull()</code>보다 낮은 우선순위를 갖게 됩니다. IDE 검사 또한 레거시 <code>readLine()</code> 대신 새로운 함수를 사용하도록 권장할 것입니다.</p><p>향후 릴리스에서 <code>readLine()</code> 함수를 점진적으로 사용 중단할 계획입니다.</p><h3 id="typeof-안정화" tabindex="-1">typeOf() 안정화 <a class="header-anchor" href="#typeof-안정화" aria-label="Permalink to &quot;typeOf() 안정화&quot;">​</a></h3><p>버전 1.6.0은 <a href="/ko/kotlin/components-stability">안정적인</a> <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/type-of.html" target="_blank" rel="noreferrer"><code>typeOf()</code></a> 함수를 제공하며, <a href="https://youtrack.jetbrains.com/issue/KT-45396" target="_blank" rel="noreferrer">주요 로드맵 항목</a> 중 하나를 완료합니다.</p><p><a href="https://blog.jetbrains.com/kotlin/2019/06/kotlin-1-3-40-released/" target="_blank" rel="noreferrer">1.3.40부터</a>, <code>typeOf()</code>는 JVM 플랫폼에서 실험적 API로 사용할 수 있었습니다. 이제 어떤 Kotlin 플랫폼에서든 사용할 수 있으며, 컴파일러가 추론할 수 있는 모든 Kotlin 타입의 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-type/#kotlin.reflect.KType" target="_blank" rel="noreferrer"><code>KType</code></a> 표현을 얻을 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reified</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">renderType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> typeOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> type.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fromExplicitType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> typeOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fromReifiedType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> renderType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="컬렉션-빌더-안정화" tabindex="-1">컬렉션 빌더 안정화 <a class="header-anchor" href="#컬렉션-빌더-안정화" aria-label="Permalink to &quot;컬렉션 빌더 안정화&quot;">​</a></h3><p>Kotlin 1.6.0에서는 컬렉션 빌더 함수가 <a href="/ko/kotlin/components-stability">안정화</a>되었습니다. 컬렉션 빌더가 반환하는 컬렉션은 이제 읽기 전용 상태에서 직렬화할 수 있습니다.</p><p>이제 옵트인 어노테이션 없이 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/build-map.html" target="_blank" rel="noreferrer"><code>buildMap()</code></a>, <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/build-list.html" target="_blank" rel="noreferrer"><code>buildList()</code></a>, 그리고 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/build-set.html" target="_blank" rel="noreferrer"><code>buildSet()</code></a>를 사용할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;b&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;c&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buildList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        addAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;d&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(y)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [a, b, c, d]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="duration-api-안정화" tabindex="-1">Duration API 안정화 <a class="header-anchor" href="#duration-api-안정화" aria-label="Permalink to &quot;Duration API 안정화&quot;">​</a></h3><p>서로 다른 시간 단위로 기간을 나타내는 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/" target="_blank" rel="noreferrer">Duration</a> 클래스가 <a href="/ko/kotlin/components-stability">안정화</a>되었습니다. 1.6.0에서 Duration API는 다음과 같은 변경 사항을 받았습니다:</p><ul><li><p>기간을 일, 시, 분, 초, 나노초로 분해하는 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/to-components.html" target="_blank" rel="noreferrer"><code>toComponents()</code></a> 함수의 첫 번째 구성 요소는 이제 <code>Int</code> 타입 대신 <code>Long</code> 타입을 갖습니다. 이전에는 값이 <code>Int</code> 범위에 맞지 않으면 해당 범위로 강제 변환되었습니다. <code>Long</code> 타입을 사용하면 <code>Int</code>에 맞지 않는 값을 잘라내지 않고 Duration 범위 내의 모든 값을 분해할 수 있습니다.</p></li><li><p><code>DurationUnit</code> enum은 이제 독립적이며 JVM에서 <code>java.util.concurrent.TimeUnit</code>의 타입 별칭이 아닙니다. <code>typealias DurationUnit = TimeUnit</code>이 유용할 수 있는 설득력 있는 사례를 찾지 못했습니다. 또한 타입 별칭을 통해 <code>TimeUnit</code> API를 노출하는 것은 <code>DurationUnit</code> 사용자를 혼란스럽게 할 수 있습니다.</p></li><li><p>커뮤니티 피드백에 따라 <code>Int.seconds</code>와 같은 확장 프로퍼티를 다시 가져왔습니다. 그러나 적용 가능성을 제한하기 위해 <code>Duration</code> 클래스의 컴패니언 객체에 배치했습니다. IDE는 여전히 완성 기능에서 확장을 제안하고 컴패니언 객체에서 자동으로 임포트를 삽입할 수 있지만, 향후에는 <code>Duration</code> 타입이 예상되는 경우로 이 동작을 제한할 계획입니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.time.Duration.Companion.seconds</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> duration </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10000</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;There are \${duration.seconds.inWholeMinutes} minutes in </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$duration</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> seconds&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // There are 166 minutes in 10000 seconds</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이전에 도입된 <code>Duration.seconds(Int)</code>와 같은 컴패니언 함수 및 사용이 중단된 최상위 확장 <code>Int.seconds</code>를 <code>Duration.Companion</code>의 새로운 확장으로 대체할 것을 제안합니다.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>이러한 대체는 오래된 최상위 확장과 새로운 컴패니언 확장 사이에 모호성을 유발할 수 있습니다. 자동 마이그레이션을 수행하기 전에 kotlin.time 패키지의 와일드카드 임포트(<code>import kotlin.time.*</code>)를 사용하는지 확인하세요.</p></div></li></ul><h3 id="정규식-regex-을-시퀀스로-분할" tabindex="-1">정규식(Regex)을 시퀀스로 분할 <a class="header-anchor" href="#정규식-regex-을-시퀀스로-분할" aria-label="Permalink to &quot;정규식(Regex)을 시퀀스로 분할&quot;">​</a></h3><p><code>Regex.splitToSequence(CharSequence)</code> 및 <code>CharSequence.splitToSequence(Regex)</code> 함수가 <a href="/ko/kotlin/components-stability">안정화</a>되었습니다. 이 함수들은 주어진 정규식의 일치 항목을 기준으로 문자열을 분할하지만, 결과를 <a href="/ko/kotlin/sequences">Sequence</a>로 반환하여 이 결과에 대한 모든 연산이 지연 실행됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> colorsText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;green, red, brown&amp;blue, orange, pink&amp;green&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> regex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;[,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">s]+&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toRegex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mixedColor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> regex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">splitToSequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(colorsText)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // or</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // val mixedColor = colorsText.splitToSequence(regex)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">firstOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&amp;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mixedColor) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;brown&amp;blue&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="정수에-대한-비트-회전-연산" tabindex="-1">정수에 대한 비트 회전 연산 <a class="header-anchor" href="#정수에-대한-비트-회전-연산" aria-label="Permalink to &quot;정수에 대한 비트 회전 연산&quot;">​</a></h3><p>Kotlin 1.6.0에서 비트 조작을 위한 <code>rotateLeft()</code> 및 <code>rotateRight()</code> 함수가 <a href="/ko/kotlin/components-stability">안정화</a>되었습니다. 이 함수들은 숫자의 이진 표현을 지정된 비트 수만큼 왼쪽 또는 오른쪽으로 회전합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Short</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0b10001</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(number</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rotateRight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radix </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 100000000000100</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(number</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rotateLeft</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radix </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1000100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="js의-replace-및-replacefirst-변경-사항" tabindex="-1">JS의 replace() 및 replaceFirst() 변경 사항 <a class="header-anchor" href="#js의-replace-및-replacefirst-변경-사항" aria-label="Permalink to &quot;JS의 replace() 및 replaceFirst() 변경 사항&quot;">​</a></h3><p>Kotlin 1.6.0 이전에는 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/replace.html" target="_blank" rel="noreferrer"><code>replace()</code></a>와 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/replace-first.html" target="_blank" rel="noreferrer"><code>replaceFirst()</code></a> 정규식 함수가 대체 문자열에 그룹 참조가 포함될 때 Java와 JS에서 다르게 동작했습니다. 모든 대상 플랫폼에서 동작 일관성을 유지하기 위해 JS에서 이들 함수의 구현을 변경했습니다.</p><p>대체 문자열에서 <code>\${name}</code> 또는 <code>$index</code>의 발생은 지정된 인덱스 또는 이름을 가진 캡처된 그룹에 해당하는 부분 시퀀스로 대체됩니다:</p><ul><li><p><code>$index</code> – &#39; \`\`\` 뒤의 첫 번째 숫자는 항상 그룹 참조의 일부로 처리됩니다. 후속 숫자는 유효한 그룹 참조를 형성하는 경우에만 <code>index</code>에 포함됩니다. 오직 숫자 &#39;0&#39;–&#39;9&#39;만 그룹 참조의 잠재적 구성 요소로 간주됩니다. 캡처된 그룹의 인덱스는 &#39;1&#39;부터 시작합니다. 인덱스 &#39;0&#39;의 그룹은 전체 일치 항목을 나타냅니다.</p></li><li><p><code>\${name}</code> – <code>name</code>은 라틴 문자 &#39;a&#39;–&#39;z&#39;, &#39;A&#39;–&#39;Z&#39; 또는 숫자 &#39;0&#39;–&#39;9&#39;로 구성될 수 있습니다. 첫 문자는 문자여야 합니다.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>대체 패턴의 명명된 그룹은 현재 JVM에서만 지원됩니다.</p></div></li><li><p>후속 문자를 대체 문자열에 리터럴로 포함하려면 역슬래시 문자 <code>\\</code>를 사용합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Regex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;(.+)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Kotlin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\$</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// $ Kotlin</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Regex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;(.+)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replaceFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.6.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// \\ 1.6.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>대체 문자열을 리터럴 문자열로 처리해야 하는 경우 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/escape-replacement.html" target="_blank" rel="noreferrer"><code>Regex.escapeReplacement()</code></a>를 사용할 수 있습니다.</p></li></ul><h3 id="기존-api-개선-사항" tabindex="-1">기존 API 개선 사항 <a class="header-anchor" href="#기존-api-개선-사항" aria-label="Permalink to &quot;기존 API 개선 사항&quot;">​</a></h3><ul><li><p>버전 1.6.0은 <code>Comparable.compareTo()</code>에 대한 infix 확장 함수를 추가했습니다. 이제 두 객체를 순서에 따라 비교하기 위해 infix 형식을 사용할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WrappedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> text: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Comparable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WrappedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compareTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(other: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WrappedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">         this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.text compareTo other.text</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>JS의 <code>Regex.replace()</code>는 이제 모든 플랫폼에서 구현을 통일하기 위해 인라인이 아닙니다.</p></li><li><p><code>compareTo()</code> 및 <code>equals()</code> String 함수와 <code>isBlank()</code> CharSequence 함수는 이제 JS에서 JVM과 정확히 동일하게 동작합니다. 이전에는 비-ASCII 문자와 관련하여 편차가 있었습니다.</p></li></ul><h3 id="사용-중단-예정" tabindex="-1">사용 중단 예정 <a class="header-anchor" href="#사용-중단-예정" aria-label="Permalink to &quot;사용 중단 예정&quot;">​</a></h3><p>Kotlin 1.6.0에서는 일부 JS 전용 표준 라이브러리 API에 대해 경고와 함께 사용 중단 주기를 시작합니다.</p><h4 id="concat-match-matches-문자열-함수" tabindex="-1">concat(), match(), matches() 문자열 함수 <a class="header-anchor" href="#concat-match-matches-문자열-함수" aria-label="Permalink to &quot;concat(), match(), matches() 문자열 함수&quot;">​</a></h4><ul><li>주어진 다른 객체의 문자열 표현과 문자열을 연결하려면 <code>concat()</code> 대신 <code>plus()</code>를 사용하세요.</li><li>입력 내에서 정규식의 모든 일치 항목을 찾으려면 <code>String.match(regex: String)</code> 대신 Regex 클래스의 <code>findAll()</code>를 사용하세요.</li><li>정규식이 전체 입력과 일치하는지 확인하려면 <code>String.matches(regex: String)</code> 대신 Regex 클래스의 <code>matches()</code>를 사용하세요.</li></ul><h4 id="비교-함수를-받는-배열에-대한-sort" tabindex="-1">비교 함수를 받는 배열에 대한 sort() <a class="header-anchor" href="#비교-함수를-받는-배열에-대한-sort" aria-label="Permalink to &quot;비교 함수를 받는 배열에 대한 sort()&quot;">​</a></h4><p><code>Array&lt;out T&gt;.sort()</code> 함수와 비교 함수에 의해 전달된 순서에 따라 배열을 정렬하는 인라인 함수 <code>ByteArray.sort()</code>, <code>ShortArray.sort()</code>, <code>IntArray.sort()</code>, <code>LongArray.sort()</code>, <code>FloatArray.sort()</code>, <code>DoubleArray.sort()</code>, <code>CharArray.sort()</code>를 사용 중단했습니다. 배열 정렬에는 다른 표준 라이브러리 함수를 사용하세요.</p><p>참고 자료는 <a href="/ko/kotlin/collection-ordering">컬렉션 정렬</a> 섹션을 참조하세요.</p><h2 id="도구" tabindex="-1">도구 <a class="header-anchor" href="#도구" aria-label="Permalink to &quot;도구&quot;">​</a></h2><h3 id="kover-–-kotlin용-코드-커버리지-도구" tabindex="-1">Kover – Kotlin용 코드 커버리지 도구 <a class="header-anchor" href="#kover-–-kotlin용-코드-커버리지-도구" aria-label="Permalink to &quot;Kover – Kotlin용 코드 커버리지 도구&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>Kover Gradle 플러그인은 실험적입니다. <a href="https://github.com/Kotlin/kotlinx-kover/issues" target="_blank" rel="noreferrer">GitHub</a>를 통해 피드백을 주시면 감사하겠습니다.</p></div><p>Kotlin 1.6.0에서는 IntelliJ](<a href="https://github.com/JetBrains/intellij-coverage" target="_blank" rel="noreferrer">https://github.com/JetBrains/intellij-coverage</a>) 및 <a href="https://github.com/jacoco/jacoco" target="_blank" rel="noreferrer">JaCoCo</a> Kotlin 코드 커버리지 에이전트를 위한 Gradle 플러그인인 Kover를 도입합니다. 인라인 함수를 포함한 모든 언어 구문에서 작동합니다.</p><p>Kover에 대한 자세한 내용은 <a href="https://github.com/Kotlin/kotlinx-kover" target="_blank" rel="noreferrer">GitHub 저장소</a> 또는 다음 비디오에서 확인하세요:</p>`,51)),t(p,{src:"https://www.youtube.com/v/jNu5LY9HIbw",title:"Kover – The Code Coverage Plugin"}),s[8]||(s[8]=h('<h2 id="coroutines-1-6-0-rc" tabindex="-1">Coroutines 1.6.0-RC <a class="header-anchor" href="#coroutines-1-6-0-rc" aria-label="Permalink to &quot;Coroutines 1.6.0-RC&quot;">​</a></h2><p><code>kotlinx.coroutines</code> <a href="https://github.com/Kotlin/kotlinx.coroutines/releases/tag/1.6.0-RC" target="_blank" rel="noreferrer">1.6.0-RC</a>가 여러 기능 및 개선 사항과 함께 출시되었습니다:</p><ul><li><a href="#preview-of-the-new-memory-manager">새로운 Kotlin/Native 메모리 관리자</a> 지원</li><li>추가 스레드를 생성하지 않고 병렬 처리를 제한할 수 있는 디스패처 <em>뷰</em> API 도입</li><li>Java 6에서 Java 8 타겟으로 마이그레이션</li><li>새로운 재작업된 API 및 멀티플랫폼 지원을 갖춘 <code>kotlinx-coroutines-test</code></li><li>코루틴에 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ThreadLocal.html" target="_blank" rel="noreferrer"><code>ThreadLocal</code></a> 변수에 대한 스레드 안전 쓰기 접근을 제공하는 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-copyable-thread-context-element/index.html" target="_blank" rel="noreferrer"><code>CopyableThreadContextElement</code></a> 도입</li></ul><p>자세한 내용은 <a href="https://github.com/Kotlin/kotlinx.coroutines/releases/tag/1.6.0-RC" target="_blank" rel="noreferrer">변경 로그</a>에서 확인하세요.</p><h2 id="kotlin-1-6-0으로-마이그레이션" tabindex="-1">Kotlin 1.6.0으로 마이그레이션 <a class="header-anchor" href="#kotlin-1-6-0으로-마이그레이션" aria-label="Permalink to &quot;Kotlin 1.6.0으로 마이그레이션&quot;">​</a></h2><p>IntelliJ IDEA 및 Android Studio는 Kotlin 플러그인이 1.6.0으로 사용 가능해지면 업데이트를 제안할 것입니다.</p><p>기존 프로젝트를 Kotlin 1.6.0으로 마이그레이션하려면 Kotlin 버전을 <code>1.6.0</code>으로 변경하고 Gradle 또는 Maven 프로젝트를 다시 임포트하세요. <a href="/ko/kotlin/releases#update-to-a-new-kotlin-version">Kotlin 1.6.0으로 업데이트하는 방법</a>을 알아보세요.</p><p>Kotlin 1.6.0으로 새 프로젝트를 시작하려면 Kotlin 플러그인을 업데이트하고 <strong>File</strong> | <strong>New</strong> | <strong>Project</strong>에서 프로젝트 마법사를 실행하세요.</p><p>새로운 명령줄 컴파일러는 <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.6.0" target="_blank" rel="noreferrer">GitHub 릴리스 페이지</a>에서 다운로드할 수 있습니다.</p><p>Kotlin 1.6.0은 <a href="/ko/kotlin/kotlin-evolution-principles#language-and-tooling-releases">기능 릴리스</a>이므로, 이전 버전의 언어로 작성된 코드와 호환되지 않는 변경 사항을 가져올 수 있습니다. 이러한 변경 사항에 대한 자세한 목록은 <a href="/ko/kotlin/compatibility-guide-16">Kotlin 1.6 호환성 가이드</a>에서 확인하세요.</p>',10))])}const f=r(E,[["render",g]]);export{C as __pageData,f as default};
