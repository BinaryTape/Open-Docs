import{_ as a,c as i,o as t,ag as e}from"./chunks/framework.Bksy39di.js";const c=JSON.parse('{"title":"多轮处理","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/ksp-multi-round.md","filePath":"kotlin/ksp-multi-round.md","lastUpdated":1754307826000}'),n={name:"kotlin/ksp-multi-round.md"};function l(h,s,r,o,p,d){return t(),i("div",null,s[0]||(s[0]=[e(`<h1 id="多轮处理" tabindex="-1">多轮处理 <a class="header-anchor" href="#多轮处理" aria-label="Permalink to &quot;多轮处理&quot;">​</a></h1><p>KSP 支持 <em>多轮处理</em>，即文件可以经过多轮处理。这意味着后续轮次会使用前一轮次的输出来作为额外的输入。</p><h2 id="更改你的处理器" tabindex="-1">更改你的处理器 <a class="header-anchor" href="#更改你的处理器" aria-label="Permalink to &quot;更改你的处理器&quot;">​</a></h2><p>要使用多轮处理，<code>SymbolProcessor.process()</code> 函数需要为无效符号返回一个延迟符号列表（<code>List&lt;KSAnnotated&gt;</code>）。使用 <code>KSAnnotated.validate()</code> 来过滤要延迟到下一轮的无效符号。</p><p>以下示例代码展示了如何通过验证检测来延迟无效符号：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(resolver: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Resolver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSAnnotated</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> symbols </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> resolver.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getSymbolsWithAnnotation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;com.example.annotation.Builder&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> symbols.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">validate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    symbols</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KSClassDeclaration </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">validate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BuilderVisitor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), Unit) }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="多轮行为" tabindex="-1">多轮行为 <a class="header-anchor" href="#多轮行为" aria-label="Permalink to &quot;多轮行为&quot;">​</a></h2><h3 id="将符号延迟到下一轮" tabindex="-1">将符号延迟到下一轮 <a class="header-anchor" href="#将符号延迟到下一轮" aria-label="Permalink to &quot;将符号延迟到下一轮&quot;">​</a></h3><p>处理器可以将某些符号的处理延迟到下一轮。当一个符号被延迟时，处理器会等待其他处理器提供额外信息。它可以根据需要持续延迟该符号，直到所需信息被其他处理器提供后，该处理器才能处理被延迟的符号。处理器应仅延迟那些缺少必要信息的无效符号。因此，处理器<strong>不应</strong>延迟来自 classpath 的符号，KSP 也会过滤掉任何非源代码的延迟符号。</p><p>例如，一个为注解类创建<strong>构建器</strong>的处理器可能要求其<strong>构造函数</strong>的所有<strong>形参</strong>类型都有效（即解析为具体类型）。在第一轮中，其中一个<strong>形参</strong>类型无法解析。然后，在第二轮中，由于第一轮生成的文件，它变得可解析了。</p><h3 id="验证符号" tabindex="-1">验证符号 <a class="header-anchor" href="#验证符号" aria-label="Permalink to &quot;验证符号&quot;">​</a></h3><p>判断一个符号是否应该被延迟的一个便捷方法是通过验证。处理器应该知道处理符号所必需的信息。请注意，验证通常需要解析，这可能代价昂贵，因此我们建议只<strong>检测</strong>所需内容。继续前例，对于<strong>构建器</strong>处理器而言，理想的验证是仅<strong>检测</strong>注解符号<strong>构造函数</strong>的所有已解析<strong>形参</strong>类型是否包含 <code>isError == false</code>。</p><p>KSP 提供了一个默认的验证工具。更多信息，请参阅 <a href="#advanced">高级</a> 部分。</p><h3 id="终止条件" tabindex="-1">终止条件 <a class="header-anchor" href="#终止条件" aria-label="Permalink to &quot;终止条件&quot;">​</a></h3><p>当一整轮处理没有生成任何新文件时，多轮处理就会终止。如果在满足终止条件时仍存在未处理的延迟符号，KSP 会为每个带有未处理延迟符号的处理器记录一条错误消息。</p><h3 id="每轮可访问的文件" tabindex="-1">每轮可访问的文件 <a class="header-anchor" href="#每轮可访问的文件" aria-label="Permalink to &quot;每轮可访问的文件&quot;">​</a></h3><p>新生成的文件和现有文件都可以通过 <code>Resolver</code> 访问。KSP 提供了两个用于访问文件的 API：<code>Resolver.getAllFiles()</code> 和 <code>Resolver.getNewFiles()</code>。<code>getAllFiles()</code> 返回现有文件和新生成文件的组合列表，而 <code>getNewFiles()</code> 仅返回新生成的文件。</p><h3 id="getsymbolsannotatedwith-的变化" tabindex="-1"><code>getSymbolsAnnotatedWith()</code> 的变化 <a class="header-anchor" href="#getsymbolsannotatedwith-的变化" aria-label="Permalink to &quot;\`getSymbolsAnnotatedWith()\` 的变化&quot;">​</a></h3><p>为了避免不必要的符号重复处理，<code>getSymbolsAnnotatedWith()</code> 仅返回在新生成的文件中找到的符号，以及上一轮中延迟的符号。</p><h3 id="处理器实例化" tabindex="-1">处理器实例化 <a class="header-anchor" href="#处理器实例化" aria-label="Permalink to &quot;处理器实例化&quot;">​</a></h3><p>处理器实例只创建一次，这意味着你可以在处理器对象中存储信息，以便在后续轮次中使用。</p><h3 id="跨轮次信息一致性" tabindex="-1">跨轮次信息一致性 <a class="header-anchor" href="#跨轮次信息一致性" aria-label="Permalink to &quot;跨轮次信息一致性&quot;">​</a></h3><p>所有 KSP 符号都不能跨多轮重用，因为解析结果可能会根据前一轮中生成的内容而改变。然而，由于 KSP 不允许修改现有代码，因此某些信息，例如符号名称的字符串值，仍应可重用。总而言之，处理器可以存储前几轮的信息，但需要记住这些信息在后续轮次中可能会失效。</p><h3 id="错误和异常处理" tabindex="-1">错误和异常处理 <a class="header-anchor" href="#错误和异常处理" aria-label="Permalink to &quot;错误和异常处理&quot;">​</a></h3><p>当发生错误（由处理器调用 <code>KSPLogger.error()</code> 定义）或异常时，处理会在当前轮次完成后停止。所有处理器都将调用 <code>onError()</code> 方法，并且<strong>不会</strong>调用 <code>finish()</code> 方法。</p><p>请注意，即使发生了错误，其他处理器在该轮次中仍会正常继续处理。这意味着错误处理发生在当前轮次处理完成后。</p><p>发生异常时，KSP 将尝试区分来自 KSP 的异常和来自处理器的异常。异常将导致处理立即终止，并作为错误记录在 KSPLogger 中。来自 KSP 的异常应报告给 KSP 开发者以进行进一步调查。在发生异常或错误的轮次结束时，所有处理器都将调用 <code>onError()</code> 函数来执行其自己的错误处理。</p><p>KSP 为 <code>onError()</code> 提供了一个默认的无操作（no-op）实现，作为 <code>SymbolProcessor</code> 接口的一部分。你可以<strong>覆盖</strong>此方法来提供自己的错误处理逻辑。</p><h2 id="高级" tabindex="-1">高级 <a class="header-anchor" href="#高级" aria-label="Permalink to &quot;高级&quot;">​</a></h2><h3 id="验证的默认行为" tabindex="-1">验证的默认行为 <a class="header-anchor" href="#验证的默认行为" aria-label="Permalink to &quot;验证的默认行为&quot;">​</a></h3><p>KSP 提供的默认验证逻辑会验证被验证符号<strong>封闭作用域</strong>内所有直接可达的符号。默认验证<strong>检测</strong>封闭<strong>作用域</strong>中的引用是否可解析为具体类型，但不会递归地深入到引用类型中执行验证。</p><h3 id="编写你自己的验证逻辑" tabindex="-1">编写你自己的验证逻辑 <a class="header-anchor" href="#编写你自己的验证逻辑" aria-label="Permalink to &quot;编写你自己的验证逻辑&quot;">​</a></h3><p>默认的验证行为可能不适用于所有情况。你可以参考 <code>KSValidateVisitor</code> 并通过提供一个自定义的 <code>predicate</code> <strong>lambda 表达式</strong>来编写自己的验证逻辑，该<strong>lambda 表达式</strong>随后由 <code>KSValidateVisitor</code> 用来过滤需要<strong>检测</strong>的符号。</p>`,33)]))}const g=a(n,[["render",l]]);export{c as __pageData,g as default};
