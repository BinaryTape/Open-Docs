import{_ as i,c as a,o as t,ag as e}from"./chunks/framework.Bksy39di.js";const c=JSON.parse('{"title":"无符号整数类型","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/unsigned-integer-types.md","filePath":"kotlin/unsigned-integer-types.md","lastUpdated":1754307826000}'),n={name:"kotlin/unsigned-integer-types.md"};function l(h,s,p,d,k,o){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="无符号整数类型" tabindex="-1">无符号整数类型 <a class="header-anchor" href="#无符号整数类型" aria-label="Permalink to &quot;无符号整数类型&quot;">​</a></h1><p>除了<a href="/kotlin/numbers#integer-types">整数类型</a>之外，Kotlin 还提供了以下无符号整数类型：</p><table tabindex="0"><thead><tr><th>类型</th><th>大小（位）</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td><code>UByte</code></td><td>8</td><td>0</td><td>255</td></tr><tr><td><code>UShort</code></td><td>16</td><td>0</td><td>65,535</td></tr><tr><td><code>UInt</code></td><td>32</td><td>0</td><td>4,294,967,295 (2<sup>32</sup> - 1)</td></tr><tr><td><code>ULong</code></td><td>64</td><td>0</td><td>18,446,744,073,709,551,615 (2<sup>64</sup> - 1)</td></tr></tbody></table><p>无符号类型支持其有符号对应类型的大多数操作。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>无符号数以<a href="/kotlin/inline-classes">内联类</a>的形式实现，含有一个单一的存储属性，该属性包含相同位宽的相应有符号对应类型。如果你想在无符号和有符号整数类型之间进行转换，请确保更新你的代码，以便任何函数调用和操作都支持新类型。</p></div><h2 id="无符号数组与区间" tabindex="-1">无符号数组与区间 <a class="header-anchor" href="#无符号数组与区间" aria-label="Permalink to &quot;无符号数组与区间&quot;">​</a></h2><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>无符号数组及其操作处于 <a href="/kotlin/components-stability">Beta</a> 阶段。它们随时可能发生不兼容的更改。 需要选择启用（参见下方详情）。</p></div><p>与原语类似，每种无符号类型都有一个表示该类型数组的对应类型：</p><ul><li><code>UByteArray</code>: 无符号字节数组。</li><li><code>UShortArray</code>: 无符号短整型数组。</li><li><code>UIntArray</code>: 无符号整型数组。</li><li><code>ULongArray</code>: 无符号长整型数组。</li></ul><p>与有符号整数数组类似，它们提供与 <code>Array</code> 类类似的 API，且没有装箱开销。</p><p>当你使用无符号数组时，会收到一个警告，表明此特性尚未稳定。要消除该警告，请通过 <code>@ExperimentalUnsignedTypes</code> 注解选择启用。由你决定客户端是否必须显式选择启用你的 API 的使用，但请记住无符号数组不是一个稳定特性，因此使用它们的 API 可能会被语言变更破坏。有关<a href="/kotlin/opt-in-requirements">选择启用要求的更多信息</a>。</p><p><a href="/kotlin/ranges">区间和数列</a>由 <code>UIntRange</code>、<code>UIntProgression</code>、<code>ULongRange</code> 和 <code>ULongProgression</code> 类支持 <code>UInt</code> 和 <code>ULong</code>。这些类与无符号整数类型一起都是稳定的。</p><h2 id="无符号整数字面值" tabindex="-1">无符号整数字面值 <a class="header-anchor" href="#无符号整数字面值" aria-label="Permalink to &quot;无符号整数字面值&quot;">​</a></h2><p>为了使无符号整数更易于使用，你可以向整数字面值附加后缀，以指示特定的无符号类型（类似于 <code>Float</code> 的 <code>F</code> 或 <code>Long</code> 的 <code>L</code>）：</p><ul><li><p><code>u</code> 和 <code>U</code> 字母表示无符号字面值，但未指定确切类型。 如果未提供预期类型，编译器会根据字面值的大小使用 <code>UInt</code> 或 <code>ULong</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UByte</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1u</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // UByte，提供了预期类型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UShort</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1u</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // UShort，提供了预期类型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ULong</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1u</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ULong，提供了预期类型</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42u</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // UInt：未提供预期类型，常量适合 UInt</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0xFFFF_FFFF_FFFFu</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // ULong：未提供预期类型，常量不适合 UInt</span></span></code></pre></div></li><li><p><code>uL</code> 和 <code>UL</code> 显式指定字面值应为无符号长整型：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1UL</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // ULong，即使未提供预期类型且常量适合 UInt</span></span></code></pre></div></li></ul><h2 id="用例" tabindex="-1">用例 <a class="header-anchor" href="#用例" aria-label="Permalink to &quot;用例&quot;">​</a></h2><p>无符号数的主要用例是利用整数的完整位范围来表示正值。例如，表示不适合有符号类型的十六进制常量，例如 32 位 <code>AARRGGBB</code> 格式的颜色：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> representation: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> yellow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0xFFCC00CCu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>你可以使用无符号数初始化字节数组，无需显式 <code>toByte()</code> 字面值类型转换：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> byteOrderMarkUtf8 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ubyteArrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0xEFu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0xBBu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0xBFu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>另一个用例是与原生 API 的互操作性。Kotlin 允许表示签名中包含无符号类型的原生声明。这种映射不会用有符号整数替换无符号整数，从而保持语义不变。</p><h3 id="非目标" tabindex="-1">非目标 <a class="header-anchor" href="#非目标" aria-label="Permalink to &quot;非目标&quot;">​</a></h3><p>虽然无符号整数只能表示正数和零，但它们的用例并非应用领域需要非负整数的场景。例如，不将其用作集合大小或集合索引值的类型。</p><p>有几个原因：</p><ul><li>使用有符号整数有助于检测意外溢出并发出错误条件信号，例如空 list 的 <code>List.lastIndex</code> 为 -1。</li><li>无符号整数不能被视为有符号整数的范围受限版本，因为它们的取值范围不是有符号整数范围的子集。有符号整数和无符号整数都不是彼此的子类型。</li></ul>`,25)]))}const g=i(n,[["render",l]]);export{c as __pageData,g as default};
