import{_ as i,a}from"./chunks/sequence-processing.DS8CrXuc.js";import{_ as n,c as e,o as t,ag as l}from"./chunks/framework.Bksy39di.js";const y=JSON.parse('{"title":"시퀀스","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/sequences.md","filePath":"ko/kotlin/sequences.md","lastUpdated":1754307826000}'),h={name:"ko/kotlin/sequences.md"};function k(p,s,r,d,E,o){return t(),e("div",null,s[0]||(s[0]=[l(`<h1 id="시퀀스" tabindex="-1">시퀀스 <a class="header-anchor" href="#시퀀스" aria-label="Permalink to &quot;시퀀스&quot;">​</a></h1><p>컬렉션과 더불어, Kotlin 표준 라이브러리에는 또 다른 타입인 <em>시퀀스</em> (<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html" target="_blank" rel="noreferrer"><code>Sequence&lt;T&gt;</code></a>)가 포함되어 있습니다. 컬렉션과는 달리, 시퀀스는 요소를 포함하지 않으며, 반복하는 동안 요소를 생성합니다. 시퀀스는 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/index.html" target="_blank" rel="noreferrer"><code>Iterable</code></a>과 동일한 함수를 제공하지만, 다단계 컬렉션 처리에 다른 접근 방식을 구현합니다.</p><p><code>Iterable</code>의 처리가 여러 단계를 포함할 때, 이들은 즉시(eagerly) 실행됩니다: 각 처리 단계는 완료되어 그 결과를 — 중간 컬렉션으로 — 반환합니다. 다음 단계는 이 컬렉션에서 실행됩니다. 반대로, 시퀀스의 다단계 처리는 가능한 경우 지연(lazily) 실행됩니다: 실제 계산은 전체 처리 체인의 결과가 요청될 때만 발생합니다.</p><p>연산 실행 순서도 다릅니다: <code>Sequence</code>는 모든 처리 단계를 각 개별 요소에 대해 하나씩 수행합니다. 반대로, <code>Iterable</code>은 전체 컬렉션에 대해 각 단계를 완료한 다음 다음 단계로 진행합니다.</p><p>따라서 시퀀스는 중간 단계의 결과를 구축하는 것을 피하게 하여, 전체 컬렉션 처리 체인의 성능을 향상시킵니다. 그러나 시퀀스의 지연(lazy) 특성은 작은 컬렉션을 처리하거나 간단한 계산을 수행할 때 상당할 수 있는 약간의 오버헤드(overhead)를 추가합니다. 그러므로 <code>Sequence</code>와 <code>Iterable</code>을 모두 고려하여 어떤 것이 귀하의 경우에 더 나은지 결정해야 합니다.</p><h2 id="구성" tabindex="-1">구성 <a class="header-anchor" href="#구성" aria-label="Permalink to &quot;구성&quot;">​</a></h2><h3 id="요소로부터" tabindex="-1">요소로부터 <a class="header-anchor" href="#요소로부터" aria-label="Permalink to &quot;요소로부터&quot;">​</a></h3><p>시퀀스를 생성하려면 <code>sequenceOf()</code> 함수를 호출하고 요소를 인수로 나열합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbersSequence </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sequenceOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;four&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;three&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;two&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;one&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="iterable로부터" tabindex="-1">Iterable로부터 <a class="header-anchor" href="#iterable로부터" aria-label="Permalink to &quot;Iterable로부터&quot;">​</a></h3><p>이미 <code>Iterable</code> 객체(예: <code>List</code> 또는 <code>Set</code>)가 있다면, <code>asSequence()</code>를 호출하여 시퀀스를 생성할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;one&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;two&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;three&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;four&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbersSequence </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asSequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h3 id="함수로부터" tabindex="-1">함수로부터 <a class="header-anchor" href="#함수로부터" aria-label="Permalink to &quot;함수로부터&quot;">​</a></h3><p>시퀀스를 생성하는 또 다른 방법은 요소를 계산하는 함수를 사용하여 시퀀스를 구축하는 것입니다. 함수를 기반으로 시퀀스를 구축하려면, 해당 함수를 인수로 사용하여 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/generate-sequence.html" target="_blank" rel="noreferrer"><code>generateSequence()</code></a>를 호출하십시오. 선택적으로, 첫 번째 요소를 명시적 값 또는 함수 호출의 결과로 지정할 수 있습니다. 제공된 함수가 <code>null</code>을 반환하면 시퀀스 생성이 중단됩니다. 따라서 아래 예시의 시퀀스는 무한합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oddNumbers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> generateSequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { it </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// \`it\` is the previous element</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oddNumbers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">take</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //println(oddNumbers.count())</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // error: the sequence is infinite</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>generateSequence()</code>로 유한 시퀀스를 생성하려면, 필요한 마지막 요소 다음에 <code>null</code>을 반환하는 함수를 제공하십시오.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oddNumbersLessThan10 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> generateSequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (it </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) it </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> else</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oddNumbersLessThan10.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="청크로부터" tabindex="-1">청크로부터 <a class="header-anchor" href="#청크로부터" aria-label="Permalink to &quot;청크로부터&quot;">​</a></h3><p>마지막으로, 시퀀스 요소를 하나씩 또는 임의 크기의 청크(chunk)로 생성할 수 있게 해주는 함수인 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/sequence.html" target="_blank" rel="noreferrer"><code>sequence()</code></a> 함수가 있습니다. 이 함수는 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence-scope/yield.html" target="_blank" rel="noreferrer"><code>yield()</code></a> 및 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence-scope/yield-all.html" target="_blank" rel="noreferrer"><code>yieldAll()</code></a> 함수 호출을 포함하는 람다 표현식을 인수로 받습니다. 이들은 시퀀스 컨슈머에게 요소를 반환하고, 컨슈머가 다음 요소를 요청할 때까지 <code>sequence()</code>의 실행을 중단합니다. <code>yield()</code>는 단일 요소를 인수로 받습니다; <code>yieldAll()</code>은 <code>Iterable</code> 객체, <code>Iterator</code> 또는 다른 <code>Sequence</code>를 받을 수 있습니다. <code>yieldAll()</code>의 <code>Sequence</code> 인수는 무한할 수 있습니다. 그러나 그러한 호출은 마지막이어야 합니다: 이후의 모든 호출은 절대 실행되지 않을 것입니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oddNumbers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        yield</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        yieldAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        yieldAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">generateSequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { it </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oddNumbers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">take</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="시퀀스-연산" tabindex="-1">시퀀스 연산 <a class="header-anchor" href="#시퀀스-연산" aria-label="Permalink to &quot;시퀀스 연산&quot;">​</a></h2><p>시퀀스 연산은 상태 요구 사항에 따라 다음 그룹으로 분류할 수 있습니다:</p><ul><li><em>무상태(Stateless)</em> 연산은 상태를 요구하지 않으며 각 요소를 독립적으로 처리합니다. 예를 들어, <a href="/ko/kotlin/collection-transformations#map"><code>map()</code></a> 또는 <a href="/ko/kotlin/collection-filtering"><code>filter()</code></a>가 있습니다. 무상태 연산은 또한 요소를 처리하기 위해 작은 상수량의 상태를 요구할 수도 있습니다. 예를 들어, <a href="/ko/kotlin/collection-parts"><code>take()</code> 또는 <code>drop()</code></a>가 있습니다.</li><li><em>상태 저장(Stateful)</em> 연산은 상당한 양의 상태를 요구하며, 일반적으로 시퀀스의 요소 수에 비례합니다.</li></ul><p>시퀀스 연산이 지연(lazily) 생성되는 다른 시퀀스를 반환하는 경우, 이를 <em>중간(intermediate)</em> 연산이라고 합니다. 그렇지 않은 경우, 해당 연산은 <em>최종(terminal)</em> 연산입니다. 최종 연산의 예로는 <a href="/ko/kotlin/constructing-collections#copy"><code>toList()</code></a> 또는 <a href="/ko/kotlin/collection-aggregate"><code>sum()</code></a>이 있습니다. 시퀀스 요소는 최종 연산을 통해서만 검색될 수 있습니다.</p><p>시퀀스는 여러 번 반복될 수 있습니다; 그러나 일부 시퀀스 구현은 한 번만 반복되도록 제한될 수 있습니다. 이는 해당 문서에 명시적으로 언급되어 있습니다.</p><h2 id="시퀀스-처리-예시" tabindex="-1">시퀀스 처리 예시 <a class="header-anchor" href="#시퀀스-처리-예시" aria-label="Permalink to &quot;시퀀스 처리 예시&quot;">​</a></h2><p>예시를 통해 <code>Iterable</code>과 <code>Sequence</code>의 차이점을 살펴보겠습니다.</p><h3 id="iterable" tabindex="-1">Iterable <a class="header-anchor" href="#iterable" aria-label="Permalink to &quot;Iterable&quot;">​</a></h3><p>단어 목록이 있다고 가정해 봅시다. 아래 코드는 세 글자보다 긴 단어를 필터링하고, 그러한 단어 중 처음 네 개의 길이를 출력합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> words </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;The quick brown fox jumps over the lazy dog&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">split</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot; &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lengthsList </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> words.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;filter: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$it</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); it.length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;length: \${it.length}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); it.length }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">take</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Lengths of first 4 words longer than 3 chars:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lengthsList)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 코드를 실행하면 <code>filter()</code>와 <code>map()</code> 함수가 코드에 나타나는 순서와 동일하게 실행되는 것을 볼 수 있습니다. 먼저 모든 요소에 대한 <code>filter:</code>를, 그 다음 필터링 후 남은 요소에 대한 <code>length:</code>를, 그리고 마지막 두 줄의 출력을 볼 수 있습니다.</p><p>목록 처리는 다음과 같이 진행됩니다:</p><p><img src="`+i+`" alt="List processing"></p><h3 id="sequence" tabindex="-1">Sequence <a class="header-anchor" href="#sequence" aria-label="Permalink to &quot;Sequence&quot;">​</a></h3><p>이제 시퀀스를 사용하여 동일한 코드를 작성해 봅시다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> words </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;The quick brown fox jumps over the lazy dog&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">split</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot; &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //convert the List to a Sequence</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wordsSequence </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> words.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asSequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lengthsSequence </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wordsSequence.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;filter: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$it</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); it.length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;length: \${it.length}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); it.length }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">take</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Lengths of first 4 words longer than 3 chars&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // terminal operation: obtaining the result as a List</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lengthsSequence.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 코드의 출력은 <code>filter()</code>와 <code>map()</code> 함수가 결과 목록을 구축할 때만 호출된다는 것을 보여줍니다. 따라서 먼저 <code>&quot;Lengths of..&quot;</code> 텍스트 줄을 본 다음 시퀀스 처리가 시작됩니다. 필터링 후 남은 요소의 경우, 다음 요소를 필터링하기 전에 맵이 실행된다는 점에 유의하십시오. 결과 크기가 4에 도달하면 <code>take(4)</code>가 반환할 수 있는 최대 크기이므로 처리가 중지됩니다.</p><p>시퀀스 처리는 다음과 같이 진행됩니다:</p><p width="700"><img src="`+a+'" alt="Sequences processing"></p><p>이 예시에서, 요소의 지연 처리와 네 개의 항목을 찾은 후 중단하는 방식은 목록 접근 방식을 사용하는 것에 비해 연산 수를 줄여줍니다.</p>',40)]))}const F=n(h,[["render",k]]);export{y as __pageData,F as default};
