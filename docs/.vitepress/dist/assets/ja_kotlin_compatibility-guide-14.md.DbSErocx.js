import{_ as e,c as t,o as r,ag as n}from"./chunks/framework.Bksy39di.js";const g=JSON.parse('{"title":"Kotlin 1.4 互換性ガイド","description":"","frontmatter":{},"headers":[],"relativePath":"ja/kotlin/compatibility-guide-14.md","filePath":"ja/kotlin/compatibility-guide-14.md","lastUpdated":1754307826000}'),l={name:"ja/kotlin/compatibility-guide-14.md"};function a(s,o,c,i,p,u){return r(),t("div",null,o[0]||(o[0]=[n('<h1 id="kotlin-1-4-互換性ガイド" tabindex="-1">Kotlin 1.4 互換性ガイド <a class="header-anchor" href="#kotlin-1-4-互換性ガイド" aria-label="Permalink to &quot;Kotlin 1.4 互換性ガイド&quot;">​</a></h1><p><em><a href="/ja/kotlin/kotlin-evolution-principles">言語の現代性を保つ</a></em> および <em><a href="/ja/kotlin/kotlin-evolution-principles">快適なアップデート</a></em> は、Kotlin言語設計における基本的な原則です。前者は、言語の進化を妨げる構文を削除すべきであると述べ、後者は、コード移行を可能な限りスムーズにするために、この削除が事前に十分に伝達されるべきであると述べています。</p><p>ほとんどの言語変更は、更新履歴やコンパイラ警告などの他のチャネルを通じて既に発表されていますが、このドキュメントではそれらすべてをまとめ、Kotlin 1.3 から Kotlin 1.4 への移行に関する完全なリファレンスを提供します。</p><h2 id="基本的な用語" tabindex="-1">基本的な用語 <a class="header-anchor" href="#基本的な用語" aria-label="Permalink to &quot;基本的な用語&quot;">​</a></h2><p>このドキュメントでは、いくつかの種類の互換性について説明します。</p><ul><li><em>source</em>: ソース互換性のない変更により、以前は（エラーや警告なしで）正常にコンパイルできていたコードが、コンパイルできなくなります。</li><li><em>binary</em>: 2つのバイナリアーティファクトは、それらを相互に入れ替えてもロードエラーやリンクエラーを引き起こさない場合、バイナリ互換性があると言われます。</li><li><em>behavioral</em>: 変更適用前後で同じプログラムが異なる振る舞いを示す場合、その変更は動作互換性のない変更であると言われます。</li></ul><p>これらの定義は純粋なKotlinに対してのみ与えられていることを覚えておいてください。他の言語（例えばJava）の視点から見たKotlinコードの互換性は、このドキュメントの範囲外です。</p><h2 id="言語と標準ライブラリ" tabindex="-1">言語と標準ライブラリ <a class="header-anchor" href="#言語と標準ライブラリ" aria-label="Permalink to &quot;言語と標準ライブラリ&quot;">​</a></h2><h3 id="in-演算子と-concurrenthashmap-による予期しない動作" tabindex="-1"><code>in</code> 演算子と <code>ConcurrentHashMap</code> による予期しない動作 <a class="header-anchor" href="#in-演算子と-concurrenthashmap-による予期しない動作" aria-label="Permalink to &quot;`in` 演算子と `ConcurrentHashMap` による予期しない動作&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-18053" target="_blank" rel="noreferrer">KT-18053</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 では、Java で記述された <code>java.util.Map</code> の実装から来る自動的な <code>contains</code> 演算子を禁止します。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 問題のある演算子に対して呼び出しサイトで警告を導入</li><li><blockquote><p>= 1.4: この警告をエラーに昇格 <code>-XXLanguage:-ProhibitConcurrentHashMapContains</code> を使用して一時的に1.4より前の動作に戻すことができます。</p></blockquote></li></ul></blockquote><h3 id="public-inline-メンバー内での-protected-メンバーへのアクセスを禁止" tabindex="-1"><code>public inline</code> メンバー内での <code>protected</code> メンバーへのアクセスを禁止 <a class="header-anchor" href="#public-inline-メンバー内での-protected-メンバーへのアクセスを禁止" aria-label="Permalink to &quot;`public inline` メンバー内での `protected` メンバーへのアクセスを禁止&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-21178" target="_blank" rel="noreferrer">KT-21178</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 では、<code>public inline</code> メンバーからの <code>protected</code> メンバーへのアクセスを禁止します。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 問題のあるケースに対して呼び出しサイトで警告を導入</li><li>1.4: この警告をエラーに昇格 <code>-XXLanguage:-ProhibitProtectedCallFromInline</code> を使用して一時的に1.4より前の動作に戻すことができます。</li></ul></blockquote><h3 id="暗黙的なレシーバーを持つ呼び出しにおけるコントラクト" tabindex="-1">暗黙的なレシーバーを持つ呼び出しにおけるコントラクト <a class="header-anchor" href="#暗黙的なレシーバーを持つ呼び出しにおけるコントラクト" aria-label="Permalink to &quot;暗黙的なレシーバーを持つ呼び出しにおけるコントラクト&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-28672" target="_blank" rel="noreferrer">KT-28672</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: 動作</p><p><strong>概要</strong>: 1.4 では、コントラクトからのスマートキャストが暗黙的なレシーバーを持つ呼び出しで利用可能になります。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-ContractsOnCallsWithImplicitReceiver</code> を使用して一時的に1.4より前の動作に戻すことができます。</p></blockquote></li></ul></blockquote><h3 id="浮動小数点数比較の一貫性のない動作" tabindex="-1">浮動小数点数比較の一貫性のない動作 <a class="header-anchor" href="#浮動小数点数比較の一貫性のない動作" aria-label="Permalink to &quot;浮動小数点数比較の一貫性のない動作&quot;">​</a></h3><blockquote><p><strong>Issues</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-22723" target="_blank" rel="noreferrer">KT-22723</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: 動作</p><p><strong>概要</strong>: Kotlin 1.4 以降、Kotlin コンパイラは浮動小数点数の比較に IEEE 754 標準を使用します。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-ProperIeee754Comparisons</code> を使用して一時的に1.4より前の動作に戻すことができます。</p></blockquote></li></ul></blockquote><h3 id="ジェネリックラムダの最後の式におけるスマートキャストなし" tabindex="-1">ジェネリックラムダの最後の式におけるスマートキャストなし <a class="header-anchor" href="#ジェネリックラムダの最後の式におけるスマートキャストなし" aria-label="Permalink to &quot;ジェネリックラムダの最後の式におけるスマートキャストなし&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-15020" target="_blank" rel="noreferrer">KT-15020</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: 動作</p><p><strong>概要</strong>: 1.4 以降、ラムダ内の最後の式に対するスマートキャストが正しく適用されます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-NewInference</code> を使用して一時的に1.4より前の動作に戻すことができます。このフラグはいくつかの新しい言語機能も無効にする点に注意してください。</p></blockquote></li></ul></blockquote><h3 id="ラムダ引数の順序に依存して結果を-unit-に強制しない" tabindex="-1">ラムダ引数の順序に依存して結果を <code>Unit</code> に強制しない <a class="header-anchor" href="#ラムダ引数の順序に依存して結果を-unit-に強制しない" aria-label="Permalink to &quot;ラムダ引数の順序に依存して結果を `Unit` に強制しない&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-36045" target="_blank" rel="noreferrer">KT-36045</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、ラムダ引数は <code>Unit</code> への暗黙的な強制なしに独立して解決されます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-NewInference</code> を使用して一時的に1.4より前の動作に戻すことができます。このフラグはいくつかの新しい言語機能も無効にする点に注意してください。</p></blockquote></li></ul></blockquote><h3 id="raw型と整数リテラル型間の誤った共通スーパータイプが不健全なコードにつながる" tabindex="-1">raw型と整数リテラル型間の誤った共通スーパータイプが不健全なコードにつながる <a class="header-anchor" href="#raw型と整数リテラル型間の誤った共通スーパータイプが不健全なコードにつながる" aria-label="Permalink to &quot;raw型と整数リテラル型間の誤った共通スーパータイプが不健全なコードにつながる&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-35681" target="_blank" rel="noreferrer">KT-35681</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、rawな <code>Comparable</code> 型と整数リテラル型間の共通スーパータイプがより特定されます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-NewInference</code> を使用して一時的に1.4より前の動作に戻すことができます。このフラグはいくつかの新しい言語機能も無効にする点に注意してください。</p></blockquote></li></ul></blockquote><h3 id="複数の等しい型変数が異なる型でインスタンス化されることによる型安全性の問題" tabindex="-1">複数の等しい型変数が異なる型でインスタンス化されることによる型安全性の問題 <a class="header-anchor" href="#複数の等しい型変数が異なる型でインスタンス化されることによる型安全性の問題" aria-label="Permalink to &quot;複数の等しい型変数が異なる型でインスタンス化されることによる型安全性の問題&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-35679" target="_blank" rel="noreferrer">KT-35679</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、Kotlin コンパイラは等しい型変数を異なる型でインスタンス化することを禁止します。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-NewInference</code> を使用して一時的に1.4より前の動作に戻すことができます。このフラグはいくつかの新しい言語機能も無効にする点に注意してください。</p></blockquote></li></ul></blockquote><h3 id="交差型に対する不正なサブタイピングによる型安全性の問題" tabindex="-1">交差型に対する不正なサブタイピングによる型安全性の問題 <a class="header-anchor" href="#交差型に対する不正なサブタイピングによる型安全性の問題" aria-label="Permalink to &quot;交差型に対する不正なサブタイピングによる型安全性の問題&quot;">​</a></h3><blockquote><p><strong>Issues</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-22474" target="_blank" rel="noreferrer">KT-22474</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 では、交差型に対するサブタイピングがより正しく動作するように洗練されます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-NewInference</code> を使用して一時的に1.4より前の動作に戻すことができます。このフラグはいくつかの新しい言語機能も無効にする点に注意してください。</p></blockquote></li></ul></blockquote><h3 id="ラムダ内の空の-when-式での型の不一致がない" tabindex="-1">ラムダ内の空の <code>when</code> 式での型の不一致がない <a class="header-anchor" href="#ラムダ内の空の-when-式での型の不一致がない" aria-label="Permalink to &quot;ラムダ内の空の `when` 式での型の不一致がない&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-17995" target="_blank" rel="noreferrer">KT-17995</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、空の <code>when</code> 式がラムダの最後の式として使用された場合、型の不一致が発生します。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-NewInference</code> を使用して一時的に1.4より前の動作に戻すことができます。このフラグはいくつかの新しい言語機能も無効にする点に注意してください。</p></blockquote></li></ul></blockquote><h3 id="複数の戻り値の可能性を持つラムダにおける早期リターンを伴う整数リテラルに対する-any-型推論" tabindex="-1">複数の戻り値の可能性を持つラムダにおける早期リターンを伴う整数リテラルに対する <code>Any</code> 型推論 <a class="header-anchor" href="#複数の戻り値の可能性を持つラムダにおける早期リターンを伴う整数リテラルに対する-any-型推論" aria-label="Permalink to &quot;複数の戻り値の可能性を持つラムダにおける早期リターンを伴う整数リテラルに対する `Any` 型推論&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-20226" target="_blank" rel="noreferrer">KT-20226</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、早期リターンがある場合のラムダから返される整数型がより特定されます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-NewInference</code> を使用して一時的に1.4より前の動作に戻すことができます。このフラグはいくつかの新しい言語機能も無効にする点に注意してください。</p></blockquote></li></ul></blockquote><h3 id="再帰型を持つスタープロジェクションの適切なキャプチャ" tabindex="-1">再帰型を持つスタープロジェクションの適切なキャプチャ <a class="header-anchor" href="#再帰型を持つスタープロジェクションの適切なキャプチャ" aria-label="Permalink to &quot;再帰型を持つスタープロジェクションの適切なキャプチャ&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-33012" target="_blank" rel="noreferrer">KT-33012</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、再帰型に対するキャプチャがより正しく動作するため、より多くの候補が適用可能になります。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-NewInference</code> を使用して一時的に1.4より前の動作に戻すことができます。このフラグはいくつかの新しい言語機能も無効にする点に注意してください。</p></blockquote></li></ul></blockquote><h3 id="不適切な型と柔軟な型での共通スーパータイプ計算が誤った結果につながる" tabindex="-1">不適切な型と柔軟な型での共通スーパータイプ計算が誤った結果につながる <a class="header-anchor" href="#不適切な型と柔軟な型での共通スーパータイプ計算が誤った結果につながる" aria-label="Permalink to &quot;不適切な型と柔軟な型での共通スーパータイプ計算が誤った結果につながる&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-37054" target="_blank" rel="noreferrer">KT-37054</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: 動作</p><p><strong>概要</strong>: Kotlin 1.4 以降、柔軟な型間の共通スーパータイプがより特定され、ランタイムエラーから保護されます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-NewInference</code> を使用して一時的に1.4より前の動作に戻すことができます。このフラグはいくつかの新しい言語機能も無効にする点に注意してください。</p></blockquote></li></ul></blockquote><h3 id="null許容型引数に対するキャプチャされた変換の不足による型安全性の問題" tabindex="-1">Null許容型引数に対するキャプチャされた変換の不足による型安全性の問題 <a class="header-anchor" href="#null許容型引数に対するキャプチャされた変換の不足による型安全性の問題" aria-label="Permalink to &quot;Null許容型引数に対するキャプチャされた変換の不足による型安全性の問題&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-35487" target="_blank" rel="noreferrer">KT-35487</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、キャプチャされた型とNull許容型の間のサブタイピングがより正しくなり、ランタイムエラーから保護されます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-NewInference</code> を使用して一時的に1.4より前の動作に戻すことができます。このフラグはいくつかの新しい言語機能も無効にする点に注意してください。</p></blockquote></li></ul></blockquote><h3 id="uncheckedキャスト後の共変型の交差型を保持する" tabindex="-1">uncheckedキャスト後の共変型の交差型を保持する <a class="header-anchor" href="#uncheckedキャスト後の共変型の交差型を保持する" aria-label="Permalink to &quot;uncheckedキャスト後の共変型の交差型を保持する&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-37280" target="_blank" rel="noreferrer">KT-37280</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、共変型の unchecked キャストは、スマートキャストに対して unchecked キャストの型ではなく、交差型を生成します。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-NewInference</code> を使用して一時的に1.4より前の動作に戻すことができます。このフラグはいくつかの新しい言語機能も無効にする点に注意してください。</p></blockquote></li></ul></blockquote><h3 id="this-式の使用によるビルダ推論からの型変数リーク" tabindex="-1"><code>this</code> 式の使用によるビルダ推論からの型変数リーク <a class="header-anchor" href="#this-式の使用によるビルダ推論からの型変数リーク" aria-label="Permalink to &quot;`this` 式の使用によるビルダ推論からの型変数リーク&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-32126" target="_blank" rel="noreferrer">KT-32126</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、<code>sequence {}</code> のようなビルダ関数内で <code>this</code> を使用することは、他の適切な制約がない場合に禁止されます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-NewInference</code> を使用して一時的に1.4より前の動作に戻すことができます。このフラグはいくつかの新しい言語機能も無効にする点に注意してください。</p></blockquote></li></ul></blockquote><h3 id="null許容型引数を持つ反変型の誤ったオーバーロード解決" tabindex="-1">Null許容型引数を持つ反変型の誤ったオーバーロード解決 <a class="header-anchor" href="#null許容型引数を持つ反変型の誤ったオーバーロード解決" aria-label="Permalink to &quot;Null許容型引数を持つ反変型の誤ったオーバーロード解決&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-31670" target="_blank" rel="noreferrer">KT-31670</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、反変型引数を取る関数の2つのオーバーロードが、型のNull許容性（例: <code>In&lt;T&gt;</code> と <code>In&lt;T?&gt;</code>）のみで異なる場合、Null許容型がより特定されるとみなされます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-NewInference</code> を使用して一時的に1.4より前の動作に戻すことができます。このフラグはいくつかの新しい言語機能も無効にする点に注意してください。</p></blockquote></li></ul></blockquote><h3 id="ネストされていない再帰制約を持つビルダ推論" tabindex="-1">ネストされていない再帰制約を持つビルダ推論 <a class="header-anchor" href="#ネストされていない再帰制約を持つビルダ推論" aria-label="Permalink to &quot;ネストされていない再帰制約を持つビルダ推論&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-34975" target="_blank" rel="noreferrer">KT-34975</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、渡されたラムダ内の再帰制約に依存する型を持つ <code>sequence {}</code> のようなビルダ関数は、コンパイラエラーを引き起こします。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-NewInference</code> を使用して一時的に1.4より前の動作に戻すことができます。このフラグはいくつかの新しい言語機能も無効にする点に注意してください。</p></blockquote></li></ul></blockquote><h3 id="熱心な型変数固定が矛盾する制約システムにつながる" tabindex="-1">熱心な型変数固定が矛盾する制約システムにつながる <a class="header-anchor" href="#熱心な型変数固定が矛盾する制約システムにつながる" aria-label="Permalink to &quot;熱心な型変数固定が矛盾する制約システムにつながる&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-25175" target="_blank" rel="noreferrer">KT-25175</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、特定のケースにおける型推論はより熱心に動作しなくなり、矛盾しない制約システムを見つけることができます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-NewInference</code> を使用して一時的に1.4より前の動作に戻すことができます。このフラグはいくつかの新しい言語機能も無効にする点に注意してください。</p></blockquote></li></ul></blockquote><h3 id="open-関数での-tailrec-修飾子の禁止" tabindex="-1"><code>open</code> 関数での <code>tailrec</code> 修飾子の禁止 <a class="header-anchor" href="#open-関数での-tailrec-修飾子の禁止" aria-label="Permalink to &quot;`open` 関数での `tailrec` 修飾子の禁止&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-18541" target="_blank" rel="noreferrer">KT-18541</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、関数は <code>open</code> と <code>tailrec</code> 修飾子を同時に持つことはできません。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: <code>open</code> と <code>tailrec</code> 修飾子を同時に持つ関数に対して警告を報告（プログレッシブモードではエラー）。</li><li><blockquote><p>= 1.4: この警告をエラーに昇格。</p></blockquote></li></ul></blockquote><h3 id="コンパニオンオブジェクトクラス自体よりも可視性の高いコンパニオンオブジェクトの-instance-フィールド" tabindex="-1">コンパニオンオブジェクトクラス自体よりも可視性の高いコンパニオンオブジェクトの <code>INSTANCE</code> フィールド <a class="header-anchor" href="#コンパニオンオブジェクトクラス自体よりも可視性の高いコンパニオンオブジェクトの-instance-フィールド" aria-label="Permalink to &quot;コンパニオンオブジェクトクラス自体よりも可視性の高いコンパニオンオブジェクトの `INSTANCE` フィールド&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-11567" target="_blank" rel="noreferrer">KT-11567</a></p><p><strong>コンポーネント</strong>: Kotlin/JVM</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、コンパニオンオブジェクトがプライベートの場合、その <code>INSTANCE</code> フィールドもプライベートになります。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: コンパイラは非推奨フラグ付きで <code>INSTANCE</code> オブジェクトを生成します。</li><li><blockquote><p>= 1.4: コンパニオンオブジェクトの <code>INSTANCE</code> フィールドは適切な可視性を持ちます。</p></blockquote></li></ul></blockquote><h3 id="戻り値の前に挿入された外側の-finally-ブロックが、finally-のない内側の-try-ブロックの-catch-区間から除外されない" tabindex="-1">戻り値の前に挿入された外側の <code>finally</code> ブロックが、<code>finally</code> のない内側の <code>try</code> ブロックの <code>catch</code> 区間から除外されない <a class="header-anchor" href="#戻り値の前に挿入された外側の-finally-ブロックが、finally-のない内側の-try-ブロックの-catch-区間から除外されない" aria-label="Permalink to &quot;戻り値の前に挿入された外側の `finally` ブロックが、`finally` のない内側の `try` ブロックの `catch` 区間から除外されない&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-31923" target="_blank" rel="noreferrer">KT-31923</a></p><p><strong>コンポーネント</strong>: Kotlin/JVM</p><p><strong>互換性のない変更の種類</strong>: 動作</p><p><strong>概要</strong>: Kotlin 1.4 以降、ネストされた <code>try/catch</code> ブロックに対して <code>catch</code> 区間が適切に計算されます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-ProperFinally</code> を使用して一時的に1.4より前の動作に戻すことができます。</p></blockquote></li></ul></blockquote><h3 id="共変およびジェネリックス特殊化されたオーバーライドの戻り値の型位置でインラインクラスのボックス化されたバージョンを使用する" tabindex="-1">共変およびジェネリックス特殊化されたオーバーライドの戻り値の型位置でインラインクラスのボックス化されたバージョンを使用する <a class="header-anchor" href="#共変およびジェネリックス特殊化されたオーバーライドの戻り値の型位置でインラインクラスのボックス化されたバージョンを使用する" aria-label="Permalink to &quot;共変およびジェネリックス特殊化されたオーバーライドの戻り値の型位置でインラインクラスのボックス化されたバージョンを使用する&quot;">​</a></h3><blockquote><p><strong>Issues</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-30419" target="_blank" rel="noreferrer">KT-30419</a></p><p><strong>コンポーネント</strong>: Kotlin/JVM</p><p><strong>互換性のない変更の種類</strong>: 動作</p><p><strong>概要</strong>: Kotlin 1.4 以降、共変およびジェネリックス特殊化されたオーバーライドを使用する関数は、インラインクラスのボックス化された値を返します。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更</p></blockquote></li></ul></blockquote><h3 id="kotlinインターフェースへの委譲を使用する場合、jvmバイトコードでチェック済み例外を宣言しない" tabindex="-1">Kotlinインターフェースへの委譲を使用する場合、JVMバイトコードでチェック済み例外を宣言しない <a class="header-anchor" href="#kotlinインターフェースへの委譲を使用する場合、jvmバイトコードでチェック済み例外を宣言しない" aria-label="Permalink to &quot;Kotlinインターフェースへの委譲を使用する場合、JVMバイトコードでチェック済み例外を宣言しない&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-35834" target="_blank" rel="noreferrer">KT-35834</a></p><p><strong>コンポーネント</strong>: Kotlin/JVM</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 では、Kotlinインターフェースへの委譲中にチェック済み例外を生成しません。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-DoNotGenerateThrowsForDelegatedKotlinMembers</code> を使用して一時的に1.4より前の動作に戻すことができます。</p></blockquote></li></ul></blockquote><h3 id="単一の-vararg-パラメータを持つメソッドへのシグネチャポリモーフィック呼び出しの動作変更により、引数が別の配列にラップされるのを回避する" tabindex="-1">単一の <code>vararg</code> パラメータを持つメソッドへのシグネチャポリモーフィック呼び出しの動作変更により、引数が別の配列にラップされるのを回避する <a class="header-anchor" href="#単一の-vararg-パラメータを持つメソッドへのシグネチャポリモーフィック呼び出しの動作変更により、引数が別の配列にラップされるのを回避する" aria-label="Permalink to &quot;単一の `vararg` パラメータを持つメソッドへのシグネチャポリモーフィック呼び出しの動作変更により、引数が別の配列にラップされるのを回避する&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-35469" target="_blank" rel="noreferrer">KT-35469</a></p><p><strong>コンポーネント</strong>: Kotlin/JVM</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 では、シグネチャポリモーフィック呼び出しで引数を別の配列にラップしません。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更</p></blockquote></li></ul></blockquote><h3 id="kclass-がジェネリックパラメータとして使用される場合のアノテーションにおける不正なジェネリックシグネチャ" tabindex="-1"><code>KClass</code> がジェネリックパラメータとして使用される場合のアノテーションにおける不正なジェネリックシグネチャ <a class="header-anchor" href="#kclass-がジェネリックパラメータとして使用される場合のアノテーションにおける不正なジェネリックシグネチャ" aria-label="Permalink to &quot;`KClass` がジェネリックパラメータとして使用される場合のアノテーションにおける不正なジェネリックシグネチャ&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-35207" target="_blank" rel="noreferrer">KT-35207</a></p><p><strong>コンポーネント</strong>: Kotlin/JVM</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 では、<code>KClass</code> がジェネリックパラメータとして使用される場合のアノテーションにおける不正な型マッピングを修正します。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更</p></blockquote></li></ul></blockquote><h3 id="シグネチャポリモーフィック呼び出しでのスプレッド演算子の禁止" tabindex="-1">シグネチャポリモーフィック呼び出しでのスプレッド演算子の禁止 <a class="header-anchor" href="#シグネチャポリモーフィック呼び出しでのスプレッド演算子の禁止" aria-label="Permalink to &quot;シグネチャポリモーフィック呼び出しでのスプレッド演算子の禁止&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-35226" target="_blank" rel="noreferrer">KT-35226</a></p><p><strong>コンポーネント</strong>: Kotlin/JVM</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 では、シグネチャポリモーフィック呼び出しでのスプレッド演算子 (<code>*</code>) の使用を禁止します。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: シグネチャポリモーフィック呼び出しでのスプレッド演算子の使用について警告を報告</li><li><blockquote><p>= 1.5: この警告をエラーに昇格 <code>-XXLanguage:-ProhibitSpreadOnSignaturePolymorphicCall</code> を使用して一時的に1.4より前の動作に戻すことができます。</p></blockquote></li></ul></blockquote><h3 id="末尾再帰最適化された関数のデフォルト値の初期化順序を変更" tabindex="-1">末尾再帰最適化された関数のデフォルト値の初期化順序を変更 <a class="header-anchor" href="#末尾再帰最適化された関数のデフォルト値の初期化順序を変更" aria-label="Permalink to &quot;末尾再帰最適化された関数のデフォルト値の初期化順序を変更&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-31540" target="_blank" rel="noreferrer">KT-31540</a></p><p><strong>コンポーネント</strong>: Kotlin/JVM</p><p><strong>互換性のない変更の種類</strong>: 動作</p><p><strong>概要</strong>: Kotlin 1.4 以降、末尾再帰関数の初期化順序は通常の関数と同じになります。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 問題のある関数に対して宣言サイトで警告を報告</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-ProperComputationOrderOfTailrecDefaultParameters</code> を使用して一時的に1.4より前の動作に戻すことができます。</p></blockquote></li></ul></blockquote><h3 id="非-const-な-val-に対して-constantvalue-属性を生成しない" tabindex="-1">非 <code>const</code> な <code>val</code> に対して <code>ConstantValue</code> 属性を生成しない <a class="header-anchor" href="#非-const-な-val-に対して-constantvalue-属性を生成しない" aria-label="Permalink to &quot;非 `const` な `val` に対して `ConstantValue` 属性を生成しない&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-16615" target="_blank" rel="noreferrer">KT-16615</a></p><p><strong>コンポーネント</strong>: Kotlin/JVM</p><p><strong>互換性のない変更の種類</strong>: 動作</p><p><strong>概要</strong>: Kotlin 1.4 以降、コンパイラは非 <code>const</code> な <code>val</code> に対して <code>ConstantValue</code> 属性を生成しません。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: IntelliJ IDEAインスペクションを通じて警告を報告</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-NoConstantValueAttributeForNonConstVals</code> を使用して一時的に1.4より前の動作に戻すことができます。</p></blockquote></li></ul></blockquote><h3 id="open-メソッド上の-jvmoverloads-のために生成されるオーバーロードは-final-にすべき" tabindex="-1"><code>open</code> メソッド上の <code>@JvmOverloads</code> のために生成されるオーバーロードは <code>final</code> にすべき <a class="header-anchor" href="#open-メソッド上の-jvmoverloads-のために生成されるオーバーロードは-final-にすべき" aria-label="Permalink to &quot;`open` メソッド上の `@JvmOverloads` のために生成されるオーバーロードは `final` にすべき&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-33240" target="_blank" rel="noreferrer">KT-33240</a></p><p><strong>コンポーネント</strong>: Kotlin/JVM</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: <code>@JvmOverloads</code> を持つ関数のオーバーロードは <code>final</code> として生成されます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更 <code>-XXLanguage:-GenerateJvmOverloadsAsFinal</code> を使用して一時的に1.4より前の動作に戻すことができます。</p></blockquote></li></ul></blockquote><h3 id="kotlin-result-を返すラムダは、アンボックス化された値ではなくボックス化された値を返すようになる" tabindex="-1"><code>kotlin.Result</code> を返すラムダは、アンボックス化された値ではなくボックス化された値を返すようになる <a class="header-anchor" href="#kotlin-result-を返すラムダは、アンボックス化された値ではなくボックス化された値を返すようになる" aria-label="Permalink to &quot;`kotlin.Result` を返すラムダは、アンボックス化された値ではなくボックス化された値を返すようになる&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-39198" target="_blank" rel="noreferrer">KT-39198</a></p><p><strong>コンポーネント</strong>: Kotlin/JVM</p><p><strong>互換性のない変更の種類</strong>: 動作</p><p><strong>概要</strong>: Kotlin 1.4 以降、<code>kotlin.Result</code> 型の値を返すラムダは、アンボックス化された値ではなくボックス化された値を返します。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更</p></blockquote></li></ul></blockquote><h3 id="nullチェックからの例外を統一する" tabindex="-1">nullチェックからの例外を統一する <a class="header-anchor" href="#nullチェックからの例外を統一する" aria-label="Permalink to &quot;nullチェックからの例外を統一する&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-22275" target="_blank" rel="noreferrer">KT-22275</a></p><p><strong>コンポーネント</strong>: Kotlin/JVM</p><p><strong>互換性のない変更の種類</strong>: 動作</p><p><strong>概要</strong>: Kotlin 1.4 以降、すべてのランタイムnullチェックは <code>java.lang.NullPointerException</code> をスローします。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: ランタイムnullチェックは、<code>KotlinNullPointerException</code>、<code>IllegalStateException</code>、<code>IllegalArgumentException</code>、<code>TypeCastException</code> など、異なる例外をスローします。</li><li><blockquote><p>= 1.4: すべてのランタイムnullチェックは <code>java.lang.NullPointerException</code> をスローします。 <code>-Xno-unified-null-checks</code> を使用して一時的に1.4より前の動作に戻すことができます。</p></blockquote></li></ul></blockquote><h3 id="配列-リスト操作-contains-indexof-lastindexof-における浮動小数点値の比較-ieee-754または全順序" tabindex="-1">配列/リスト操作 (<code>contains</code>, <code>indexOf</code>, <code>lastIndexOf</code>) における浮動小数点値の比較: IEEE 754または全順序 <a class="header-anchor" href="#配列-リスト操作-contains-indexof-lastindexof-における浮動小数点値の比較-ieee-754または全順序" aria-label="Permalink to &quot;配列/リスト操作 (`contains`, `indexOf`, `lastIndexOf`) における浮動小数点値の比較: IEEE 754または全順序&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-28753" target="_blank" rel="noreferrer">KT-28753</a></p><p><strong>コンポーネント</strong>: <code>kotlin-stdlib</code> (JVM)</p><p><strong>互換性のない変更の種類</strong>: 動作</p><p><strong>概要</strong>: <code>Double/FloatArray.asList()</code> から返される <code>List</code> 実装は、<code>contains</code>、<code>indexOf</code>、<code>lastIndexOf</code> を実装し、それらが全順序の等価性を使用するようにします。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更</p></blockquote></li></ul></blockquote><h3 id="コレクションの-min-および-max-関数の戻り値の型を徐々に非nullableに変更する" tabindex="-1">コレクションの <code>min</code> および <code>max</code> 関数の戻り値の型を徐々に非nullableに変更する <a class="header-anchor" href="#コレクションの-min-および-max-関数の戻り値の型を徐々に非nullableに変更する" aria-label="Permalink to &quot;コレクションの `min` および `max` 関数の戻り値の型を徐々に非nullableに変更する&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-38854" target="_blank" rel="noreferrer">KT-38854</a></p><p><strong>コンポーネント</strong>: <code>kotlin-stdlib</code> (JVM)</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: コレクションの <code>min</code> および <code>max</code> 関数の戻り値の型は 1.6 で非nullableに変更されます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>1.4: 同義語として <code>...OrNull</code> 関数を導入し、影響を受けるAPIを非推奨にする（詳細はIssueを参照）</li><li>1.5.x: 影響を受けるAPIの非推奨レベルをエラーに昇格</li><li><blockquote><p>=1.6: 影響を受けるAPIを非nullableな戻り値の型で再導入</p></blockquote></li></ul></blockquote><h3 id="appendln-を非推奨にし、appendline-を推奨する" tabindex="-1"><code>appendln</code> を非推奨にし、<code>appendLine</code> を推奨する <a class="header-anchor" href="#appendln-を非推奨にし、appendline-を推奨する" aria-label="Permalink to &quot;`appendln` を非推奨にし、`appendLine` を推奨する&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-38754" target="_blank" rel="noreferrer">KT-38754</a></p><p><strong>コンポーネント</strong>: <code>kotlin-stdlib</code> (JVM)</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: <code>StringBuilder.appendln()</code> は非推奨になり、<code>StringBuilder.appendLine()</code> が推奨されます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>1.4: <code>appendln</code> の代替として <code>appendLine</code> 関数を導入し、<code>appendln</code> を非推奨にする</li><li><blockquote><p>=1.5: 非推奨レベルをエラーに昇格</p></blockquote></li></ul></blockquote><h3 id="浮動小数点型から-short-および-byte-への変換を非推奨にする" tabindex="-1">浮動小数点型から <code>Short</code> および <code>Byte</code> への変換を非推奨にする <a class="header-anchor" href="#浮動小数点型から-short-および-byte-への変換を非推奨にする" aria-label="Permalink to &quot;浮動小数点型から `Short` および `Byte` への変換を非推奨にする&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-30360" target="_blank" rel="noreferrer">KT-30360</a></p><p><strong>コンポーネント</strong>: <code>kotlin-stdlib</code> (JVM)</p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、浮動小数点型から <code>Short</code> および <code>Byte</code> への変換は非推奨になります。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>1.4: <code>Double.toShort()/toByte()</code> および <code>Float.toShort()/toByte()</code> を非推奨にし、代替を提案</li><li><blockquote><p>=1.5: 非推奨レベルをエラーに昇格</p></blockquote></li></ul></blockquote><h3 id="無効な-startindex-に対する-regex-findall-での早期失敗" tabindex="-1">無効な <code>startIndex</code> に対する <code>Regex.findAll</code> での早期失敗 <a class="header-anchor" href="#無効な-startindex-に対する-regex-findall-での早期失敗" aria-label="Permalink to &quot;無効な `startIndex` に対する `Regex.findAll` での早期失敗&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-28356" target="_blank" rel="noreferrer">KT-28356</a></p><p><strong>コンポーネント</strong>: <code>kotlin-stdlib</code></p><p><strong>互換性のない変更の種類</strong>: 動作</p><p><strong>概要</strong>: Kotlin 1.4 以降、<code>findAll</code> は <code>startIndex</code> が <code>findAll</code> に入る時点で入力文字シーケンスの有効な位置インデックスの範囲内にあることを確認するように改善され、そうでない場合は <code>IndexOutOfBoundsException</code> をスローします。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更</p></blockquote></li></ul></blockquote><h3 id="非推奨の-kotlin-coroutines-experimental-の削除" tabindex="-1">非推奨の <code>kotlin.coroutines.experimental</code> の削除 <a class="header-anchor" href="#非推奨の-kotlin-coroutines-experimental-の削除" aria-label="Permalink to &quot;非推奨の `kotlin.coroutines.experimental` の削除&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-36083" target="_blank" rel="noreferrer">KT-36083</a></p><p><strong>コンポーネント</strong>: <code>kotlin-stdlib</code></p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、非推奨の <code>kotlin.coroutines.experimental</code> API は標準ライブラリから削除されます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: <code>kotlin.coroutines.experimental</code> は <code>ERROR</code> レベルで非推奨。</li><li><blockquote><p>= 1.4: <code>kotlin.coroutines.experimental</code> は標準ライブラリから削除されます。JVM では、別途互換性アーティファクトが提供されます（詳細はIssueを参照）。</p></blockquote></li></ul></blockquote><h3 id="非推奨の-mod-演算子の削除" tabindex="-1">非推奨の <code>mod</code> 演算子の削除 <a class="header-anchor" href="#非推奨の-mod-演算子の削除" aria-label="Permalink to &quot;非推奨の `mod` 演算子の削除&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-26654" target="_blank" rel="noreferrer">KT-26654</a></p><p><strong>コンポーネント</strong>: <code>kotlin-stdlib</code></p><p><strong>互換性のない変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.4 以降、数値型に対する <code>mod</code> 演算子は標準ライブラリから削除されます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: <code>mod</code> は <code>ERROR</code> レベルで非推奨。</li><li><blockquote><p>= 1.4: <code>mod</code> は標準ライブラリから削除されます。</p></blockquote></li></ul></blockquote><h3 id="throwable-addsuppressed-メンバーを非表示にし、代わりに拡張関数を優先する" tabindex="-1"><code>Throwable.addSuppressed</code> メンバーを非表示にし、代わりに拡張関数を優先する <a class="header-anchor" href="#throwable-addsuppressed-メンバーを非表示にし、代わりに拡張関数を優先する" aria-label="Permalink to &quot;`Throwable.addSuppressed` メンバーを非表示にし、代わりに拡張関数を優先する&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-38777" target="_blank" rel="noreferrer">KT-38777</a></p><p><strong>コンポーネント</strong>: <code>kotlin-stdlib</code></p><p><strong>互換性のない変更の種類</strong>: 動作</p><p><strong>概要</strong>: <code>Throwable.addSuppressed()</code> 拡張関数が <code>Throwable.addSuppressed()</code> メンバー関数よりも優先されるようになりました。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 従来の動作（詳細はIssueを参照）</li><li><blockquote><p>= 1.4: 動作変更</p></blockquote></li></ul></blockquote><h3 id="capitalize-は二重音字をタイトルケースに変換すべき" tabindex="-1"><code>capitalize</code> は二重音字をタイトルケースに変換すべき <a class="header-anchor" href="#capitalize-は二重音字をタイトルケースに変換すべき" aria-label="Permalink to &quot;`capitalize` は二重音字をタイトルケースに変換すべき&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-38817" target="_blank" rel="noreferrer">KT-38817</a></p><p><strong>コンポーネント</strong>: <code>kotlin-stdlib</code></p><p><strong>互換性のない変更の種類</strong>: 動作</p><p><strong>概要</strong>: <code>String.capitalize()</code> 関数は、<a href="https://en.wikipedia.org/wiki/Gaj%27s_Latin_alphabet" target="_blank" rel="noreferrer">セルビア・クロアチア語のガジュのラテン文字</a> の二重音字をタイトルケース（<code>Ǆ</code> ではなく <code>ǅ</code>）で大文字にします。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: 二重音字は大文字（<code>Ǆ</code>）で大文字化されます。</li><li><blockquote><p>= 1.4: 二重音字はタイトルケース（<code>ǅ</code>）で大文字化されます。</p></blockquote></li></ul></blockquote><h2 id="ツール" tabindex="-1">ツール <a class="header-anchor" href="#ツール" aria-label="Permalink to &quot;ツール&quot;">​</a></h2><h3 id="windows-では、区切り文字を含むコンパイラ引数を二重引用符で渡す必要があります" tabindex="-1">Windows では、区切り文字を含むコンパイラ引数を二重引用符で渡す必要があります <a class="header-anchor" href="#windows-では、区切り文字を含むコンパイラ引数を二重引用符で渡す必要があります" aria-label="Permalink to &quot;Windows では、区切り文字を含むコンパイラ引数を二重引用符で渡す必要があります&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-41309" target="_blank" rel="noreferrer">KT-41309</a></p><p><strong>コンポーネント</strong>: CLI</p><p><strong>互換性のない変更の種類</strong>: 動作</p><p><strong>概要</strong>: Windows では、区切り文字（空白、<code>=</code>、<code>;</code>、<code>,</code>）を含む <code>kotlinc.bat</code> 引数には二重引用符（<code>&quot;</code>）が必要です。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: すべてのコンパイラ引数は引用符なしで渡されます。</li><li><blockquote><p>= 1.4: 区切り文字（空白、<code>=</code>、<code>;</code>、<code>,</code>）を含むコンパイラ引数には二重引用符（<code>&quot;</code>）が必要です。</p></blockquote></li></ul></blockquote><h3 id="kapt-プロパティに対する合成-annotations-メソッドの名前が変更されました" tabindex="-1">KAPT: プロパティに対する合成 <code>$annotations()</code> メソッドの名前が変更されました <a class="header-anchor" href="#kapt-プロパティに対する合成-annotations-メソッドの名前が変更されました" aria-label="Permalink to &quot;KAPT: プロパティに対する合成 `$annotations()` メソッドの名前が変更されました&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-36926" target="_blank" rel="noreferrer">KT-36926</a></p><p><strong>コンポーネント</strong>: KAPT</p><p><strong>互換性のない変更の種類</strong>: 動作</p><p><strong>概要</strong>: KAPT によってプロパティに対して生成される合成 <code>$annotations()</code> メソッドの名前が 1.4 で変更されました。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>&lt; 1.4: プロパティに対する合成 <code>$annotations()</code> メソッドの名前は <code>&lt;propertyName&gt;@annotations()</code> テンプレートに従います。</li><li><blockquote><p>= 1.4: プロパティに対する合成 <code>$annotations()</code> メソッドの名前には <code>get</code> プレフィックス (<code>get&lt;PropertyName&gt;@annotations()</code>) が含まれます。</p></blockquote></li></ul></blockquote>',95)]))}const b=e(l,[["render",a]]);export{g as __pageData,b as default};
