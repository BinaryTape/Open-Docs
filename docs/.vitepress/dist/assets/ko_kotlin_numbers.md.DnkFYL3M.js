import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.Bksy39di.js";const E=JSON.parse('{"title":"숫자","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/numbers.md","filePath":"ko/kotlin/numbers.md","lastUpdated":1754307826000}'),t={name:"ko/kotlin/numbers.md"};function h(p,s,e,k,d,r){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="숫자" tabindex="-1">숫자 <a class="header-anchor" href="#숫자" aria-label="Permalink to &quot;숫자&quot;">​</a></h1><h2 id="정수-타입" tabindex="-1">정수 타입 <a class="header-anchor" href="#정수-타입" aria-label="Permalink to &quot;정수 타입&quot;">​</a></h2><p>Kotlin은 숫자를 나타내는 내장 타입을 제공합니다. 정수 타입은 크기와 값 범위가 다른 네 가지 타입이 있습니다.</p><table tabindex="0"><thead><tr><th>타입</th><th>크기 (비트)</th><th>최솟값</th><th>최댓값</th></tr></thead><tbody><tr><td><code>Byte</code></td><td>8</td><td>-128</td><td>127</td></tr><tr><td><code>Short</code></td><td>16</td><td>-32768</td><td>32767</td></tr><tr><td><code>Int</code></td><td>32</td><td>-2,147,483,648 (-2<sup>31</sup>)</td><td>2,147,483,647 (2<sup>31</sup> - 1)</td></tr><tr><td><code>Long</code></td><td>64</td><td>-9,223,372,036,854,775,808 (-2<sup>63</sup>)</td><td>9,223,372,036,854,775,807 (2<sup>63</sup> - 1)</td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>부호 있는 정수 타입 외에도 Kotlin은 부호 없는 정수 타입을 제공합니다. 부호 없는 정수는 다른 용도에 맞춰져 있으므로 별도로 다룹니다. <a href="/ko/kotlin/unsigned-integer-types"></a>를 참조하세요.</p></div><p>변수를 명시적인 타입 지정 없이 초기화하면 컴파일러는 값을 나타내기에 충분한 가장 작은 범위를 가진 타입을 <code>Int</code>부터 추론합니다. 값이 <code>Int</code>의 범위를 초과하지 않으면 타입은 <code>Int</code>가 됩니다. 범위를 초과하면 <code>Long</code> 타입이 됩니다. <code>Long</code> 값을 명시적으로 지정하려면 값에 접미사 <code>L</code>을 추가합니다. <code>Byte</code> 또는 <code>Short</code> 타입을 사용하려면 선언에서 명시적으로 지정해야 합니다. 명시적 타입 지정은 컴파일러가 지정된 타입의 범위를 값이 초과하지 않는지 확인하도록 트리거합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> one </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Int</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> threeBillion </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3000000000</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Long</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oneLong </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1L</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Long</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oneByte: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Byte</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span></code></pre></div><h2 id="부동-소수점-타입" tabindex="-1">부동 소수점 타입 <a class="header-anchor" href="#부동-소수점-타입" aria-label="Permalink to &quot;부동 소수점 타입&quot;">​</a></h2><p>실수(real numbers)의 경우 Kotlin은 <a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noreferrer">IEEE 754 표준</a>을 따르는 부동 소수점 타입 <code>Float</code> 및 <code>Double</code>을 제공합니다. <code>Float</code>는 IEEE 754 _단정밀도(single precision)_를 반영하며, <code>Double</code>은 _배정밀도(double precision)_를 반영합니다.</p><p>이 타입들은 크기가 다르며, 다른 정밀도로 부동 소수점 숫자를 저장할 수 있습니다.</p><table tabindex="0"><thead><tr><th>타입</th><th>크기 (비트)</th><th>유효 비트</th><th>지수 비트</th><th>10진수 자릿수</th></tr></thead><tbody><tr><td><code>Float</code></td><td>32</td><td>24</td><td>8</td><td>6-7</td></tr><tr><td><code>Double</code></td><td>64</td><td>53</td><td>11</td><td>15-16</td></tr></tbody></table><p><code>Double</code> 및 <code>Float</code> 변수는 소수 부분이 있는 숫자로만 초기화할 수 있습니다. 소수 부분은 마침표(<code>.</code>)로 정수 부분과 구분합니다.</p><p>소수(fractional numbers)로 초기화된 변수의 경우 컴파일러는 <code>Double</code> 타입을 추론합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pi </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.14</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // Double</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> one: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Double</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Int is inferred</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Initializer type mismatch</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oneDouble </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Double</span></span></code></pre></div><p>값에 대해 <code>Float</code> 타입을 명시적으로 지정하려면 접미사 <code>f</code> 또는 <code>F</code>를 추가합니다. 이 방식으로 제공된 값이 7자리 이상의 10진수 자릿수를 포함하면 반올림됩니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.7182818284</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // Double</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> eFloat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.7182818284f</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Float, actual value is 2.7182817</span></span></code></pre></div><p>다른 일부 언어와 달리 Kotlin에서는 숫자에 대한 암시적 확장 변환이 없습니다. 예를 들어, <code>Double</code> 파라미터를 가진 함수는 <code>Double</code> 값에 대해서만 호출할 수 있으며, <code>Float</code>, <code>Int</code> 또는 다른 숫자 값에는 호출할 수 없습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printDouble</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xInt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xFloat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printDouble</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printDouble</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xInt)   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Argument type mismatch</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printDouble</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xFloat)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Argument type mismatch</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>숫자 값을 다른 타입으로 변환하려면 <a href="#explicit-number-conversions">명시적 숫자 변환</a>을 사용하세요.</p><h2 id="숫자-리터럴-상수" tabindex="-1">숫자 리터럴 상수 <a class="header-anchor" href="#숫자-리터럴-상수" aria-label="Permalink to &quot;숫자 리터럴 상수&quot;">​</a></h2><p>정수 값에 대한 여러 종류의 리터럴 상수가 있습니다.</p><ul><li>10진수: <code>123</code></li><li>대문자 <code>L</code>로 끝나는 <code>Long</code> 타입: <code>123L</code></li><li>16진수: <code>0x0F</code></li><li>2진수: <code>0b00001011</code></li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>8진수 리터럴은 Kotlin에서 지원되지 않습니다.</p></div><p>Kotlin은 부동 소수점 숫자에 대한 일반적인 표기법도 지원합니다.</p><ul><li><code>Double</code> (소수 부분이 문자로 끝나지 않는 경우 기본값): <code>123.5</code>, <code>123.5e10</code></li><li>문자 <code>f</code> 또는 <code>F</code>로 끝나는 <code>Float</code> 타입: <code>123.5f</code></li></ul><p>숫자 상수를 더 읽기 쉽게 하기 위해 밑줄을 사용할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oneMillion </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1_000_000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> creditCardNumber </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1234_5678_9012_3456L</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> socialSecurityNumber </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 999_99_9999L</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hexBytes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0xFF_EC_DE_5E</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bytes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0b11010010_01101001_10010100_10010010</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bigFractional </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1_234_567.7182818284</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>부호 없는 정수 리터럴에는 특별한 접미사도 있습니다. <a href="/ko/kotlin/unsigned-integer-types">부호 없는 정수 타입의 리터럴</a>에 대해 자세히 알아보세요.</p></div><h2 id="java-virtual-machine에서-숫자의-박싱-및-캐싱" tabindex="-1">Java Virtual Machine에서 숫자의 박싱 및 캐싱 <a class="header-anchor" href="#java-virtual-machine에서-숫자의-박싱-및-캐싱" aria-label="Permalink to &quot;Java Virtual Machine에서 숫자의 박싱 및 캐싱&quot;">​</a></h2><p>JVM이 숫자를 저장하는 방식은 작은 (바이트 크기의) 숫자에 대해 기본적으로 사용되는 캐시 때문에 코드가 직관적이지 않게 동작할 수 있습니다.</p><p>JVM은 숫자를 <code>int</code>, <code>double</code> 등과 같은 기본 타입(primitive types)으로 저장합니다. <a href="/ko/kotlin/generics">제네릭 타입</a>을 사용하거나 <code>Int?</code>와 같은 널 허용(nullable) 숫자 참조를 생성하면 숫자는 <code>Integer</code> 또는 <code>Double</code>과 같은 Java 클래스로 박싱됩니다.</p><p>JVM은 <code>Integer</code> 및 <code>−128</code>에서 <code>127</code> 사이의 숫자를 나타내는 다른 객체에 <a href="https://docs.oracle.com/javase/specs/jls/se22/html/jls-5.html#jls-5.1.7" target="_blank" rel="noreferrer">메모리 최적화 기법</a>을 적용합니다. 이러한 객체에 대한 모든 널 허용 참조는 동일한 캐시된 객체를 참조합니다. 예를 들어, 다음 코드의 널 허용 객체는 <a href="/ko/kotlin/equality#referential-equality">참조 동등성</a>을 가집니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> boxedA: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> anotherBoxedA: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(boxedA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> anotherBoxedA) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 범위를 벗어나는 숫자의 경우, 널 허용 객체는 다르지만 <a href="/ko/kotlin/equality#structural-equality">구조적으로 동일합니다</a>.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> boxedB: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> anotherBoxedB: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(boxedB </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> anotherBoxedB) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// false</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(boxedB </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> anotherBoxedB) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이러한 이유로 Kotlin은 박싱 가능한 숫자 및 리터럴과 함께 참조 동등성을 사용하는 것에 대해 <code>&quot;Identity equality for arguments of types ... and ... is prohibited.&quot;</code>와 같은 메시지로 경고합니다. <code>Int</code>, <code>Short</code>, <code>Long</code>, <code>Byte</code> 타입 (및 <code>Char</code>, <code>Boolean</code> 타입)을 비교할 때는 일관된 결과를 얻기 위해 구조적 동등성 검사를 사용하세요.</p><h2 id="명시적-숫자-변환" tabindex="-1">명시적 숫자 변환 <a class="header-anchor" href="#명시적-숫자-변환" aria-label="Permalink to &quot;명시적 숫자 변환&quot;">​</a></h2><p>서로 다른 표현 방식 때문에 숫자 타입은 서로의 <em>하위 타입이 아닙니다</em>. 결과적으로, 작은 타입은 큰 타입으로 암시적으로 변환되지 않으며 그 반대도 마찬가지입니다. 예를 들어, <code>Byte</code> 타입의 값을 <code>Int</code> 변수에 할당하려면 명시적 변환이 필요합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> byte: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Byte</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // OK, literals are checked statically</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intAssignedByte: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> byte </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Initializer type mismatch</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intConvertedByte: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> byte.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(intConvertedByte)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>모든 숫자 타입은 다른 타입으로의 변환을 지원합니다.</p><ul><li><code>toByte(): Byte</code> (<a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin/-float/to-byte.html" target="_blank" rel="noreferrer">Float</a> 및 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin/-double/to-byte.html" target="_blank" rel="noreferrer">Double</a>의 경우 사용 중단됨)</li><li><code>toShort(): Short</code></li><li><code>toInt(): Int</code></li><li><code>toLong(): Long</code></li><li><code>toFloat(): Float</code></li><li><code>toDouble(): Double</code></li></ul><p>많은 경우, 타입이 문맥에서 추론되고 산술 연산자가 자동 변환을 처리하도록 오버로드되어 있기 때문에 명시적 변환이 필요하지 않습니다. 예를 들어:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1L</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // Long + Int =&gt; Long</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(l </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Long)   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="암시적-변환-반대-이유" tabindex="-1">암시적 변환 반대 이유 <a class="header-anchor" href="#암시적-변환-반대-이유" aria-label="Permalink to &quot;암시적 변환 반대 이유&quot;">​</a></h3><p>Kotlin은 암시적 변환이 예상치 못한 동작으로 이어질 수 있기 때문에 이를 지원하지 않습니다.</p><p>만약 다른 타입의 숫자가 암시적으로 변환된다면, 때때로 동등성과 식별자(identity)를 알 수 없게 잃을 수 있습니다. 예를 들어, <code>Int</code>가 <code>Long</code>의 하위 타입이라고 가정해 봅시다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Hypothetical code, does not actually compile:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // A boxed Int (java.lang.Integer)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Implicit conversion yields a boxed Long (java.lang.Long)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a)      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Prints &quot;false&quot; as Long.equals() checks not only the value but whether the other number is Long as well</span></span></code></pre></div><h2 id="숫자-연산" tabindex="-1">숫자 연산 <a class="header-anchor" href="#숫자-연산" aria-label="Permalink to &quot;숫자 연산&quot;">​</a></h2><p>Kotlin은 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>와 같은 표준 산술 연산을 지원합니다. 이 연산자들은 적절한 클래스의 멤버로 선언됩니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2_500_000_000L</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.14</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.71</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>사용자 정의 숫자 클래스에서 이러한 연산자를 오버라이드할 수 있습니다. 자세한 내용은 <a href="/ko/kotlin/operator-overloading">연산자 오버로딩</a>을 참조하세요.</p><h3 id="정수-나눗셈" tabindex="-1">정수 나눗셈 <a class="header-anchor" href="#정수-나눗셈" aria-label="Permalink to &quot;정수 나눗셈&quot;">​</a></h3><p>정수 간의 나눗셈은 항상 정수를 반환합니다. 소수 부분은 버려집니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Operator &#39;==&#39; cannot be applied to &#39;Int&#39; and &#39;Double&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이것은 어떤 두 정수 타입 간의 나눗셈에도 적용됩니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5L</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Error, as Long (x) cannot be compared to Int (2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>소수 부분을 포함하는 나눗셈 결과를 반환하려면 인자 중 하나를 명시적으로 부동 소수점 타입으로 변환하세요.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toDouble</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="비트-연산" tabindex="-1">비트 연산 <a class="header-anchor" href="#비트-연산" aria-label="Permalink to &quot;비트 연산&quot;">​</a></h3><p>Kotlin은 정수에 대한 _비트 연산(bitwise operations)_을 제공합니다. 이 연산은 숫자의 이진 표현 비트와 직접적으로 이진 수준에서 작동합니다. 비트 연산은 중위 형식(infix form)으로 호출할 수 있는 함수로 표현됩니다. 이 연산은 <code>Int</code>와 <code>Long</code>에만 적용될 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xShiftedLeft </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x shl </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xShiftedLeft)  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xAnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x and </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0x000FF000</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xAnd)          </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>비트 연산의 전체 목록:</p><ul><li><code>shl(bits)</code> – 부호 있는 왼쪽 시프트 (signed shift left)</li><li><code>shr(bits)</code> – 부호 있는 오른쪽 시프트 (signed shift right)</li><li><code>ushr(bits)</code> – 부호 없는 오른쪽 시프트 (unsigned shift right)</li><li><code>and(bits)</code> – 비트 AND</li><li><code>or(bits)</code> – 비트 OR</li><li><code>xor(bits)</code> – 비트 XOR</li><li><code>inv()</code> – 비트 반전 (bitwise inversion)</li></ul><h3 id="부동-소수점-숫자-비교" tabindex="-1">부동 소수점 숫자 비교 <a class="header-anchor" href="#부동-소수점-숫자-비교" aria-label="Permalink to &quot;부동 소수점 숫자 비교&quot;">​</a></h3><p>이 섹션에서 다루는 부동 소수점 숫자 연산은 다음과 같습니다.</p><ul><li>동등성 검사: <code>a == b</code> 및 <code>a != b</code></li><li>비교 연산자: <code>a &lt; b</code>, <code>a &gt; b</code>, <code>a &lt;= b</code>, <code>a &gt;= b</code></li><li>범위 인스턴스화 및 범위 검사: <code>a..b</code>, <code>x in a..b</code>, <code>x !in a..b</code></li></ul><p>피연산자 <code>a</code>와 <code>b</code>가 <code>Float</code> 또는 <code>Double</code>이거나 이들의 널 허용(nullable) 대응 타입(타입이 선언되거나 추론되거나 <a href="/ko/kotlin/typecasts#smart-casts">스마트 캐스트</a>의 결과인 경우)으로 정적으로 알려진 경우, 숫자 연산 및 이들이 형성하는 범위는 <a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noreferrer">IEEE 754 부동 소수점 산술 표준</a>을 따릅니다.</p><p>그러나 제네릭 사용 사례를 지원하고 전체 순서(total ordering)를 제공하기 위해 <strong>정적으로 부동 소수점 타입으로 지정되지 않은</strong> 피연산자의 경우 동작이 다릅니다. 예를 들어, <code>Any</code>, <code>Comparable&lt;...&gt;</code>, 또는 <code>Collection&lt;T&gt;</code> 타입과 같은 경우입니다. 이 경우 연산은 <code>Float</code> 및 <code>Double</code>에 대한 <code>equals</code> 및 <code>compareTo</code> 구현을 사용합니다. 그 결과:</p><ul><li><code>NaN</code>은 자신과 동일하게 간주됩니다.</li><li><code>NaN</code>은 <code>POSITIVE_INFINITY</code>를 포함한 다른 모든 요소보다 큰 것으로 간주됩니다.</li><li><code>-0.0</code>은 <code>0.0</code>보다 작은 것으로 간주됩니다.</li></ul><p>다음은 정적으로 부동 소수점 타입으로 지정된 피연산자 (<code>Double.NaN</code>)와 정적으로 부동 소수점 타입으로 지정되지 않은 피연산자 (<code>listOf(T)</code>) 간의 동작 차이를 보여주는 예시입니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Operand statically typed as floating-point number</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Double.NaN </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Double.NaN)                 </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Operand NOT statically typed as floating-point number</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // So NaN is equal to itself</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Double.NaN) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Double.NaN)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Operand statically typed as floating-point number</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)                              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Operand NOT statically typed as floating-point number</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // So -0.0 is less than 0.0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// false</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Double.NaN, Double.POSITIVE_INFINITY, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sorted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // [-0.0, 0.0, Infinity, NaN]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,71)]))}const g=i(t,[["render",h]]);export{E as __pageData,g as default};
