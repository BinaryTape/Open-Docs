import{_ as c,C as o,c as f,o as g,ag as i,G as a,w as r,j as e,a as l}from"./chunks/framework.Bksy39di.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/native-migration-guide.md","filePath":"zh-Hant/kotlin/native-migration-guide.md","lastUpdated":1754307826000}'),p={name:"zh-Hant/kotlin/native-migration-guide.md"};function h(k,t,u,m,b,v){const d=o("list"),n=o("def"),s=o("deflist");return g(),f("div",null,[t[5]||(t[5]=i('<h1 id="遷移至新的記憶體管理器" tabindex="-1">遷移至新的記憶體管理器 <a class="header-anchor" href="#遷移至新的記憶體管理器" aria-label="Permalink to &quot;遷移至新的記憶體管理器&quot;">​</a></h1><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Kotlin 1.9.20 已完全移除對舊版記憶體管理器的支援。請將您的專案遷移至目前記憶體模型，此模型自 Kotlin 1.7.20 起已預設啟用。</p></div><p>本指南比較了新的 <a href="/zh-Hant/kotlin/native-memory-manager">Kotlin/Native 記憶體管理器</a> 與舊版，並說明如何遷移您的專案。</p><p>新記憶體管理器最顯著的變化是解除了物件共享的限制。您不再需要凍結物件即可在執行緒之間共享它們，具體來說：</p><ul><li>頂層屬性可由任何執行緒存取和修改，而無需使用 <code>@SharedImmutable</code>。</li><li>透過 interop 傳遞的物件可由任何執行緒存取和修改，無需凍結它們。</li><li><code>Worker.executeAfter</code> 不再要求操作被凍結。</li><li><code>Worker.execute</code> 不再要求生產者返回一個獨立的物件子圖。</li><li>包含 <code>AtomicReference</code> 和 <code>FreezableAtomicReference</code> 的參照循環不會導致記憶體洩漏。</li></ul><p>除了方便的物件共享外，新的記憶體管理器還帶來了其他主要變化：</p><ul><li>全域屬性在定義它們的文件首次被存取時延遲初始化。以前全域屬性是在程式啟動時初始化的。作為一種權宜之計，您可以為必須在程式啟動時初始化的屬性標記 <code>@EagerInitialization</code> 註解。在使用前，請查閱其 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native/-eager-initialization/" target="_blank" rel="noreferrer">文件</a>。</li><li><code>by lazy {}</code> 屬性支援執行緒安全模式，但不處理無界遞迴。</li><li>逸出 <code>Worker.executeAfter</code> 中 <code>operation</code> 的例外會像在其他執行期部分一樣處理，透過嘗試執行使用者定義的未處理例外掛鉤，或者如果未找到該掛鉤或該掛鉤本身因例外而失敗，則終止程式。</li><li>凍結已棄用並始終禁用。</li></ul><p>請遵循以下指南將您的專案從舊版記憶體管理器遷移：</p><h2 id="更新-kotlin" tabindex="-1">更新 Kotlin <a class="header-anchor" href="#更新-kotlin" aria-label="Permalink to &quot;更新 Kotlin&quot;">​</a></h2><p>新的 Kotlin/Native 記憶體管理器自 Kotlin 1.7.20 起已預設啟用。請檢查 Kotlin 版本並在需要時<a href="/zh-Hant/kotlin/releases#update-to-a-new-kotlin-version">更新到最新版本</a>。</p><h2 id="更新依賴項" tabindex="-1">更新依賴項 <a class="header-anchor" href="#更新依賴項" aria-label="Permalink to &quot;更新依賴項&quot;">​</a></h2>',11)),a(s,{style:{}},{default:r(()=>[a(n,{title:"kotlinx.coroutines"},{default:r(()=>[t[1]||(t[1]=e("p",null,[l("更新到 1.6.0 或更高版本。請勿使用帶有 "),e("code",null,"native-mt"),l(" 尾碼的版本。")],-1)),t[2]||(t[2]=e("p",null,"關於新的記憶體管理器，您還應該記住一些具體注意事項：",-1)),a(d,null,{default:r(()=>t[0]||(t[0]=[e("li",null,"每個常見的原生類型（通道、流、協程）都能跨越 Worker 邊界工作，因為不再需要凍結。",-1),e("li",null,[e("code",null,"Dispatchers.Default"),l(" 在 Linux 和 Windows 上由 Worker 池支援，在 Apple 目標上由全域佇列支援。")],-1),e("li",null,[l("使用 "),e("code",null,"newSingleThreadContext"),l(" 建立一個由 Worker 支援的協程分發器。")],-1),e("li",null,[l("使用 "),e("code",null,"newFixedThreadPoolContext"),l(" 建立一個由一個包含 N 個 Worker 的池支援的協程分發器。")],-1),e("li",null,[e("code",null,"Dispatchers.Main"),l(" 在 Darwin 上由主佇列支援，在其他平台則由獨立的 Worker 支援。")],-1)])),_:1})]),_:1}),a(n,{title:"Ktor"},{default:r(()=>t[3]||(t[3]=[l(" 更新到 2.0 或更高版本。 ")])),_:1}),a(n,{title:"其他依賴項"},{default:r(()=>t[4]||(t[4]=[e("p",null,"大多數函式庫應該無需任何更改即可運作，但是，可能會有例外情況。",-1),e("p",null,"請確保您將依賴項更新到最新版本，並且舊版與新記憶體管理器的函式庫版本之間沒有差異。",-1)])),_:1})]),_:1}),t[6]||(t[6]=i('<h2 id="更新您的程式碼" tabindex="-1">更新您的程式碼 <a class="header-anchor" href="#更新您的程式碼" aria-label="Permalink to &quot;更新您的程式碼&quot;">​</a></h2><p>為了支援新的記憶體管理器，請移除受影響 API 的使用：</p><table tabindex="0"><thead><tr><th style="text-align:left;">舊版 API</th><th style="text-align:left;">應採取的動作</th></tr></thead><tbody><tr><td style="text-align:left;"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-shared-immutable/" target="_blank" rel="noreferrer"><code>@SharedImmutable</code></a></td><td style="text-align:left;">您可以移除所有用法，儘管在新記憶體管理器中沒有使用此 API 的警告。</td></tr><tr><td style="text-align:left;"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-freezable-atomic-reference/" target="_blank" rel="noreferrer"><code>FreezableAtomicReference</code> 類別</a></td><td style="text-align:left;">改用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-atomic-reference/" target="_blank" rel="noreferrer"><code>AtomicReference</code></a>。</td></tr><tr><td style="text-align:left;"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-freezing-exception/" target="_blank" rel="noreferrer"><code>FreezingException</code> 類別</a></td><td style="text-align:left;">移除所有用法。</td></tr><tr><td style="text-align:left;"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-invalid-mutability-exception/" target="_blank" rel="noreferrer"><code>InvalidMutabilityException</code> 類別</a></td><td style="text-align:left;">移除所有用法。</td></tr><tr><td style="text-align:left;"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native/-incorrect-dereference-exception/" target="_blank" rel="noreferrer"><code>IncorrectDereferenceException</code> 類別</a></td><td style="text-align:left;">移除所有用法。</td></tr><tr><td style="text-align:left;"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/freeze.html" target="_blank" rel="noreferrer"><code>freeze()</code> 函式</a></td><td style="text-align:left;">移除所有用法。</td></tr><tr><td style="text-align:left;"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/is-frozen.html" target="_blank" rel="noreferrer"><code>isFrozen</code> 屬性</a></td><td style="text-align:left;">您可以移除所有用法。由於凍結已棄用，此屬性總是回傳 <code>false</code>。</td></tr><tr><td style="text-align:left;"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/ensure-never-frozen.html" target="_blank" rel="noreferrer"><code>ensureNeverFrozen()</code> 函式</a></td><td style="text-align:left;">移除所有用法。</td></tr><tr><td style="text-align:left;"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/atomic-lazy.html" target="_blank" rel="noreferrer"><code>atomicLazy()</code> 函式</a></td><td style="text-align:left;">改用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html" target="_blank" rel="noreferrer"><code>lazy()</code></a>。</td></tr><tr><td style="text-align:left;"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-mutable-data/" target="_blank" rel="noreferrer"><code>MutableData</code> 類別</a></td><td style="text-align:left;">改用任何常規集合。</td></tr><tr><td style="text-align:left;"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-worker-bound-reference/" target="_blank" rel="noreferrer"><code>WorkerBoundReference&lt;out T : Any&gt;</code> 類別</a></td><td style="text-align:left;">直接使用 <code>T</code>。</td></tr><tr><td style="text-align:left;"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-detached-object-graph/" target="_blank" rel="noreferrer"><code>DetachedObjectGraph&lt;T&gt;</code> 類別</a></td><td style="text-align:left;">直接使用 <code>T</code>。為了透過 C interop 傳遞值，請使用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlinx.cinterop/-stable-ref/" target="_blank" rel="noreferrer"><code>StableRef</code> 類別</a>。</td></tr></tbody></table><h2 id="接下來是什麼" tabindex="-1">接下來是什麼 <a class="header-anchor" href="#接下來是什麼" aria-label="Permalink to &quot;接下來是什麼&quot;">​</a></h2><ul><li><a href="/zh-Hant/kotlin/native-memory-manager">深入了解新的記憶體管理器</a></li><li><a href="/zh-Hant/kotlin/native-arc-integration">查看與 Swift/Objective-C ARC 整合的具體細節</a></li><li><a href="/zh-Hant/kotlin/native-faq#how-do-i-reference-objects-safely-from-different-coroutines">了解如何在不同的協程中安全地引用物件</a></li></ul>',5))])}const y=c(p,[["render",h]]);export{_ as __pageData,y as default};
