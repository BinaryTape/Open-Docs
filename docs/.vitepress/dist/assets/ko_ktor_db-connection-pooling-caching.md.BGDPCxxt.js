import{_ as l,C as o,c as p,o as r,j as e,G as t,ag as h,a as i,w as c}from"./chunks/framework.Bksy39di.js";const x=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ko/ktor/db-connection-pooling-caching.md","filePath":"ko/ktor/db-connection-pooling-caching.md","lastUpdated":1755457140000}'),u={name:"ko/ktor/db-connection-pooling-caching.md"};function g(k,a,b,m,v,C){const s=o("show-structure"),n=o("tldr"),d=o("link-summary");return r(),p("div",null,[a[2]||(a[2]=e("h1",{id:"커넥션-풀링-및-캐싱",tabindex:"-1"},[i("커넥션 풀링 및 캐싱 "),e("a",{class:"header-anchor",href:"#커넥션-풀링-및-캐싱","aria-label":'Permalink to "커넥션 풀링 및 캐싱"'},"​")],-1)),t(s,{for:"chapter",depth:"2"}),t(n,null,{default:c(()=>a[0]||(a[0]=[e("p",null,[e("b",null,"코드 예시"),i(": "),e("a",{href:"https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/tutorial-website-interactive-persistence-advanced"}," tutorial-website-interactive-persistence-advanced ")],-1),e("p",null,[e("b",null,"사용된 라이브러리"),i(": "),e("a",{href:"https://github.com/brettwooldridge/HikariCP"},"HikariCP"),i(", "),e("a",{href:"https://www.ehcache.org/"},"Ehcache")],-1)])),_:1}),t(d,null,{default:c(()=>a[1]||(a[1]=[i("데이터베이스 커넥션 풀링 및 캐싱을 구현하는 방법을 알아보세요.")])),_:1}),a[3]||(a[3]=h(`<p><a href="./db-persistence">이전 튜토리얼</a>에서는 Exposed 프레임워크를 사용하여 웹사이트에 퍼시스턴스를 추가했습니다. 이 튜토리얼에서는 HikariCP 및 Ehcache 라이브러리를 각각 사용하여 데이터베이스 커넥션 풀링 및 캐싱을 구현하는 방법을 살펴보겠습니다.</p><h2 id="add-dependencies" tabindex="-1">의존성 추가 <a class="header-anchor" href="#add-dependencies" aria-label="Permalink to &quot;의존성 추가 {id=&quot;add-dependencies&quot;}&quot;">​</a></h2><p>먼저, HikariCP 및 Ehcache 라이브러리에 대한 의존성을 추가해야 합니다. <code>gradle.properties</code> 파일을 열고 라이브러리 버전을 지정합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ehcache_version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">logback_version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span></span></code></pre></div><p>그런 다음 <code>build.gradle.kts</code>를 열고 다음 의존성을 추가합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p><code>build.gradle.kts</code> 파일의 오른쪽 상단 모서리에 있는 <strong>Load Gradle Changes</strong> 아이콘을 클릭하여 새로 추가된 의존성을 설치합니다.</p><h2 id="connection-pooling" tabindex="-1">커넥션 풀링 <a class="header-anchor" href="#connection-pooling" aria-label="Permalink to &quot;커넥션 풀링 {id=&quot;connection-pooling&quot;}&quot;">​</a></h2><p>Exposed는 <code>transaction</code> 호출 범위 내에서 데이터베이스에 대한 첫 번째 조작을 수행할 때 각 <code>transaction</code> 호출 내에서 새로운 JDBC 커넥션을 시작합니다. 하지만 여러 JDBC 커넥션을 설정하는 것은 리소스 소모가 큽니다. 기존 커넥션을 재사용하면 성능 향상에 도움이 될 수 있습니다. <em>커넥션 풀링</em> 메커니즘이 이 문제를 해결합니다.</p><p>이 섹션에서는 HikariCP 프레임워크를 사용하여 애플리케이션에서 JDBC 커넥션 풀링을 관리합니다.</p><h3 id="connection-settings-config" tabindex="-1">커넥션 설정 구성 파일로 추출 <a class="header-anchor" href="#connection-settings-config" aria-label="Permalink to &quot;커넥션 설정 구성 파일로 추출 {id=&quot;connection-settings-config&quot;}&quot;">​</a></h3><p><a href="./db-persistence#connect_db">이전 튜토리얼</a>에서 데이터베이스 커넥션을 설정하기 위해 <code>com/example/dao/DatabaseSingleton.kt</code> 파일에 하드코딩된 <code>driverClassName</code> 및 <code>jdbcURL</code>을 사용했습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>데이터베이스 커넥션 설정을 <a href="./server-configuration-file">사용자 정의 구성 그룹</a>으로 추출해 봅시다.</p><ol><li><p><code>src/main/resources/application.conf</code> 파일을 열고 <code>ktor</code> 그룹 외부에 <code>storage</code> 그룹을 다음과 같이 추가합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div></li><li><p><code>com/example/dao/DatabaseSingleton.kt</code>를 열고 <code>init</code> 함수를 업데이트하여 구성 파일에서 스토리지 설정을 로드합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p><code>init</code> 함수는 이제 <code>ApplicationConfig</code>를 받아들이고 <code>config.property</code>를 사용하여 사용자 정의 설정을 로드합니다.</p></li><li><p>마지막으로 <code>com/example/Application.kt</code>를 열고 <code>environment.config</code>를 <code>DatabaseSingleton.init</code>에 전달하여 애플리케이션 시작 시 커넥션 설정을 로드합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div></li></ol><h3 id="enable-connection-pooling" tabindex="-1">커넥션 풀링 활성화 <a class="header-anchor" href="#enable-connection-pooling" aria-label="Permalink to &quot;커넥션 풀링 활성화 {id=&quot;enable-connection-pooling&quot;}&quot;">​</a></h3><p>Exposed에서 커넥션 풀링을 활성화하려면 <code>Database.connect</code> 함수의 파라미터로 <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.sql/javax/sql/DataSource.html" target="_blank" rel="noreferrer">DataSource</a>를 제공해야 합니다. HikariCP는 <code>DataSource</code> 인터페이스를 구현하는 <code>HikariDataSource</code> 클래스를 제공합니다.</p><ol><li><p><code>HikariDataSource</code>를 생성하려면 <code>com/example/dao/DatabaseSingleton.kt</code>를 열고 <code>DatabaseSingleton</code> 객체에 <code>createHikariDataSource</code> 함수를 추가합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>다음은 데이터 소스 설정에 대한 몇 가지 참고 사항입니다:</p><ul><li><code>createHikariDataSource</code> 함수는 드라이버 클래스 이름과 데이터베이스 URL을 파라미터로 받습니다.</li><li><code>maximumPoolSize</code> 속성은 커넥션 풀이 도달할 수 있는 최대 크기를 지정합니다.</li><li><code>isAutoCommit</code> 및 <code>transactionIsolation</code>은 Exposed에서 사용하는 기본 설정과 동기화되도록 설정됩니다.</li></ul></li><li><p><code>HikariDataSource</code>를 사용하려면 <code>Database.connect</code> 함수에 전달합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>이제 <a href="./db-persistence#run_app">애플리케이션을 실행</a>하고 모든 것이 이전처럼 작동하는지 확인할 수 있습니다.</p></li></ol><h2 id="caching" tabindex="-1">캐싱 <a class="header-anchor" href="#caching" aria-label="Permalink to &quot;캐싱 {id=&quot;caching&quot;}&quot;">​</a></h2><p>데이터베이스에 데이터베이스 캐시를 보충할 수 있습니다. 캐싱은 자주 사용되는 데이터를 임시 메모리에 저장하여 데이터베이스의 작업 부하를 줄이고 자주 필요한 데이터를 읽는 시간을 단축하는 기술입니다.</p><p>이 튜토리얼에서는 Ehcache 라이브러리를 사용하여 파일에 캐시를 구성합니다.</p><h3 id="cache-file-path" tabindex="-1">구성 파일에 캐시 파일 경로 추가 <a class="header-anchor" href="#cache-file-path" aria-label="Permalink to &quot;구성 파일에 캐시 파일 경로 추가 {id=&quot;cache-file-path&quot;}&quot;">​</a></h3><p><code>src/main/resources/application.conf</code> 파일을 열고 <code>ehcacheFilePath</code> 속성을 <code>storage</code> 그룹에 추가합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>이 속성은 캐시 데이터를 저장하는 데 사용되는 파일의 경로를 지정합니다. 나중에 캐시 작업을 위한 <code>DAOFacade</code> 구현을 구성하는 데 사용합니다.</p><h3 id="implement-caching" tabindex="-1">캐싱 구현 <a class="header-anchor" href="#implement-caching" aria-label="Permalink to &quot;캐싱 구현 {id=&quot;implement-caching&quot;}&quot;">​</a></h3><p>캐싱을 구현하려면 캐시에서 값을 반환하고 캐시된 값이 없을 경우 데이터베이스 인터페이스로 위임하는 또 다른 <code>DAOFacade</code> 구현을 제공해야 합니다.</p><ol><li><p><code>com.example.dao</code> 패키지에 새 <code>DAOFacadeCacheImpl.kt</code> 파일을 생성하고 다음 구현을 추가합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>다음은 이 코드 샘플에 대한 간략한 개요입니다:</p><ul><li>캐시를 초기화하고 구성하기 위해 Ehcache <code>CacheManager</code> 인스턴스를 정의합니다. <code>storagePath</code>를 디스크 저장소에 사용될 루트 디렉토리로 제공합니다.</li><li>ID별로 아티클을 저장하는 항목에 대한 캐시를 생성합니다. <code>articlesCache</code>는 <code>Int</code> 키를 <code>Article</code> 값에 매핑합니다.</li><li>그런 다음 로컬 메모리 및 디스크 리소스에 대한 크기 제약 조건을 제공합니다. 이러한 파라미터에 대한 자세한 내용은 <a href="https://www.ehcache.org/documentation/2.8/configuration/cache-size.html" target="_blank" rel="noreferrer">Ehcache 문서</a>에서 확인할 수 있습니다.</li><li>마지막으로, 제공된 이름, 키 및 값 유형으로 <code>cacheManager.getCache()</code>를 호출하여 생성된 캐시를 얻습니다.</li></ul></li><li><p>캐시에서 사용하려면 <code>Article</code> 클래스는 직렬화 가능해야 하며 <code>java.io.Serializable</code>을 구현해야 합니다. <code>com/example/models/Article.kt</code>를 열고 코드를 다음과 같이 업데이트합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div></li><li><p>이제 <code>DAOFacade</code>의 멤버를 구현할 준비가 되었습니다. <code>DAOFacadeCacheImpl.kt</code>로 돌아가서 다음 메서드를 추가합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><ul><li><code>allArticles</code>: 모든 아티클을 캐시하려고 시도하지 않습니다. 이는 주 데이터베이스에 위임합니다.</li><li><code>article</code>: 아티클을 가져올 때 먼저 캐시에 있는지 확인하고, 없는 경우에만 주 <code>DAOFacade</code>에 위임하고 이 아티클을 캐시에 추가합니다.</li><li><code>addNewArticle</code>: 새 아티클을 추가할 때 주 <code>DAOFacade</code>에 위임하지만, 이 아티클을 캐시에도 추가합니다.</li><li><code>editArticle</code>: 기존 아티클을 편집할 때 캐시와 데이터베이스를 모두 업데이트합니다.</li><li><code>deleteArticle</code>: 삭제 시 캐시와 주 데이터베이스 모두에서 아티클을 삭제해야 합니다.</li></ul></li></ol><h3 id="init-dao-facade" tabindex="-1">DAOFacadeCacheImpl 초기화 <a class="header-anchor" href="#init-dao-facade" aria-label="Permalink to &quot;DAOFacadeCacheImpl 초기화 {id=&quot;init-dao-facade&quot;}&quot;">​</a></h3><p><code>DAOFacadeCacheImpl</code> 인스턴스를 생성하고 애플리케이션이 시작되기 전에 데이터베이스에 삽입될 샘플 아티클을 추가해 봅시다:</p><ol><li><p>먼저 <code>DAOFacadeImpl.kt</code> 파일을 열고 파일 하단의 <code>dao</code> 변수 초기화를 제거합니다.</p></li><li><p>그런 다음 <code>com/example/plugins/Routing.kt</code>를 열고 <code>configureRouting</code> 블록 내에서 <code>dao</code> 변수를 초기화합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>이제 끝입니다. 이제 <a href="./db-persistence#run_app">애플리케이션을 실행</a>하고 모든 것이 이전처럼 작동하는지 확인할 수 있습니다.</p></li></ol><blockquote><p>커넥션 풀링 및 캐싱을 포함한 전체 예시는 여기에서 찾을 수 있습니다: <a href="https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/tutorial-website-interactive-persistence-advanced" target="_blank" rel="noreferrer">tutorial-website-interactive-persistence-advanced</a>.</p></blockquote>`,32))])}const y=l(u,[["render",g]]);export{x as __pageData,y as default};
