import{_ as p,a as e,b as d,c as u,d as s,e as m,f,g as S,h as O,i as b}from"./chunks/remote-artifact-distribution.DrML6DzP.js";import{_ as K,C as h,c as k,o as M,ag as n,j as l,G as o,w as r,a}from"./chunks/framework.Bksy39di.js";const V=JSON.parse('{"title":"Kotlin Multiplatform 프로젝트 구성 선택하기","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kmp/multiplatform-project-configuration.md","filePath":"ko/kmp/multiplatform-project-configuration.md","lastUpdated":1755516278000}'),g={name:"ko/kmp/multiplatform-project-configuration.md"};function P(A,t,T,_,w,C){const i=h("list");return M(),k("div",null,[t[15]||(t[15]=n("",17)),l("table",null,[t[2]||(t[2]=l("tr",null,[l("th",null,"장점"),l("th",null,"단점")],-1)),l("tr",null,[l("td",null,[o(i,null,{default:r(()=>t[0]||(t[0]=[l("li",null,"단일 모듈로 구성된 간단한 디자인은 인지 부하를 줄여줍니다. 기능을 어디에 배치하거나 논리적으로 어떻게 분할할지 고민할 필요가 없습니다.",-1),l("li",null,"시작점으로 훌륭하게 작동합니다.",-1)])),_:1})]),l("td",null,[o(i,null,{default:r(()=>t[1]||(t[1]=[l("li",null,"공유 모듈이 커질수록 컴파일 시간이 증가합니다.",-1),l("li",null,"이 디자인은 기능을 분리하거나 앱에 필요한 기능에만 종속성을 갖는 것을 허용하지 않습니다.",-1)])),_:1})])])]),t[16]||(t[16]=l("h3",{id:"여러-공유-모듈",tabindex:"-1"},[a("여러 공유 모듈 "),l("a",{class:"header-anchor",href:"#여러-공유-모듈","aria-label":'Permalink to "여러 공유 모듈"'},"​")],-1)),t[17]||(t[17]=l("p",null,"공유 모듈이 커짐에 따라 이를 기능 모듈로 분할하는 것이 좋습니다. 이는 단일 모듈을 가질 때 발생할 수 있는 확장성 문제를 피하는 데 도움이 됩니다.",-1)),t[18]||(t[18]=l("p",null,"Android 앱은 모든 기능 모듈에 직접 종속될 수 있으며, 필요한 경우 일부에만 종속될 수 있습니다.",-1)),t[19]||(t[19]=l("p",null,"iOS 앱은 Kotlin Multiplatform 모듈이 생성한 하나의 프레임워크에 종속될 수 있습니다. 여러 모듈을 사용하는 경우, 사용하는 모든 모듈에 종속되는 추가 모듈인 _엄브렐러 모듈(umbrella module)_을 추가해야 하며, 그 다음 모든 모듈을 포함하는 프레임워크인 _엄브렐러 프레임워크(umbrella framework)_를 구성해야 합니다.",-1)),t[20]||(t[20]=l("div",{class:"tip custom-block"},[l("p",{class:"custom-block-title"},"TIP"),l("p",null,"엄브렐러 프레임워크 번들은 프로젝트의 모든 공유 모듈을 포함하며 iOS 앱으로 가져와집니다.")],-1)),l("table",null,[t[5]||(t[5]=l("tr",null,[l("th",null,"장점"),l("th",null,"단점")],-1)),l("tr",null,[l("td",null,[o(i,null,{default:r(()=>t[3]||(t[3]=[l("li",null,"공유 코드의 관심사 분리(Separation of concerns).",-1),l("li",null,"더 나은 확장성.",-1)])),_:1})]),l("td",null,[o(i,null,{default:r(()=>t[4]||(t[4]=[l("li",null,"엄브렐러 프레임워크 설정을 포함하여 더 복잡한 설정.",-1),l("li",null,"모듈 간의 더 복잡한 종속성 관리.",-1)])),_:1})])])]),t[21]||(t[21]=n("",6)),t[22]||(t[22]=l("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"엄브렐러-프레임워크가-필요한-이유는-무엇인가요",tabindex:"-1"},[a("엄브렐러 프레임워크가 필요한 이유는 무엇인가요? "),l("a",{class:"header-anchor",href:"#엄브렐러-프레임워크가-필요한-이유는-무엇인가요","aria-label":'Permalink to "엄브렐러 프레임워크가 필요한 이유는 무엇인가요? {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),t[23]||(t[23]=n("",12)),l("table",null,[t[8]||(t[8]=l("tr",null,[l("th",null,"장점"),l("th",null,"단점")],-1)),l("tr",null,[l("td",null,[o(i,null,{default:r(()=>t[6]||(t[6]=[l("li",null,"위저드를 통해 쉽게 설정할 수 있습니다.",-1),l("li",null,"모든 코드가 동일한 저장소에 있으므로 iOS 개발자는 Kotlin Multiplatform 코드로 쉽게 작업할 수 있습니다.",-1)])),_:1})]),l("td",null,[o(i,null,{default:r(()=>t[7]||(t[7]=[l("li",null,"iOS 개발자는 익숙하지 않은 도구를 설정하고 구성해야 합니다.",-1),l("li",null,"이 접근 방식은 이미 다른 저장소에 저장된 기존 앱에는 종종 작동하지 않습니다.",-1)])),_:1})])])]),t[24]||(t[24]=n("",25)),l("table",null,[t[11]||(t[11]=l("tr",null,[l("th",null,"장점"),l("th",null,"단점")],-1)),l("tr",null,[l("td",null,[o(i,null,{default:r(()=>t[9]||(t[9]=[l("li",null,"Android 및 iOS 팀 구성원 모두 Kotlin Multiplatform 코드를 쉽게 편집할 수 있으므로, 공유 코드의 생성 및 유지보수가 공동의 책임이 됩니다. 이는 팀 간의 고립을 방지하고 협업을 장려합니다.",-1),l("li",null,"이 접근 방식은 공유 코드의 별도 버전 관리 및 게시를 요구하지 않습니다.",-1),l("li",null,"iOS 팀 구성원이 아티팩트가 생성되고 게시될 때까지 기다릴 필요가 없으므로 개발 워크플로가 더 빠릅니다.",-1)])),_:1})]),l("td",null,[o(i,null,{default:r(()=>t[10]||(t[10]=[l("li",null,"팀 구성원은 자신의 머신에 완전한 개발 환경을 설정해야 합니다.",-1),l("li",null,"iOS 개발자는 Android Studio와 Gradle 사용법을 배워야 합니다.",-1),l("li",null,"더 많은 코드가 공유되고 팀이 커짐에 따라 변경 사항 관리가 어려워집니다.",-1)])),_:1})])])]),t[25]||(t[25]=l("h3",{id:"원격-아티팩트-배포",tabindex:"-1"},[a("원격: 아티팩트 배포 "),l("a",{class:"header-anchor",href:"#원격-아티팩트-배포","aria-label":'Permalink to "원격: 아티팩트 배포"'},"​")],-1)),t[26]||(t[26]=l("p",null,"원격 배포는 프레임워크 아티팩트가 CocoaPod 또는 SPM을 사용하는 Swift 패키지로 게시되어 iOS 앱에서 사용되는 것을 의미합니다. Android 앱은 바이너리 종속성을 로컬 또는 원격으로 사용할 수 있습니다.",-1)),t[27]||(t[27]=l("p",null,"원격 배포는 기존 프로젝트에 기술을 점진적으로 도입하는 데 자주 사용됩니다. 이는 iOS 개발자를 위한 워크플로 및 빌드 프로세스를 크게 변경하지 않습니다. 두 개 이상의 저장소를 가진 팀은 주로 원격 배포를 사용하여 프로젝트 코드를 저장합니다.",-1)),t[28]||(t[28]=l("p",null,[a("시작점으로, 원격 배포 워크플로를 크게 단순화하는 빌드 도구 모음인 "),l("a",{href:"https://touchlab.co/trykmmbridge",target:"_blank",rel:"noreferrer"},"KMMBridge"),a("를 사용하는 것을 고려할 수 있습니다. 또는 언제든지 유사한 워크플로를 직접 설정할 수도 있습니다:")],-1)),t[29]||(t[29]=l("p",null,[l("img",{src:p,alt:"원격 아티팩트 배포",width:"700"})],-1)),l("table",null,[t[14]||(t[14]=l("tr",null,[l("th",null,"장점"),l("th",null,"단점")],-1)),l("tr",null,[t[13]||(t[13]=l("td",null,"프로젝트에 참여하지 않는 iOS 팀 구성원은 Kotlin 코드를 작성하거나 Android Studio 및 Gradle과 같은 도구 사용법을 배울 필요가 없습니다. 이는 팀의 진입 장벽을 크게 낮춥니다.",-1)),l("td",null,[o(i,null,{default:r(()=>t[12]||(t[12]=[l("li",null,"공유 코드 편집 및 빌드 프로세스에 게시 및 버전 관리가 포함되므로 iOS 개발자의 워크플로가 더 느립니다.",-1),l("li",null,"iOS에서 공유 Kotlin 코드 디버깅이 어렵습니다.",-1),l("li",null,"iOS 팀 구성원이 공유 코드에 기여할 가능성이 크게 줄어듭니다.",-1),l("li",null,"공유 코드의 유지보수는 전적으로 참여 팀 구성원에게 달려 있습니다.",-1)])),_:1})])])]),t[30]||(t[30]=l("h4",{id:"로컬-개발을-위한-로컬-종속성-설정",tabindex:"-1"},[a("로컬 개발을 위한 로컬 종속성 설정 "),l("a",{class:"header-anchor",href:"#로컬-개발을-위한-로컬-종속성-설정","aria-label":'Permalink to "로컬 개발을 위한 로컬 종속성 설정"'},"​")],-1)),t[31]||(t[31]=l("p",null,"많은 팀이 Kotlin Multiplatform 기술을 채택할 때 iOS 개발자를 위한 개발 프로세스를 동일하게 유지하기 위해 원격 배포 워크플로를 선택합니다. 그러나 이 워크플로에서는 Kotlin Multiplatform 코드를 변경하기 어렵습니다.",-1)),t[32]||(t[32]=l("p",null,'Kotlin Multiplatform 모듈에서 생성된 프레임워크에 대한 로컬 종속성을 사용하여 추가 "로컬 개발" 워크플로를 설정하는 것을 권장합니다.',-1)),t[33]||(t[33]=l("p",null,"개발자가 새로운 기능을 추가할 때, Kotlin Multiplatform 모듈을 로컬 종속성으로 사용하는 방식으로 전환합니다. 이를 통해 공통 Kotlin 코드를 변경하고, iOS에서 동작을 즉시 확인하며, Kotlin 코드를 디버깅할 수 있습니다. 기능이 준비되면 원격 종속성으로 다시 전환하고 그에 따라 변경 사항을 게시할 수 있습니다. 먼저 공유 모듈에 대한 변경 사항을 게시한 후에야 앱에 변경 사항을 적용합니다.",-1)),t[34]||(t[34]=l("p",null,"원격 배포 워크플로의 경우 CocoaPods 통합 또는 SPM을 사용합니다. 로컬 배포 워크플로의 경우 프레임워크를 직접 통합합니다.",-1)),t[35]||(t[35]=l("p",null,[a("CocoaPods를 사용하는 경우, 로컬 배포 워크플로에 CocoaPods를 사용할 수도 있습니다. "),l("a",{href:"https://touchlab.co/kmmbridgecocoapodslocal",target:"_blank",rel:"noreferrer"},"TouchLab 문서"),a("에 설명된 대로 환경 변수를 변경하여 전환할 수 있습니다.")],-1))])}const v=K(g,[["render",P]]);export{V as __pageData,v as default};
