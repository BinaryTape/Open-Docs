import{_ as s,c as a,o as e,ag as t}from"./chunks/framework.Bksy39di.js";const r=JSON.parse('{"title":"동적 타입","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/dynamic-type.md","filePath":"ko/kotlin/dynamic-type.md","lastUpdated":1754307826000}'),d={name:"ko/kotlin/dynamic-type.md"};function n(l,i,o,p,c,h){return e(),a("div",null,i[0]||(i[0]=[t(`<h1 id="동적-타입" tabindex="-1">동적 타입 <a class="header-anchor" href="#동적-타입" aria-label="Permalink to &quot;동적 타입&quot;">​</a></h1><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>동적 타입은 JVM을 대상으로 하는 코드에서 지원되지 않습니다.</p></div><p>정적 타입 언어임에도 불구하고, Kotlin은 JavaScript 생태계와 같이 타입이 없거나 느슨하게 타입이 지정된 환경과 상호 운용해야 합니다. 이러한 사용 사례를 용이하게 하기 위해 언어에서 <code>dynamic</code> 타입이 제공됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dyn: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dynamic</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span></code></pre></div><p><code>dynamic</code> 타입은 기본적으로 Kotlin의 타입 검사기를 비활성화합니다:</p><ul><li><code>dynamic</code> 타입 값은 모든 변수에 할당되거나 어디든지 매개변수로 전달될 수 있습니다.</li><li>어떤 값이든 <code>dynamic</code> 타입 변수에 할당되거나 <code>dynamic</code>을 매개변수로 받는 함수에 전달될 수 있습니다.</li><li><code>dynamic</code> 타입 값에 대한 <code>null</code> 검사는 비활성화됩니다.</li></ul><p><code>dynamic</code>의 가장 독특한 특징은 <code>dynamic</code> 변수에서 <strong>어떤</strong> 프로퍼티나 함수라도 어떤 매개변수와 함께 호출할 수 있다는 점입니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dyn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">whatever</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dyn) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &#39;whatever&#39;는 어디에도 정의되어 있지 않습니다</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dyn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">whatever</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">arrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p>JavaScript 플랫폼에서는 이 코드가 &quot;그대로&quot; 컴파일됩니다: Kotlin의 <code>dyn.whatever(1)</code>은 생성된 JavaScript 코드에서 <code>dyn.whatever(1)</code>이 됩니다.</p><p><code>dynamic</code> 타입 값에서 Kotlin으로 작성된 함수를 호출할 때, Kotlin-JavaScript 컴파일러에 의해 수행되는 이름 맹글링(name mangling)을 염두에 두세요. 호출해야 하는 함수에 잘 정의된 이름을 할당하기 위해 <a href="/ko/kotlin/js-to-kotlin-interop#jsname-annotation">@JsName 어노테이션</a>을 사용해야 할 수도 있습니다.</p><p>동적 호출은 항상 결과로 <code>dynamic</code>을 반환하므로, 이러한 호출을 자유롭게 연결할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dyn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().bar.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">baz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>동적 호출에 람다를 전달할 때, 모든 매개변수는 기본적으로 <code>dynamic</code> 타입을 가집니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dyn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// x는 dynamic입니다</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>dynamic</code> 타입 값을 사용하는 표현식은 JavaScript로 &quot;그대로&quot; 변환되며, Kotlin 연산자 규칙을 사용하지 않습니다. 다음 연산자들이 지원됩니다:</p><ul><li>이항: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&gt;</code>, <code>&lt;</code> <code>&gt;=</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code>, <code>&amp;&amp;</code>, <code>||</code></li><li>단항 <ul><li>전위: <code>-</code>, <code>+</code>, <code>!</code></li><li>전위 및 후위: <code>++</code>, <code>--</code></li></ul></li><li>대입: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code></li><li>인덱스 접근: <ul><li>읽기: <code>d[a]</code>, 두 개 이상의 인수는 오류입니다</li><li>쓰기: <code>d[a1] = a2</code>, <code>[]</code> 안에 두 개 이상의 인수는 오류입니다</li></ul></li></ul><p><code>in</code>, <code>!in</code>, <code>..</code> 연산은 <code>dynamic</code> 타입 값과 함께 금지됩니다.</p><p>더 자세한 기술적 설명은 <a href="https://github.com/JetBrains/kotlin/blob/master/spec-docs/dynamic-types.md" target="_blank" rel="noreferrer">명세 문서</a>를 참조하세요.</p>`,18)]))}const E=s(d,[["render",n]]);export{r as __pageData,E as default};
