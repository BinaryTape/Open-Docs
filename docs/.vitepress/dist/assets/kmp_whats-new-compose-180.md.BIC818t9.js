import{_ as n}from"./chunks/compose-180-LineHeightStyle.DsnceP5I.js";import{_ as o,C as r,c as p,o as h,ag as e,G as t,j as i,a as l}from"./chunks/framework.Bksy39di.js";const b=JSON.parse('{"title":"Compose Multiplatform 1.8.2 新特性","description":"","frontmatter":{},"headers":[],"relativePath":"kmp/whats-new-compose-180.md","filePath":"kmp/whats-new-compose-180.md","lastUpdated":1755516278000}'),d={name:"kmp/whats-new-compose-180.md"};function k(c,a,g,E,m,u){const s=r("secondary-label");return h(),p("div",null,[a[0]||(a[0]=e(`<h1 id="compose-multiplatform-1-8-2-新特性" tabindex="-1">Compose Multiplatform 1.8.2 新特性 <a class="header-anchor" href="#compose-multiplatform-1-8-2-新特性" aria-label="Permalink to &quot;Compose Multiplatform 1.8.2 新特性&quot;">​</a></h1><p>此特性版本的主要亮点如下：</p><ul><li><a href="#variable-fonts">可变字体</a></li><li><a href="#drag-and-drop">iOS 上的拖放</a></li><li><a href="#deep-linking">iOS 上的深度链接</a></li><li><a href="#accessibility-support-improvements">iOS 上的辅助功能改进</a></li><li><a href="#preloading-of-resources">Web 目标平台的资源预加载</a></li><li><a href="#browser-controls-supported-in-the-navigation-library">与浏览器导航控件的集成</a></li></ul><p>查看此版本的完整更改列表，请<a href="https://github.com/JetBrains/compose-multiplatform/releases/tag/v1.8.0" target="_blank" rel="noreferrer">访问 GitHub</a>。</p><h2 id="dependencies" tabindex="-1">Dependencies <a class="header-anchor" href="#dependencies" aria-label="Permalink to &quot;Dependencies&quot;">​</a></h2><ul><li>Gradle 插件 <code>org.jetbrains.compose</code>，版本 1.8.2。基于 Jetpack Compose 库： <ul><li><a href="https://developer.android.com/jetpack/androidx/releases/compose-runtime#1.8.2" target="_blank" rel="noreferrer">Runtime 1.8.2</a></li><li><a href="https://developer.android.com/jetpack/androidx/releases/compose-ui#1.8.2" target="_blank" rel="noreferrer">UI 1.8.2</a></li><li><a href="https://developer.android.com/jetpack/androidx/releases/compose-foundation#1.8.2" target="_blank" rel="noreferrer">Foundation 1.8.2</a></li><li><a href="https://developer.android.com/jetpack/androidx/releases/compose-material#1.8.2" target="_blank" rel="noreferrer">Material 1.8.2</a></li><li><a href="https://developer.android.com/jetpack/androidx/releases/compose-material3#1.3.2" target="_blank" rel="noreferrer">Material3 1.3.2</a></li></ul></li><li>Lifecycle 库 <code>org.jetbrains.androidx.lifecycle:lifecycle-*:2.9.0</code>。基于 <a href="https://developer.android.com/jetpack/androidx/releases/lifecycle#2.9.0" target="_blank" rel="noreferrer">Jetpack Lifecycle 2.9.0</a></li><li>Navigation 库 <code>org.jetbrains.androidx.navigation:navigation-*:2.9.0-beta03</code>。基于 <a href="https://developer.android.com/jetpack/androidx/releases/navigation#2.9.0" target="_blank" rel="noreferrer">Jetpack Navigation 2.9.0</a></li><li>Material3 Adaptive 库 <code>org.jetbrains.compose.material3.adaptive:adaptive*:1.2.0-alpha03</code>。基于 <a href="https://developer.android.com/jetpack/androidx/releases/compose-material3-adaptive#1.1.0" target="_blank" rel="noreferrer">Jetpack Material3 Adaptive 1.1.0</a></li><li>Savedstate 库 <code>org.jetbrains.androidx.savedstate:savedstate:1.3.1</code>。基于 <a href="https://developer.android.com/jetpack/androidx/releases/savedstate#1.3.0" target="_blank" rel="noreferrer">Jetpack Savedstate 1.3.0</a></li><li>WindowManager Core 库 <code>org.jetbrains.androidx.window:window-core:1.4.0-alpha07</code>。基于 <a href="https://developer.android.com/jetpack/androidx/releases/window#1.4.0-alpha04" target="_blank" rel="noreferrer">Jetpack WindowManager 1.4.0-alpha04</a></li></ul><h2 id="重大变更" tabindex="-1">重大变更 <a class="header-anchor" href="#重大变更" aria-label="Permalink to &quot;重大变更&quot;">​</a></h2><h3 id="compose-multiplatform-完全迁移至-k2-编译器" tabindex="-1">Compose Multiplatform 完全迁移至 K2 编译器 <a class="header-anchor" href="#compose-multiplatform-完全迁移至-k2-编译器" aria-label="Permalink to &quot;Compose Multiplatform 完全迁移至 K2 编译器&quot;">​</a></h3><p>此版本中，Compose Multiplatform 代码库已完全迁移至 K2 编译器。 从 1.8.0 开始， 依赖 Compose Multiplatform 的项目所生成的 native 和 web klib 只能在 Kotlin 2.1.0 或更高版本中使用。</p><p>除了 Compose 编译器 Gradle 插件的底层更改之外，这对您的项目意味着：</p><ul><li>对于使用依赖 Compose Multiplatform 的库的应用程序： 建议您将项目更新到 Kotlin 2.1.20，并将依赖项更新到针对 Compose Multiplatform 1.8.0 和 Kotlin 2.1.x 编译的版本。</li><li>对于依赖 Compose Multiplatform 的库： 您需要将项目更新到 Kotlin 2.1.x 和 Compose 1.8.0， 然后重新编译库并发布新版本。</li></ul><p>如果您在升级到 Compose Multiplatform 1.8.0 时遇到任何兼容性问题，请通过在 <a href="https://youtrack.jetbrains.com/newIssue?project=CMP" target="_blank" rel="noreferrer">YouTrack</a> 中提交 issue 来告知我们。</p><h3 id="移除了对-material-icons-core-的隐式依赖项" tabindex="-1">移除了对 <code>material-icons-core</code> 的隐式依赖项 <a class="header-anchor" href="#移除了对-material-icons-core-的隐式依赖项" aria-label="Permalink to &quot;移除了对 \`material-icons-core\` 的隐式依赖项&quot;">​</a></h3><p>Compose Multiplatform 1.8.2 包含一项<a href="https://android.googlesource.com/platform/frameworks/support/+/1d1abef790da93325a83fe19b50ccdec06be6956" target="_blank" rel="noreferrer">在 Material 中进行的更改</a>：不再有对 <code>material-icons-core</code> 的传递性依赖项。 这与<a href="#full-migration-of-compose-multiplatform-to-the-k2-compiler">弃用使用 K1 构建的依赖项</a>的趋势保持一致。</p><p>如果您的项目需要继续使用 <code>material-icons-core</code> 库，请将此依赖项显式地添加到您的 <code>build.gradle.kts</code> 中，例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">implementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org.jetbrains.compose.material:material-icons-core:1.7.3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="navigation-中从-bundle-迁移到-savedstate" tabindex="-1">Navigation 中从 Bundle 迁移到 SavedState <a class="header-anchor" href="#navigation-中从-bundle-迁移到-savedstate" aria-label="Permalink to &quot;Navigation 中从 Bundle 迁移到 SavedState&quot;">​</a></h3><p>Compose Multiplatform 1.8.2 中的 Navigation，以及 Android Navigation 组件，正在过渡到使用 <code>SavedState</code> 类来存储 UI 状态。 这会打破在导航图中声明目标时访问状态数据的模式。 升级到 2.9.* 版本的 <a href="./compose-navigation-routing">Navigation 库</a>时，请务必更新相关代码以使用 <code>SavedState</code> 的访问器。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>为了实现更健壮的架构，请使用<a href="https://developer.android.com/guide/navigation/design/type-safety" target="_blank" rel="noreferrer">类型安全的导航方法</a>，避免使用字符串路由。</p></div><p>之前：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">composable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Destinations.Followers.route) { navBackStackEntry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navBackStackEntry.arguments?.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;userid&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> page </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navBackStackEntry.arguments?.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;page&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (uId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> page </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        FollowersMainComposable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(navController, accountId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uId, page </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> page)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>从 Compose Multiplatform 1.8.2 开始：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">composable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Destinations.Followers.route) { navBackStackEntry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navBackStackEntry.arguments?.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getStringOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;userid&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> page </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navBackStackEntry.arguments?.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getStringOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;page&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (uId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> page </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        FollowersMainComposable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(navController, accountId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uId, page </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> page)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="ios-上已废弃-composeuiviewcontrollerdelegate" tabindex="-1">iOS 上已废弃 <code>ComposeUIViewControllerDelegate</code> <a class="header-anchor" href="#ios-上已废弃-composeuiviewcontrollerdelegate" aria-label="Permalink to &quot;iOS 上已废弃 \`ComposeUIViewControllerDelegate\`&quot;">​</a></h3><p><code>ComposeUIViewControllerDelegate</code> API 已被废弃，转而推荐使用父视图控制器。 如果您在 Compose Multiplatform 1.8.2 中使用已废弃的 API，将遇到废弃错误，提示您应通过父视图控制器来覆盖 <code>UIViewController</code> 类方法。</p><p>关于子父视图控制器关系的更多信息，请查阅 Apple 的开发者<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller" target="_blank" rel="noreferrer">文档</a>。</p><h3 id="ios-上移除了过时的-platformlayers-选项" tabindex="-1">iOS 上移除了过时的 <code>platformLayers</code> 选项 <a class="header-anchor" href="#ios-上移除了过时的-platformlayers-选项" aria-label="Permalink to &quot;iOS 上移除了过时的 \`platformLayers\` 选项&quot;">​</a></h3><p><code>platformLayers</code> 实验性选项<a href="./whats-new-compose-160#separate-platform-views-for-popups-dialogs-and-dropdowns-ios-desktop">在 1.6.0 中引入</a>，旨在允许启用替代分层模式并在父容器边界之外绘制弹窗和对话框。</p><p>此模式现在是 iOS 上的默认行为，并且启用它的选项已因过时而被移除。</p><h3 id="测试中的重大变更" tabindex="-1">测试中的重大变更 <a class="header-anchor" href="#测试中的重大变更" aria-label="Permalink to &quot;测试中的重大变更&quot;">​</a></h3><h4 id="测试中协程延迟的新处理方式" tabindex="-1">测试中协程延迟的新处理方式 <a class="header-anchor" href="#测试中协程延迟的新处理方式" aria-label="Permalink to &quot;测试中协程延迟的新处理方式&quot;">​</a></h4><p>此前，Compose Multiplatform 测试不会将带有 <code>delay()</code> 调用的副作用视为空闲。 因此，例如，以下测试将无限期挂起：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loopInLaunchedEffectTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runComposeUiTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setContent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        LaunchedEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Unit) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Tick&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>当协程在组合作用域中启动后调用 <code>delay()</code> 函数时，<code>waitForIdle()</code>、<code>awaitIdle()</code> 和 <code>runOnIdle()</code> 函数现在会将 Compose 视为空闲。 此更改修复了上述挂起测试，但会破坏依赖 <code>waitForIdle()</code>、<code>awaitIdle()</code> 和 <code>runOnIdle()</code> 执行带有 <code>delay()</code> 的协程的测试。</p><p>为了在这些情况下产生相同的结果，请人工推进时间：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> updateText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mutableStateOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> text </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mutableStateOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setContent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    LaunchedEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(updateText) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (updateText) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            text </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;1&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">updateText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">waitForIdle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Since waitForIdle() no longer waits for the delayed LaunchedEffect() to complete,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// the test needs to advance time to make the following assertion correct:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mainClock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">advanceTimeBy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1001</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">assertEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, text)</span></span></code></pre></div><p>已经使用 <code>mainClock.advanceTimeBy()</code> 调用来推进测试时钟的测试，可能会在重新组合、布局、绘制和效果方面表现出不同。</p><h4 id="runonidle-的实现与-android-对齐" tabindex="-1"><code>runOnIdle()</code> 的实现与 Android 对齐 <a class="header-anchor" href="#runonidle-的实现与-android-对齐" aria-label="Permalink to &quot;\`runOnIdle()\` 的实现与 Android 对齐&quot;">​</a></h4><p>为了使 Compose Multiplatform 中 <code>runOnIdle()</code> 测试函数的实现与 Android 行为保持一致，我们引入了以下更改：</p><ul><li><code>runOnIdle()</code> 现在在其 UI 线程上执行其 <code>action</code>。</li><li><code>runOnIdle()</code> 在执行 <code>action</code> 后不再调用 <code>waitForIdle()</code>。</li></ul><p>如果您的测试依赖于 <code>runOnIdle()</code> <code>action</code> 之后的额外 <code>waitForIdle()</code> 调用，请在将测试更新到 Compose Multiplatform 1.8.2 时，根据需要将此调用添加到您的测试中。</p><h4 id="测试中推进时间与渲染解耦" tabindex="-1">测试中推进时间与渲染解耦 <a class="header-anchor" href="#测试中推进时间与渲染解耦" aria-label="Permalink to &quot;测试中推进时间与渲染解耦&quot;">​</a></h4><p>在 Compose Multiplatform 1.8.2 中，如果时间没有推进到下一个帧的渲染点之外（虚拟测试帧每 16 毫秒渲染一次），<code>mainClock.advanceTimeBy()</code> 函数将不再导致重新组合、布局或绘制。</p><p>这可能会破坏依赖于每个 <code>mainClock.advanceTimeBy()</code> 调用触发渲染的测试。 关于详细信息，请参见 <a href="https://github.com/JetBrains/compose-multiplatform-core/pull/1618" target="_blank" rel="noreferrer">PR 描述</a>。</p><h2 id="跨平台" tabindex="-1">跨平台 <a class="header-anchor" href="#跨平台" aria-label="Permalink to &quot;跨平台&quot;">​</a></h2><h3 id="可变字体" tabindex="-1">可变字体 <a class="header-anchor" href="#可变字体" aria-label="Permalink to &quot;可变字体&quot;">​</a></h3><p>Compose Multiplatform 1.8.2 支持所有平台上的可变字体。 使用可变字体，您可以保留一个字体文件，其中包含所有样式偏好设置，例如字重、宽度、倾斜、斜体、自定义轴、带有排版颜色的视觉字重，以及对特定文本大小的调整。</p><p>关于详细信息，请参见 <a href="https://developer.android.com/develop/ui/compose/text/fonts#variable-fonts" target="_blank" rel="noreferrer">Jetpack Compose 文档</a>。</p><h3 id="skia-更新至里程碑-132" tabindex="-1">Skia 更新至里程碑 132 <a class="header-anchor" href="#skia-更新至里程碑-132" aria-label="Permalink to &quot;Skia 更新至里程碑 132&quot;">​</a></h3><p>Compose Multiplatform 通过 Skiko 使用的 Skia 版本已更新至里程碑 132。</p><p>此前使用的 Skia 版本是里程碑 126。您可以在<a href="./https://skia.googlesource.com/skia/+/main/RELEASE_NOTES#milestone-132">发布说明</a>中查看这些版本之间的更改。</p><h3 id="新的-clipboard-接口" tabindex="-1">新的 Clipboard 接口 <a class="header-anchor" href="#新的-clipboard-接口" aria-label="Permalink to &quot;新的 Clipboard 接口&quot;">​</a></h3><p>Compose Multiplatform 已采用 Jetpack Compose 的新 <code>Clipboard</code> 接口。</p><p>此前使用的 <code>ClipboardManager</code> 接口由于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API" target="_blank" rel="noreferrer">Web 上的 Clipboard API</a> 的异步性质而在 Web 目标平台无法访问，现已废弃，转而推荐使用 <code>Clipboard</code>。新接口支持 <code>suspend</code> 函数，并且兼容所有目标平台，包括 Web。</p><p>来自公共代码的 Clipboard 交互目前受限于 API 设计。 关于更多详细信息，请参见 <a href="https://youtrack.jetbrains.com/issue/CMP-7624" target="_blank" rel="noreferrer">CMP-7624</a>。</p><h3 id="行高对齐" tabindex="-1">行高对齐 <a class="header-anchor" href="#行高对齐" aria-label="Permalink to &quot;行高对齐&quot;">​</a></h3><p>行高对齐的通用 API，此前仅 Compose Multiplatform 在 Android 上支持，现在所有平台均支持。 使用 <code>LineHeightStyle.Alignment</code>，您可以配置文本行如何在行高提供的空间内对齐。 文本行可以对齐到保留空间的底部、中心或顶部，或根据其上升和下降值按比例调整。</p><img src="`+n+'" alt="行高对齐" width="508"><p>请注意，在 Material3 中，行高对齐的默认值是 <code>Center</code>，这意味着除非另行指定，否则在所有平台上的 Material3 组件中，带有 <code>lineHeight</code> 的文本将应用居中对齐。</p><h2 id="ios" tabindex="-1">iOS <a class="header-anchor" href="#ios" aria-label="Permalink to &quot;iOS&quot;">​</a></h2><h3 id="深度链接" tabindex="-1">深度链接 <a class="header-anchor" href="#深度链接" aria-label="Permalink to &quot;深度链接&quot;">​</a></h3><p>通过将 Compose Multiplatform 1.8.2 与 <a href="./compose-navigation-routing">org.jetbrains.androidx.navigation.navigation-compose</a> 2.9.0-beta05 结合使用，您可以按照通常的 Compose 方式在 iOS 上实现深度链接：将深度链接分配给目标，并使用 <code>NavController</code> 导航到它们。</p><p>关于如何将深度链接引入公共代码的指南，请参见<a href="./compose-navigation-deep-links">深度链接</a>。</p><h3 id="xcframeworks-中的-compose-资源" tabindex="-1">XCFrameworks 中的 Compose 资源 <a class="header-anchor" href="#xcframeworks-中的-compose-资源" aria-label="Permalink to &quot;XCFrameworks 中的 Compose 资源&quot;">​</a></h3><p>Compose Multiplatform 现在直接将资源嵌入到生成的 XCFrameworks 中。 您可以构建并使用带有资源的 Compose 库作为标准 XCFrameworks。</p><p>此特性需要 Kotlin Gradle 插件版本 2.2 或更高。</p><h3 id="辅助功能支持改进" tabindex="-1">辅助功能支持改进 <a class="header-anchor" href="#辅助功能支持改进" aria-label="Permalink to &quot;辅助功能支持改进&quot;">​</a></h3><h4 id="支持从右到左语言" tabindex="-1">支持从右到左语言 <a class="header-anchor" href="#支持从右到左语言" aria-label="Permalink to &quot;支持从右到左语言&quot;">​</a></h4><p>Compose Multiplatform 1.8.2 引入了对从右到左语言的辅助功能支持，包括对手势的正确文本方向处理。</p><p>关于 RTL 支持的更多信息，请参考<a href="./compose-rtl">从右到左语言</a>。</p><h4 id="可滚动列表的辅助功能" tabindex="-1">可滚动列表的辅助功能 <a class="header-anchor" href="#可滚动列表的辅助功能" aria-label="Permalink to &quot;可滚动列表的辅助功能&quot;">​</a></h4><p>此版本改进了滚动边界和元素位置计算的性能和准确性。 通过考虑安全区域，例如刘海屏和屏幕边缘，我们确保了在间隙和边距附近滚动的精确辅助功能属性。</p><p>我们还引入了对滚动状态播报的支持。 启用 VoiceOver 后，当您执行三指滚动手势时，将听到列表状态更新。 播报内容包括：</p><ul><li>当位于列表顶部时为“第一页”。</li><li>向前滚动时为“下一页”。</li><li>向后滚动时为“上一页”。</li><li>到达末尾时为“最后一页”。</li></ul><p>还提供了这些播报的本地化版本，允许 VoiceOver 以您选择的语言朗读它们。</p><h4 id="容器视图的辅助功能" tabindex="-1">容器视图的辅助功能 <a class="header-anchor" href="#容器视图的辅助功能" aria-label="Permalink to &quot;容器视图的辅助功能&quot;">​</a></h4><p>从 Compose Multiplatform 1.8.2 开始，您可以为容器定义遍历语义属性，以确保在滚动和滑动复杂视图时的正确阅读顺序。</p><p>除了为屏幕阅读器正确排序元素外，对遍历属性的支持还使得可以使用向上或向下轻扫的辅助功能手势在不同的遍历组之间导航。 要切换到容器的辅助功能导航模式，请在 VoiceOver 激活时用两根手指在屏幕上旋转。</p><p>关于遍历语义属性的更多信息，请在<a href="./compose-accessibility#traversal-order">辅助功能</a>部分了解。</p><h4 id="可访问的文本输入" tabindex="-1">可访问的文本输入 <a class="header-anchor" href="#可访问的文本输入" aria-label="Permalink to &quot;可访问的文本输入&quot;">​</a></h4><p>在 Compose Multiplatform 1.8.2 中，我们引入了对文本字段辅助功能特性的支持。 当文本输入字段获得焦点时，它现在被标记为可编辑，从而确保正确的辅助功能状态表示。</p><p>您现在还可以在 UI 测试中使用可访问的文本输入。</p><h4 id="支持通过触控板和键盘进行控制" tabindex="-1">支持通过触控板和键盘进行控制 <a class="header-anchor" href="#支持通过触控板和键盘进行控制" aria-label="Permalink to &quot;支持通过触控板和键盘进行控制&quot;">​</a></h4><p>Compose Multiplatform for iOS 现在支持两种额外的输入方法来控制您的设备。您可以使用 AssistiveTouch 来使用鼠标或触控板，或者使用完全键盘访问来使用键盘，而不是依赖于触摸屏：</p><ul><li>AssistiveTouch（<strong>设置</strong> | <strong>辅助功能</strong> | <strong>触控</strong> | <strong>AssistiveTouch</strong>）允许您使用连接的鼠标或触控板上的指针来控制您的 iPhone 或 iPad。您可以使用指针点击屏幕上的图标、导航 AssistiveTouch 菜单或使用屏幕键盘进行输入。</li><li>完全键盘访问（<strong>设置</strong> | <strong>辅助功能</strong> | <strong>键盘</strong> | <strong>完全键盘访问</strong>）允许使用连接的键盘控制设备。您可以使用 <strong>Tab</strong> 等键进行导航，并使用 <strong>Space</strong> 激活项目。</li></ul><h4 id="按需加载辅助功能树" tabindex="-1">按需加载辅助功能树 <a class="header-anchor" href="#按需加载辅助功能树" aria-label="Permalink to &quot;按需加载辅助功能树&quot;">​</a></h4><p>现在，您无需设置将 Compose 语义树与 iOS 辅助功能树同步的特定模式，而是可以依靠 Compose Multiplatform 惰性地处理此过程。 该树在 iOS 辅助功能引擎的首次请求后完全加载，并在屏幕阅读器停止与其交互时被释放。</p><p>这使得完全支持 iOS 语音控制、VoiceOver 以及其他依赖辅助功能树的辅助功能工具成为可能。</p><p>用于<a href="./compose-ios-accessibility#choose-the-tree-synchronization-option">配置辅助功能树同步</a>的 <code>AccessibilitySyncOptions</code> 类已因不再需要而被移除。</p><h4 id="辅助功能属性计算的准确性改进" tabindex="-1">辅助功能属性计算的准确性改进 <a class="header-anchor" href="#辅助功能属性计算的准确性改进" aria-label="Permalink to &quot;辅助功能属性计算的准确性改进&quot;">​</a></h4><p>我们已更新 Compose Multiplatform 组件的辅助功能属性，以匹配 UIKit 组件的预期行为。 UI 元素现在提供广泛的辅助功能数据，并且任何 alpha 值为 0 的透明组件不再提供辅助功能语义。</p><p>对齐语义也使我们能够修复与辅助功能属性不正确计算相关的几个问题，例如 <code>DropDown</code> 元素的缺失命中框、可见文本与辅助功能标签不匹配以及错误的单选按钮状态。</p><h3 id="ios-日志记录的稳定-api" tabindex="-1">iOS 日志记录的稳定 API <a class="header-anchor" href="#ios-日志记录的稳定-api" aria-label="Permalink to &quot;iOS 日志记录的稳定 API&quot;">​</a></h3><p>在 iOS 上启用操作系统日志记录的 API 现在已稳定。<code>enableTraceOSLog()</code> 函数不再需要实验性选择加入，并且现在与 Android 风格的日志记录保持一致。此日志记录提供可使用 Xcode Instruments 进行分析的跟踪信息，用于调试和性能分析。</p><h3 id="拖放" tabindex="-1">拖放 <a class="header-anchor" href="#拖放" aria-label="Permalink to &quot;拖放&quot;">​</a></h3>',95)),t(s,{ref:"Experimental"},null,512),a[1]||(a[1]=e('<p>Compose Multiplatform for iOS 引入了对拖放功能的​​支持，允许您将内容拖入或拖出 Compose 应用程序（请参见拉取请求 <a href="https://github.com/JetBrains/compose-multiplatform-core/pull/1690" target="_blank" rel="noreferrer">1690</a> 获取演示视频）。 要定义可拖动内容和放置目标，请使用 <code>dragAndDropSource</code> 和 <code>dragAndDropTarget</code> 修饰符。</p><p>在 iOS 上，拖放会话数据由 <a href="https://developer.apple.com/documentation/uikit/uidragitem" target="_blank" rel="noreferrer"><code>UIDragItem</code></a> 表示。 此对象包含有关跨进程数据传输的信息，以及一个用于应用内使用的可选本地对象。 例如，您可以使用 <code>DragAndDropTransferData(listOf(UIDragItem.fromString(text)))</code> 拖动文本，其中 <code>UIDragItem.fromString(text)</code> 将文本编码为适合拖放操作的格式。 目前，仅支持 <code>String</code> 和 <code>NSObject</code> 类型。</p><p>关于常见用例，请参见 Jetpack Compose 文档中的<a href="https://developer.android.com/develop/ui/compose/touch-input/user-interactions/drag-and-drop" target="_blank" rel="noreferrer">专题文章</a>。</p><h3 id="滚动互操作视图的触控处理改进" tabindex="-1">滚动互操作视图的触控处理改进 <a class="header-anchor" href="#滚动互操作视图的触控处理改进" aria-label="Permalink to &quot;滚动互操作视图的触控处理改进&quot;">​</a></h3><p>在此版本中：</p><ul><li>内容不可滚动并以模态 <code>UIViewController</code> 形式呈现的 Compose 视图，现在可以通过向下轻扫手势关闭。</li><li>嵌套的可滚动视图在通用<a href="./compose-ios-touch">互操作触控框架</a>内正常工作：当在可滚动的 Compose 视图内滚动原生内容，或在可滚动的原生视图内滚动 Compose 内容时，UI 会严格遵循 iOS 逻辑来解决模糊的触控序列。</li></ul><h3 id="选择启用并发渲染" tabindex="-1">选择启用并发渲染 <a class="header-anchor" href="#选择启用并发渲染" aria-label="Permalink to &quot;选择启用并发渲染&quot;">​</a></h3>',7)),t(s,{ref:"Experimental"},null,512),a[2]||(a[2]=e(`<p>Compose Multiplatform for iOS 现在支持将渲染任务卸载到专用的渲染线程。 并发渲染可能会在没有 UIKit 互操作的情况下提高性能。</p><p>通过启用 <code>ComposeUIViewControllerConfiguration</code> 类的 <code>useSeparateRenderThreadWhenPossible</code> 标志，或直接在 <code>ComposeUIViewController</code> 配置块中启用 <code>parallelRendering</code> 属性，选择在单独的渲染线程上编码渲染命令：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalComposeUiApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">vararg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> args: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    UIKitMain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        ComposeUIViewController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(configure </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { parallelRendering </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="web" tabindex="-1">Web <a class="header-anchor" href="#web" aria-label="Permalink to &quot;Web&quot;">​</a></h2><h3 id="navigation-库支持浏览器控件" tabindex="-1">Navigation 库支持浏览器控件 <a class="header-anchor" href="#navigation-库支持浏览器控件" aria-label="Permalink to &quot;Navigation 库支持浏览器控件&quot;">​</a></h3><p>在通过 Compose Multiplatform 构建的 Kotlin/Wasm 和 Kotlin/JS 应用程序中，导航现在可以与基本浏览器控件正常工作。 要启用此功能，请使用 <code>window.bindToNavigation()</code> 方法将浏览器窗口链接到主导航图。 启用后，Web 应用程序将正确响应使用“后退”和“前进”按钮在浏览器历史记录中移动（请参见拉取请求 <a href="https://github.com/JetBrains/compose-multiplatform-core/pull/1621" target="_blank" rel="noreferrer">1621</a> 获取演示视频）。</p><p>Web 应用程序还将操作浏览器地址栏以反映当前目标路由，并在用户粘贴包含正确编码路由的 URL 时直接导航到目标（请参见拉取请求 <a href="https://github.com/JetBrains/compose-multiplatform-core/pull/1640" target="_blank" rel="noreferrer">1640</a> 获取演示视频）。 <code>window.bindToNavigation()</code> 方法具有可选的 <code>getBackStackEntryPath</code> 形参，允许您自定义路由字符串到 URL 片段的转换。</p><h3 id="设置浏览器光标" tabindex="-1">设置浏览器光标 <a class="header-anchor" href="#设置浏览器光标" aria-label="Permalink to &quot;设置浏览器光标&quot;">​</a></h3>`,8)),t(s,{ref:"Experimental"},null,512),a[3]||(a[3]=i("p",null,[l("我们引入了一个实验性的 "),i("code",null,"PointerIcon.Companion.fromKeyword()"),l(" 函数，用于管理可在浏览器页面上用作鼠标指针的图标。通过传递一个关键字作为形参，您可以根据上下文指定要显示的光标类型。 例如，您可以为选择文本、打开上下文菜单或指示加载过程分配不同的指针图标。")],-1)),a[4]||(a[4]=i("p",null,[l("查看可用的"),i("a",{href:"https://developer.mozilla.org/en-US/docs/Web/CSS/cursor",target:"_blank",rel:"noreferrer"},"关键字"),l("完整列表。")],-1)),a[5]||(a[5]=i("h3",{id:"资源预加载",tabindex:"-1"},[l("资源预加载 "),i("a",{class:"header-anchor",href:"#资源预加载","aria-label":'Permalink to "资源预加载"'},"​")],-1)),t(s,{ref:"Experimental"},null,512),a[6]||(a[6]=e('<p>Compose Multiplatform 1.8.2 引入了一个新的实验性 API，用于为 Web 目标平台预加载字体和图像。 预加载有助于防止视觉问题，例如未样式化文本的闪现 (FOUT) 或图像和图标的闪烁。</p><p>以下函数现在可用于加载和缓存资源：</p><ul><li><code>preloadFont()</code>，用于预加载字体。</li><li><code>preloadImageBitmap()</code>，用于预加载位图图像。</li><li><code>preloadImageVector()</code>，用于预加载矢量图像。</li></ul><p>关于详细信息，请参见<a href="./compose-multiplatform-resources-usage#preload-resources-using-the-compose-multiplatform-preload-api">文档</a>。</p><h2 id="桌面" tabindex="-1">桌面 <a class="header-anchor" href="#桌面" aria-label="Permalink to &quot;桌面&quot;">​</a></h2><h3 id="windows-上的软件渲染改进" tabindex="-1">Windows 上的软件渲染改进 <a class="header-anchor" href="#windows-上的软件渲染改进" aria-label="Permalink to &quot;Windows 上的软件渲染改进&quot;">​</a></h3><p>切换到 Windows 上 Skia 推荐的 clang 编译器，加快了依赖于 CPU 的渲染速度。 这主要影响纯软件渲染，因为渲染通常依赖于 GPU，只有部分计算在 CPU 上完成。 因此，在某些虚拟机和一些<a href="https://github.com/JetBrains/skiko/blob/30df516c1a1a25237880f3e0fe83e44a13821292/skiko/src/jvmMain/kotlin/org/jetbrains/skiko/GraphicsApi.jvm.kt#L13" target="_blank" rel="noreferrer">不受 Skia 支持</a>的旧显卡上，这种改进非常明显：Compose Multiplatform 生成的 Windows 应用在这些环境中现在比 Compose Multiplatform 1.7.3 快达 6 倍。</p><p>除了对 Windows for ARM64 的支持，这一改进使得 macOS 下虚拟 Windows 系统上的 Compose Multiplatform UI 性能显著提升。</p><h3 id="支持-windows-for-arm64" tabindex="-1">支持 Windows for ARM64 <a class="header-anchor" href="#支持-windows-for-arm64" aria-label="Permalink to &quot;支持 Windows for ARM64&quot;">​</a></h3><p>Compose Multiplatform 1.8.2 引入了对 JVM 上 Windows for ARM64 的支持，从而改进了在基于 ARM 的 Windows 设备上构建和运行应用程序的整体体验。</p><h2 id="gradle-插件" tabindex="-1">Gradle 插件 <a class="header-anchor" href="#gradle-插件" aria-label="Permalink to &quot;Gradle 插件&quot;">​</a></h2><h3 id="更改生成的-res-类名的选项" tabindex="-1">更改生成的 Res 类名的选项 <a class="header-anchor" href="#更改生成的-res-类名的选项" aria-label="Permalink to &quot;更改生成的 Res 类名的选项&quot;">​</a></h3><p>您现在可以自定义生成的资源类的名称，该类提供对应用程序中资源的访问。 自定义命名对于区分多模块项目中的资源特别有用，并有助于与项目命名约定保持一致。</p><p>要定义自定义名称，请将以下行添加到 <code>build.gradle.kts</code> 文件中的 <code>compose.resources</code> 块中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">compose.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resources</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nameOfResClass </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;MyRes&quot;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>关于更多详细信息，请参见<a href="https://github.com/JetBrains/compose-multiplatform/pull/5296" target="_blank" rel="noreferrer">拉取请求</a>。</p><h3 id="androidlibrary-目标平台中对多平台资源的支持" tabindex="-1"><code>androidLibrary</code> 目标平台中对多平台资源的支持 <a class="header-anchor" href="#androidlibrary-目标平台中对多平台资源的支持" aria-label="Permalink to &quot;`androidLibrary` 目标平台中对多平台资源的支持&quot;">​</a></h3>',17)),t(s,{ref:"Experimental"},null,512),a[7]||(a[7]=e(`<p>从 Android Gradle 插件版本 8.8.0 开始，您可以在新的 <code>androidLibrary</code> 目标平台中使用生成的 assets。 为了使 Compose Multiplatform 与这些更改保持一致，我们引入了对新目标配置的支持，以处理打包到 Android assets 中的多平台资源。</p><p>如果您正在使用 <code>androidLibrary</code> 目标平台，请在您的配置中启用资源：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin {</span></span>
<span class="line"><span>    androidLibrary {</span></span>
<span class="line"><span>        androidResources.enable = true</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>否则，您将遇到以下异常：<code>org.jetbrains.compose.resources.MissingResourceException: Missing resource with path: …</code>。</p>`,4))])}const C=o(d,[["render",k]]);export{b as __pageData,C as default};
