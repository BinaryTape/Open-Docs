import{_ as e,a as p,b as d,c as u,d as m,e as f,f as s,g as S,h as k,i as h}from"./chunks/remote-artifact-distribution.DrML6DzP.js";import{_ as w,C as b,c as O,o as K,ag as n,j as l,G as i,w as r,a}from"./chunks/framework.Bksy39di.js";const x=JSON.parse('{"title":"为您的 Kotlin Multiplatform 项目选择配置","description":"","frontmatter":{},"headers":[],"relativePath":"kmp/multiplatform-project-configuration.md","filePath":"kmp/multiplatform-project-configuration.md","lastUpdated":1755516278000}'),M={name:"kmp/multiplatform-project-configuration.md"};function g(A,o,P,_,T,C){const t=b("list");return K(),O("div",null,[o[15]||(o[15]=n("",17)),l("table",null,[o[2]||(o[2]=l("tr",null,[l("th",null,"优点"),l("th",null,"缺点")],-1)),l("tr",null,[l("td",null,[i(t,null,{default:r(()=>o[0]||(o[0]=[l("li",null,"仅包含单个模块的简单设计降低了认知负担。您无需考虑将功能放在何处，也无需考虑如何逻辑地将其拆分为多个部分。",-1),l("li",null,"非常适合作为起点。",-1)])),_:1})]),l("td",null,[i(t,null,{default:r(()=>o[1]||(o[1]=[l("li",null,"随着共享模块的增长，编译时间会增加。",-1),l("li",null,"此设计不允许拥有单独的特性，也不允许仅依赖应用所需的特性。",-1)])),_:1})])])]),o[16]||(o[16]=n("",5)),l("table",null,[o[5]||(o[5]=l("tr",null,[l("th",null,"优点"),l("th",null,"缺点")],-1)),l("tr",null,[l("td",null,[i(t,null,{default:r(()=>o[3]||(o[3]=[l("li",null,"共享代码的关注点分离。",-1),l("li",null,"更好的可伸缩性。",-1)])),_:1})]),l("td",null,[i(t,null,{default:r(()=>o[4]||(o[4]=[l("li",null,"更复杂的设置，包括伞 framework 设置。",-1),l("li",null,"更复杂的跨模块依赖项管理。",-1)])),_:1})])])]),o[17]||(o[17]=n("",6)),o[18]||(o[18]=l("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"为什么需要伞-framework",tabindex:"-1"},[a("为什么需要伞 framework？ "),l("a",{class:"header-anchor",href:"#为什么需要伞-framework","aria-label":'Permalink to "为什么需要伞 framework？ {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),o[19]||(o[19]=n("",12)),l("table",null,[o[8]||(o[8]=l("tr",null,[l("th",null,"优点"),l("th",null,"缺点")],-1)),l("tr",null,[l("td",null,[i(t,null,{default:r(()=>o[6]||(o[6]=[l("li",null,"借助向导轻松设置。",-1),l("li",null,"由于所有代码都位于同一个版本库中，iOS 开发者可以轻松处理 Kotlin Multiplatform 代码。",-1)])),_:1})]),l("td",null,[i(t,null,{default:r(()=>o[7]||(o[7]=[l("li",null,"iOS 开发者需要设置和配置不熟悉的工具。",-1),l("li",null,"此方法通常不适用于已存储在不同版本库中的现有应用。",-1)])),_:1})])])]),o[20]||(o[20]=n("",25)),l("table",null,[o[11]||(o[11]=l("tr",null,[l("th",null,"优点"),l("th",null,"缺点")],-1)),l("tr",null,[l("td",null,[i(t,null,{default:r(()=>o[9]||(o[9]=[l("li",null,"Android 和 iOS 团队成员都可以轻松编辑 Kotlin Multiplatform 代码，确保创建和维护共享代码是共同的责任。这有助于防止团队孤立并鼓励协作。",-1),l("li",null,"此方法不需要单独对共享代码进行版本控制和发布。",-1),l("li",null,"开发工作流程更快，因为 iOS 团队成员无需等待构件被创建和发布。",-1)])),_:1})]),l("td",null,[i(t,null,{default:r(()=>o[10]||(o[10]=[l("li",null,"团队成员需要在他们的机器上设置完整的开发环境。",-1),l("li",null,"iOS 开发者必须学习如何使用 Android Studio 和 Gradle。",-1),l("li",null,"随着共享代码的增多和团队的壮大，管理更改变得困难。",-1)])),_:1})])])]),o[21]||(o[21]=l("h3",{id:"远程-构件分发",tabindex:"-1"},[a("远程：构件分发 "),l("a",{class:"header-anchor",href:"#远程-构件分发","aria-label":'Permalink to "远程：构件分发"'},"​")],-1)),o[22]||(o[22]=l("p",null,"远程分发意味着 framework 构件使用 SPM 作为 CocoaPod 或 Swift 包发布，并由 iOS 应用使用。Android 应用可以本地或远程使用二进制依赖项。",-1)),o[23]||(o[23]=l("p",null,"远程分发通常用于将技术逐步引入现有项目。它不会显著改变 iOS 开发者​​的工作流程和构建过程。拥有两个或更多版本库的团队主要使用远程分发来存储项目代码。",-1)),o[24]||(o[24]=l("p",null,[a("作为开始，您可能想要使用 "),l("a",{href:"https://touchlab.co/trykmmbridge",target:"_blank",rel:"noreferrer"},"KMMBridge"),a(" – 一套极大地简化远程分发工作流程的构建工具。或者，您也可以始终自行设置类似的工作流程：")],-1)),o[25]||(o[25]=l("p",null,[l("img",{src:e,alt:"Remote artifact distribution",width:"700"})],-1)),l("table",null,[o[14]||(o[14]=l("tr",null,[l("th",null,"优点"),l("th",null,"缺点")],-1)),l("tr",null,[o[13]||(o[13]=l("td",null,"不参与的 iOS 团队成员无需用 Kotlin 编写代码，也无需学习如何使用 Android Studio 和 Gradle 等工具。这显著降低了团队的进入门槛。",-1)),l("td",null,[i(t,null,{default:r(()=>o[12]||(o[12]=[l("li",null,"iOS 开发者工作流程较慢，因为编辑和构建共享代码的过程涉及发布和版本控制。",-1),l("li",null,"在 iOS 上调试共享 Kotlin 代码很困难。",-1),l("li",null,"iOS 团队成员对共享代码贡献的可能性显著降低。",-1),l("li",null,"共享代码的维护完全取决于参与的团队成员。",-1)])),_:1})])])]),o[26]||(o[26]=l("h4",{id:"为本地开发设置本地依赖项",tabindex:"-1"},[a("为本地开发设置本地依赖项 "),l("a",{class:"header-anchor",href:"#为本地开发设置本地依赖项","aria-label":'Permalink to "为本地开发设置本地依赖项"'},"​")],-1)),o[27]||(o[27]=l("p",null,"许多团队在采用 Kotlin Multiplatform 技术时选择远程分发工作流程，以保持 iOS 开发者​​的开发过程不变。然而，在此工作流程中，他们很难更改 Kotlin Multiplatform 代码。我们建议设置一个额外的“本地开发”工作流程，其中包含对由 Kotlin Multiplatform 模块生成的 framework 的本地依赖项。",-1)),o[28]||(o[28]=l("p",null,"当开发者添加新功能时，他们会切换到将 Kotlin Multiplatform 模块作为本地依赖项使用。这允许更改公共 Kotlin 代码，立即从 iOS 观察行为，并调试 Kotlin 代码。当功能准备就绪时，他们可以切换回远程依赖项并相应地发布他们的更改。首先，他们发布对共享模块的更改，然后才对应用进行更改。",-1)),o[29]||(o[29]=l("p",null,"对于远程分发工作流程，请使用 CocoaPods 集成或 SPM。对于本地分发工作流程，请直接集成 framework。",-1)),o[30]||(o[30]=l("p",null,[a("如果您使用 CocoaPods，您可以选择使用 CocoaPods 进行本地分发工作流程。您可以通过更改环境变量在它们之间切换，如 "),l("a",{href:"https://touchlab.co/kmmbridgecocoapodslocal",target:"_blank",rel:"noreferrer"},"TouchLab 文档"),a(" 中所述。")],-1))])}const V=w(M,[["render",g]]);export{x as __pageData,V as default};
