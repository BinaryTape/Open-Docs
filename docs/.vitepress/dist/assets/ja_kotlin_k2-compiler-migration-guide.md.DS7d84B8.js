import{_ as n}from"./chunks/k2-compiler-architecture.D_ba9KK9.js";import{_ as l,c as e,o as p,ag as i,j as s,a}from"./chunks/framework.Bksy39di.js";const u=JSON.parse('{"title":"K2コンパイラー移行ガイド","description":"","frontmatter":{},"headers":[],"relativePath":"ja/kotlin/k2-compiler-migration-guide.md","filePath":"ja/kotlin/k2-compiler-migration-guide.md","lastUpdated":1754307826000}'),h={name:"ja/kotlin/k2-compiler-migration-guide.md"};function k(r,t,d,o,c,E){return p(),e("div",null,t[0]||(t[0]=[i('<h1 id="k2コンパイラー移行ガイド" tabindex="-1">K2コンパイラー移行ガイド <a class="header-anchor" href="#k2コンパイラー移行ガイド" aria-label="Permalink to &quot;K2コンパイラー移行ガイド&quot;">​</a></h1><p>Kotlin言語とエコシステムが進化し続けるにつれて、Kotlinコンパイラーも進化してきました。最初のステップは、ロジックを共有し、異なるプラットフォームのターゲット向けのコード生成を簡素化する、新しいJVMおよびJS IR（中間表現）バックエンドの導入でした。そして今、その進化の次の段階として、K2として知られる新しいフロントエンドが登場します。</p><p><img src="'+n+`" alt="Kotlin K2 compiler architecture" width="700"></p><p>K2コンパイラーの登場により、Kotlinフロントエンドは完全に書き直され、新しく、より効率的なアーキテクチャを備えています。新しいコンパイラーがもたらす根本的な変更は、より多くのセマンティック情報を含む1つの統一されたデータ構造の使用です。このフロントエンドは、意味解析、呼び出し解決、および型推論を実行する役割を担います。</p><p>新しいアーキテクチャと豊富なデータ構造により、K2コンパイラーは以下の利点を提供します。</p><ul><li><strong>呼び出し解決と型推論の改善</strong>。コンパイラーの動作が一貫し、コードをよりよく理解します。</li><li><strong>新しい言語機能の糖衣構文の導入が容易に</strong>。将来的には、新しい機能が導入される際に、より簡潔で読みやすいコードを使用できるようになります。</li><li><strong>コンパイル時間の高速化</strong>。コンパイル時間は<a href="#performance-improvements">大幅に高速化されます</a>。</li><li><strong>IDEパフォーマンスの向上</strong>。2025.1以降、IntelliJ IDEAはK2モードを使用してKotlinコードを分析し、安定性を高め、パフォーマンスを向上させます。詳細については、<a href="#support-in-ides">IDEのサポート</a>を参照してください。</li></ul><p>このガイドでは、以下の内容を説明します。</p><ul><li>新しいK2コンパイラーの利点を説明します。</li><li>移行中に遭遇する可能性のある変更点と、それに応じてコードを適応させる方法を強調します。</li><li>以前のバージョンにロールバックする方法を説明します。</li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>新しいK2コンパイラーは、2.0.0からデフォルトで有効になっています。Kotlin 2.0.0で提供される新機能、および新しいK2コンパイラーの詳細については、<a href="/ja/kotlin/whatsnew20">Kotlin 2.0.0の新機能</a>を参照してください。</p></div><h2 id="パフォーマンスの改善" tabindex="-1">パフォーマンスの改善 <a class="header-anchor" href="#パフォーマンスの改善" aria-label="Permalink to &quot;パフォーマンスの改善&quot;">​</a></h2><p>K2コンパイラーのパフォーマンスを評価するために、2つのオープンソースプロジェクト、<a href="https://github.com/ankidroid/Anki-Android" target="_blank" rel="noreferrer">Anki-Android</a>と<a href="https://github.com/JetBrains/Exposed" target="_blank" rel="noreferrer">Exposed</a>でパフォーマンステストを実行しました。そこで見つかった主要なパフォーマンス改善点は次のとおりです。</p><ul><li>K2コンパイラーは、最大94%のコンパイル速度向上をもたらします。例えば、Anki-Androidプロジェクトでは、クリーンビルド時間がKotlin 1.9.23の57.7秒からKotlin 2.0.0の29.7秒に短縮されました。</li><li>初期化フェーズは、K2コンパイラーを使用すると最大488%高速になります。例えば、Anki-Androidプロジェクトでは、インクリメンタルビルドの初期化フェーズがKotlin 1.9.23の0.126秒からKotlin 2.0.0のわずか0.022秒に短縮されました。</li><li>Kotlin K2コンパイラーは、以前のコンパイラーと比較して、解析フェーズで最大376%高速化されています。例えば、Anki-Androidプロジェクトでは、インクリメンタルビルドの解析時間がKotlin 1.9.23の0.581秒からKotlin 2.0.0のわずか0.122秒に削減されました。</li></ul><p>これらの改善の詳細、およびK2コンパイラーのパフォーマンスを分析した方法については、弊社の<a href="https://blog.jetbrains.com/kotlin/2024/04/k2-compiler-performance-benchmarks-and-how-to-measure-them-on-your-projects/" target="_blank" rel="noreferrer">ブログ記事</a>を参照してください。</p><h2 id="言語機能の改善" tabindex="-1">言語機能の改善 <a class="header-anchor" href="#言語機能の改善" aria-label="Permalink to &quot;言語機能の改善&quot;">​</a></h2><p>Kotlin K2コンパイラーは、<a href="#smart-casts">スマートキャスト</a>と<a href="#kotlin-multiplatform">Kotlin Multiplatform</a>に関連する言語機能を改善します。</p><h3 id="スマートキャスト" tabindex="-1">スマートキャスト <a class="header-anchor" href="#スマートキャスト" aria-label="Permalink to &quot;スマートキャスト&quot;">​</a></h3><p>Kotlinコンパイラーは、特定の場合にオブジェクトを型に自動的にキャストできるため、手動で明示的に指定する手間が省けます。これは<a href="/ja/kotlin/typecasts#smart-casts">スマートキャスト</a>と呼ばれます。Kotlin K2コンパイラーは、以前よりもさらに多くのシナリオでスマートキャストを実行するようになりました。</p><p>Kotlin 2.0.0では、以下の分野でスマートキャストに関連する改善を行いました。</p><ul><li><a href="#local-variables-and-further-scopes">ローカル変数とそれ以降のスコープ</a></li><li><a href="#type-checks-with-the-logical-or-operator">論理OR演算子による型チェック</a></li><li><a href="#inline-functions">インライン関数</a></li><li><a href="#properties-with-function-types">関数型を持つプロパティ</a></li><li><a href="#exception-handling">例外処理</a></li><li><a href="#increment-and-decrement-operators">インクリメントおよびデクリメント演算子</a></li></ul><h4 id="ローカル変数とそれ以降のスコープ" tabindex="-1">ローカル変数とそれ以降のスコープ <a class="header-anchor" href="#ローカル変数とそれ以降のスコープ" aria-label="Permalink to &quot;ローカル変数とそれ以降のスコープ&quot;">​</a></h4><p>以前は、<code>if</code>条件内で変数が<code>null</code>ではないと評価された場合、その変数はスマートキャストされました。この変数に関する情報は、<code>if</code>ブロックのスコープ内でさらに共有されました。</p><p>しかし、<code>if</code>条件の<strong>外側</strong>で変数を宣言した場合、その変数に関する情報は<code>if</code>条件内で利用できなかったため、スマートキャストできませんでした。この動作は<code>when</code>式や<code>while</code>ループでも見られました。</p><p>Kotlin 2.0.0からは、<code>if</code>、<code>when</code>、または<code>while</code>条件で変数を使用する前に変数を宣言すると、コンパイラーによって収集された変数に関するすべての情報が、スマートキャストのために対応するブロックでアクセス可能になります。</p><p>これは、真偽条件を変数に抽出するなどの場合に役立ちます。そうすることで、変数に意味のある名前を付け、コードの可読性を向上させ、後でコードで変数を再利用することが可能になります。例えば：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> purr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Purr purr&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> petAnimal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(animal: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isCat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> animal </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Cat</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (isCat) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Kotlin 2.0.0では、コンパイラーはisCatに関する情報に</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // アクセスできるため、animalがCat型にスマートキャストされたことを</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 認識します。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // したがって、purr()関数を呼び出すことができます。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Kotlin 1.9.20では、コンパイラーはスマートキャストを</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 認識しないため、purr()関数を呼び出すとエラーが発生します。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        animal.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">purr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kitty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    petAnimal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kitty)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Purr purr</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="論理or演算子による型チェック" tabindex="-1">論理OR演算子による型チェック <a class="header-anchor" href="#論理or演算子による型チェック" aria-label="Permalink to &quot;論理OR演算子による型チェック&quot;">​</a></h4><p>Kotlin 2.0.0では、オブジェクトの型チェックを<code>or</code>演算子 (<code>||</code>) と組み合わせると、それらの最も近い共通のスーパータイプにスマートキャストが行われます。この変更以前は、スマートキャストは常に<code>Any</code>型に対して行われていました。</p><p>この場合、そのプロパティにアクセスしたり、関数を呼び出したりする前に、その後も手動でオブジェクトの型をチェックする必要がありました。例えば：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Status</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> signal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Ok</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Status</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Postponed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Status</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Declined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Status</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> signalCheck</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(signalStatus: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (signalStatus </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Postponed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> signalStatus </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Declined) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // signalStatusは共通スーパータイプであるStatusにスマートキャストされる</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        signalStatus.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">signal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Kotlin 2.0.0より前は、signalStatusはAny型にスマートキャストされ、</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // signal()関数を呼び出すと\`Unresolved reference\`エラーが発生しました。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // signal()関数は、別の型チェックの後でのみ正常に呼び出すことができました。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // check(signalStatus is Status)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // signalStatus.signal()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>共通スーパータイプは、<a href="https://en.wikipedia.org/wiki/Union_type" target="_blank" rel="noreferrer">共用体型</a>の<strong>近似</strong>です。共用体型は<a href="https://youtrack.jetbrains.com/issue/KT-13108/Denotable-union-and-intersection-types" target="_blank" rel="noreferrer">現在Kotlinではサポートされていません</a>。</p></div><h4 id="インライン関数" tabindex="-1">インライン関数 <a class="header-anchor" href="#インライン関数" aria-label="Permalink to &quot;インライン関数&quot;">​</a></h4><p>Kotlin 2.0.0では、K2コンパイラーはインライン関数を異なる方法で扱い、他のコンパイラー解析と組み合わせてスマートキャストが安全かどうかを判断できるようにします。</p><p>具体的には、インライン関数は暗黙的な<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.contracts/-contract-builder/calls-in-place.html" target="_blank" rel="noreferrer"><code>callsInPlace</code></a>コントラクトを持つものとして扱われるようになりました。これは、インライン関数に渡されたラムダ関数がインプレイスで呼び出されることを意味します。ラムダ関数がインプレイスで呼び出されるため、コンパイラーはラムダ関数がその関数本体に含まれる変数の参照を漏洩させることができないことを認識します。</p><p>コンパイラーはこの知識を他のコンパイラー解析と組み合わせて、キャプチャされた変数のいずれかをスマートキャストするのが安全かどうかを決定します。例えば：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Processor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inlineAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Unit) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nextProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Processor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Processor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> processor: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Processor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    inlineAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Kotlin 2.0.0では、コンパイラーはprocessorが</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ローカル変数であり、inlineAction()がインライン関数であることを認識しているため、</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // processorへの参照が漏洩することはありません。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // したがって、processorをスマートキャストしても安全です。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // processorがnullでない場合、processorはスマートキャストされる</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (processor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // コンパイラーはprocessorがnullではないことを認識しているため、</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // セーフコールは不要である</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            processor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Kotlin 1.9.20では、セーフコールを実行する必要がある：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // processor?.process()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        processor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nextProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> processor</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="関数型を持つプロパティ" tabindex="-1">関数型を持つプロパティ <a class="header-anchor" href="#関数型を持つプロパティ" aria-label="Permalink to &quot;関数型を持つプロパティ&quot;">​</a></h4><p>以前のバージョンのKotlinでは、関数型を持つクラスプロパティがスマートキャストされないというバグがありました。Kotlin 2.0.0とK2コンパイラーでこの動作を修正しました。例えば：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Holder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> provider: (() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Unit)?) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Kotlin 2.0.0では、providerがnullでない場合、</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // スマートキャストされる</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (provider </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // コンパイラーはproviderがnullではないことを認識している</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            provider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 1.9.20では、コンパイラーはproviderがnullではないことを</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 認識しないため、エラーが発生する：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Reference has a nullable type &#39;(() -&gt; Unit)?&#39;, use explicit &#39;?.invoke()&#39; to make a function-like call instead</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>この変更は、<code>invoke</code>演算子をオーバーロードした場合にも適用されます。例えば：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Provider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    operator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Processor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Holder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> provider: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Provider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> processor: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Processor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (provider </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            provider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 1.9.20では、コンパイラーがエラーを発生させる：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Reference has a nullable type &#39;Provider?&#39;, use explicit &#39;?.invoke()&#39; to make a function-like call instead</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="例外処理" tabindex="-1">例外処理 <a class="header-anchor" href="#例外処理" aria-label="Permalink to &quot;例外処理&quot;">​</a></h4><p>Kotlin 2.0.0では、例外処理の改善を行い、スマートキャスト情報が<code>catch</code>および<code>finally</code>ブロックに渡されるようになりました。この変更により、コンパイラーがオブジェクトがnull許容型であるかどうかを追跡するため、コードがより安全になります。例えば：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stringInput: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // stringInputはString型にスマートキャストされる</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    stringInput </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // コンパイラーはstringInputがnullではないことを認識している</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stringInput.length)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // コンパイラーはstringInputの以前のスマートキャスト情報を破棄する。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 現在、stringInputはString?型になっている。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        stringInput </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 例外をトリガーする</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throw</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Exception</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        stringInput </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (exception: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Exception</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Kotlin 2.0.0では、コンパイラーはstringInputが</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // nullになる可能性があることを認識しているため、stringInputはnull許容のままである。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stringInput?.length)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // null</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Kotlin 1.9.20では、コンパイラーはセーフコールが不要であると言うが、これは誤りである。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    testString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="インクリメントおよびデクリメント演算子" tabindex="-1">インクリメントおよびデクリメント演算子 <a class="header-anchor" href="#インクリメントおよびデクリメント演算子" aria-label="Permalink to &quot;インクリメントおよびデクリメント演算子&quot;">​</a></h4><p>Kotlin 2.0.0より前は、コンパイラーはインクリメントまたはデクリメント演算子を使用した後にオブジェクトの型が変更されることを理解していませんでした。コンパイラーがオブジェクトの型を正確に追跡できなかったため、コードが未解決の参照エラーにつながる可能性がありました。Kotlin 2.0.0では、これが修正されました。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rho</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    operator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Sigma</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TODO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sigma</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Rho</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sigma</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Unit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Tau</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> tau</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Unit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Rho</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unknownObject: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Rho</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // unknownObjectがTauインターフェースを継承しているかチェック</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // なお、unknownObjectはRhoインターフェースとTauインターフェースの両方を</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 継承している可能性がある。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (unknownObject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Tau) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Rhoインターフェースのオーバーロードされたinc()演算子を使用する。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Kotlin 2.0.0では、unknownObjectの型はSigmaにスマートキャストされる。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        ++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">unknownObject</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Kotlin 2.0.0では、コンパイラーはunknownObjectがSigma型であることを認識しているため、</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // sigma()関数を正常に呼び出すことができる。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        unknownObject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sigma</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Kotlin 1.9.20では、inc()が呼び出されてもコンパイラーはスマートキャストを</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 実行しないため、コンパイラーは依然としてunknownObjectがTau型であると認識する。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // sigma()関数を呼び出すとコンパイル時エラーが発生する。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Kotlin 2.0.0では、コンパイラーはunknownObjectがSigma型であることを認識しているため、</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // tau()関数を呼び出すとコンパイル時エラーが発生する。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        unknownObject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tau</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 未解決の参照 &#39;tau&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Kotlin 1.9.20では、コンパイラーが誤ってunknownObjectがTau型であると</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 認識するため、tau()関数を呼び出すことができたが、</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ClassCastExceptionが発生する。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="kotlin-multiplatform" tabindex="-1">Kotlin Multiplatform <a class="header-anchor" href="#kotlin-multiplatform" aria-label="Permalink to &quot;Kotlin Multiplatform&quot;">​</a></h3><p>K2コンパイラーには、Kotlin Multiplatformに関連する以下の分野で改善があります。</p><ul><li><a href="#separation-of-common-and-platform-sources-during-compilation">コンパイル時の共通ソースとプラットフォームソースの分離</a></li><li><a href="#different-visibility-levels-of-expected-and-actual-declarations">expectedおよびactual宣言の異なる可視性レベル</a></li></ul><h4 id="コンパイル時の共通ソースとプラットフォームソースの分離" tabindex="-1">コンパイル時の共通ソースとプラットフォームソースの分離 <a class="header-anchor" href="#コンパイル時の共通ソースとプラットフォームソースの分離" aria-label="Permalink to &quot;コンパイル時の共通ソースとプラットフォームソースの分離&quot;">​</a></h4><p>以前は、Kotlinコンパイラーの設計により、コンパイル時に共通ソースセットとプラットフォームソースセットを分離することができませんでした。その結果、共通コードがプラットフォームコードにアクセスでき、プラットフォーム間で異なる動作を引き起こしていました。さらに、共通コードからのいくつかのコンパイラー設定と依存関係がプラットフォームコードに漏洩していました。</p><p>Kotlin 2.0.0では、新しいKotlin K2コンパイラーの実装に、共通ソースセットとプラットフォームソースセット間の厳密な分離を確実にするためのコンパイルスキームの再設計が含まれています。この変更は、<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-expect-actual.html#expected-and-actual-functions" target="_blank" rel="noreferrer">expectedおよびactual関数</a>を使用する際に最も顕著です。以前は、共通コードの関数呼び出しがプラットフォームコードの関数に解決されることが可能でした。例えば：</p><table><tr><td>共通コード</td><td>プラットフォームコード</td></tr><tr><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;common foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> exampleFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></td><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JVM</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;platform foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JavaScript</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JavaScriptプラットフォームにはfoo()関数のオーバーロードがない</span></span></code></pre></div></td></tr></table><p>この例では、共通コードは実行されるプラットフォームによって異なる動作をします。</p><ul><li>JVMプラットフォームでは、共通コードで<code>foo()</code>関数を呼び出すと、プラットフォームコードの<code>foo()</code>関数が<code>platform foo</code>として呼び出されます。</li><li>JavaScriptプラットフォームでは、プラットフォームコードにそのような関数が利用できないため、共通コードで<code>foo()</code>関数を呼び出すと、共通コードの<code>foo()</code>関数が<code>common foo</code>として呼び出されます。</li></ul><p>Kotlin 2.0.0では、共通コードはプラットフォームコードにアクセスできないため、両方のプラットフォームで<code>foo()</code>関数が共通コードの<code>foo()</code>関数に正常に解決されます：<code>common foo</code>。</p><p>プラットフォーム間の動作の一貫性が向上したことに加えて、IntelliJ IDEAまたはAndroid Studioとコンパイラーの間で競合する動作があったケースを修正するために努力しました。例えば、<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-expect-actual.html#expected-and-actual-classes" target="_blank" rel="noreferrer">expectedおよびactualクラス</a>を使用した場合、以下のことが起こりました。</p><table><tr><td>共通コード</td><td>プラットフォームコード</td></tr><tr><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">expect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Identity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> confirmIdentity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> common</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 2.0.0より前は、IDEのみのエラーをトリガーした</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    Identity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">confirmIdentity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // RESOLUTION_TO_CLASSIFIER : ExpectedクラスIdentityにはデフォルトコンストラクターがない。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></td><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">actual </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Identity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    actual </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> confirmIdentity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;expect class fun: jvm&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></td></tr></table><p>この例では、expectedクラス<code>Identity</code>にはデフォルトコンストラクターがないため、共通コードで正常に呼び出すことができません。以前は、エラーはIDEによってのみ報告されましたが、コードはJVMでまだ正常にコンパイルされました。しかし、現在ではコンパイラーが正しくエラーを報告します。</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Expected class &#39;expect class Identity : Any&#39; does not have default constructor</span></span></code></pre></div><h5 id="解決動作が変わらない場合" tabindex="-1">解決動作が変わらない場合 <a class="header-anchor" href="#解決動作が変わらない場合" aria-label="Permalink to &quot;解決動作が変わらない場合&quot;">​</a></h5><p>現在も新しいコンパイルスキームへの移行の過程にあるため、同じソースセット内にない関数を呼び出す際の解決動作は依然として同じです。この違いは、マルチプラットフォームライブラリからのオーバーロードを共通コードで使用する際に、主に気づくでしょう。</p><p>例えば、2つの<code>whichFun()</code>関数が異なるシグネチャを持つライブラリがあるとします。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 例のライブラリ</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// モジュール: common</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> whichFun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;common function&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// モジュール: JVM</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> whichFun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;platform function&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>共通コードで<code>whichFun()</code>関数を呼び出すと、ライブラリ内で最も関連性の高い引数型を持つ関数が解決されます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JVMターゲット向けに例のライブラリを使用するプロジェクト</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// モジュール: common</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    whichFun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // platform function</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>比較すると、同じソースセット内で<code>whichFun()</code>のオーバーロードを宣言した場合、コードがプラットフォーム固有のバージョンにアクセスできないため、共通コードの関数が解決されます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 例のライブラリは使用されていない</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// モジュール: common</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> whichFun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;common function&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    whichFun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // common function</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// モジュール: JVM</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> whichFun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;platform function&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>マルチプラットフォームライブラリと同様に、<code>commonTest</code>モジュールは別のソースセットにあるため、プラットフォーム固有のコードにアクセスできます。したがって、<code>commonTest</code>モジュール内の関数への呼び出しの解決は、以前のコンパイルスキームと同じ動作を示します。</p><p>将来的には、これらの残りのケースも新しいコンパイルスキームとより一貫性を持つようになるでしょう。</p><h4 id="expectedおよびactual宣言の異なる可視性レベル" tabindex="-1">expectedおよびactual宣言の異なる可視性レベル <a class="header-anchor" href="#expectedおよびactual宣言の異なる可視性レベル" aria-label="Permalink to &quot;expectedおよびactual宣言の異なる可視性レベル&quot;">​</a></h4><p>Kotlin 2.0.0より前は、Kotlin Multiplatformプロジェクトで<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-expect-actual.html" target="_blank" rel="noreferrer">expectedおよびactual宣言</a>を使用する場合、それらは同じ<a href="/ja/kotlin/visibility-modifiers">可視性レベル</a>を持つ必要がありました。Kotlin 2.0.0では、異なる可視性レベルもサポートするようになりましたが、これはactual宣言がexpected宣言よりも_許容範囲が広い_場合に<strong>のみ</strong>です。例えば：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">expect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">internal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Attribute</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 可視性はinternal</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">actual </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Attribute</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 可視性はデフォルトでpublicで、</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                                // より許容範囲が広い</span></span></code></pre></div><p>同様に、actual宣言で<a href="/ja/kotlin/type-aliases">型エイリアス</a>を使用している場合、<strong>基になる型の</strong>可視性はexpected宣言と同じか、より許容範囲が広いべきです。例えば：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">expect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">internal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Attribute</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                 // 可視性はinternal</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">internal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> actual </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typealias</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Attribute</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Expanded</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Expanded</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                                  // 可視性はデフォルトでpublicで、</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                                                // より許容範囲が広い</span></span></code></pre></div><h2 id="kotlin-k2コンパイラーを有効にする方法" tabindex="-1">Kotlin K2コンパイラーを有効にする方法 <a class="header-anchor" href="#kotlin-k2コンパイラーを有効にする方法" aria-label="Permalink to &quot;Kotlin K2コンパイラーを有効にする方法&quot;">​</a></h2><p>Kotlin 2.0.0以降、Kotlin K2コンパイラーはデフォルトで有効になっています。</p><p>Kotlinバージョンをアップグレードするには、<a href="/ja/kotlin/gradle-configure-project#apply-the-plugin">Gradle</a>および<a href="/ja/kotlin/maven#configure-and-enable-the-plugin">Maven</a>のビルドスクリプトで、バージョンを2.0.0以降に変更してください。</p><p>IntelliJ IDEAまたはAndroid Studioで最高の体験をするには、IDEで<a href="#support-in-ides">K2モードを有効にすること</a>を検討してください。</p>`,79),s("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"以前のideの動作",tabindex:"-1"},[a("以前のIDEの動作 "),s("a",{class:"header-anchor",href:"#以前のideの動作","aria-label":'Permalink to "以前のIDEの動作 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1),i(`<p>以前のIDEの動作に戻したい場合は、K2モードを無効にできます。</p><ol><li><strong>Settings</strong> | <strong>Languages &amp; Frameworks</strong> | <strong>Kotlin</strong> に移動します。</li><li><strong>Enable K2 mode</strong> オプションの選択を解除します。</li></ol><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Kotlin 2.1.0以降で<a href="/ja/kotlin/components-stability#stability-levels-explained">Stable</a>な言語機能を導入する予定です。それまでは、コード解析のために以前のIDE機能を使い続けることができ、認識されない言語機能によるコードハイライトの問題に遭遇することはないでしょう。</p></div><h2 id="kotlin-playgroundでkotlin-k2コンパイラーを試す" tabindex="-1">Kotlin PlaygroundでKotlin K2コンパイラーを試す <a class="header-anchor" href="#kotlin-playgroundでkotlin-k2コンパイラーを試す" aria-label="Permalink to &quot;Kotlin PlaygroundでKotlin K2コンパイラーを試す&quot;">​</a></h2><p>Kotlin Playgroundは、Kotlin 2.0.0以降のリリースをサポートしています。<a href="https://pl.kotl.in/czuoQprce" target="_blank" rel="noreferrer">試してみましょう！</a></p><h2 id="以前のコンパイラーにロールバックする方法" tabindex="-1">以前のコンパイラーにロールバックする方法 <a class="header-anchor" href="#以前のコンパイラーにロールバックする方法" aria-label="Permalink to &quot;以前のコンパイラーにロールバックする方法&quot;">​</a></h2><p>Kotlin 2.0.0以降のリリースで以前のコンパイラーを使用するには、以下のいずれかを実行します。</p><ul><li><p><code>build.gradle.kts</code>ファイルで、<a href="/ja/kotlin/gradle-compiler-options#example-of-setting-languageversion">言語バージョン</a>を<code>1.9</code>に設定します。</p><p>または</p></li><li><p>以下のコンパイラーオプションを使用します：<code>-language-version 1.9</code>。</p></li></ul><h2 id="変更点" tabindex="-1">変更点 <a class="header-anchor" href="#変更点" aria-label="Permalink to &quot;変更点&quot;">​</a></h2><p>新しいフロントエンドの導入により、Kotlinコンパイラーはいくつかの変更を経験しました。まずは、コードに影響を与える最も重要な変更点を強調し、何が変わったかを説明し、今後のベストプラクティスを詳述することから始めましょう。詳細を知りたい場合は、さらなる読書を容易にするために、これらの変更を<a href="#per-subject-area">主題領域</a>に整理しました。</p><p>このセクションでは、以下の変更点を強調します。</p><ul><li><a href="#immediate-initialization-of-open-properties-with-backing-fields">バッキングフィールドを持つopenプロパティの即時初期化</a></li><li><a href="#deprecated-synthetics-setter-on-a-projected-receiver">投影されたレシーバー上の合成セッターの非推奨化</a></li><li><a href="#forbidden-use-of-inaccessible-generic-types">アクセス不可能なジェネリック型の使用禁止</a></li><li><a href="#consistent-resolution-order-of-kotlin-properties-and-java-fields-with-the-same-name">KotlinプロパティとJavaフィールドが同じ名前を持つ場合の解決順序の一貫性</a></li><li><a href="#improved-null-safety-for-java-primitive-arrays">Javaプリミティブ配列のnull安全性の改善</a></li><li><a href="#stricter-rules-for-abstract-members-in-expected-classes">expectedクラスにおける抽象メンバーのより厳格なルール</a></li></ul><h3 id="バッキングフィールドを持つopenプロパティの即時初期化" tabindex="-1">バッキングフィールドを持つopenプロパティの即時初期化 <a class="header-anchor" href="#バッキングフィールドを持つopenプロパティの即時初期化" aria-label="Permalink to &quot;バッキングフィールドを持つopenプロパティの即時初期化&quot;">​</a></h3><p><strong>変更点</strong></p><p>Kotlin 2.0では、バッキングフィールドを持つすべての<code>open</code>プロパティは直ちに初期化されなければなりません。そうしないと、コンパイルエラーが発生します。以前は<code>open var</code>プロパティのみが直ちに初期化される必要がありましたが、現在ではバッキングフィールドを持つ<code>open val</code>プロパティにも拡張されます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">open</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    open</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    open</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Kotlin 2.0からエラーとなるが、以前は正常にコンパイルされていた </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //Error: open val must have initializer</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 常にエラー</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Error: open var must have initializer</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Derived</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>この変更により、コンパイラーの動作がより予測可能になります。<code>open val</code>プロパティがカスタムセッターを持つ<code>var</code>プロパティによってオーバーライドされる例を考えてみましょう。</p><p>カスタムセッターが使用される場合、遅延初期化は混乱を招く可能性があります。なぜなら、バッキングフィールドを初期化したいのか、セッターを呼び出したいのかが不明瞭になるからです。以前は、セッターを呼び出したい場合、古いコンパイラーはセッターがバッキングフィールドを初期化することを保証できませんでした。</p><p><strong>現在のベストプラクティス</strong></p><p>バッキングフィールドを持つopenプロパティは常に初期化することを推奨します。これは、より効率的でエラーが発生しにくいプラクティスであると我々は考えています。</p><p>ただし、プロパティをすぐに初期化しない場合は、次のことができます。</p><ul><li>プロパティを<code>final</code>にする。</li><li>遅延初期化を可能にするプライベートなバッキングプロパティを使用する。</li></ul><p>詳細については、<a href="https://youtrack.jetbrains.com/issue/KT-57555" target="_blank" rel="noreferrer">YouTrackの対応するイシュー</a>を参照してください。</p><h3 id="投影されたレシーバー上の合成セッターの非推奨化" tabindex="-1">投影されたレシーバー上の合成セッターの非推奨化 <a class="header-anchor" href="#投影されたレシーバー上の合成セッターの非推奨化" aria-label="Permalink to &quot;投影されたレシーバー上の合成セッターの非推奨化&quot;">​</a></h3><p><strong>変更点</strong></p><p>Javaクラスの合成セッターを使用して、クラスの投影型と競合する型を割り当てると、エラーがトリガーされます。</p><p><code>getFoo()</code>メソッドと<code>setFoo()</code>メソッドを含む<code>Container</code>という名前のJavaクラスがあるとします。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> E </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getFoo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setFoo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(E </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>Container</code>クラスのインスタンスが投影型を持つ以下のKotlinコードがある場合、<code>setFoo()</code>メソッドを使用すると常にエラーが生成されます。しかし、Kotlin 2.0.0からのみ、合成プロパティ<code>foo</code>がエラーをトリガーします。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> exampleFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(starProjected: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;*&gt;, inProjected: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">in</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, sampleString: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    starProjected.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setFoo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sampleString)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Kotlin 1.0以降エラー</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 合成セッター\`foo\`は\`setFoo()\`メソッドに解決される</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    starProjected.foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sampleString</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Kotlin 2.0.0以降エラー</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    inProjected.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setFoo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sampleString)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Kotlin 1.0以降エラー</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 合成セッター\`foo\`は\`setFoo()\`メソッドに解決される</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    inProjected.foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sampleString</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Kotlin 2.0.0以降エラー</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>現在のベストプラクティス</strong></p><p>この変更によってコードにエラーが発生する場合は、型宣言の構造を再考することをお勧めします。型投影を使用する必要がないか、あるいはコードから代入を削除する必要があるかもしれません。</p><p>詳細については、<a href="https://youtrack.jetbrains.com/issue/KT-54309" target="_blank" rel="noreferrer">YouTrackの対応するイシュー</a>を参照してください。</p><h3 id="アクセス不可能なジェネリック型の使用禁止" tabindex="-1">アクセス不可能なジェネリック型の使用禁止 <a class="header-anchor" href="#アクセス不可能なジェネリック型の使用禁止" aria-label="Permalink to &quot;アクセス不可能なジェネリック型の使用禁止&quot;">​</a></h3><p><strong>変更点</strong></p><p>K2コンパイラーの新しいアーキテクチャにより、アクセス不可能なジェネリック型の処理方法を変更しました。一般的に、コード内でアクセス不可能なジェネリック型に依存すべきではありません。これは、プロジェクトのビルド設定に誤りがあることを示しており、コンパイラーがコンパイルに必要な情報にアクセスできないようにするためです。Kotlin 2.0.0では、アクセス不可能なジェネリック型を持つ関数リテラルを宣言したり呼び出したりすることはできません。また、アクセス不可能なジェネリック型引数を持つジェネリック型を使用することもできません。この制限は、後でコードでコンパイラーエラーを回避するのに役立ちます。</p><p>例えば、あるモジュールでジェネリッククラスを宣言したとします。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// モジュール1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">V</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">V</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>モジュール1に依存関係が設定されている別のモジュール（モジュール2）がある場合、コードは<code>Node&lt;V&gt;</code>クラスにアクセスし、関数型で型として使用できます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// モジュール2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(func: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 関数は正常にコンパイルされる</span></span></code></pre></div><p>ただし、プロジェクトが誤って設定されており、モジュール2のみに依存する第3のモジュール（モジュール3）がある場合、Kotlinコンパイラーはモジュール3をコンパイルする際に<strong>モジュール1</strong>の<code>Node&lt;V&gt;</code>クラスにアクセスできなくなります。現在、<code>Node&lt;V&gt;</code>型を使用するモジュール3内のラムダまたは匿名関数は、Kotlin 2.0.0でエラーをトリガーし、これにより後でコードで回避可能なコンパイラーエラー、クラッシュ、および実行時例外を防ぎます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// モジュール3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 暗黙的なラムダパラメータ (it) の型がアクセス不可能なNodeに</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 解決されるため、Kotlin 2.0.0ではエラーが発生する</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 未使用のラムダパラメータ (_) の型がアクセス不可能なNodeに</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 解決されるため、Kotlin 2.0.0ではエラーが発生する</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 未使用の匿名関数のパラメータ (_) の型がアクセス不可能なNodeに</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 解決されるため、Kotlin 2.0.0ではエラーが発生する</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (_) {})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>アクセス不可能なジェネリック型の値パラメータを含む場合に、関数リテラルがエラーをトリガーするだけでなく、型がアクセス不可能なジェネリック型引数を持つ場合にもエラーが発生します。</p><p>例えば、モジュール1に同じジェネリッククラス宣言があるとします。モジュール2では、別のジェネリッククラス<code>Container&lt;C&gt;</code>を宣言します。さらに、モジュール2で、ジェネリッククラス<code>Node&lt;V&gt;</code>を型引数として<code>Container&lt;C&gt;</code>を使用する関数を宣言します。</p><table><tr><td>モジュール1</td><td>モジュール2</td></tr><tr><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// モジュール1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">V</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">V</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div></td><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// モジュール2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">vararg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> content: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ジェネリッククラス型を持つ関数で、</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ジェネリッククラス型引数も持つ</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> produce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> consume</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;) {}</span></span></code></pre></div></td></tr></table><p>モジュール3でこれらの関数を呼び出そうとすると、ジェネリッククラス<code>Node&lt;V&gt;</code>がモジュール3からアクセスできないため、Kotlin 2.0.0でエラーがトリガーされます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// モジュール3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ジェネリッククラスNode&lt;V&gt;がアクセス不可能なため、</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Kotlin 2.0.0でエラーが発生する</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    consume</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">produce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>将来のリリースでは、アクセス不可能な型の使用全般を非推奨にし続けます。Kotlin 2.0.0ではすでに、非ジェネリック型を含むアクセス不可能な型を使用するいくつかのシナリオで警告を追加することで開始しました。</p><p>例えば、前の例と同じモジュール設定を使用しますが、ジェネリッククラス<code>Node&lt;V&gt;</code>を非ジェネリッククラス<code>IntNode</code>に変更し、すべての関数をモジュール2で宣言するとします。</p><table><tr><td>モジュール1</td><td>モジュール2</td></tr><tr><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// モジュール1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IntNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div></td><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// モジュール2</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// \`IntNode\`型を持つラムダパラメータを含む関数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(func: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IntNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">vararg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> content: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// \`IntNode\`を型引数として持つジェネリッククラス型を持つ関数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> produce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IntNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IntNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> consume</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IntNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {}</span></span></code></pre></div></td></tr></table><p>モジュール3でこれらの関数を呼び出すと、いくつかの警告がトリガーされます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// モジュール3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // クラスIntNodeがアクセス不可能なため、</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Kotlin 2.0.0で警告が発生する。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // パラメータ &#39;it&#39; のクラス &#39;IntNode&#39; はアクセスできません。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (_) {})</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // パラメータ &#39;_&#39; のクラス &#39;IntNode&#39; はアクセスできません。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // IntNodeがアクセス不可能なため、</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 将来のKotlinリリースで警告がトリガーされるでしょう。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    consume</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">produce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>現在のベストプラクティス</strong></p><p>アクセス不可能なジェネリック型に関する新しい警告に遭遇した場合、ビルドシステムの設定に問題がある可能性が非常に高いです。ビルドスクリプトと設定を確認することを推奨します。</p><p>最終手段として、モジュール3からモジュール1への直接的な依存関係を設定できます。あるいは、同じモジュール内で型にアクセスできるようにコードを変更することもできます。</p><p>詳細については、<a href="https://youtrack.jetbrains.com/issue/KT-64474" target="_blank" rel="noreferrer">YouTrackの対応するイシュー</a>を参照してください。</p><h3 id="kotlinプロパティとjavaフィールドが同じ名前を持つ場合の解決順序の一貫性" tabindex="-1">KotlinプロパティとJavaフィールドが同じ名前を持つ場合の解決順序の一貫性 <a class="header-anchor" href="#kotlinプロパティとjavaフィールドが同じ名前を持つ場合の解決順序の一貫性" aria-label="Permalink to &quot;KotlinプロパティとJavaフィールドが同じ名前を持つ場合の解決順序の一貫性&quot;">​</a></h3><p><strong>変更点</strong></p><p>Kotlin 2.0.0より前は、JavaクラスとKotlinクラスが互いに継承し、同じ名前のKotlinプロパティとJavaフィールドを含む場合、重複した名前の解決動作が一貫していませんでした。また、IntelliJ IDEAとコンパイラーの間でも競合する動作がありました。Kotlin 2.0.0の新しい解決動作を開発する際、我々はユーザーへの影響を最小限に抑えることを目指しました。</p><p>例えば、<code>Base</code>というJavaクラスがあるとします。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;a&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;b&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>また、前述の<code>Base</code>クラスを継承する<code>Derived</code>というKotlinクラスがあるとします。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Derived</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;aa&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // カスタムget()関数を宣言する</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;bb&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Derived.aに解決される</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // aa</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Base.bに解決される</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // b</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Kotlin 2.0.0より前は、<code>a</code>は<code>Derived</code> Kotlinクラス内のKotlinプロパティに解決され、<code>b</code>は<code>Base</code> Javaクラス内のJavaフィールドに解決されました。</p><p>Kotlin 2.0.0では、例での解決動作は一貫しており、Kotlinプロパティが同じ名前のJavaフィールドを置き換えることを保証します。現在、<code>b</code>は<code>Derived.b</code>に解決されます。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Kotlin 2.0.0より前は、IntelliJ IDEAを使用して<code>a</code>の宣言または使用箇所に移動すると、Kotlinプロパティに移動すべきだったにもかかわらず、誤ってJavaフィールドに移動しました。 Kotlin 2.0.0からは、IntelliJ IDEAはコンパイラーと同じ場所に正しく移動します。</p></div><p>一般的なルールとして、サブクラスが優先されます。前の例ではこれを示しており、<code>Derived</code>が<code>Base</code> Javaクラスのサブクラスであるため、<code>Derived</code>クラスのKotlinプロパティ<code>a</code>が解決されます。</p><p>継承が逆転し、JavaクラスがKotlinクラスを継承する場合には、サブクラスのJavaフィールドが、同じ名前のKotlinプロパティよりも優先されます。</p><p>この例を考えてみましょう。</p><table><tr><td>Kotlin</td><td>Java</td></tr><tr><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">open</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;aa&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></td><td><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Derived</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;a&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></td></tr></table><p>そして、以下のコードでは：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Derived.aに解決される</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // a</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>現在のベストプラクティス</strong></p><p>この変更がコードに影響を与える場合は、本当に重複した名前を使用する必要があるかを検討してください。それぞれが同じ名前のフィールドまたはプロパティを含み、互いに継承するJavaまたはKotlinクラスを持ちたい場合は、サブクラスのフィールドまたはプロパティが優先されることを覚えておいてください。</p><p>詳細については、<a href="https://youtrack.jetbrains.com/issue/KT-55017" target="_blank" rel="noreferrer">YouTrackの対応するイシュー</a>を参照してください。</p><h3 id="javaプリミティブ配列のnull安全性の改善" tabindex="-1">Javaプリミティブ配列のnull安全性の改善 <a class="header-anchor" href="#javaプリミティブ配列のnull安全性の改善" aria-label="Permalink to &quot;Javaプリミティブ配列のnull安全性の改善&quot;">​</a></h3><p><strong>変更点</strong></p><p>Kotlin 2.0.0以降、コンパイラーはKotlinにインポートされたJavaプリミティブ配列のnull許容性を正しく推論します。現在、Javaプリミティブ配列とともに使用される<code>TYPE_USE</code>アノテーションからのネイティブなnull許容性を保持し、それらの値がアノテーションに従って使用されていない場合にエラーを発生させます。</p><p>通常、<code>@Nullable</code>および<code>@NotNull</code>アノテーションを持つJava型がKotlinから呼び出されると、適切なネイティブなnull許容性を受け取ります。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DataService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ResultContainer&lt;@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nullable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dataService: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DataService</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dataService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// -&gt; ResultContainer&lt;String?&gt;</span></span></code></pre></div><p>しかし、以前はJavaプリミティブ配列がKotlinにインポートされた場合、すべての<code>TYPE_USE</code>アノテーションが失われ、プラットフォームのnull許容性となり、安全でないコードにつながる可能性がありました。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DataProvider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nullable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dataService: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DataProvider</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dataService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// -&gt; IntArray .. IntArray?</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// dataService.fetchData()はアノテーションによると\`null\`である可能性があるにもかかわらず、エラーなし</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// これによりNullPointerExceptionが発生する可能性がある</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dataService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>この問題は、宣言自体に対するnull許容性アノテーションには影響せず、<code>TYPE_USE</code>アノテーションのみに影響したことに注意してください。</p><p><strong>現在のベストプラクティス</strong></p><p>Kotlin 2.0.0では、Javaプリミティブ配列のnull安全性がKotlinで標準となったため、使用している場合は新しい警告とエラーについてコードを確認してください。</p><ul><li>明示的なnull許容性チェックなしで<code>@Nullable</code> Javaプリミティブ配列を使用するコード、またはnull許容でないプリミティブ配列を期待するJavaメソッドに<code>null</code>を渡そうとするコードは、これからはコンパイルに失敗します。</li><li><code>@NotNull</code>プリミティブ配列をnull許容性チェックとともに使用すると、「不必要なセーフコール」または「nullとの比較は常にfalse」の警告が発せられます。</li></ul><p>詳細については、<a href="https://youtrack.jetbrains.com/issue/KT-54521" target="_blank" rel="noreferrer">YouTrackの対応するイシュー</a>を参照してください。</p><h3 id="expectedクラスにおける抽象メンバーのより厳格なルール" tabindex="-1">expectedクラスにおける抽象メンバーのより厳格なルール <a class="header-anchor" href="#expectedクラスにおける抽象メンバーのより厳格なルール" aria-label="Permalink to &quot;expectedクラスにおける抽象メンバーのより厳格なルール&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>expectedおよびactualクラスは<a href="/ja/kotlin/components-stability#stability-levels-explained">ベータ</a>版です。これらはほぼ安定していますが、将来的には移行手順を実行する必要があるかもしれません。皆様が行うべきさらなる変更を最小限に抑えるよう最善を尽くします。</p></div><p><strong>変更点</strong></p><p>K2コンパイラーを使用したコンパイル時の共通ソースとプラットフォームソースの分離により、expectedクラスの抽象メンバーに対してより厳格なルールを実装しました。</p><p>以前のコンパイラーでは、expectedな非抽象クラスが<a href="/ja/kotlin/inheritance#overriding-rules">関数をオーバーライドする</a>ことなく抽象関数を継承することが可能でした。コンパイラーが共通コードとプラットフォームコードの両方に同時にアクセスできたため、コンパイラーは抽象関数がactualクラスに対応するオーバーライドと定義を持っているかどうかを確認できました。</p><p>現在、共通ソースとプラットフォームソースは別々にコンパイルされるため、継承された関数はexpectedクラスで明示的にオーバーライドされ、コンパイラーがその関数が抽象でないことを認識するようにしなければなりません。そうしないと、コンパイラーは<code>ABSTRACT_MEMBER_NOT_IMPLEMENTED</code>エラーを報告します。</p><p>例えば、共通ソースセットで、抽象関数<code>listFiles()</code>を持つ<code>FileSystem</code>という抽象クラスを宣言したとします。<code>listFiles()</code>関数は、actual宣言の一部としてプラットフォームソースセットで定義します。</p><p>共通コードで、<code>FileSystem</code>クラスを継承する<code>PlatformFileSystem</code>というexpectedな非抽象クラスがある場合、<code>PlatformFileSystem</code>クラスは抽象関数<code>listFiles()</code>を継承します。しかし、Kotlinでは非抽象クラスに抽象関数を持つことはできません。<code>listFiles()</code>関数を非抽象にするには、<code>abstract</code>キーワードなしでオーバーライドとして宣言する必要があります。</p><table><tr><td>共通コード</td><td>プラットフォームコード</td></tr><tr><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FileSystem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listFiles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">expect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">open</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PlatformFileSystem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FileSystem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Kotlin 2.0.0では、明示的なオーバーライドが必要である</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    expect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listFiles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Kotlin 2.0.0より前は、オーバーライドは不要だった</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></td><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">actual </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">open</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PlatformFileSystem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FileSystem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    actual </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listFiles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></td></tr></table><p><strong>現在のベストプラクティス</strong></p><p>expectedな非抽象クラスで抽象関数を継承する場合は、非抽象オーバーライドを追加してください。</p><p>詳細については、<a href="https://youtrack.jetbrains.com/issue/KT-59739/K2-MPP-reports-ABSTRACTMEMBERNOTIMPLEMENTED-for-inheritor-in-common-code-when-the-implementation-is-located-in-the-actual" target="_blank" rel="noreferrer">YouTrack</a>の対応するイシューを参照してください。</p><h3 id="主題領域別" tabindex="-1">主題領域別 <a class="header-anchor" href="#主題領域別" aria-label="Permalink to &quot;主題領域別&quot;">​</a></h3><p>これらの主題領域には、コードに影響を与える可能性は低いが、さらなる読書のために関連するYouTrackイシューへのリンクを提供する変更点がリストされています。Issue IDの横にアスタリスク (*) が付いている変更は、セクションの冒頭で説明されています。</p>`,103),s("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"型推論",tabindex:"-1"},[a("型推論 "),s("a",{class:"header-anchor",href:"#型推論","aria-label":'Permalink to "型推論 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1),i('<table tabindex="0"><thead><tr><th>Issue ID</th><th>タイトル</th></tr></thead><tbody><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-64189" target="_blank" rel="noreferrer">KT-64189</a></td><td>プロパティ参照のコンパイル済み関数シグネチャの型が明示的にNormalの場合の誤った型</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-47986" target="_blank" rel="noreferrer">KT-47986</a></td><td>ビルダー推論コンテキストで型変数を上限に暗黙的に推論することを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-59275" target="_blank" rel="noreferrer">KT-59275</a></td><td>K2: 配列リテラル内のジェネリックアノテーション呼び出しに明示的な型引数を要求する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-53752" target="_blank" rel="noreferrer">KT-53752</a></td><td>交差型に対するサブタイピングチェックの漏れ</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-59138" target="_blank" rel="noreferrer">KT-59138</a></td><td>KotlinにおけるJava型パラメータに基づく型のデフォルト表現を変更する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-57178" target="_blank" rel="noreferrer">KT-57178</a></td><td>前置インクリメントの推論された型を、inc()演算子の戻り値の型ではなくゲッターの戻り値の型に変更する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-57609" target="_blank" rel="noreferrer">KT-57609</a></td><td>K2: 反変パラメータに使用される@UnsafeVarianceの存在に依存するのをやめる</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-57620" target="_blank" rel="noreferrer">KT-57620</a></td><td>K2: 生の型に対して包含されたメンバーへの解決を禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-64641" target="_blank" rel="noreferrer">KT-64641</a></td><td>K2: 拡張関数パラメータを持つ呼び出し可能への呼び出し可能参照の型を適切に推論する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-57011" target="_blank" rel="noreferrer">KT-57011</a></td><td>分解変数の実際の型を、明示的な型が指定された場合に一貫させる</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-38895" target="_blank" rel="noreferrer">KT-38895</a></td><td>K2: 整数リテラルのオーバーフローにおける一貫性のない動作を修正する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-54862" target="_blank" rel="noreferrer">KT-54862</a></td><td>型引数からの匿名関数から匿名型が公開される可能性がある</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-22379" target="_blank" rel="noreferrer">KT-22379</a></td><td>breakを持つwhileループの条件が不正なスマートキャストを生成する可能性がある</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-62507" target="_blank" rel="noreferrer">KT-62507</a></td><td>K2: expect/actualトップレベルプロパティに対する共通コードでのスマートキャストを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-65750" target="_blank" rel="noreferrer">KT-65750</a></td><td>戻り値の型を変更するインクリメント演算子とプラス演算子はスマートキャストに影響を与える必要がある</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-65349" target="_blank" rel="noreferrer">KT-65349</a></td><td>[LC] K2: 変数型を明示的に指定すると、K1で動作していた一部のケースでバウンドスマートキャストが機能しなくなる</td></tr></tbody></table>',1),s("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"ジェネリクス",tabindex:"-1"},[a("ジェネリクス "),s("a",{class:"header-anchor",href:"#ジェネリクス","aria-label":'Permalink to "ジェネリクス {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1),i('<table tabindex="0"><thead><tr><th>Issue ID</th><th>タイトル</th></tr></thead><tbody><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-54309" target="_blank" rel="noreferrer">KT-54309</a>*</td><td><a href="#deprecated-synthetics-setter-on-a-projected-receiver">投影されたレシーバー上の合成セッターの使用を非推奨にする</a></td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-57600" target="_blank" rel="noreferrer">KT-57600</a></td><td>生型パラメータを持つJavaメソッドをジェネリック型パラメータでオーバーライドすることを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-54663" target="_blank" rel="noreferrer">KT-54663</a></td><td>null許容性のある型パラメータを`in`投影されたDNNパラメータに渡すことを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-54066" target="_blank" rel="noreferrer">KT-54066</a></td><td>型エイリアスのコンストラクターにおける上限違反を非推奨にする</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-49404" target="_blank" rel="noreferrer">KT-49404</a></td><td>Javaクラスに基づく反変なキャプチャ型に対する型不正を修正する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-61718" target="_blank" rel="noreferrer">KT-61718</a></td><td>自己上限とキャプチャ型を持つ不正なコードを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-61749" target="_blank" rel="noreferrer">KT-61749</a></td><td>ジェネリックアウタークラスのジェネリックインナークラスにおける不正なバウンド違反を禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-62923" target="_blank" rel="noreferrer">KT-62923</a></td><td>K2: インナークラスの外側のスーパータイプの投影に対するPROJECTION_IN_IMMEDIATE_ARGUMENT_TO_SUPERTYPEを導入する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-63243" target="_blank" rel="noreferrer">KT-63243</a></td><td>別のスーパータイプからの追加の特殊化された実装を持つプリミティブのコレクションから継承する場合にMANY_IMPL_MEMBER_NOT_IMPLEMENTEDを報告する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-60305" target="_blank" rel="noreferrer">KT-60305</a></td><td>K2: 展開型に共変性修飾子を持つ型エイリアスでのコンストラクター呼び出しと継承を禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-64965" target="_blank" rel="noreferrer">KT-64965</a></td><td>自己上限を持つキャプチャ型の不適切な処理によって引き起こされる型ホールの修正</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-64966" target="_blank" rel="noreferrer">KT-64966</a></td><td>ジェネリックパラメータに誤った型を持つジェネリック委譲コンストラクター呼び出しを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-65712" target="_blank" rel="noreferrer">KT-65712</a></td><td>上限がキャプチャ型である場合に、不足している上限違反を報告する</td></tr></tbody></table>',1),s("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"解決",tabindex:"-1"},[a("解決 "),s("a",{class:"header-anchor",href:"#解決","aria-label":'Permalink to "解決 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1),i('<table tabindex="0"><thead><tr><th>Issue ID</th><th>タイトル</th></tr></thead><tbody><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-55017" target="_blank" rel="noreferrer">KT-55017</a>*</td><td><a href="#consistent-resolution-order-of-kotlin-properties-and-java-fields-with-the-same-name">オーバーロード解決時に、基底クラスのJavaフィールドよりも派生クラスのKotlinプロパティを選択する</a></td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-58260" target="_blank" rel="noreferrer">KT-58260</a></td><td><code>invoke</code>規約が期待される脱糖と一貫して動作するようにする</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-62866" target="_blank" rel="noreferrer">KT-62866</a></td><td>K2: コンパニオンオブジェクトが静的スコープよりも優先される場合の修飾子解決動作を変更する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-57750" target="_blank" rel="noreferrer">KT-57750</a></td><td>型を解決し、同じ名前のクラスがスターインポートされている場合に曖昧性エラーを報告する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-63558" target="_blank" rel="noreferrer">KT-63558</a></td><td>K2: COMPATIBILITY_WARNINGに関する解決を移行する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-51194" target="_blank" rel="noreferrer">KT-51194</a></td><td>同じ依存関係の2つの異なるバージョンに含まれる依存クラスがある場合のCONFLICTING_INHERITED_MEMBERSの偽陰性</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-37592" target="_blank" rel="noreferrer">KT-37592</a></td><td>レシーバーを持つ関数型のプロパティinvokeは、拡張関数invokeよりも優先される</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-51666" target="_blank" rel="noreferrer">KT-51666</a></td><td>修飾された<code>this</code>: 型ケースで修飾された<code>this</code>を導入/優先する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-54166" target="_blank" rel="noreferrer">KT-54166</a></td><td>クラスパスにおけるFQ名競合の場合の未指定動作を確認する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-64431" target="_blank" rel="noreferrer">KT-64431</a></td><td>K2: インポートで型エイリアスを修飾子として使用することを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-56520" target="_blank" rel="noreferrer">KT-56520</a></td><td>K1/K2: 下位レベルで曖昧性を持つ型参照に対する解決タワーの誤動作</td></tr></tbody></table>',1),s("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"可視性",tabindex:"-1"},[a("可視性 "),s("a",{class:"header-anchor",href:"#可視性","aria-label":'Permalink to "可視性 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1),i('<table tabindex="0"><thead><tr><th>Issue ID</th><th>タイトル</th></tr></thead><tbody><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-64474/" target="_blank" rel="noreferrer">KT-64474</a>*</td><td><a href="#forbidden-use-of-inaccessible-generic-types">アクセス不可能な型の使用を未指定動作として宣言する</a></td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-55179" target="_blank" rel="noreferrer">KT-55179</a></td><td>内部インライン関数からプライベートクラスのコンパニオンオブジェクトメンバーを呼び出す際のPRIVATE_CLASS_MEMBER_FROM_INLINEの偽陰性</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-58042" target="_blank" rel="noreferrer">KT-58042</a></td><td>オーバーライドされた宣言が可視であっても、同等のゲッターが不可視の場合、合成プロパティを不可視にする</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-64255" target="_blank" rel="noreferrer">KT-64255</a></td><td>別のモジュールの派生クラスから内部セッターにアクセスすることを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-33917" target="_blank" rel="noreferrer">KT-33917</a></td><td>プライベートインライン関数から匿名型を公開することを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-54997" target="_blank" rel="noreferrer">KT-54997</a></td><td>public-APIインライン関数からの暗黙的な非public-APIアクセスを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-56310" target="_blank" rel="noreferrer">KT-56310</a></td><td>スマートキャストはprotectedメンバーの可視性に影響を与えるべきではない</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-65494" target="_blank" rel="noreferrer">KT-65494</a></td><td>publicインライン関数から見落とされたプライベート演算子関数へのアクセスを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-65004" target="_blank" rel="noreferrer">KT-65004</a></td><td>K1: protected valをオーバーライドするvarのセッターがpublicとして生成される</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-64972" target="_blank" rel="noreferrer">KT-64972</a></td><td>Kotlin/Nativeのリンク時においてプライベートメンバーによるオーバーライドを禁止する</td></tr></tbody></table>',1),s("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"アノテーション",tabindex:"-1"},[a("アノテーション "),s("a",{class:"header-anchor",href:"#アノテーション","aria-label":'Permalink to "アノテーション {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1),i('<table tabindex="0"><thead><tr><th>Issue ID</th><th>タイトル</th></tr></thead><tbody><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-58723" target="_blank" rel="noreferrer">KT-58723</a></td><td>EXPRESSIONターゲットを持たないアノテーションでステートメントをアノテーション付けすることを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-49930" target="_blank" rel="noreferrer">KT-49930</a></td><td>`REPEATED_ANNOTATION`チェック中に括弧式を無視する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-57422" target="_blank" rel="noreferrer">KT-57422</a></td><td>K2: プロパティゲッターに対する使用箇所 &#39;get&#39; ターゲットアノテーションを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-46483" target="_blank" rel="noreferrer">KT-46483</a></td><td>where句の型パラメータに対するアノテーションを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-64299" target="_blank" rel="noreferrer">KT-64299</a></td><td>コンパニオンオブジェクトに対するアノテーションの解決において、コンパニオンスコープが無視される</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-64654" target="_blank" rel="noreferrer">KT-64654</a></td><td>K2: ユーザーとコンパイラー必須のアノテーション間に曖昧性が導入された</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-64527" target="_blank" rel="noreferrer">KT-64527</a></td><td>enum値のアノテーションはenum値クラスにコピーされるべきではない</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-63389" target="_blank" rel="noreferrer">KT-63389</a></td><td>K2: `()?`でラップされた型の互換性のないアノテーションに対して`WRONG_ANNOTATION_TARGET`が報告される</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-63388" target="_blank" rel="noreferrer">KT-63388</a></td><td>K2: catchパラメータ型の注釈に対して`WRONG_ANNOTATION_TARGET`が報告される</td></tr></tbody></table>',1),s("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"null安全性",tabindex:"-1"},[a("null安全性 "),s("a",{class:"header-anchor",href:"#null安全性","aria-label":'Permalink to "null安全性 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1),i('<table tabindex="0"><thead><tr><th>Issue ID</th><th>タイトル</th></tr></thead><tbody><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-54521" target="_blank" rel="noreferrer">KT-54521</a>*</td><td><a href="#improved-null-safety-for-java-primitive-arrays">JavaでNullableとしてアノテーション付けされた配列型の安全でない使用を非推奨にする</a></td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-41034" target="_blank" rel="noreferrer">KT-41034</a></td><td>K2: セーフコールと規約演算子の組み合わせに対する評価セマンティクスを変更する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-50850" target="_blank" rel="noreferrer">KT-50850</a></td><td>スーパタイプの順序は継承された関数のnull許容パラメータを定義する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-53982" target="_blank" rel="noreferrer">KT-53982</a></td><td>publicシグネチャでローカル型を近似する際にnull許容性を保持する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-62998" target="_blank" rel="noreferrer">KT-62998</a></td><td>null許容値を非nullのJavaフィールドに割り当てることを、安全でない代入のセレクターとして禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-63209" target="_blank" rel="noreferrer">KT-63209</a></td><td>警告レベルのJava型のエラーレベルのnull許容引数に対する不足しているエラーを報告する</td></tr></tbody></table>',1),s("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"java相互運用性",tabindex:"-1"},[a("Java相互運用性 "),s("a",{class:"header-anchor",href:"#java相互運用性","aria-label":'Permalink to "Java相互運用性 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1),i('<table tabindex="0"><thead><tr><th>Issue ID</th><th>タイトル</th></tr></thead><tbody><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-53061" target="_blank" rel="noreferrer">KT-53061</a></td><td>ソース内で同じFQ名を持つJavaとKotlinのクラスを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-49882" target="_blank" rel="noreferrer">KT-49882</a></td><td>Javaコレクションから継承されたクラスは、スーパタイプの順序によって一貫性のない動作をする</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-66324" target="_blank" rel="noreferrer">KT-66324</a></td><td>K2: KotlinプライベートクラスからのJavaクラス継承の場合における未指定動作</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-66220" target="_blank" rel="noreferrer">KT-66220</a></td><td>Javaの可変長引数メソッドをインライン関数に渡すと、実行時に単一の配列ではなく配列の配列になる</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-66204" target="_blank" rel="noreferrer">KT-66204</a></td><td>K-J-K階層で内部メンバーをオーバーライドできるようにする</td></tr></tbody></table>',1),s("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"プロパティ",tabindex:"-1"},[a("プロパティ "),s("a",{class:"header-anchor",href:"#プロパティ","aria-label":'Permalink to "プロパティ {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1),i('<table tabindex="0"><thead><tr><th>Issue ID</th><th>タイトル</th></tr></thead><tbody><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-57555" target="_blank" rel="noreferrer">KT-57555</a>*</td><td><a href="#immediate-initialization-of-open-properties-with-backing-fields">[LC] バッキングフィールドを持つopenプロパティの遅延初期化を禁止する</a></td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-58589" target="_blank" rel="noreferrer">KT-58589</a></td><td>プライマリコンストラクターが存在しない場合、またはクラスがローカルである場合に、見落とされたMUST_BE_INITIALIZEDを非推奨にする</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-64295" target="_blank" rel="noreferrer">KT-64295</a></td><td>プロパティに対する潜在的なinvoke呼び出しの場合に再帰的な解決を禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-57290" target="_blank" rel="noreferrer">KT-57290</a></td><td>基底クラスが別のモジュールからのものである場合に、見えない派生クラスからの基底クラスプロパティに対するスマートキャストを非推奨にする</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-62661" target="_blank" rel="noreferrer">KT-62661</a></td><td>K2: データクラスプロパティに対するOPT_IN_USAGE_ERRORの漏れ</td></tr></tbody></table>',1),s("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"制御フロー",tabindex:"-1"},[a("制御フロー "),s("a",{class:"header-anchor",href:"#制御フロー","aria-label":'Permalink to "制御フロー {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1),i('<table tabindex="0"><thead><tr><th>Issue ID</th><th>タイトル</th></tr></thead><tbody><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-56408" target="_blank" rel="noreferrer">KT-56408</a></td><td>K1とK2間でのクラス初期化ブロックにおけるCFAの一貫性のないルール</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-57871" target="_blank" rel="noreferrer">KT-57871</a></td><td>括弧内のelse分岐がないif条件におけるK1/K2の不整合</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-42995" target="_blank" rel="noreferrer">KT-42995</a></td><td>スコープ関数で初期化されたtry/catchブロックでの&quot;VAL_REASSIGNMENT&quot;の偽陰性</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-65724" target="_blank" rel="noreferrer">KT-65724</a></td><td>tryブロックからcatchおよびfinallyブロックへのデータフロー情報を伝播する</td></tr></tbody></table>',1),s("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"enumクラス",tabindex:"-1"},[a("Enumクラス "),s("a",{class:"header-anchor",href:"#enumクラス","aria-label":'Permalink to "Enumクラス {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1),i('<table tabindex="0"><thead><tr><th>Issue ID</th><th>タイトル</th></tr></thead><tbody><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-57608" target="_blank" rel="noreferrer">KT-57608</a></td><td>enumエントリの初期化中にenumクラスのコンパニオンオブジェクトへのアクセスを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-34372" target="_blank" rel="noreferrer">KT-34372</a></td><td>enumクラスにおける仮想インラインメソッドの見落とされたエラーを報告する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-52802" target="_blank" rel="noreferrer">KT-52802</a></td><td>プロパティ/フィールドとenumエントリ間の解決における曖昧性を報告する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-47310" target="_blank" rel="noreferrer">KT-47310</a></td><td>コンパニオンプロパティがenumエントリよりも優先される場合の修飾子解決動作を変更する</td></tr></tbody></table>',1),s("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"関数型-sam-インターフェース",tabindex:"-1"},[a("関数型（SAM）インターフェース "),s("a",{class:"header-anchor",href:"#関数型-sam-インターフェース","aria-label":'Permalink to "関数型（SAM）インターフェース {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1),i('<table tabindex="0"><thead><tr><th>Issue ID</th><th>タイトル</th></tr></thead><tbody><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-52628" target="_blank" rel="noreferrer">KT-52628</a></td><td>アノテーションなしでOptInを必要とするSAMコンストラクターの使用を非推奨にする</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-57014" target="_blank" rel="noreferrer">KT-57014</a></td><td>JDK関数インターフェースのSAMコンストラクターに対するラムダから不正なnull許容値で値を返すことを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-64342" target="_blank" rel="noreferrer">KT-64342</a></td><td>呼び出し可能参照のパラメータ型のSAM変換がCCEにつながる</td></tr></tbody></table>',1),s("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"コンパニオンオブジェクト",tabindex:"-1"},[a("コンパニオンオブジェクト "),s("a",{class:"header-anchor",href:"#コンパニオンオブジェクト","aria-label":'Permalink to "コンパニオンオブジェクト {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1),i('<table tabindex="0"><thead><tr><th>Issue ID</th><th>タイトル</th></tr></thead><tbody><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-54316" target="_blank" rel="noreferrer">KT-54316</a></td><td>コンパニオンオブジェクトのメンバーへの呼び出し外参照が無効なシグネチャを持つ</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-47313" target="_blank" rel="noreferrer">KT-47313</a></td><td>Vにコンパニオンがある場合の(V)::foo参照解決を変更する</td></tr></tbody></table>',1),s("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"その他",tabindex:"-1"},[a("その他 "),s("a",{class:"header-anchor",href:"#その他","aria-label":'Permalink to "その他 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1),i('<table tabindex="0"><thead><tr><th>Issue ID</th><th>タイトル</th></tr></thead><tbody><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-59739" target="_blank" rel="noreferrer">KT-59739</a>*</td><td>K2/MPPは、共通コードの継承者に対して、実装が実際の対応する箇所にある場合に[ABSTRACT_MEMBER_NOT_IMPLEMENTED]を報告する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-49015" target="_blank" rel="noreferrer">KT-49015</a></td><td>修飾された<code>this</code>: 潜在的なラベル競合の場合に動作を変更する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-56545" target="_blank" rel="noreferrer">KT-56545</a></td><td>Javaサブクラスにおける意図しない競合オーバーロードの場合のJVMバックエンドでの不正な関数マングリングを修正する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-62019" target="_blank" rel="noreferrer">KT-62019</a></td><td>[LCの問題] ステートメント位置での中断マークされた匿名関数の宣言を禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-55111" target="_blank" rel="noreferrer">KT-55111</a></td><td>OptIn: マーカーの下でデフォルト引数（デフォルト値を持つパラメータ）を持つコンストラクター呼び出しを禁止する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-61182" target="_blank" rel="noreferrer">KT-61182</a></td><td>変数に対する式とinvoke解決に対して、誤ってUnit変換が許可される</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-65776" target="_blank" rel="noreferrer">KT-65776</a></td><td>[LC] K2は`false &amp;&amp; ...`および`false || ...`を破壊する</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-65682" target="_blank" rel="noreferrer">KT-65682</a></td><td>[LC] `header`/`impl`キーワードを非推奨にする</td></tr><tr><td><a href="https://youtrack.jetbrains.com/issue/KT-45375" target="_blank" rel="noreferrer">KT-45375</a></td><td>デフォルトでinvokedynamic + LambdaMetafactoryを介してすべてのKotlinラムダを生成する</td></tr></tbody></table><h2 id="kotlinリリースとの互換性" tabindex="-1">Kotlinリリースとの互換性 <a class="header-anchor" href="#kotlinリリースとの互換性" aria-label="Permalink to &quot;Kotlinリリースとの互換性&quot;">​</a></h2><p>以下のKotlinリリースは、新しいK2コンパイラーをサポートしています。</p><table tabindex="0"><thead><tr><th>Kotlinリリース</th><th>安定性レベル</th></tr></thead><tbody><tr><td>2.0.0–2.2.10</td><td>Stable</td></tr><tr><td>1.9.20–1.9.25</td><td>Beta</td></tr><tr><td>1.9.0–1.9.10</td><td>JVMはBeta</td></tr><tr><td>1.7.0–1.8.22</td><td>Alpha</td></tr></tbody></table><h2 id="kotlinライブラリとの互換性" tabindex="-1">Kotlinライブラリとの互換性 <a class="header-anchor" href="#kotlinライブラリとの互換性" aria-label="Permalink to &quot;Kotlinライブラリとの互換性&quot;">​</a></h2><p>Kotlin/JVMを使用している場合、K2コンパイラーはどのバージョンのKotlinでコンパイルされたライブラリでも動作します。</p><p>Kotlin Multiplatformを使用している場合、K2コンパイラーはKotlinバージョン1.9.20以降でコンパイルされたライブラリで動作することが保証されています。</p><h2 id="コンパイラープラグインのサポート" tabindex="-1">コンパイラープラグインのサポート <a class="header-anchor" href="#コンパイラープラグインのサポート" aria-label="Permalink to &quot;コンパイラープラグインのサポート&quot;">​</a></h2><p>現在、Kotlin K2コンパイラーは以下のKotlinコンパイラープラグインをサポートしています。</p><ul><li><a href="/ja/kotlin/all-open-plugin"><code>all-open</code></a></li><li><a href="https://github.com/Kotlin/kotlinx-atomicfu" target="_blank" rel="noreferrer">AtomicFU</a></li><li><a href="https://github.com/JetBrains/kotlin/tree/master/plugins/jvm-abi-gen" target="_blank" rel="noreferrer"><code>jvm-abi-gen</code></a></li><li><a href="https://github.com/JetBrains/kotlin/tree/master/plugins/js-plain-objects" target="_blank" rel="noreferrer"><code>js-plain-objects</code></a></li><li><a href="/ja/kotlin/whatsnew1920#preview-kapt-compiler-plugin-with-k2">kapt</a></li><li><a href="/ja/kotlin/lombok">Lombok</a></li><li><a href="/ja/kotlin/no-arg-plugin"><code>no-arg</code></a></li><li><a href="https://plugins.gradle.org/plugin/org.jetbrains.kotlin.plugin.parcelize" target="_blank" rel="noreferrer">Parcelize</a></li><li><a href="/ja/kotlin/sam-with-receiver-plugin">SAM with receiver</a></li><li><a href="/ja/kotlin/serialization">Serialization</a></li></ul><p>さらに、Kotlin K2コンパイラーは以下をサポートしています。</p><ul><li><a href="https://developer.android.com/jetpack/compose" target="_blank" rel="noreferrer">Jetpack Compose</a> 1.5.0コンパイラープラグイン以降のバージョン。</li><li><a href="/ja/kotlin/ksp-overview">Kotlin Symbol Processing (KSP)</a> は<a href="https://android-developers.googleblog.com/2023/12/ksp2-preview-kotlin-k2-standalone.html" target="_blank" rel="noreferrer">KSP2</a>以降。</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>他に追加のコンパイラープラグインを使用している場合は、K2と互換性があるかどうかをドキュメントで確認してください。</p></div><h3 id="カスタムコンパイラープラグインをアップグレードする" tabindex="-1">カスタムコンパイラープラグインをアップグレードする <a class="header-anchor" href="#カスタムコンパイラープラグインをアップグレードする" aria-label="Permalink to &quot;カスタムコンパイラープラグインをアップグレードする&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>カスタムコンパイラープラグインは、<a href="/ja/kotlin/components-stability#stability-levels-explained">実験的</a>なプラグインAPIを使用します。そのため、APIはいつでも変更される可能性があり、後方互換性は保証できません。</p></div><p>アップグレードプロセスには、お持ちのカスタムプラグインの種類に応じて2つのパスがあります。</p><h4 id="バックエンドのみのコンパイラープラグイン" tabindex="-1">バックエンドのみのコンパイラープラグイン <a class="header-anchor" href="#バックエンドのみのコンパイラープラグイン" aria-label="Permalink to &quot;バックエンドのみのコンパイラープラグイン&quot;">​</a></h4><p>プラグインが<code>IrGenerationExtension</code>拡張ポイントのみを実装している場合、プロセスは他の新しいコンパイラーリリースと同じです。使用しているAPIに変更がないか確認し、必要に応じて変更を加えます。</p><h4 id="バックエンドおよびフロントエンドのコンパイラープラグイン" tabindex="-1">バックエンドおよびフロントエンドのコンパイラープラグイン <a class="header-anchor" href="#バックエンドおよびフロントエンドのコンパイラープラグイン" aria-label="Permalink to &quot;バックエンドおよびフロントエンドのコンパイラープラグイン&quot;">​</a></h4><p>プラグインがフロントエンド関連の拡張ポイントを使用している場合、新しいK2コンパイラーAPIを使用してプラグインを書き直す必要があります。新しいAPIの概要については、<a href="https://github.com/JetBrains/kotlin/blob/master/docs/fir/fir-plugins.md" target="_blank" rel="noreferrer">FIR Plugin API</a>を参照してください。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>カスタムコンパイラープラグインのアップグレードに関する質問がある場合は、弊社の<a href="https://kotlinlang.slack.com/archives/C7L3JB43G" target="_blank" rel="noreferrer">#compiler</a> Slackチャンネルに参加してください。最善を尽くしてサポートします。</p></div><h2 id="新しいk2コンパイラーに関するフィードバックを共有する" tabindex="-1">新しいK2コンパイラーに関するフィードバックを共有する <a class="header-anchor" href="#新しいk2コンパイラーに関するフィードバックを共有する" aria-label="Permalink to &quot;新しいK2コンパイラーに関するフィードバックを共有する&quot;">​</a></h2><p>皆様からのフィードバックを心よりお待ちしております！</p><ul><li>新しいK2コンパイラーへの移行中に直面した問題は、<a href="https://youtrack.jetbrains.com/newIssue?project=KT&amp;summary=K2+release+migration+issue&amp;description=Describe+the+problem+you+encountered+here.&amp;c=tag+k2-release-migration" target="_blank" rel="noreferrer">弊社のイシュートラッカー</a>で報告してください。</li><li><a href="https://www.jetbrains.com/help/idea/settings-usage-statistics.html" target="_blank" rel="noreferrer">使用状況統計の送信オプションを有効にして</a>、JetBrainsがK2の使用状況に関する匿名データを収集できるようにしてください。</li></ul>',24)]))}const b=l(h,[["render",k]]);export{u as __pageData,b as default};
