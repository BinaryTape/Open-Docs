import{_ as o,a as d,b as E}from"./chunks/wasm-debugger-improved.BQ6ItNQi.js";import{_ as g}from"./chunks/compiler-options-levels.DqXOqvYF.js";import{_ as c}from"./chunks/xcode-swift-export-run-script-phase.CN5rl4tW.js";import{_ as y,a as F}from"./chunks/wasm-custom-formatters-firefox.C2LVO8ja.js";import{_ as u,C as t,c as b,o as m,ag as e,j as s,a,G as n,w as l}from"./chunks/framework.Bksy39di.js";const _=JSON.parse('{"title":"Kotlin 2.1.0 有哪些新特性","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/whatsnew21.md","filePath":"kotlin/whatsnew21.md","lastUpdated":1754307826000}'),C={name:"kotlin/whatsnew21.md"},A={tabindex:"0"},f={style:{"text-align":"left"}};function v(B,i,D,q,K,x){const p=t("shortcut"),h=t("tab"),k=t("tabs"),r=t("list");return m(),b("div",null,[i[16]||(i[16]=e(`<h1 id="kotlin-2-1-0-有哪些新特性" tabindex="-1">Kotlin 2.1.0 有哪些新特性 <a class="header-anchor" href="#kotlin-2-1-0-有哪些新特性" aria-label="Permalink to &quot;Kotlin 2.1.0 有哪些新特性&quot;">​</a></h1><p><em><a href="/kotlin/releases#release-details">发布日期：2024 年 11 月 27 日</a></em></p><p>Kotlin 2.1.0 版本现已发布！以下是主要亮点：</p><ul><li><strong>新的语言特性抢先体验预览</strong>：<a href="#guard-conditions-in-when-with-a-subject">带主题的 <code>when</code> 表达式中的守卫条件</a>、 <a href="#non-local-break-and-continue">非局部 <code>break</code> 和 <code>continue</code></a>，以及<a href="#multi-dollar-string-interpolation">多美元符号字符串内插</a>。</li><li><strong>K2 编译器更新</strong>：<a href="#extra-compiler-checks">编译器检测方面更大的灵活性</a>以及 <a href="#improved-k2-kapt-implementation">kapt 实现的改进</a>。</li><li><strong>Kotlin Multiplatform</strong>：引入了 <a href="#basic-support-for-swift-export">Swift 导出基础支持</a>， <a href="#new-gradle-dsl-for-compiler-options-in-multiplatform-projects-promoted-to-stable">适用于编译器选项的稳定 Gradle DSL</a> 等。</li><li><strong>Kotlin/Native</strong>：<a href="#iosarm64-promoted-to-tier-1">改进了对 <code>iosArm64</code> 的支持</a>及其他更新。</li><li><strong>Kotlin/Wasm</strong>：多项更新，包括<a href="#support-for-incremental-compilation">对增量编译的支持</a>。</li><li><strong>Gradle 支持</strong>：<a href="#gradle-improvements">改进了与更新版 Gradle 和 Android Gradle 插件的兼容性</a>， 同时<a href="#new-api-for-kotlin-gradle-plugin-extensions">更新了 Kotlin Gradle 插件 API</a>。</li><li><strong>文档</strong>：<a href="#documentation-updates">Kotlin 文档的显著改进</a>。</li></ul><h2 id="ide-支持" tabindex="-1">IDE 支持 <a class="header-anchor" href="#ide-支持" aria-label="Permalink to &quot;IDE 支持&quot;">​</a></h2><p>支持 2.1.0 的 Kotlin 插件已捆绑在最新的 IntelliJ IDEA 和 Android Studio 中。 你无需在 IDE 中更新 Kotlin 插件。 你只需在构建脚本中将 Kotlin 版本更改为 2.1.0 即可。</p><p>关于详情，请参见 <a href="/kotlin/releases#update-to-a-new-kotlin-version">更新到新的 Kotlin 版本</a>。</p><h2 id="语言" tabindex="-1">语言 <a class="header-anchor" href="#语言" aria-label="Permalink to &quot;语言&quot;">​</a></h2><p>在发布包含 K2 编译器的 Kotlin 2.0.0 之后，JetBrains 团队正致力于通过新特性来改进语言。 在此版本中，我们很高兴地宣布几项新的语言设计改进。</p><p>这些特性已在抢先体验预览中提供，我们鼓励你尝试并分享你的反馈：</p><ul><li><a href="#guard-conditions-in-when-with-a-subject">带主题的 <code>when</code> 表达式中的守卫条件</a></li><li><a href="#non-local-break-and-continue">非局部 <code>break</code> 和 <code>continue</code></a></li><li><a href="#multi-dollar-string-interpolation">多美元符号内插：改进了字符串字面值中 <code>$ </code> 的处理</a></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>所有特性均已在最新 2024.3 版 IntelliJ IDEA 中提供 IDE 支持，且 K2 模式已启用。 欲了解更多，请参阅 <a href="https://blog.jetbrains.com/idea/2024/11/intellij-idea-2024-3/" target="_blank" rel="noreferrer">IntelliJ IDEA 2024.3 博客文章</a>。</p></div><p><a href="/kotlin/kotlin-language-features-and-proposals">查看 Kotlin 语言设计特性与提案的完整列表</a>。</p><p>此版本还带来了以下语言更新：</p><ul><li><a href="#support-for-requiring-opt-in-to-extend-apis"></a></li><li><a href="#improved-overload-resolution-for-functions-with-generic-types"></a></li><li><a href="#improved-exhaustiveness-checks-for-when-expressions-with-sealed-classes"></a></li></ul><h3 id="带主题的-when-表达式中的守卫条件" tabindex="-1">带主题的 <code>when</code> 表达式中的守卫条件 <a class="header-anchor" href="#带主题的-when-表达式中的守卫条件" aria-label="Permalink to &quot;带主题的 \`when\` 表达式中的守卫条件&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>此特性为<a href="/kotlin/kotlin-evolution-principles#pre-stable-features">抢先体验预览</a>特性， 需要显式选择加入（详见下文）。 欢迎在 <a href="https://youtrack.jetbrains.com/issue/KT-71140" target="_blank" rel="noreferrer">YouTrack</a> 中提供你的反馈。</p></div><p>从 2.1.0 开始，你可以在带主题的 <code>when</code> 表达式或语句中使用守卫条件。</p><p>守卫条件允许你为 <code>when</code> 表达式的分支包含多个条件， 使复杂的控制流更加显式和简洁，并扁平化代码结构。</p><p>要在分支中包含守卫条件，请将其置于主条件之后，用 <code>if</code> 分隔：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mouseHunter: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> feedCat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Dog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> breed: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> feedDog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> feedAnimal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(animal: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (animal) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Branch with only the primary condition. Calls \`feedDog()\` when \`animal\` is \`Dog\`</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Animal.Dog </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> animal.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">feedDog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Branch with both primary and guard conditions. Calls \`feedCat()\` when \`animal\` is \`Cat\` and is not \`mouseHunter\`</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Animal.Cat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">animal.mouseHunter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> animal.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">feedCat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Prints &quot;Unknown animal&quot; if none of the above conditions match</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Unknown animal&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在一个 <code>when</code> 表达式中，你可以组合包含守卫条件和不含守卫条件的分支。 包含守卫条件的分支中的代码仅当主条件和守卫条件都为 <code>true</code> 时才会运行。 如果主条件不匹配，则不会求值守卫条件。 此外，守卫条件支持 <code>else if</code>。</p><p>要在你的项目中启用守卫条件，请在命令行中使用以下编译器选项：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlinc</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Xwhen-guards</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main.kt</span></span></code></pre></div><p>或者将其添加到你的 Gradle 构建文件的 <code>compilerOptions {}</code> 代码块中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xwhen-guards&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="非局部-break-和-continue" tabindex="-1">非局部 <code>break</code> 和 <code>continue</code> <a class="header-anchor" href="#非局部-break-和-continue" aria-label="Permalink to &quot;非局部 \`break\` 和 \`continue\`&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>此特性为<a href="/kotlin/kotlin-evolution-principles#pre-stable-features">抢先体验预览</a>特性， 需要显式选择加入（详见下文）。 欢迎在 <a href="https://youtrack.jetbrains.com/issue/KT-1436" target="_blank" rel="noreferrer">YouTrack</a> 中提供你的反馈。</p></div><p>Kotlin 2.1.0 添加了另一个期待已久的特性预览：使用非局部 <code>break</code> 和 <code>continue</code> 的能力。 此特性扩展了你在内联函数作用域内可以使用的工具集，并减少了项目中的样板代码。</p><p>以前，你只能使用非局部返回。 现在，Kotlin 还支持非局部 <code>break</code> 和 <code>continue</code> <a href="/kotlin/returns">跳转表达式</a>。 这意味着你可以将它们应用于作为参数传递给包含循环的内联函数的 lambda 表达式中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> processList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (element </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elements) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> variable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nullableMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() ?: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            log.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">warning</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Element is null or invalid, continuing...&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            continue</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (variable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // If variable is zero, return true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>要在你的项目中尝试此特性，请在命令行中使用 <code>-Xnon-local-break-continue</code> 编译器选项：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlinc</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Xnon-local-break-continue</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main.kt</span></span></code></pre></div><p>或者将其添加到你的 Gradle 构建文件的 <code>compilerOptions {}</code> 代码块中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xnon-local-break-continue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我们计划在未来的 Kotlin 版本中将此特性稳定化。 如果你在使用非局部 <code>break</code> 和 <code>continue</code> 时遇到任何问题， 请向我们的<a href="https://youtrack.jetbrains.com/issue/KT-1436" target="_blank" rel="noreferrer">问题跟踪器</a>报告。</p><h3 id="多美元符号字符串内插" tabindex="-1">多美元符号字符串内插 <a class="header-anchor" href="#多美元符号字符串内插" aria-label="Permalink to &quot;多美元符号字符串内插&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>此特性为<a href="/kotlin/kotlin-evolution-principles#pre-stable-features">抢先体验预览</a>特性， 需要显式选择加入（详见下文）。 欢迎在 <a href="https://youtrack.jetbrains.com/issue/KT-2425" target="_blank" rel="noreferrer">YouTrack</a> 中提供你的反馈。</p></div><p>Kotlin 2.1.0 引入了对多美元符号字符串内插的支持， 改进了字符串字面值中美元符号 (<code>$</code>) 的处理方式。 此特性在需要多个美元符号的上下文（例如模板引擎、JSON schema 或其他数据格式）中非常有用。</p><p>Kotlin 中的字符串内插使用单个美元符号。 然而，在字符串中使用字面值美元符号（在金融数据和模板系统中很常见）需要变通方法，例如 <code>\${&#39;$&#39;}</code>。 启用多美元符号内插特性后，你可以配置需要多少个美元符号才能触发内插， 较少的美元符号将被视为字符串字面值。</p><p>以下是如何使用多美元符号字符串内插生成带有占位符的 JSON schema 多行字符串的示例：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KClass</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;*&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.jsonSchema : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$schema</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;: &quot;https://json-schema.org/draft/2020-12/schema&quot;,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$id</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;: &quot;https://example.com/product.schema.json&quot;,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$dynamicAnchor</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;: &quot;meta&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &quot;title&quot;: &quot;\${simpleName ?: qualifiedName ?: &quot;unknown&quot;}&quot;,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &quot;type&quot;: &quot;object&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    }</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span></code></pre></div><p>在此示例中，开头的 <code>$</code> 表示你需要<strong>两个美元符号</strong> (<code>$$</code>) 才能触发内插。 它防止 <code>$schema</code>、<code>$id</code> 和 <code>$dynamicAnchor</code> 被解释为内插标记。</p><p>当处理使用美元符号作为占位符语法的系统时，此方法尤其有用。</p><p>要启用此特性，请在命令行中使用以下编译器选项：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlinc</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Xmulti-dollar-interpolation</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main.kt</span></span></code></pre></div><p>或者，更新你的 Gradle 构建文件的 <code>compilerOptions {}</code> 代码块：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xmulti-dollar-interpolation&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>如果你的代码已经使用单个美元符号的标准字符串内插，则无需更改。 你可以在需要字符串中字面值美元符号时使用 <code>$</code>。</p><h3 id="支持要求显式选择加入才能扩展-api" tabindex="-1">支持要求显式选择加入才能扩展 API <a class="header-anchor" href="#支持要求显式选择加入才能扩展-api" aria-label="Permalink to &quot;支持要求显式选择加入才能扩展 API&quot;">​</a></h3><p>Kotlin 2.1.0 引入了 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-subclass-opt-in-required/" target="_blank" rel="noreferrer"><code>@SubclassOptInRequired</code></a> 注解， 它允许库作者要求用户在实现实验性接口或扩展实验性类之前进行显式选择加入。</p><p>当库 API 足够稳定可以但可能会随新的抽象函数而演进， 从而导致其继承不稳定时，此特性可能很有用。</p><p>要向 API 元素添加显式选择加入要求，请使用 <code>@SubclassOptInRequired</code> 注解并引用注解类：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@RequiresOptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">level </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RequiresOptIn.Level.WARNING,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Interfaces in this library are experimental&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">annotation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UnstableApi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@SubclassOptInRequired</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UnstableApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CoreLibraryApi</span></span></code></pre></div><p>在此示例中，<code>CoreLibraryApi</code> 接口要求用户在实现它之前进行显式选择加入。 用户可以这样进行选择加入：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UnstableApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyImplementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CoreLibraryApi</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>当你使用 <code>@SubclassOptInRequired</code> 注解要求显式选择加入时， 该要求不会传播到任何<a href="/kotlin/nested-classes">嵌套类或内部类</a>。</p></div><p>要查看如何在 API 中使用 <code>@SubclassOptInRequired</code> 注解的实际示例， 请查看 <code>kotlinx.coroutines</code> 库中的 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/" target="_blank" rel="noreferrer"><code>SharedFlow</code></a> 接口。</p><h3 id="改进了泛型函数重载解析" tabindex="-1">改进了泛型函数重载解析 <a class="header-anchor" href="#改进了泛型函数重载解析" aria-label="Permalink to &quot;改进了泛型函数重载解析&quot;">​</a></h3><p>以前，如果你有多个函数重载，其中一些具有泛型的值形参， 而另一些在相同位置具有函数类型，则解析行为有时可能不一致。</p><p>这导致了成员函数和扩展函数的不同行为。 例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> KeyValueStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">V</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">V</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lazyValue: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> V) {} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">V</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KeyValueStore</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">K, V</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">storeExtension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">V</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">V</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KeyValueStore</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">K, V</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">storeExtension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lazyValue: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> V) {} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kvs: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KeyValueStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Member functions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kvs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Resolves to 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kvs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Resolves to 2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Extension functions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kvs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">storeExtension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Resolves to 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kvs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">storeExtension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Doesn&#39;t resolve</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在此示例中，<code>KeyValueStore</code> 类有两个 <code>store()</code> 函数的重载， 其中一个重载具有泛型类型 <code>K</code> 和 <code>V</code> 的函数形参， 另一个具有返回泛型类型 <code>V</code> 的 lambda 函数。 类似地，扩展函数 <code>storeExtension()</code> 也有两个重载。</p><p>当调用 <code>store()</code> 函数时，无论是否带 lambda 函数， 编译器都能成功解析正确的重载。 然而，当扩展函数 <code>storeExtension()</code> 在调用时带 lambda 函数时， 编译器未能解析正确的重载，因为它错误地认为两个重载都适用。</p><p>为了解决这个问题，我们引入了一个新的启发式方法，以便编译器可以在函数形参（带有泛型类型）无法根据不同实参的信息接受 lambda 函数时， 丢弃一个可能的重载。 此更改使成员函数和扩展函数的行为保持一致， 并且默认在 Kotlin 2.1.0 中启用。</p><h3 id="改进了-when-表达式对密封类的穷尽性检测" tabindex="-1">改进了 <code>when</code> 表达式对密封类的穷尽性检测 <a class="header-anchor" href="#改进了-when-表达式对密封类的穷尽性检测" aria-label="Permalink to &quot;改进了 \`when\` 表达式对密封类的穷尽性检测&quot;">​</a></h3><p>在以前的 Kotlin 版本中，即使 <code>sealed class</code> 层次结构中的所有情况都已覆盖， 编译器也要求 <code>when</code> 表达式的类型形参具有密封上限时，添加 <code>else</code> 分支。 Kotlin 2.1.0 解决了并改进了此行为， 使穷尽性检测功能更强大，并允许你移除冗余的 <code>else</code> 分支， 使 <code>when</code> 表达式更简洁、更直观。</p><p>以下是演示此更改的示例：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Result</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">object</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Success</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (result) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Error </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Error!&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Success </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Requires no else branch</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="kotlin-k2-编译器" tabindex="-1">Kotlin K2 编译器 <a class="header-anchor" href="#kotlin-k2-编译器" aria-label="Permalink to &quot;Kotlin K2 编译器&quot;">​</a></h2><p>借助 Kotlin 2.1.0，K2 编译器现在在<a href="#extra-compiler-checks">处理编译器检测</a> 和<a href="#global-warning-suppression">警告</a>时提供了更大的灵活性，并<a href="#improved-k2-kapt-implementation">改进了对 kapt 插件的支持</a>。</p><h3 id="额外编译器检测" tabindex="-1">额外编译器检测 <a class="header-anchor" href="#额外编译器检测" aria-label="Permalink to &quot;额外编译器检测&quot;">​</a></h3><p>借助 Kotlin 2.1.0，你现在可以在 K2 编译器中启用额外检测。 这些是额外的声明、表达式和类型检测，通常对编译来说并非关键， 但如果你想验证以下情况，它们仍然很有用：</p><table tabindex="0"><thead><tr><th style="text-align:left;">检测类型</th><th style="text-align:left;">备注</th></tr></thead><tbody><tr><td style="text-align:left;"><code>REDUNDANT_NULLABLE</code></td><td style="text-align:left;">使用 <code>Boolean??</code> 而非 <code>Boolean?</code></td></tr><tr><td style="text-align:left;"><code>PLATFORM_CLASS_MAPPED_TO_KOTLIN</code></td><td style="text-align:left;">使用 <code>java.lang.String</code> 而非 <code>kotlin.String</code></td></tr><tr><td style="text-align:left;"><code>ARRAY_EQUALITY_OPERATOR_CAN_BE_REPLACED_WITH_EQUALS</code></td><td style="text-align:left;">使用 <code>arrayOf(&quot;&quot;) == arrayOf(&quot;&quot;)</code> 而非 <code>arrayOf(&quot;&quot;).contentEquals(arrayOf(&quot;&quot;))</code></td></tr><tr><td style="text-align:left;"><code>REDUNDANT_CALL_OF_CONVERSION_METHOD</code></td><td style="text-align:left;">使用 <code>42.toInt()</code> 而非 <code>42</code></td></tr><tr><td style="text-align:left;"><code>USELESS_CALL_ON_NOT_NULL</code></td><td style="text-align:left;">使用 <code>&quot;&quot;.orEmpty()</code> 而非 <code>&quot;&quot;</code></td></tr><tr><td style="text-align:left;"><code>REDUNDANT_SINGLE_EXPRESSION_STRING_TEMPLATE</code></td><td style="text-align:left;">使用 <code>&quot;$string&quot;</code> 而非 <code>string</code></td></tr><tr><td style="text-align:left;"><code>UNUSED_ANONYMOUS_PARAMETER</code></td><td style="text-align:left;">lambda 表达式中传递了形参但从未使用</td></tr><tr><td style="text-align:left;"><code>REDUNDANT_VISIBILITY_MODIFIER</code></td><td style="text-align:left;">使用 <code>public class Klass</code> 而非 <code>class Klass</code></td></tr><tr><td style="text-align:left;"><code>REDUNDANT_MODALITY_MODIFIER</code></td><td style="text-align:left;">使用 <code>final class Klass</code> 而非 <code>class Klass</code></td></tr><tr><td style="text-align:left;"><code>REDUNDANT_SETTER_PARAMETER_TYPE</code></td><td style="text-align:left;">使用 <code>set(value: Int)</code> 而非 <code>set(value)</code></td></tr><tr><td style="text-align:left;"><code>CAN_BE_VAL</code></td><td style="text-align:left;">定义了 <code>var local = 0</code> 但从不重新赋值，可以改为 <code>val local = 42</code></td></tr><tr><td style="text-align:left;"><code>ASSIGNED_VALUE_IS_NEVER_READ</code></td><td style="text-align:left;">定义了 <code>val local = 42</code> 但之后在代码中从未使用</td></tr><tr><td style="text-align:left;"><code>UNUSED_VARIABLE</code></td><td style="text-align:left;">定义了 <code>val local = 0</code> 但在代码中从未使用</td></tr><tr><td style="text-align:left;"><code>REDUNDANT_RETURN_UNIT_TYPE</code></td><td style="text-align:left;">使用 <code>fun foo(): Unit {}</code> 而非 <code>fun foo() {}</code></td></tr><tr><td style="text-align:left;"><code>UNREACHABLE_CODE</code></td><td style="text-align:left;">代码语句存在但从不能执行</td></tr></tbody></table><p>如果检测为 <code>true</code>，你将收到编译器警告并附带问题修复建议。</p><p>额外检测默认禁用。 要启用它们，请在命令行中使用 <code>-Wextra</code> 编译器选项，或在你的 Gradle 构建文件的 <code>compilerOptions {}</code> 代码块中指定 <code>extraWarnings</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        extraWarnings.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>有关如何定义和使用编译器选项的更多信息， 请参阅 <a href="/kotlin/gradle-compiler-options">Kotlin Gradle 插件中的编译器选项</a>。</p><h3 id="全局警告抑制" tabindex="-1">全局警告抑制 <a class="header-anchor" href="#全局警告抑制" aria-label="Permalink to &quot;全局警告抑制&quot;">​</a></h3><p>在 2.1.0 中，Kotlin 编译器获得了一项高度请求的特性——全局抑制警告的能力。</p><p>你现在可以通过在命令行中使用 <code>-Xsuppress-warning=WARNING_NAME</code> 语法或在构建文件的 <code>compilerOptions {}</code> 代码块中使用 <code>freeCompilerArgs</code> 属性， 来在整个项目中抑制特定警告。</p><p>例如，如果你的项目中启用了<a href="#extra-compiler-checks">额外编译器检测</a>但想抑制其中一个，请使用：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        extraWarnings.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xsuppress-warning=CAN_BE_VAL&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,83)),s("p",null,[i[2]||(i[2]=a("如果你想抑制警告但不知道其名称，请选择元素并点击灯泡图标（或使用 ")),n(p,null,{default:l(()=>i[0]||(i[0]=[a("Cmd + Enter")])),_:1}),i[3]||(i[3]=a("/")),n(p,null,{default:l(()=>i[1]||(i[1]=[a("Alt + Enter")])),_:1}),i[4]||(i[4]=a("）："))]),i[17]||(i[17]=s("p",null,[s("img",{src:o,alt:"警告名称意图",width:"500"})],-1)),i[18]||(i[18]=s("p",null,[a("新的编译器选项目前是"),s("a",{href:"/kotlin/components-stability#stability-levels-explained"},"实验性的"),a("。 以下详细信息也值得注意：")],-1)),s("ul",null,[i[8]||(i[8]=s("li",null,[s("p",null,"不允许抑制错误。")],-1)),i[9]||(i[9]=s("li",null,[s("p",null,"如果你传递了未知的警告名称，编译将导致错误。")],-1)),s("li",null,[i[7]||(i[7]=s("p",null,"你可以一次指定多个警告：",-1)),n(k,null,{default:l(()=>[n(h,{title:"命令行"},{default:l(()=>i[5]||(i[5]=[s("div",{class:"language-bash vp-adaptive-theme"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"bash"),s("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlinc"),s("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," -Xsuppress-warning=NOTHING_TO_INLINE"),s("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," -Xsuppress-warning=NO_TAIL_CALLS_FOUND"),s("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," main.kt")])])])],-1)])),_:1}),n(h,{title:"构建文件"},{default:l(()=>i[6]||(i[6]=[s("div",{class:"language-kotlin vp-adaptive-theme"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"kotlin"),s("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"// build.gradle.kts")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    compilerOptions"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        freeCompilerArgs."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"addAll"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"            listOf"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'                "-Xsuppress-warning=NOTHING_TO_INLINE"'),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},",")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'                "-Xsuppress-warning=NO_TAIL_CALLS_FOUND"')]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            )")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        )")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1})])]),i[19]||(i[19]=e(`<h3 id="改进的-k2-kapt-实现" tabindex="-1">改进的 K2 kapt 实现 <a class="header-anchor" href="#改进的-k2-kapt-实现" aria-label="Permalink to &quot;改进的 K2 kapt 实现&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>K2 编译器的 kapt 插件 (K2 kapt) 处于 <a href="/kotlin/components-stability#stability-levels-explained">Alpha</a> 状态。 它可能随时更改。 欢迎在 <a href="https://youtrack.jetbrains.com/issue/KT-71439/K2-kapt-feedback" target="_blank" rel="noreferrer">YouTrack</a> 中提供你的反馈。</p></div><p>目前，使用 <a href="/kotlin/kapt">kapt</a> 插件的项目默认使用 K1 编译器， 支持 Kotlin 版本高达 1.9。</p><p>在 Kotlin 1.9.20 中，我们推出了 K2 编译器的 kapt 插件 (K2 kapt) 的实验性实现。 我们现在改进了 K2 kapt 的内部实现，以缓解技术和性能问题。</p><p>虽然新的 K2 kapt 实现没有引入新特性， 但与之前的 K2 kapt 实现相比，其性能显著提高。 此外，K2 kapt 插件的行为现在更接近 K1 kapt。</p><p>要使用新的 K2 kapt 插件实现，请像之前启用 K2 kapt 插件一样启用它。 将以下选项添加到项目的 <code>gradle.properties</code> 文件中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kapt.use.k2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span></code></pre></div><p>在未来的版本中，K2 kapt 实现将默认启用，而不是 K1 kapt， 因此你将不再需要手动启用它。</p><p>在新实现稳定之前，我们非常感谢你的<a href="https://youtrack.jetbrains.com/issue/KT-71439/K2-kapt-feedback" target="_blank" rel="noreferrer">反馈</a>。</p><h3 id="针对无符号类型与非原语类型之间重载冲突的解析" tabindex="-1">针对无符号类型与非原语类型之间重载冲突的解析 <a class="header-anchor" href="#针对无符号类型与非原语类型之间重载冲突的解析" aria-label="Permalink to &quot;针对无符号类型与非原语类型之间重载冲突的解析&quot;">​</a></h3><p>此版本解决了在先前版本中可能发生的无符号类型和非原语类型函数重载冲突的解析问题， 例如以下示例：</p><h4 id="重载扩展函数" tabindex="-1">重载扩展函数 <a class="header-anchor" href="#重载扩展函数" aria-label="Permalink to &quot;重载扩展函数&quot;">​</a></h4><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">doStuff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Any&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UByte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">doStuff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;UByte&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uByte: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UByte</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UByte.MIN_VALUE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    uByte.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">doStuff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Overload resolution ambiguity before Kotlin 2.1.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在早期版本中，调用 <code>uByte.doStuff()</code> 会导致歧义，因为 <code>Any</code> 和 <code>UByte</code> 扩展都适用。</p><h4 id="重载顶层函数" tabindex="-1">重载顶层函数 <a class="header-anchor" href="#重载顶层函数" aria-label="Permalink to &quot;重载顶层函数&quot;">​</a></h4><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doStuff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Any&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doStuff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UByte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;UByte&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uByte: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UByte</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UByte.MIN_VALUE</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    doStuff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uByte) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Overload resolution ambiguity before Kotlin 2.1.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>类似地，调用 <code>doStuff(uByte)</code> 也存在歧义，因为编译器无法决定是使用 <code>Any</code> 版本还是 <code>UByte</code> 版本。 在 2.1.0 中，编译器现在可以正确处理这些情况，通过优先选择更具体的类型（在本例中为 <code>UByte</code>）来解决歧义。</p><h2 id="kotlin-jvm" tabindex="-1">Kotlin/JVM <a class="header-anchor" href="#kotlin-jvm" aria-label="Permalink to &quot;Kotlin/JVM&quot;">​</a></h2><p>从 2.1.0 版本开始，编译器可以生成包含 Java 23 字节码的类。</p><h3 id="jspecify-可空性不匹配诊断的严重性更改为严格" tabindex="-1">JSpecify 可空性不匹配诊断的严重性更改为严格 <a class="header-anchor" href="#jspecify-可空性不匹配诊断的严重性更改为严格" aria-label="Permalink to &quot;JSpecify 可空性不匹配诊断的严重性更改为严格&quot;">​</a></h3><p>Kotlin 2.1.0 强制严格处理 <code>org.jspecify.annotations</code> 中的可空性注解， 从而提高了 Java 互操作的类型安全。</p><p>以下可空性注解受影响：</p><ul><li><code>org.jspecify.annotations.Nullable</code></li><li><code>org.jspecify.annotations.NonNull</code></li><li><code>org.jspecify.annotations.NullMarked</code></li><li><code>org.jspecify.nullness</code> 中的旧版注解（JSpecify 0.2 及更早版本）</li></ul><p>从 Kotlin 2.1.0 开始，可空性不匹配默认从警告提升为错误。 这确保了在类型检测期间强制执行 <code>@NonNull</code> 和 <code>@Nullable</code> 等注解， 从而防止运行时意外的可空性问题。</p><p><code>@NullMarked</code> 注解还会影响其作用域内所有成员的可空性， 当你处理带注解的 Java 代码时，行为更可预测。</p><p>以下是演示新默认行为的示例：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Java</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.jspecify.annotations.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeJavaClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NonNull</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nullable</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sjc: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SomeJavaClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Accesses a non-null result, which is allowed</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sjc.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().length</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Raises an error in the default strict mode because the result is nullable</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // To avoid the error, use ?.length instead</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sjc.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().length</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>你可以手动控制这些注解的诊断严重性。 为此，请使用 <code>-Xnullability-annotations</code> 编译器选项来选择模式：</p><ul><li><code>ignore</code>：忽略可空性不匹配。</li><li><code>warning</code>：报告可空性不匹配的警告。</li><li><code>strict</code>：报告可空性不匹配的错误（默认模式）。</li></ul><p>更多信息，请参阅<a href="/kotlin/java-interop#nullability-annotations">可空性注解</a>。</p><h2 id="kotlin-multiplatform" tabindex="-1">Kotlin Multiplatform <a class="header-anchor" href="#kotlin-multiplatform" aria-label="Permalink to &quot;Kotlin Multiplatform&quot;">​</a></h2><p>Kotlin 2.1.0 引入了 <a href="#basic-support-for-swift-export">Swift 导出基础支持</a>，并使 <a href="#ability-to-publish-kotlin-libraries-from-any-host">发布 Kotlin Multiplatform 库更容易</a>。 它还专注于 Gradle 方面的改进，以稳定<a href="#new-gradle-dsl-for-compiler-options-in-multiplatform-projects-promoted-to-stable">配置编译器选项的新 DSL</a>， 并带来了 <a href="#preview-gradle-s-isolated-projects-in-kotlin-multiplatform">Isolated Projects 特性的预览</a>。</p><h3 id="适用于多平台项目中编译器选项的新-gradle-dsl-已提升至稳定" tabindex="-1">适用于多平台项目中编译器选项的新 Gradle DSL 已提升至稳定 <a class="header-anchor" href="#适用于多平台项目中编译器选项的新-gradle-dsl-已提升至稳定" aria-label="Permalink to &quot;适用于多平台项目中编译器选项的新 Gradle DSL 已提升至稳定&quot;">​</a></h3><p>在 Kotlin 2.0.0 中，<a href="/kotlin/whatsnew20#new-gradle-dsl-for-compiler-options-in-multiplatform-projects">我们引入了一个新的实验性 Gradle DSL</a>， 以简化多平台项目中编译器选项的配置。 在 Kotlin 2.1.0 中，此 DSL 已提升至稳定。</p><p>整体项目配置现在分为三层。最高层是扩展层， 然后是目标层，最低层是编译单元（通常是编译任务）：</p><p><img src="`+g+`" alt="Kotlin 编译器选项级别" width="700"></p><p>要了解有关不同级别以及如何在它们之间配置编译器选项的更多信息， 请参阅 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-dsl-reference.html#compiler-options" target="_blank" rel="noreferrer">编译器选项</a>。</p><h3 id="预览-gradle-的-kotlin-multiplatform-中的-isolated-projects" tabindex="-1">预览 Gradle 的 Kotlin Multiplatform 中的 Isolated Projects <a class="header-anchor" href="#预览-gradle-的-kotlin-multiplatform-中的-isolated-projects" aria-label="Permalink to &quot;预览 Gradle 的 Kotlin Multiplatform 中的 Isolated Projects&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>此特性为<a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>，目前在 Gradle 中处于 pre-Alpha 状态。 仅应与 Gradle 8.10 版本一起使用，并且仅用于评估目的。该特性可能随时被移除或更改。 欢迎在 <a href="https://youtrack.jetbrains.com/issue/KT-57279/Support-Gradle-Project-Isolation-Feature-for-Kotlin-Multiplatform" target="_blank" rel="noreferrer">YouTrack</a> 中提供你的反馈。 需要显式选择加入（详见下文）。</p></div><p>在 Kotlin 2.1.0 中， 你可以在多平台项目中预览 Gradle 的 <a href="https://docs.gradle.org/current/userguide/isolated_projects.html" target="_blank" rel="noreferrer">Isolated Projects</a> 特性。</p><p>Gradle 中的 Isolated Projects 特性通过“隔离” 各个 Gradle 项目的配置来提高构建性能。 每个项目的构建逻辑被限制为不能直接访问其他项目的可变状态， 从而允许它们安全地并行运行。 为了支持此特性，我们对 Kotlin Gradle 插件的模型做了一些更改， 我们很乐意在此预览阶段听取你的经验。</p><p>有两种方法可以启用 Kotlin Gradle 插件的新模型：</p><ul><li><p>选项 1：<strong>不启用 Isolated Projects 进行兼容性测试</strong> – 要检测与 Kotlin Gradle 插件新模型的兼容性而不启用 Isolated Projects 特性， 请将以下 Gradle 属性添加到项目的 <code>gradle.properties</code> 文件中：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># gradle.properties</span></span>
<span class="line"><span>kotlin.kmp.isolated-projects.support=enable</span></span></code></pre></div></li><li><p>选项 2：<strong>启用 Isolated Projects 进行测试</strong> – 在 Gradle 中启用 Isolated Projects 特性会自动配置 Kotlin Gradle 插件以使用新模型。 要启用 Isolated Projects 特性，请<a href="https://docs.gradle.org/current/userguide/isolated_projects.html#how_do_i_use_it" target="_blank" rel="noreferrer">设置系统属性</a>。 在这种情况下，你无需将 Kotlin Gradle 插件的 Gradle 属性添加到你的项目中。</p></li></ul><h3 id="swift-导出基础支持" tabindex="-1">Swift 导出基础支持 <a class="header-anchor" href="#swift-导出基础支持" aria-label="Permalink to &quot;Swift 导出基础支持&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>此特性目前处于早期开发阶段。它可能随时被移除或更改。 需要显式选择加入（详见下文），并且你应仅将其用于评估目的。 欢迎在 <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack</a> 中提供你的反馈。</p></div><p>2.1.0 版本朝着提供 Kotlin 中的 Swift 导出迈出了第一步， 允许你将 Kotlin 源代码直接导出到 Swift 接口而无需使用 Objective-C 头文件。 这应该会使 Apple 目标的跨平台开发变得更容易。</p><p>当前的基础支持包括以下功能：</p><ul><li>将 Kotlin 的多个 Gradle 模块直接导出到 Swift。</li><li>使用 <code>moduleName</code> 属性定义自定义 Swift 模块名称。</li><li>使用 <code>flattenPackage</code> 属性设置包结构的折叠规则。</li></ul><p>你可以在你的项目中使用以下构建文件作为设置 Swift 导出的起点：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosX64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosSimulatorArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalSwiftExportDsl::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    swiftExport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Root module name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        moduleName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Shared&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Collapse rule</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Removes package prefix from generated Swift code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        flattenPackage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;com.example.sandbox&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Export external modules</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">project</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;:subproject&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Exported module name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            moduleName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Subproject&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Collapse exported dependency rule</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            flattenPackage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;com.subproject.library&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>你也可以克隆我们已设置好 Swift 导出的<a href="https://github.com/Kotlin/swift-export-sample" target="_blank" rel="noreferrer">公共示例</a>。</p><p>编译器会自动生成所有必要的文件（包括 <code>swiftmodule</code> 文件、 静态 <code>a</code> 库以及头文件和 <code>modulemap</code> 文件），并将它们复制到应用的构建目录中， 你可以从 Xcode 访问该目录。</p><h4 id="如何启用-swift-导出" tabindex="-1">如何启用 Swift 导出 <a class="header-anchor" href="#如何启用-swift-导出" aria-label="Permalink to &quot;如何启用 Swift 导出&quot;">​</a></h4><p>请记住，此特性目前仍处于早期开发阶段。</p><p>Swift 导出目前适用于使用<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-direct-integration.html" target="_blank" rel="noreferrer">直接集成</a> 连接 iOS framework 到 Xcode 项目的项目。 这是在 Android Studio 或通过 <a href="https://kmp.jetbrains.com/" target="_blank" rel="noreferrer">web wizard</a> 创建的 Kotlin Multiplatform 项目的标准配置。</p><p>要在你的项目中尝试 Swift 导出：</p><ol><li><p>将以下 Gradle 选项添加到你的 <code>gradle.properties</code> 文件中：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># gradle.properties</span></span>
<span class="line"><span>kotlin.experimental.swift-export.enabled=true</span></span></code></pre></div></li><li><p>在 Xcode 中，打开项目设置。</p></li><li><p>在 <strong>Build Phases</strong> 选项卡中，找到带有 <code>embedAndSignAppleFrameworkForXcode</code> 任务的 <strong>Run Script</strong> 阶段。</p></li><li><p>调整脚本，在运行脚本阶段使用 <code>embedSwiftExportForXcode</code> 任务代替：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./gradlew</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> :</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Shared</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> module</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nam</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">:embedSwiftExportForXcode</span></span></code></pre></div><p><img src="`+c+`" alt="添加 Swift 导出脚本" width="700"></p></li></ol><h4 id="对-swift-导出提供反馈" tabindex="-1">对 Swift 导出提供反馈 <a class="header-anchor" href="#对-swift-导出提供反馈" aria-label="Permalink to &quot;对 Swift 导出提供反馈&quot;">​</a></h4><p>我们计划在未来的 Kotlin 版本中扩展和稳定 Swift 导出支持。 请在<a href="https://youtl.in/issue" target="_blank" rel="noreferrer">此 YouTrack 问题</a>中留下你的反馈。</p><h3 id="从任何主机发布-kotlin-库的能力" tabindex="-1">从任何主机发布 Kotlin 库的能力 <a class="header-anchor" href="#从任何主机发布-kotlin-库的能力" aria-label="Permalink to &quot;从任何主机发布 Kotlin 库的能力&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>此特性目前为<a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>。 需要显式选择加入（详见下文），并且你应仅将其用于评估目的。 欢迎在 <a href="https://youtrack.jetbrains.com/issue/KT-71290" target="_blank" rel="noreferrer">YouTrack</a> 中提供你的反馈。</p></div><p>Kotlin 编译器生成 <code>.klib</code> 构件以发布 Kotlin 库。 以前，你可以从任何主机获取必要的构件，除了需要 Mac 机器的 Apple 平台目标。 这给面向 iOS、macOS、tvOS 和 watchOS 目标的 Kotlin Multiplatform 项目带来了特殊限制。</p><p>Kotlin 2.1.0 解除了这一限制，增加了对交叉编译的支持。 现在你可以使用任何主机来生成 <code>.klib</code> 构件， 这应该会大大简化 Kotlin 和 Kotlin Multiplatform 库的发布过程。</p><h4 id="如何启用从任何主机发布库" tabindex="-1">如何启用从任何主机发布库 <a class="header-anchor" href="#如何启用从任何主机发布库" aria-label="Permalink to &quot;如何启用从任何主机发布库&quot;">​</a></h4><p>要在你的项目中尝试交叉编译，请将以下二进制选项添加到你的 <code>gradle.properties</code> 文件中：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># gradle.properties</span></span>
<span class="line"><span>kotlin.native.enableKlibsCrossCompilation=true</span></span></code></pre></div><p>此特性目前为实验性，并存在一些限制。你仍然需要使用 Mac 机器，如果：</p><ul><li>你的库具有 <a href="/kotlin/native-c-interop">cinterop 依赖项</a>。</li><li>你在项目中设置了 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-overview.html" target="_blank" rel="noreferrer">CocoaPods 集成</a>。</li><li>你需要为 Apple 目标构建或测试<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-build-native-binaries.html" target="_blank" rel="noreferrer">最终二进制文件</a>。</li></ul><h4 id="对从任何主机发布库提供反馈" tabindex="-1">对从任何主机发布库提供反馈 <a class="header-anchor" href="#对从任何主机发布库提供反馈" aria-label="Permalink to &quot;对从任何主机发布库提供反馈&quot;">​</a></h4><p>我们计划在未来的 Kotlin 版本中稳定此特性并进一步改进库发布。 请在我们的问题跟踪器 <a href="https://youtrack.jetbrains.com/issue/KT-71290" target="_blank" rel="noreferrer">YouTrack</a> 中留下你的反馈。</p><p>更多信息，请参阅 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-publish-lib-setup.html" target="_blank" rel="noreferrer">发布多平台库</a>。</p><h3 id="支持非打包-klib" tabindex="-1">支持非打包 klib <a class="header-anchor" href="#支持非打包-klib" aria-label="Permalink to &quot;支持非打包 klib&quot;">​</a></h3><p>Kotlin 2.1.0 允许生成非打包的 <code>.klib</code> 文件构件。 这使你可以选择直接配置 klib 的依赖项，而无需先将其解包。</p><p>此更改还可以提高性能， 减少 Kotlin/Wasm、Kotlin/JS 和 Kotlin/Native 项目的编译和链接时间。</p><p>例如， 我们的基准测试显示，在包含 1 个链接任务和 10 个编译任务的项目中，总构建时间提高了大约 3% （该项目构建一个依赖于 9 个简化项目的单个原生可执行二进制文件）。 然而，对构建时间的实际影响取决于子项目的数量及其各自的大小。</p><h4 id="如何设置你的项目" tabindex="-1">如何设置你的项目 <a class="header-anchor" href="#如何设置你的项目" aria-label="Permalink to &quot;如何设置你的项目&quot;">​</a></h4><p>默认情况下，Kotlin 编译和链接任务现在配置为使用新的非打包构件。</p><p>如果你已经设置了用于解析 klib 的自定义构建逻辑，并且想要使用新的解包构件， 你需要在你的 Gradle 构建文件中显式指定 klib 包解析的首选变体：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> org.jetbrains.kotlin.gradle.plugin.attributes.KlibPackaging</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> resolvableConfiguration </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> configurations.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolvable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;resolvable&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // For the new non-packed configuration:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    attributes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(KlibPackaging.ATTRIBUTE, project.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">named</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(KlibPackaging.NON_PACKED))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // For the previous packed configuration:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    attributes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(KlibPackaging.ATTRIBUTE, project.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">named</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(KlibPackaging.PACKED))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>非打包的 <code>.klib</code> 文件生成在项目构建目录中与之前打包文件相同的路径下。 反过来，打包的 klib 现在位于 <code>build/libs</code> 目录中。</p><p>如果未指定属性，则使用打包变体。 你可以使用以下控制台命令查看可用属性和变体的列表：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./gradlew</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> outgoingVariants</span></span></code></pre></div><p>欢迎在 <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack</a> 中提供对此特性的反馈。</p><h3 id="旧-android-目标的进一步弃用" tabindex="-1">旧 <code>android</code> 目标的进一步弃用 <a class="header-anchor" href="#旧-android-目标的进一步弃用" aria-label="Permalink to &quot;旧 \`android\` 目标的进一步弃用&quot;">​</a></h3><p>在 Kotlin 2.1.0 中，旧 <code>android</code> 目标名称的弃用警告已提升为错误。</p><p>目前，我们建议你在面向 Android 的 Kotlin Multiplatform 项目中使用 <code>androidTarget</code> 选项。 这是一个临时解决方案，是为了即将到来的 Google Android/KMP 插件腾出 <code>android</code> 名称所必需的。</p><p>当新插件可用时，我们将提供进一步的迁移说明。 来自 Google 的新 DSL 将是 Kotlin Multiplatform 中 Android 目标支持的首选选项。</p><p>更多信息， 请参阅 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-compatibility-guide.html#rename-of-android-target-to-androidtarget" target="_blank" rel="noreferrer">Kotlin Multiplatform 兼容性指南</a>。</p><h3 id="移除了对声明相同类型多个目标的支持" tabindex="-1">移除了对声明相同类型多个目标的支持 <a class="header-anchor" href="#移除了对声明相同类型多个目标的支持" aria-label="Permalink to &quot;移除了对声明相同类型多个目标的支持&quot;">​</a></h3><p>在 Kotlin 2.1.0 之前，你可以在多平台项目中声明相同类型的多个目标。 然而，这使得区分目标和有效支持共享源代码集变得具有挑战性。 在大多数情况下，更简单的设置（例如使用单独的 Gradle 项目）效果更好。 有关详细指导和迁移示例， 请参阅 Kotlin Multiplatform 兼容性指南中的<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-compatibility-guide.html#declaring-several-similar-targets" target="_blank" rel="noreferrer">声明多个类似目标</a>。</p><p>Kotlin 1.9.20 在你的多平台项目中声明相同类型的多个目标时会触发弃用警告。 在 Kotlin 2.1.0 中，此弃用警告现在对于除 Kotlin/JS 目标之外的所有目标都是一个错误。 要了解有关 Kotlin/JS 目标为何豁免的更多信息， 请参阅 <a href="https://youtrack.jetbrains.com/issue/KT-47038/KJS-MPP-Split-JS-target-into-JsBrowser-and-JsNode" target="_blank" rel="noreferrer">YouTrack</a> 中的此问题。</p><h2 id="kotlin-native" tabindex="-1">Kotlin/Native <a class="header-anchor" href="#kotlin-native" aria-label="Permalink to &quot;Kotlin/Native&quot;">​</a></h2><p>Kotlin 2.1.0 包含对 <a href="#iosarm64-promoted-to-tier-1"><code>iosArm64</code> 目标支持的升级</a>、 <a href="#changes-to-caching-in-cinterop">cinterop 中缓存过程的改进</a>以及其他更新。</p><h3 id="iosarm64-提升至-tier-1" tabindex="-1">iosArm64 提升至 Tier 1 <a class="header-anchor" href="#iosarm64-提升至-tier-1" aria-label="Permalink to &quot;iosArm64 提升至 Tier 1&quot;">​</a></h3><p><code>iosArm64</code> 目标对于 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/get-started.html" target="_blank" rel="noreferrer">Kotlin Multiplatform</a> 开发至关重要， 现已提升至 Tier 1。这是 Kotlin/Native 编译器中最高级别的支持。</p><p>这意味着该目标会在 CI 流水线中定期进行检测，以确保其能够编译和运行。 我们还为该目标在编译器版本之间提供源代码和二进制兼容性。</p><p>有关目标层级的更多信息，请参阅 <a href="/kotlin/native-target-support">Kotlin/Native 目标支持</a>。</p><h3 id="llvm-从-11-1-0-更新到-16-0-0" tabindex="-1">LLVM 从 11.1.0 更新到 16.0.0 <a class="header-anchor" href="#llvm-从-11-1-0-更新到-16-0-0" aria-label="Permalink to &quot;LLVM 从 11.1.0 更新到 16.0.0&quot;">​</a></h3><p>在 Kotlin 2.1.0 中，我们将 LLVM 从 11.1.0 版本更新到 16.0.0。 新版本包含错误修复和安全更新。 在某些情况下，它还提供了编译器优化和更快的编译速度。</p><p>如果你的项目中有 Linux 目标， 请注意 Kotlin/Native 编译器现在默认对所有 Linux 目标使用 <code>lld</code> 链接器。</p><p>此更新不应影响你的代码，但如果你遇到任何问题，请向我们的<a href="http://kotl.in/issue" target="_blank" rel="noreferrer">问题跟踪器</a>报告。</p><h3 id="cinterop-中缓存的更改" tabindex="-1">cinterop 中缓存的更改 <a class="header-anchor" href="#cinterop-中缓存的更改" aria-label="Permalink to &quot;cinterop 中缓存的更改&quot;">​</a></h3><p>在 Kotlin 2.1.0 中，我们正在对 cinterop 缓存过程进行更改。它不再具有 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/CacheableTask.html" target="_blank" rel="noreferrer"><code>CacheableTask</code></a> 注解类型。 新的推荐方法是使用 <a href="https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks/-task-outputs/cache-if.html" target="_blank" rel="noreferrer"><code>cacheIf</code></a> 输出类型来缓存任务结果。</p><p>这应该能解决 <code>UP-TO-DATE</code> 检测未能检测到<a href="/kotlin/native-definition-file">定义文件</a>中指定头文件更改的问题， 从而阻止构建系统重新编译代码。</p><h3 id="mimalloc-内存分配器的弃用" tabindex="-1">mimalloc 内存分配器的弃用 <a class="header-anchor" href="#mimalloc-内存分配器的弃用" aria-label="Permalink to &quot;mimalloc 内存分配器的弃用&quot;">​</a></h3><p>早在 Kotlin 1.9.0 中，我们就引入了新的内存分配器，然后在 Kotlin 1.9.20 中默认启用了它。 新的分配器旨在提高垃圾回收效率， 并改进 Kotlin/Native 内存管理器的运行时性能。</p><p>新的内存分配器取代了以前的默认分配器 <a href="https://github.com/microsoft/mimalloc" target="_blank" rel="noreferrer">mimalloc</a>。 现在，是时候弃用 Kotlin/Native 编译器中的 mimalloc 了。</p><p>你现在可以从构建脚本中移除 <code>-Xallocator=mimalloc</code> 编译器选项。 如果你遇到任何问题，请向我们的<a href="http://kotl.in/issue" target="_blank" rel="noreferrer">问题跟踪器</a>报告。</p><p>有关 Kotlin 中内存分配器和垃圾回收的更多信息， 请参阅 <a href="/kotlin/native-memory-manager">Kotlin/Native 内存管理</a>。</p><h2 id="kotlin-wasm" tabindex="-1">Kotlin/Wasm <a class="header-anchor" href="#kotlin-wasm" aria-label="Permalink to &quot;Kotlin/Wasm&quot;">​</a></h2><p>Kotlin/Wasm 收到多项更新，并<a href="#support-for-incremental-compilation">支持增量编译</a>。</p><h3 id="支持增量编译" tabindex="-1">支持增量编译 <a class="header-anchor" href="#支持增量编译" aria-label="Permalink to &quot;支持增量编译&quot;">​</a></h3><p>以前，当你更改 Kotlin 代码时，Kotlin/Wasm 工具链必须重新编译整个代码库。</p><p>从 2.1.0 开始，Wasm 目标支持增量编译。 在开发任务中，编译器现在只重新编译与上次编译更改相关的文件， 这显著减少了编译时间。</p><p>此更改目前将编译速度提高了一倍，并计划在未来版本中进一步改进。</p><p>在当前设置中，Wasm 目标的增量编译默认禁用。 要启用增量编译，请将以下行添加到你的项目的 <code>local.properties</code> 或 <code>gradle.properties</code> 文件中：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># gradle.properties</span></span>
<span class="line"><span>kotlin.incremental.wasm=true</span></span></code></pre></div><p>试用 Kotlin/Wasm 增量编译 并<a href="https://youtrack.jetbrains.com/issue/KT-72158/Kotlin-Wasm-incremental-compilation-feedback" target="_blank" rel="noreferrer">分享你的反馈</a>。 你的见解将有助于更快地稳定此特性并默认启用。</p><h3 id="浏览器-api-已移至-kotlinx-browser-独立库" tabindex="-1">浏览器 API 已移至 kotlinx-browser 独立库 <a class="header-anchor" href="#浏览器-api-已移至-kotlinx-browser-独立库" aria-label="Permalink to &quot;浏览器 API 已移至 kotlinx-browser 独立库&quot;">​</a></h3><p>以前，Web API 及相关目标工具的声明是 Kotlin/Wasm 标准库的一部分。</p><p>在此版本中，<code>org.w3c.*</code> 声明已从 Kotlin/Wasm 标准库移至新的 <a href="https://github.com/kotlin/kotlinx-browser" target="_blank" rel="noreferrer">kotlinx-browser 库</a>。 此库还包括其他 Web 相关包，例如 <code>org.khronos.webgl</code>、<code>kotlin.dom</code> 和 <code>kotlinx.browser</code>。</p><p>这种分离提供了模块化，允许 Web 相关 API 独立于 Kotlin 的发布周期进行更新。 此外，Kotlin/Wasm 标准库现在仅包含任何 JavaScript 环境中可用的声明。</p><p>要使用已移动包中的声明， 你需要将 <code>kotlinx-browser</code> 依赖项添加到你的项目构建配置文件中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wasmJsMain </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        implementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org.jetbrains.kotlinx:kotlinx-browser:0.3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="改进了-kotlin-wasm-的调试体验" tabindex="-1">改进了 Kotlin/Wasm 的调试体验 <a class="header-anchor" href="#改进了-kotlin-wasm-的调试体验" aria-label="Permalink to &quot;改进了 Kotlin/Wasm 的调试体验&quot;">​</a></h3><p>以前，在 Web 浏览器中调试 Kotlin/Wasm 代码时，你可能会遇到 调试界面中变量值的低级表示。 这通常使得跟踪应用程序的当前状态变得具有挑战性。</p><p><img src="`+d+'" alt="Kotlin/Wasm 旧版调试器" width="700"></p><p>为了改善这种体验，变量视图中添加了自定义格式化程序。 此实现使用 <a href="https://firefox-source-docs.mozilla.org/devtools-user/custom_formatters/index.html" target="_blank" rel="noreferrer">custom formatters API</a>， 该 API 在 Firefox 和基于 Chromium 的主要浏览器中均受支持。</p><p>通过此更改，你现在可以以更用户友好和易于理解的方式显示和查找变量值。</p><p><img src="'+E+`" alt="Kotlin/Wasm 改进版调试器" width="700"></p><p>要尝试新的调试体验：</p><ol><li><p>将以下编译器选项添加到 <code>wasmJs {}</code> 编译器选项中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    wasmJs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xwasm-debugger-custom-formatters&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>在你的浏览器中启用自定义格式化程序：</p><ul><li><p>在 Chrome DevTools 中，可通过 <strong>Settings | Preferences | Console</strong> 访问：</p><p><img src="`+y+'" alt="在 Chrome 中启用自定义格式化程序" width="700"></p></li><li><p>在 Firefox DevTools 中，可通过 <strong>Settings | Advanced settings</strong> 访问：</p><p><img src="'+F+`" alt="在 Firefox 中启用自定义格式化程序" width="700"></p></li></ul></li></ol><h3 id="减小-kotlin-wasm-二进制文件的大小" tabindex="-1">减小 Kotlin/Wasm 二进制文件的大小 <a class="header-anchor" href="#减小-kotlin-wasm-二进制文件的大小" aria-label="Permalink to &quot;减小 Kotlin/Wasm 二进制文件的大小&quot;">​</a></h3><p>你的生产构建生成的 Wasm 二进制文件大小将减少高达 30%， 并且你可能会看到一些性能改进。 这是因为 <code>--closed-world</code>、<code>--type-ssa</code> 和 <code>--type-merging</code> Binaryen 选项现在被认为对所有 Kotlin/Wasm 项目来说都是安全的，并默认启用。</p><h3 id="改进了-kotlin-wasm-中的-javascript-数组互操作性" tabindex="-1">改进了 Kotlin/Wasm 中的 JavaScript 数组互操作性 <a class="header-anchor" href="#改进了-kotlin-wasm-中的-javascript-数组互操作性" aria-label="Permalink to &quot;改进了 Kotlin/Wasm 中的 JavaScript 数组互操作性&quot;">​</a></h3><p>虽然 Kotlin/Wasm 的标准库为 JavaScript 数组提供了 <code>JsArray&lt;T&gt;</code> 类型， 但没有直接的方法将 <code>JsArray&lt;T&gt;</code> 转换为 Kotlin 的原生 <code>Array</code> 或 <code>List</code> 类型。</p><p>这一空白需要创建自定义函数来进行数组转换，从而使 Kotlin 和 JavaScript 代码之间的互操作性变得复杂。</p><p>此版本引入了一个适配器函数，可自动将 <code>JsArray&lt;T&gt;</code> 转换为 <code>Array&lt;T&gt;</code>，反之亦然， 从而简化了数组操作。</p><p>以下是泛型类型之间转换的示例：Kotlin <code>List&lt;T&gt;</code> 和 <code>Array&lt;T&gt;</code> 到 JavaScript <code>JsArray&lt;T&gt;</code>。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JsString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Kotlin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Wasm&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toJsString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Uses .toJsArray() to convert List or Array to JsArray</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jsArray: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JsArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JsString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toJsArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Uses .toArray() and .toList() to convert it back to Kotlin types</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlinArray: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JsString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jsArray.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlinList: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JsString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jsArray.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>类似的函数可用于将类型化数组转换为其 Kotlin 等效类型 （例如，<code>IntArray</code> 和 <code>Int32Array</code>）。有关详细信息和实现， 请参阅 <a href="https://github.com/Kotlin/kotlinx-browser/blob/dfbdceed314567983c98f1d66e8c2e10d99c5a55/src/wasmJsMain/kotlin/arrayCopy.kt" target="_blank" rel="noreferrer"><code>kotlinx-browser</code> 版本库</a>。</p><p>以下是类型化数组之间转换的示例：Kotlin <code>IntArray</code> 到 JavaScript <code>Int32Array</code>。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> org.khronos.webgl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intArray: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IntArray</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> intArrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Uses .toInt32Array() to convert Kotlin IntArray to JavaScript Int32Array</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jsInt32Array: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int32Array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intArray.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toInt32Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Uses toIntArray() to convert JavaScript Int32Array back to Kotlin IntArray</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlinIntArray: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IntArray</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jsInt32Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toIntArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h3 id="支持在-kotlin-wasm-中访问-javascript-异常详细信息" tabindex="-1">支持在 Kotlin/Wasm 中访问 JavaScript 异常详细信息 <a class="header-anchor" href="#支持在-kotlin-wasm-中访问-javascript-异常详细信息" aria-label="Permalink to &quot;支持在 Kotlin/Wasm 中访问 JavaScript 异常详细信息&quot;">​</a></h3><p>以前，当 JavaScript 异常在 Kotlin/Wasm 中发生时， <code>JsException</code> 类型仅提供通用消息，没有来自原始 JavaScript 错误的详细信息。</p><p>从 Kotlin 2.1.0 开始，你可以配置 <code>JsException</code> 以包含原始错误消息和堆栈跟踪，方法是启用特定的编译器选项。 这提供了更多上下文，有助于诊断源自 JavaScript 的问题。</p><p>此行为取决于 <code>WebAssembly.JSTag</code> API，该 API 仅在某些浏览器中可用：</p><ul><li><strong>Chrome</strong>：从版本 115 开始支持</li><li><strong>Firefox</strong>：从版本 129 开始支持</li><li><strong>Safari</strong>：尚未支持</li></ul><p>要启用此特性（默认禁用）， 请将以下编译器选项添加到你的 <code>build.gradle.kts</code> 文件中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    wasmJs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xwasm-attach-js-exception&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>以下是演示新行为的示例：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> object</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JsAny</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(json: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        JSON.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;an invalid JSON&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JsException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Thrown value is: \${e.thrownValue}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // SyntaxError: Unexpected token &#39;a&#39;, &quot;an invalid JSON&quot; is not valid JSON</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Message: \${e.message}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Message: Unexpected token &#39;a&#39;, &quot;an invalid JSON&quot; is not valid JSON</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Stacktrace:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Stacktrace:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Prints the full JavaScript stack trace</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>启用 <code>-Xwasm-attach-js-exception</code> 选项后，<code>JsException</code> 会提供来自 JavaScript 错误的具体详细信息。 如果没有此选项，<code>JsException</code> 仅包含一条通用消息，说明在运行 JavaScript 代码时抛出了异常。</p><h3 id="弃用默认导出" tabindex="-1">弃用默认导出 <a class="header-anchor" href="#弃用默认导出" aria-label="Permalink to &quot;弃用默认导出&quot;">​</a></h3><p>作为迁移到命名导出的一部分， 以前在 JavaScript 中对 Kotlin/Wasm 导出使用默认导入时，控制台会打印错误。</p><p>在 2.1.0 中，默认导入已完全移除，以完全支持命名导出。</p><p>当针对 Kotlin/Wasm 目标进行 JavaScript 编码时，你现在需要使用相应的命名导入而不是默认导入。</p><p>此更改标志着迁移到命名导出的弃用周期的最后一个阶段：</p><p><strong>在 2.0.0 版本中</strong>：控制台打印一条警告消息，解释通过默认导出导出实体已被弃用。</p><p><strong>在 2.0.20 版本中</strong>：发生错误，要求使用相应的命名导入。</p><p><strong>在 2.1.0 版本中</strong>：已完全移除默认导入的使用。</p><h3 id="子项目特有的-node-js-设置" tabindex="-1">子项目特有的 Node.js 设置 <a class="header-anchor" href="#子项目特有的-node-js-设置" aria-label="Permalink to &quot;子项目特有的 Node.js 设置&quot;">​</a></h3><p>你可以通过定义 <code>rootProject</code> 的 <code>NodeJsRootPlugin</code> 类的属性来配置项目的 Node.js 设置。 在 2.1.0 中，你可以使用新类 <code>NodeJsPlugin</code> 为每个子项目配置这些设置。 以下是演示如何为子项目设置特定 Node.js 版本的示例：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">project.plugins.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">org</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jetbrains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gradle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">targets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nodejs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NodeJsPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    project.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">the</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">org</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jetbrains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gradle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">targets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nodejs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NodeJsEnvSpec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;().version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;22.0.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>要将新类用于整个项目，请在 <code>allprojects {}</code> 代码块中添加相同的代码：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">allprojects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    project.plugins.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">org</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jetbrains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gradle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">targets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nodejs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NodeJsPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        project.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">the</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">org</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jetbrains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gradle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">targets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nodejs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NodeJsEnvSpec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;().version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;your Node.js version&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>你还可以使用 Gradle 约定插件将设置应用于特定的子项目集。</p><h2 id="kotlin-js" tabindex="-1">Kotlin/JS <a class="header-anchor" href="#kotlin-js" aria-label="Permalink to &quot;Kotlin/JS&quot;">​</a></h2><h3 id="支持属性中的非标识符字符" tabindex="-1">支持属性中的非标识符字符 <a class="header-anchor" href="#支持属性中的非标识符字符" aria-label="Permalink to &quot;支持属性中的非标识符字符&quot;">​</a></h3><p>Kotlin/JS 以前不允许在反引号中包含空格的<a href="/kotlin/coding-conventions#names-for-test-methods">测试方法名称</a>。</p><p>类似地，也无法访问包含 Kotlin 标识符中不允许的字符（例如连字符或空格）的 JavaScript 对象属性：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Headers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> accept: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Invalid Kotlin identifier due to hyphen</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> \`content</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">length\`: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> headers: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Headers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TODO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;value provided by a JS library&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> accept </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> headers.accept</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Causes error due to the hyphen in property name</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> headers.\`content</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">length\`</span></span></code></pre></div><p>此行为与 JavaScript 和 TypeScript 不同，后者允许使用非标识符字符访问此类属性。</p><p>从 Kotlin 2.1.0 开始，此特性默认启用。 Kotlin/JS 现在允许你使用反引号 (\`\`) 和 <code>@JsName</code> 注解 与包含非标识符字符的 JavaScript 属性进行交互，并使用测试方法名称。</p><p>此外， 你可以使用 <code>@JsName</code> 和 <code> @JsQualifier</code> 注解将 Kotlin 属性名称映射到 JavaScript 等效名称：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">object</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> \`property example\`: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;bar&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JsQualifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;fooNamespace&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> object</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> \`property example\`: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JsExport</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">object</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Baz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> \`property example\`: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;bar&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // In JavaScript, this is compiled into Bar.property_example_HASH</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Bar.\`property example\`)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // In JavaScript, this is compiled into fooNamespace[&quot;property example&quot;]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Foo.\`property example\`)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // In JavaScript, this is compiled into Baz[&quot;property example&quot;]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Baz.\`property example\`)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="支持生成-es2015-箭头函数" tabindex="-1">支持生成 ES2015 箭头函数 <a class="header-anchor" href="#支持生成-es2015-箭头函数" aria-label="Permalink to &quot;支持生成 ES2015 箭头函数&quot;">​</a></h3><p>在 Kotlin 2.1.0 中，Kotlin/JS 引入了对生成 ES2015 箭头函数（例如 <code>(a, b) =&gt; expression</code>）的支持， 而不是匿名函数。</p><p>使用箭头函数可以减小项目的捆绑包大小， 尤其是在使用实验性的 <code>-Xir-generate-inline-anonymous-functions</code> 模式时。 这还使得生成的代码更符合现代 JS。</p><p>此特性在目标为 ES2015 时默认启用。 或者，你可以通过使用 <code>-Xes-arrow-functions</code> 命令行实参来启用它。</p><p>了解更多关于 <a href="https://262.ecma-international.org/6.0/" target="_blank" rel="noreferrer">ES2015 (ECMAScript 2015, ES6) 的官方文档</a>。</p><h2 id="gradle-改进" tabindex="-1">Gradle 改进 <a class="header-anchor" href="#gradle-改进" aria-label="Permalink to &quot;Gradle 改进&quot;">​</a></h2><p>Kotlin 2.1.0 完全兼容 Gradle 7.6.3 到 8.6。 Gradle 8.7 到 8.10 也受支持，只有一个例外。 如果你使用 Kotlin Multiplatform Gradle 插件， 你可能会在调用 JVM 目标中的 <code>withJava()</code> 函数的多平台项目中看到弃用警告。 我们计划尽快解决此问题。</p><p>更多信息， 请参阅 <a href="https://youtrack.jetbrains.com/issue/KT-66542" target="_blank" rel="noreferrer">YouTrack</a> 中的相关问题。</p><p>你也可以使用最新 Gradle 版本及更高版本， 但如果你这样做，请记住你可能会遇到弃用警告或某些新的 Gradle 特性可能无法正常工作。</p><h3 id="最低支持-agp-版本提升至-7-3-1" tabindex="-1">最低支持 AGP 版本提升至 7.3.1 <a class="header-anchor" href="#最低支持-agp-版本提升至-7-3-1" aria-label="Permalink to &quot;最低支持 AGP 版本提升至 7.3.1&quot;">​</a></h3><p>从 Kotlin 2.1.0 开始，最低支持的 Android Gradle 插件版本为 7.3.1。</p><h3 id="最低支持-gradle-版本提升至-7-6-3" tabindex="-1">最低支持 Gradle 版本提升至 7.6.3 <a class="header-anchor" href="#最低支持-gradle-版本提升至-7-6-3" aria-label="Permalink to &quot;最低支持 Gradle 版本提升至 7.6.3&quot;">​</a></h3><p>从 Kotlin 2.1.0 开始，最低支持的 Gradle 版本为 7.6.3。</p><h3 id="kotlin-gradle-插件扩展的新-api" tabindex="-1">Kotlin Gradle 插件扩展的新 API <a class="header-anchor" href="#kotlin-gradle-插件扩展的新-api" aria-label="Permalink to &quot;Kotlin Gradle 插件扩展的新 API&quot;">​</a></h3><p>Kotlin 2.1.0 引入了一个新 API，使其更容易创建你自己的插件来配置 Kotlin Gradle 插件。 此更改弃用了 <code>KotlinTopLevelExtension</code> 和 <code>KotlinTopLevelExtensionConfig</code> 接口，并为插件作者引入了以下接口：</p>`,192)),s("table",A,[i[15]||(i[15]=s("thead",null,[s("tr",null,[s("th",{style:{"text-align":"left"}},"名称"),s("th",{style:{"text-align":"left"}},"描述")])],-1)),s("tbody",null,[s("tr",null,[i[12]||(i[12]=s("td",{style:{"text-align":"left"}},[s("code",null,"KotlinBaseExtension")],-1)),s("td",f,[i[11]||(i[11]=a("用于配置整个项目的通用 Kotlin JVM、Android 和 Multiplatform 插件选项的插件 DSL 扩展类型：")),n(r,null,{default:l(()=>i[10]||(i[10]=[s("li",null,[s("code",null,"org.jetbrains.kotlin.jvm")],-1),s("li",null,[s("code",null,"org.jetbrains.kotlin.android")],-1),s("li",null,[s("code",null,"org.jetbrains.kotlin.multiplatform")],-1)])),_:1})])]),i[13]||(i[13]=s("tr",null,[s("td",{style:{"text-align":"left"}},[s("code",null,"KotlinJvmExtension")]),s("td",{style:{"text-align":"left"}},[a("用于配置整个项目的 Kotlin "),s("strong",null,"JVM"),a(" 插件选项的插件 DSL 扩展类型。")])],-1)),i[14]||(i[14]=s("tr",null,[s("td",{style:{"text-align":"left"}},[s("code",null,"KotlinAndroidExtension")]),s("td",{style:{"text-align":"left"}},[a("用于配置整个项目的 Kotlin "),s("strong",null,"Android"),a(" 插件选项的插件 DSL 扩展类型。")])],-1))])]),i[20]||(i[20]=e(`<p>例如，如果你想同时为 JVM 和 Android 项目配置编译器选项，请使用 <code>KotlinBaseExtension</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">configure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KotlinBaseExtension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HasConfigurableKotlinCompilerOptions</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;*&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(compilerOptions) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KotlinJvmCompilerOptions) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                jvmTarget.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(JvmTarget.JVM_17)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这会将 JVM 目标设置为 17，同时适用于 JVM 和 Android 项目。</p><p>要专门为 JVM 项目配置编译器选项，请使用 <code>KotlinJvmExtension</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">configure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KotlinJvmExtension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        jvmTarget.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(JvmTarget.JVM_17)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    target.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mavenPublication</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        groupId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;com.example&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        artifactId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;example-project&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;1.0-SNAPSHOT&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此示例类似地将 JVM 目标设置为 17，适用于 JVM 项目。 它还为项目配置了 Maven publication，以便其输出发布到 Maven 版本库。</p><p>你可以完全相同地使用 <code>KotlinAndroidExtension</code>。</p><h3 id="编译器符号从-kotlin-gradle-插件-api-中隐藏" tabindex="-1">编译器符号从 Kotlin Gradle 插件 API 中隐藏 <a class="header-anchor" href="#编译器符号从-kotlin-gradle-插件-api-中隐藏" aria-label="Permalink to &quot;编译器符号从 Kotlin Gradle 插件 API 中隐藏&quot;">​</a></h3><p>以前，KGP 在其运行时依赖项中包含了 <code>org.jetbrains.kotlin:kotlin-compiler-embeddable</code>， 这使得内部编译器符号在构建脚本类路径中可用。 这些符号仅供内部使用。</p><p>从 Kotlin 2.1.0 开始，KGP 将 <code>org.jetbrains.kotlin:kotlin-compiler-embeddable</code> 的子集类文件捆绑到其 JAR 文件中并逐步移除它们。 此更改旨在防止兼容性问题并简化 KGP 的维护。</p><p>如果构建逻辑的其他部分（例如 <code>kotlinter</code> 等插件）依赖于与 KGP 捆绑版本不同的 <code>org.jetbrains.kotlin:kotlin-compiler-embeddable</code> 版本， 则可能导致冲突和运行时异常。</p><p>为了防止此类问题，KGP 现在会显示警告，如果 <code>org.jetbrains.kotlin:kotlin-compiler-embeddable</code> 与 KGP 同时出现在构建类路径中。</p><p>作为长期解决方案，如果你是使用 <code>org.jetbrains.kotlin:kotlin-compiler-embeddable</code> 类的插件作者，我们建议你在独立的类加载器中运行它们。 例如，你可以使用 <a href="https://docs.gradle.org/current/userguide/worker_api.html" target="_blank" rel="noreferrer">Gradle Workers API</a> 实现类加载器或进程隔离。</p><h4 id="使用-gradle-workers-api" tabindex="-1">使用 Gradle Workers API <a class="header-anchor" href="#使用-gradle-workers-api" aria-label="Permalink to &quot;使用 Gradle Workers API&quot;">​</a></h4><p>此示例演示了如何在生成 Gradle 插件的项目中安全地使用 Kotlin 编译器。 首先，在你的构建脚本中添加一个 compile-only 依赖项。 这使得符号仅在编译时可用：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compileOnly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org.jetbrains.kotlin:kotlin-compiler-embeddable:2.2.10&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>接下来，定义一个 Gradle 工作操作以打印 Kotlin 编译器版本：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> org.gradle.workers.WorkAction</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> org.gradle.workers.WorkParameters</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> org.jetbrains.kotlin.config.KotlinCompilerVersion</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ActionUsingKotlinCompiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WorkAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WorkParameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Kotlin compiler version: \${KotlinCompilerVersion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getVersion</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>现在创建一个任务，使用类加载器隔离将此操作提交给 worker 执行器：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> org.gradle.api.DefaultTask</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> org.gradle.api.file.ConfigurableFileCollection</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> org.gradle.api.tasks.Classpath</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> org.gradle.api.tasks.TaskAction</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> org.gradle.workers.WorkerExecutor</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> javax.inject.Inject</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TaskUsingKotlinCompiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DefaultTask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Inject</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> executor: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WorkerExecutor</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Classpath</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlinCompiler: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ConfigurableFileCollection</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @TaskAction</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> workQueue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> executor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">classLoaderIsolation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            classpath.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kotlinCompiler)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        workQueue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">submit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ActionUsingKotlinCompiler::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.java) {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>最后，在你的 Gradle 插件中配置 Kotlin 编译器类路径：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> org.gradle.api.Plugin</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> org.gradle.api.Project</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Plugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Project</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Project</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myDependencyScope </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target.configurations.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myDependencyScope&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        target.dependencies.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myDependencyScope.name, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$KOTLIN_COMPILER_EMBEDDABLE</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$KOTLIN_COMPILER_VERSION</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myResolvableConfiguration </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target.configurations.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myResolvable&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            extendsFrom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myDependencyScope)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        target.tasks.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">register</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myTask&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, TaskUsingKotlinCompiler::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.java) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            kotlinCompiler.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myResolvableConfiguration)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    companion</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KOTLIN_COMPILER_EMBEDDABLE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;org.jetbrains.kotlin:kotlin-compiler-embeddable&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KOTLIN_COMPILER_VERSION </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;2.2.10&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="compose-编译器更新" tabindex="-1">Compose 编译器更新 <a class="header-anchor" href="#compose-编译器更新" aria-label="Permalink to &quot;Compose 编译器更新&quot;">​</a></h2><h3 id="支持多个稳定性配置文件" tabindex="-1">支持多个稳定性配置文件 <a class="header-anchor" href="#支持多个稳定性配置文件" aria-label="Permalink to &quot;支持多个稳定性配置文件&quot;">​</a></h3><p>Compose 编译器可以解析多个稳定性配置文件， 但 Compose Compiler Gradle 插件的 <code>stabilityConfigurationFile</code> 选项以前只允许 指定单个文件。 在 Kotlin 2.1.0 中，此功能经过重构，允许你为单个模块使用多个稳定性配置文件：</p><ul><li><code>stabilityConfigurationFile</code> 选项已弃用。</li><li>新增选项 <code>stabilityConfigurationFiles</code>，类型为 <code>ListProperty&lt;RegularFile&gt;</code>。</li></ul><p>以下是如何使用新选项将多个文件传递给 Compose 编译器：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kt</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">composeCompiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    stabilityConfigurationFiles.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        project.layout.projectDirectory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">file</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;configuration-file1.conf&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        project.layout.projectDirectory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">file</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;configuration-file2.conf&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="可暂停组合" tabindex="-1">可暂停组合 <a class="header-anchor" href="#可暂停组合" aria-label="Permalink to &quot;可暂停组合&quot;">​</a></h3><p>可暂停组合是一项新的实验性特性，它改变了编译器生成可跳过函数的方式。 启用此特性后，组合可以在运行时在跳过点暂停， 允许长时间运行的组合过程在多个帧之间拆分。 可暂停组合用于惰性列表和其他性能密集型组件，用于预取可能导致帧在阻塞方式执行时丢弃的内容。</p><p>要试用可暂停组合，请在 Compose 编译器的 Gradle 配置中添加以下特性标志：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">composeCompiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    featureFlags </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ComposeFeatureFlag.PausableComposition</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>此特性的运行时支持已在 <code>androidx.compose.runtime</code> 的 1.8.0-alpha02 版本中添加。 与旧版本运行时一起使用时，此特性标志无效。</p></div><h3 id="开放和覆盖的-composable-函数的更改" tabindex="-1">开放和覆盖的 <code>@Composable</code> 函数的更改 <a class="header-anchor" href="#开放和覆盖的-composable-函数的更改" aria-label="Permalink to &quot;开放和覆盖的 \`@Composable\` 函数的更改&quot;">​</a></h3><p>虚拟（<code>open</code>、<code>abstract</code> 和 <code>overridden</code>）的 <code>@Composable</code> 函数不再可重启。 可重启组的代码生成会生成<a href="https://issuetracker.google.com/329477544" target="_blank" rel="noreferrer">无法正确</a>与继承配合使用的调用， 导致运行时崩溃。</p><p>这意味着虚拟函数不会被重启或跳过： 每当它们的状态失效时，运行时将重新组合它们的父级可组合项。 如果你的代码对重组敏感，你可能会注意到运行时行为的变化。</p><h3 id="性能改进" tabindex="-1">性能改进 <a class="header-anchor" href="#性能改进" aria-label="Permalink to &quot;性能改进&quot;">​</a></h3><p>Compose 编译器过去会创建模块 IR 的完整副本以转换 <code>@Composable</code> 类型。 除了复制与 Compose 无关的元素时增加内存消耗外， 此行为在<a href="https://issuetracker.google.com/365066530" target="_blank" rel="noreferrer">某些边缘情况</a>下也会破坏下游编译器插件。</p><p>此复制操作已被移除，从而可能带来更快的编译时间。</p><h2 id="标准库" tabindex="-1">标准库 <a class="header-anchor" href="#标准库" aria-label="Permalink to &quot;标准库&quot;">​</a></h2><h3 id="标准库-api-弃用严重性的更改" tabindex="-1">标准库 API 弃用严重性的更改 <a class="header-anchor" href="#标准库-api-弃用严重性的更改" aria-label="Permalink to &quot;标准库 API 弃用严重性的更改&quot;">​</a></h3><p>在 Kotlin 2.1.0 中，我们正在提高几个标准库 API 的弃用严重性级别，从警告提升为错误。 如果你的代码依赖于这些 API，你需要更新它以确保兼容性。 最显著的更改包括：</p><ul><li><p><strong><code>Char</code> 和 <code>String</code> 的区域敏感大小写转换函数已弃用</strong>： <code>Char.toLowerCase()</code>、<code>Char.toUpperCase()</code>、<code>String.toUpperCase()</code> 和 <code>String.toLowerCase()</code> 等函数现在已弃用，使用它们会导致错误。 请将它们替换为区域无关的函数替代方案或其他大小写转换机制。 如果你想继续使用默认区域，请将 <code>String.toLowerCase()</code> 等调用替换为 <code>String.lowercase(Locale.getDefault())</code>，显式指定区域。 对于区域无关的转换，请将它们替换为 <code>String.lowercase()</code>，后者默认使用不变区域。</p></li><li><p><strong>Kotlin/Native 冻结 API 已弃用</strong>： 使用以前标记为 <code>@FreezingIsDeprecated</code> 注解的冻结相关声明现在会导致错误。 此更改反映了 Kotlin/Native 中从传统内存管理器到新内存模型的过渡， 传统内存管理器需要冻结对象才能在线程之间共享。 要了解如何在新的内存模型中从冻结相关 API 迁移， 请参阅 <a href="/kotlin/native-migration-guide#update-your-code">Kotlin/Native 迁移指南</a>。 有关更多信息，请参阅<a href="/kotlin/whatsnew1720#freezing">关于冻结弃用的公告</a>。</p></li><li><p><strong><code>appendln()</code> 已弃用，取而代之的是 <code>appendLine()</code></strong>： <code>StringBuilder.appendln()</code> 和 <code>Appendable.appendln()</code> 函数现在已弃用，使用它们会导致错误。 要替换它们，请使用 <code>StringBuilder.appendLine()</code> 或 <code>Appendable.appendLine()</code> 函数。 <code>appendln()</code> 函数被弃用是因为，在 Kotlin/JVM 上，它使用 <code>line.separator</code> 系统属性， 该属性在每个操作系统上都有不同的默认值。在 Kotlin/JVM 上，此属性在 Windows 上默认为 <code>\\r </code> (CR LF)，在其他系统上默认为 <code></code> (LF)。 另一方面，<code>appendLine()</code> 函数始终使用 <code></code> (LF) 作为行分隔符，确保在不同平台上的行为一致。</p></li></ul><p>有关此版本中受影响 API 的完整列表，请参阅 <a href="https://youtrack.jetbrains.com/issue/KT-71628" target="_blank" rel="noreferrer">KT-71628</a> YouTrack 问题。</p><h3 id="java-nio-file-path-的稳定文件树遍历扩展" tabindex="-1"><code>java.nio.file.Path</code> 的稳定文件树遍历扩展 <a class="header-anchor" href="#java-nio-file-path-的稳定文件树遍历扩展" aria-label="Permalink to &quot;\`java.nio.file.Path\` 的稳定文件树遍历扩展&quot;">​</a></h3><p>Kotlin 1.7.20 引入了 <a href="/kotlin/extensions#extension-functions"><code>java.nio.file.Path</code> 类</a>的实验性扩展函数， 允许你遍历文件树。 在 Kotlin 2.1.0 中，以下文件树遍历扩展现在已<a href="/kotlin/components-stability#stability-levels-explained">稳定</a>：</p><ul><li><code>walk()</code> 惰性遍历以指定路径为根的文件树。</li><li><code>fileVisitor()</code> 使得可以单独创建 <code>FileVisitor</code>。 <code>FileVisitor</code> 指定在遍历过程中对目录和文件执行的操作。</li><li><code>visitFileTree(fileVisitor: FileVisitor, ...)</code> 遍历文件树， 在每个遇到的条目上调用指定的 <code>FileVisitor</code>，它在底层使用 <code>java.nio.file.Files.walkFileTree()</code> 函数。</li><li><code>visitFileTree(..., builderAction: FileVisitorBuilder.() -&gt; Unit)</code> 使用提供的 <code>builderAction</code> 创建 <code>FileVisitor</code> 并调用 <code>visitFileTree(fileVisitor, ...)</code> 函数。</li><li><code>sealed interface FileVisitorBuilder</code> 允许你定义自定义 <code>FileVisitor</code> 实现。</li><li><code>enum class PathWalkOption</code> 为 <code>Path.walk()</code> 函数提供遍历选项。</li></ul><p>以下示例演示了如何使用这些文件遍历 API 创建自定义 <code>FileVisitor</code> 行为， 这允许你定义访问文件和目录的特定操作。</p><p>例如，你可以显式创建 <code>FileVisitor</code> 并稍后使用它：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cleanVisitor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fileVisitor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    onPreVisitDirectory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { directory, attributes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Placeholder: Add logic on visiting directories</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        FileVisitResult.CONTINUE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    onVisitFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { file, attributes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Placeholder: Add logic on visiting files</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        FileVisitResult.CONTINUE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Placeholder: Add logic here for general setup before traversal</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">projectDirectory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">visitFileTree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cleanVisitor)</span></span></code></pre></div><p>你也可以使用 <code>builderAction</code> 创建 <code>FileVisitor</code> 并立即将其用于遍历：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">projectDirectory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">visitFileTree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Defines the builderAction:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    onPreVisitDirectory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { directory, attributes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Some logic on visiting directories</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        FileVisitResult.CONTINUE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    onVisitFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { file, attributes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Some logic on visiting files</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        FileVisitResult.CONTINUE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此外，你可以使用 <code>walk()</code> 函数遍历以指定路径为根的文件树：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> traverseFileTree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cleanVisitor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fileVisitor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        onPreVisitDirectory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { directory, _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (directory.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;build&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                directory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">deleteRecursively</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                FileVisitResult.SKIP_SUBTREE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                FileVisitResult.CONTINUE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Deletes files with the .class extension</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        onVisitFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { file, _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (file.extension </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;class&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                file.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">deleteExisting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            FileVisitResult.CONTINUE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Sets up the root directory and files</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rootDirectory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createTempDirectory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Project&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Creates the src directory with A.kt and A.class files</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rootDirectory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;src&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { srcDirectory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        srcDirectory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createDirectory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        srcDirectory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A.kt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        srcDirectory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A.class&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Creates the build directory with a Project.jar file</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rootDirectory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;build&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { buildDirectory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        buildDirectory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createDirectory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        buildDirectory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Project.jar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Uses the walk() function:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> directoryStructure </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rootDirectory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">walk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(PathWalkOption.INCLUDE_DIRECTORIES)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">relativeTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rootDirectory).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sorted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(directoryStructure)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // &quot;[, build, build/Project.jar, src, src/A.class, src/A.kt]&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Traverses the file tree with cleanVisitor, applying the rootDirectory.visitFileTree(cleanVisitor) cleanup rules</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> directoryStructureAfterClean </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rootDirectory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">walk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(PathWalkOption.INCLUDE_DIRECTORIES)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">relativeTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rootDirectory).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sorted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(directoryStructureAfterClean)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // &quot;[, src, src/A.kt]&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="文档更新" tabindex="-1">文档更新 <a class="header-anchor" href="#文档更新" aria-label="Permalink to &quot;文档更新&quot;">​</a></h2><p>Kotlin 文档有一些显著的更改：</p><h3 id="语言概念" tabindex="-1">语言概念 <a class="header-anchor" href="#语言概念" aria-label="Permalink to &quot;语言概念&quot;">​</a></h3><ul><li>改进的 <a href="/kotlin/null-safety">空安全</a> 页面 – 了解如何安全地处理代码中的 <code>null</code> 值。</li><li>改进的 <a href="/kotlin/object-declarations">对象声明和表达式</a> 页面 – 了解如何一步定义类和创建实例。</li><li>改进的 <a href="/kotlin/control-flow#when-expressions-and-statements">When 表达式和语句</a> 部分 – 了解 <code>when</code> 条件以及如何使用它。</li><li>更新的 <a href="/kotlin/roadmap">Kotlin 路线图</a>、<a href="/kotlin/kotlin-evolution-principles">Kotlin 演进原则</a> 和 <a href="/kotlin/kotlin-language-features-and-proposals">Kotlin 语言特性和提案</a> 页面 – 了解 Kotlin 的计划、持续发展和指导原则。</li></ul><h3 id="compose-编译器" tabindex="-1">Compose 编译器 <a class="header-anchor" href="#compose-编译器" aria-label="Permalink to &quot;Compose 编译器&quot;">​</a></h3><ul><li><a href="/kotlin/compose-compiler-migration-guide">Compose 编译器文档</a> 现在位于“编译器和插件”部分 – 了解 Compose 编译器、编译器选项和迁移步骤。</li></ul><h3 id="api-参考" tabindex="-1">API 参考 <a class="header-anchor" href="#api-参考" aria-label="Permalink to &quot;API 参考&quot;">​</a></h3><ul><li>新的 <a href="https://kotlinlang.org/api/kotlin-gradle-plugin" target="_blank" rel="noreferrer">Kotlin Gradle 插件 API 参考</a> – 探索 Kotlin Gradle 插件和 Compose 编译器 Gradle 插件的 API 参考。</li></ul><h3 id="多平台开发" tabindex="-1">多平台开发 <a class="header-anchor" href="#多平台开发" aria-label="Permalink to &quot;多平台开发&quot;">​</a></h3><ul><li>新的 <a href="https://kotlinlang.org/docs/api-guidelines-build-for-multiplatform.html" target="_blank" rel="noreferrer">构建 Kotlin 库以用于多平台</a> 页面 – 了解如何为 Kotlin Multiplatform 设计你的 Kotlin 库。</li><li>新的 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/get-started.html" target="_blank" rel="noreferrer">Kotlin Multiplatform 简介</a> 页面 – 了解 Kotlin Multiplatform 的关键概念、依赖项、库等。</li><li>更新的 <a href="/kotlinmultiplatform.topic">Kotlin Multiplatform 概览</a> 页面 – 浏览 Kotlin Multiplatform 的要点和常见用例。</li><li>新的 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-ios-integration-overview.html" target="_blank" rel="noreferrer">iOS 集成</a> 部分 – 了解如何将 Kotlin Multiplatform 共享模块集成到你的 iOS 应用中。</li><li>新的 <a href="/kotlin/native-definition-file">Kotlin/Native 的定义文件</a> 页面 – 了解如何创建定义文件以使用 C 和 Objective-C 库。</li><li><a href="/kotlin/wasm-wasi">WASI 入门</a> – 了解如何在各种 WebAssembly 虚拟机中使用 WASI 运行简单的 Kotlin/Wasm 应用程序。</li></ul><h3 id="工具" tabindex="-1">工具 <a class="header-anchor" href="#工具" aria-label="Permalink to &quot;工具&quot;">​</a></h3><ul><li><a href="/kotlin/dokka-migration">新的 Dokka 迁移指南</a> – 了解如何迁移到 Dokka Gradle 插件 v2。</li></ul><h2 id="kotlin-2-1-0-兼容性指南" tabindex="-1">Kotlin 2.1.0 兼容性指南 <a class="header-anchor" href="#kotlin-2-1-0-兼容性指南" aria-label="Permalink to &quot;Kotlin 2.1.0 兼容性指南&quot;">​</a></h2><p>Kotlin 2.1.0 是一个特性版本，因此 可能会带来与你为早期语言版本编写的代码不兼容的更改。 在 <a href="/kotlin/compatibility-guide-21">Kotlin 2.1.0 兼容性指南</a> 中找到这些更改的详细列表。</p><h2 id="安装-kotlin-2-1-0" tabindex="-1">安装 Kotlin 2.1.0 <a class="header-anchor" href="#安装-kotlin-2-1-0" aria-label="Permalink to &quot;安装 Kotlin 2.1.0&quot;">​</a></h2><p>从 IntelliJ IDEA 2023.3 和 Android Studio Iguana (2023.2.1) Canary 15 开始，Kotlin 插件作为 捆绑插件包含在你的 IDE 中。这意味着你无法再从 JetBrains Marketplace 安装插件。</p><p>要更新到新的 Kotlin 版本，请在你的构建脚本中将 <a href="/kotlin/releases#update-to-a-new-kotlin-version">Kotlin 版本更改</a> 为 2.1.0。</p>`,71))])}const N=u(C,[["render",v]]);export{_ as __pageData,N as default};
