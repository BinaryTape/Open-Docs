import{_ as t,C as i,c as s,o as n,j as a,G as r,ag as l,a as c}from"./chunks/framework.Bksy39di.js";const q=JSON.parse('{"title":"从 2.0.x 迁移到 2.2.x","description":"","frontmatter":{},"headers":[],"relativePath":"ktor/migration-to-22x.md","filePath":"ktor/migration-to-22x.md","lastUpdated":1755457140000}'),d={name:"ktor/migration-to-22x.md"};function h(p,e,u,k,g,m){const o=i("show-structure");return n(),s("div",null,[e[0]||(e[0]=a("h1",{id:"从-2-0-x-迁移到-2-2-x",tabindex:"-1"},[c("从 2.0.x 迁移到 2.2.x "),a("a",{class:"header-anchor",href:"#从-2-0-x-迁移到-2-2-x","aria-label":'Permalink to "从 2.0.x 迁移到 2.2.x"'},"​")],-1)),r(o,{for:"chapter",depth:"2"}),e[1]||(e[1]=l(`<p>本指南提供了关于如何将你的 Ktor 应用程序从 2.0.x 版本迁移到 2.2.x 版本的说明。</p><blockquote><p>标记为 <code>WARNING</code> 弃用级别的 API 将继续工作，直到 3.0.0 版本发布。 关于弃用级别的更多信息，请参阅 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-deprecated/" target="_blank" rel="noreferrer">Deprecated</a>。</p></blockquote><h2 id="server" tabindex="-1">Ktor 服务器 <a class="header-anchor" href="#server" aria-label="Permalink to &quot;Ktor 服务器 {id=&quot;server&quot;}&quot;">​</a></h2><h3 id="cookies" tabindex="-1">Cookie <a class="header-anchor" href="#cookies" aria-label="Permalink to &quot;Cookie {id=&quot;cookies&quot;}&quot;">​</a></h3><p>从 v2.2.0 开始，以下与配置<a href="./server-responses#cookies">响应 cookie</a> 相关的 API 成员已更改：</p><ul><li>传递给 <code>append</code> 函数的 <code>maxAge</code> 形参类型从 <code>Int</code> 更改为 <code>Long</code>。</li><li><code>appendExpired</code> 函数已弃用。请改用带 <code>expires</code> 形参的 <code>append</code> 函数。</li></ul><h3 id="request-address-info" tabindex="-1">请求地址信息 <a class="header-anchor" href="#request-address-info" aria-label="Permalink to &quot;请求地址信息 {id=&quot;request-address-info&quot;}&quot;">​</a></h3><p>从 2.2.0 版本开始，用于获取请求所发往的主机名/端口的 <code>RequestConnectionPoint.host</code> 和 <code>RequestConnectionPoint.port</code> 属性已弃用。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> originHost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> call.request.origin.host</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> originPort </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> call.request.origin.port</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>请改用 <code>RequestConnectionPoint.serverHost</code> 和 <code>RequestConnectionPoint.serverPort</code>。 我们还添加了 <code>localHost</code>/<code>localPort</code> 属性，它们返回接收请求的主机名/端口。 关于请求地址信息的更多信息，请参阅<a href="./server-forward-headers#original-request-information">原始请求信息</a>。</p><h3 id="merge-configs" tabindex="-1">合并配置 <a class="header-anchor" href="#merge-configs" aria-label="Permalink to &quot;合并配置 {id=&quot;merge-configs&quot;}&quot;">​</a></h3><p>在 v2.2.0 之前，<code>List&lt;ApplicationConfig&gt;.merge()</code> 函数用于合并应用程序配置。 如果两个配置具有相同的键，则结果配置将采用第一个配置中的值。 在此版本中，引入了以下 API 以改进此行为：</p><ul><li><code>public fun ApplicationConfig.withFallback(other: ApplicationConfig): ApplicationConfig</code>：此函数的工作方式与 <code>merge()</code> 相同，并采用第一个配置中的值。</li><li><code>public fun ApplicationConfig.mergeWith(other: ApplicationConfig): ApplicationConfig</code>：结果配置将采用第二个配置中的值。</li></ul><h2 id="client" tabindex="-1">Ktor 客户端 <a class="header-anchor" href="#client" aria-label="Permalink to &quot;Ktor 客户端 {id=&quot;client&quot;}&quot;">​</a></h2><h3 id="persistent-storage" tabindex="-1">缓存：持久化存储 <a class="header-anchor" href="#persistent-storage" aria-label="Permalink to &quot;缓存：持久化存储 {id=&quot;persistent-storage&quot;}&quot;">​</a></h3><p>从 v2.2.0 开始，以下与响应<a href="./client-caching">缓存</a>相关的 API 已弃用：</p><ul><li><code>HttpCacheStorage</code> 类已替换为 <code>CacheStorage</code> 接口，后者可用于为所需平台实现持久化存储。</li><li><code>publicStorage</code>/<code>privateStorage</code> 属性已替换为接受 <code>CacheStorage</code> 实例的相应函数。</li></ul><h3 id="custom-plugins" tabindex="-1">自定义插件 <a class="header-anchor" href="#custom-plugins" aria-label="Permalink to &quot;自定义插件 {id=&quot;custom-plugins&quot;}&quot;">​</a></h3><p>从 2.2.0 版本开始，Ktor 提供了一个新的 API 用于创建自定义客户端插件。 欲了解更多信息，请参阅<a href="./client-custom-plugins">自定义客户端插件</a>。</p><h2 id="new-mm" tabindex="-1">新内存模型 <a class="header-anchor" href="#new-mm" aria-label="Permalink to &quot;新内存模型 {id=&quot;new-mm&quot;}&quot;">​</a></h2><p>从 v2.2.0 开始，Ktor 使用 Kotlin 的 1.7.20 版本，其中新的 Kotlin/Native 内存模型<a href="https://kotlinlang.org/docs/whatsnew1720.html#the-new-kotlin-native-memory-manager-enabled-by-default" target="_blank" rel="noreferrer">默认启用</a>。 这意味着你无需为<a href="./server-native">原生服务器</a>或面向 <a href="./client-engines#native">Kotlin/Native</a> 的客户端引擎显式启用它。</p>`,21))])}const b=t(d,[["render",h]]);export{q as __pageData,b as default};
