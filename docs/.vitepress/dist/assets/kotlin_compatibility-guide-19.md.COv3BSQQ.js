import{_ as o,c as t,o as c,ag as r}from"./chunks/framework.Bksy39di.js";const u=JSON.parse('{"title":"Kotlin 1.9 兼容性指南","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/compatibility-guide-19.md","filePath":"kotlin/compatibility-guide-19.md","lastUpdated":1754307826000}'),n={name:"kotlin/compatibility-guide-19.md"};function a(l,e,d,s,i,p){return c(),t("div",null,e[0]||(e[0]=[r('<h1 id="kotlin-1-9-兼容性指南" tabindex="-1">Kotlin 1.9 兼容性指南 <a class="header-anchor" href="#kotlin-1-9-兼容性指南" aria-label="Permalink to &quot;Kotlin 1.9 兼容性指南&quot;">​</a></h1><p><em><a href="/kotlin/kotlin-evolution-principles">保持语言现代化</a></em> 和 <em><a href="/kotlin/kotlin-evolution-principles">舒适的更新</a></em> 是 Kotlin 语言设计的核心原则。前者指出，阻碍语言演进的构造应被移除；后者指出，此移除应提前充分沟通，以使代码迁移尽可能顺畅。</p><p>虽然大多数语言更改已通过其他渠道（例如更新日志或编译器警告）公布，但本文档将它们全部汇总，为从 Kotlin 1.8 迁移到 Kotlin 1.9 提供完整的参考。</p><h2 id="基本术语" tabindex="-1">基本术语 <a class="header-anchor" href="#基本术语" aria-label="Permalink to &quot;基本术语&quot;">​</a></h2><p>本文档介绍了几种兼容性：</p><ul><li><em>source</em>：<code>source</code>（源代码）不兼容性变更会使原本可以正常编译（无错误或警告）的代码不再能够编译</li><li><em>binary</em>：如果两个二进制 <code>artifact</code> 相互替换不会导致加载或链接错误，则称它们是 <code>binary</code>（二进制）兼容的</li><li><em>behavioral</em>：如果同一程序在应用更改前后表现出不同行为，则称该更改是 <code>behavioral</code>（行为）不兼容的</li></ul><p>请记住，这些定义仅适用于纯 Kotlin。从其他语言视角（例如 Java）看 Kotlin 代码的兼容性不在本文档的<code>作用域</code>内。</p><h2 id="语言" tabindex="-1">语言 <a class="header-anchor" href="#语言" aria-label="Permalink to &quot;语言&quot;">​</a></h2><h3 id="移除语言版本-1-3" tabindex="-1">移除语言版本 1.3 <a class="header-anchor" href="#移除语言版本-1-3" aria-label="Permalink to &quot;移除语言版本 1.3&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-61111/Remove-language-version-1.3" target="_blank" rel="noreferrer">KT-61111</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.9 引入了语言版本 1.9 并移除了对语言版本 1.3 的支持。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.0: 报告警告</li><li>1.9.0: 将警告提升为错误</li></ul></blockquote><h3 id="禁止当超接口类型为函数字面值时调用超类构造函数" tabindex="-1">禁止当超接口类型为函数字面值时调用超类构造函数 <a class="header-anchor" href="#禁止当超接口类型为函数字面值时调用超类构造函数" aria-label="Permalink to &quot;禁止当超接口类型为函数字面值时调用超类构造函数&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-46344" target="_blank" rel="noreferrer">KT-46344</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 如果接口继承自函数字面值类型，Kotlin 1.9 会禁止调用超类构造函数，因为不存在此类构造函数。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.0: 报告警告（或在渐进模式下报告错误）</li><li>1.9.0: 将警告提升为错误</li></ul></blockquote><h3 id="禁止注解形参类型中的循环" tabindex="-1">禁止注解形参类型中的循环 <a class="header-anchor" href="#禁止注解形参类型中的循环" aria-label="Permalink to &quot;禁止注解形参类型中的循环&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-47932" target="_blank" rel="noreferrer">KT-47932</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.9 禁止注解的类型直接或间接地用作其 <code>parameter</code> 类型之一。这可以防止创建循环。但是，允许 <code>parameter</code> 类型为该注解类型的 <code>Array</code> 或 <code>vararg</code>。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.0: 报告关于注解 <code>parameter</code> 类型中循环的警告（或在渐进模式下报告错误）</li><li>1.9.0: 将警告提升为错误，可以使用 <code>-XXLanguage:-ProhibitCyclesInAnnotations</code> 暂时恢复到 1.9 之前的行为</li></ul></blockquote><h3 id="禁止在无形参的函数类型上使用-extensionfunctiontype-注解" tabindex="-1">禁止在无形参的函数类型上使用 @ExtensionFunctionType 注解 <a class="header-anchor" href="#禁止在无形参的函数类型上使用-extensionfunctiontype-注解" aria-label="Permalink to &quot;禁止在无形参的函数类型上使用 @ExtensionFunctionType 注解&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-43527" target="_blank" rel="noreferrer">KT-43527</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.9 禁止在无<code>形参</code>的<code>函数</code>类型上，或在非<code>函数</code>类型上使用 <code>@ExtensionFunctionType</code> 注解。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.0: 报告关于非<code>函数</code>类型注解的警告，报告关于<strong>是</strong><code>函数</code>类型的注解的错误</li><li>1.9.0: 将关于<code>函数</code>类型的警告提升为错误</li></ul></blockquote><h3 id="禁止-java-字段类型在赋值时不匹配" tabindex="-1">禁止 Java 字段类型在赋值时不匹配 <a class="header-anchor" href="#禁止-java-字段类型在赋值时不匹配" aria-label="Permalink to &quot;禁止 Java 字段类型在赋值时不匹配&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48994" target="_blank" rel="noreferrer">KT-48994</a></p><p><strong>Component</strong>: Kotlin/JVM</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 如果检测到赋值给 Java <code>field</code> 的值的类型与 Java <code>field</code> 的投影类型不匹配，Kotlin 1.9 会报告<code>编译器</code>错误。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.0: 当投影的 Java <code>field</code> 类型与赋值的值类型不匹配时，报告警告（或在渐进模式下报告错误）</li><li>1.9.0: 将警告提升为错误，可以使用 <code>-XXLanguage:-RefineTypeCheckingOnAssignmentsToJavaFields</code> 暂时恢复到 1.9 之前的行为</li></ul></blockquote><h3 id="平台类型空安全断言异常中不包含源代码摘录" tabindex="-1">平台类型<code>空安全</code>断言异常中不包含源代码摘录 <a class="header-anchor" href="#平台类型空安全断言异常中不包含源代码摘录" aria-label="Permalink to &quot;平台类型`空安全`断言异常中不包含源代码摘录&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-57570" target="_blank" rel="noreferrer">KT-57570</a></p><p><strong>Component</strong>: Kotlin/JVM</p><p><strong>Incompatible change type</strong>: behavioral</p><p><strong>Short summary</strong>: 在 Kotlin 1.9 中，表达式空<code>检测</code>的异常消息不包含源代码摘录。取而代之的是，会显示<code>方法</code>或<code>字段</code>的名称。如果<code>表达式</code>不是<code>方法</code>或<code>字段</code>，则消息中不提供额外信息。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>&lt; 1.9.0: 表达式空<code>检测</code>生成的异常消息包含源代码摘录</li><li>1.9.0: 表达式空<code>检测</code>生成的异常消息仅包含<code>方法</code>或<code>字段</code>名称，可以使用 <code>-XXLanguage:-NoSourceCodeInNotNullAssertionExceptions</code> 暂时恢复到 1.9 之前的行为</li></ul></blockquote><h3 id="禁止将超类调用委托给抽象超类成员" tabindex="-1">禁止将超类调用委托给抽象超类成员 <a class="header-anchor" href="#禁止将超类调用委托给抽象超类成员" aria-label="Permalink to &quot;禁止将超类调用委托给抽象超类成员&quot;">​</a></h3><blockquote><p><strong>Issues</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-45508" target="_blank" rel="noreferrer">KT-45508</a>, <a href="https://youtrack.jetbrains.com/issue/KT-49017" target="_blank" rel="noreferrer">KT-49017</a>, <a href="https://youtrack.jetbrains.com/issue/KT-38078" target="_blank" rel="noreferrer">KT-38078</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 将报告编译错误，当显式或隐式超类调用<code>委托</code>给超类的 <em>抽象</em> 成员时，即使超接口中存在默认实现。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.5.20: 引入警告，当使用未<code>覆盖</code>所有抽象成员的非抽象类时</li><li>1.7.0: 如果超类调用实际上访问了超类中的抽象成员，则报告警告</li><li>1.7.0: 如果启用了 <code>-Xjvm-default=all</code> 或 <code>-Xjvm-default=all-compatibility</code> 兼容模式，则在所有受影响的情况下报告错误；在渐进模式下报告错误</li><li>1.8.0: 报告在声明具有超类中未<code>覆盖</code>的抽象<code>方法</code>的具象类，以及超类中 <code>Any</code> <code>方法</code>的超类调用被<code>覆盖</code>为抽象的情况下的错误</li><li>1.9.0: 在所有受影响的情况下报告错误，包括对超类中抽象<code>方法</code>的显式超类调用</li></ul></blockquote><h3 id="废弃-when-表达式中令人混淆的语法" tabindex="-1">废弃 <code>when</code> 表达式中令人混淆的语法 <a class="header-anchor" href="#废弃-when-表达式中令人混淆的语法" aria-label="Permalink to &quot;废弃 `when` 表达式中令人混淆的语法&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48385" target="_blank" rel="noreferrer">KT-48385</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.6 <code>废弃</code>了 <code>when</code> 条件表达式中几个令人混淆的语法构造。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.20: 对受影响的表达式引入<code>废弃</code>警告</li><li>1.8.0: 将此警告提升为错误，<code>-XXLanguage:-ProhibitConfusingSyntaxInWhenBranches</code> 可用于暂时恢复到 1.8 之前的行为</li><li><blockquote><p>= 2.1: 将一些<code>废弃</code>的构造重新用于新的语言<code>特性</code></p></blockquote></li></ul></blockquote><h3 id="阻止不同数字类型之间的隐式强制转换" tabindex="-1">阻止不同数字类型之间的隐式强制转换 <a class="header-anchor" href="#阻止不同数字类型之间的隐式强制转换" aria-label="Permalink to &quot;阻止不同数字类型之间的隐式强制转换&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48645" target="_blank" rel="noreferrer">KT-48645</a></p><p><strong>Component</strong>: Kotlin/JVM</p><p><strong>Incompatible change type</strong>: behavioral</p><p><strong>Short summary</strong>: Kotlin 将避免将数字值自动转换为<code>原语</code>数字类型，而仅在语义上需要<code>向下转型</code>为该类型的情况下才进行转换。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>&lt; 1.5.30: 在所有受影响的情况下的旧行为</li><li>1.5.30: <code>构建</code>的属性<code>委托</code>访问器中<code>向下转型</code>行为的修复，<code>-Xuse-old-backend</code> 可用于暂时恢复到 1.5.30 修复之前的行为</li><li><blockquote><p>= 2.0: 在其他受影响的情况下修复<code>向下转型</code>行为</p></blockquote></li></ul></blockquote><h3 id="禁止泛型类型别名使用中的上界违例-在别名类型的类型实参的泛型类型实参中使用的类型形参" tabindex="-1">禁止泛型类型别名使用中的上界违例（在别名类型的类型<code>实参</code>的泛型类型<code>实参</code>中使用的类型<code>形参</code>） <a class="header-anchor" href="#禁止泛型类型别名使用中的上界违例-在别名类型的类型实参的泛型类型实参中使用的类型形参" aria-label="Permalink to &quot;禁止泛型类型别名使用中的上界违例（在别名类型的类型`实参`的泛型类型`实参`中使用的类型`形参`）&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-54066" target="_blank" rel="noreferrer">KT-54066</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 将禁止使用带有类型<code>实参</code>的类型别名，这些<code>实参</code>违反了别名类型相应类型<code>形参</code>的<code>上界</code>限制，当类型别名类型<code>形参</code>用作别名类型的类型<code>实参</code>的泛型类型<code>实参</code>时，例如 <code>typealias Alias&lt;T&gt; = Base&lt;List&lt;T&gt;&gt;</code>。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.8.0: 当泛型类型别名使用中的类型<code>实参</code>违反了别名类型相应类型<code>形参</code>的<code>上界</code>约束时，报告警告</li><li>2.0.0: 将警告提升为错误</li></ul></blockquote><h3 id="在公共签名中近似局部类型时保持可空性" tabindex="-1">在公共签名中近似局部类型时保持<code>可空性</code> <a class="header-anchor" href="#在公共签名中近似局部类型时保持可空性" aria-label="Permalink to &quot;在公共签名中近似局部类型时保持`可空性`&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-53982" target="_blank" rel="noreferrer">KT-53982</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source, binary</p><p><strong>Short summary</strong>: 当局部或匿名类型从没有显式指定返回类型的<code>表达式</code>体<code>函数</code>返回时，Kotlin <code>编译器</code>会使用该类型的已知超类型来<code>推断</code>（或近似）返回类型。在此过程中，<code>编译器</code>可能会<code>推断</code>出<code>非空的</code>类型，而实际上可能返回 <code>null</code> 值。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.8.0: 通过 <code>flexible</code> 超类型近似 <code>flexible</code> 类型</li><li>1.8.0: 当<code>声明</code>被<code>推断</code>为应<code>可空</code>却为<code>非空</code>类型时，报告警告，提示用户显式指定类型</li><li>2.0.0: 通过<code>可空</code>超类型近似<code>可空</code>类型，<code>-XXLanguage:-KeepNullabilityWhenApproximatingLocalType</code> 可用于暂时恢复到 2.0 之前的行为</li></ul></blockquote><h3 id="不通过覆盖传播废弃状态" tabindex="-1">不通过<code>覆盖</code>传播<code>废弃</code>状态 <a class="header-anchor" href="#不通过覆盖传播废弃状态" aria-label="Permalink to &quot;不通过`覆盖`传播`废弃`状态&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-47902" target="_blank" rel="noreferrer">KT-47902</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.9 将不再将<code>废弃</code>状态从超类中已<code>废弃</code>的成员传播到子类中其<code>覆盖</code>的成员，从而为<code>废弃</code>超类成员同时使其在子类中不被<code>废弃</code>提供了显式机制。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.20: 报告带有未来行为更改消息的警告，并提示要么抑制此警告，要么在已<code>废弃</code>成员的<code>覆盖</code>处显式写入 <code>@Deprecated</code> 注解</li><li>1.9.0: 停止向被<code>覆盖</code>的成员传播<code>废弃</code>状态。此更改也会立即在渐进模式下生效</li></ul></blockquote><h3 id="禁止在注解类中除其形参-声明之外的任何地方使用集合字面值" tabindex="-1">禁止在注解类中除其<code>形参``声明</code>之外的任何地方使用<code>集合</code>字面值 <a class="header-anchor" href="#禁止在注解类中除其形参-声明之外的任何地方使用集合字面值" aria-label="Permalink to &quot;禁止在注解类中除其`形参``声明`之外的任何地方使用`集合`字面值&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-39041" target="_blank" rel="noreferrer">KT-39041</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 允许以受限方式使用<code>集合</code>字面值——用于将数组传递给注解类的<code>形参</code>或为此类<code>形参</code>指定默认值。然而除此之外，Kotlin 允许在注解类内部的任何其他地方使用<code>集合</code>字面值，例如在其嵌套对象中。Kotlin 1.9 将禁止在注解类中除其<code>形参</code>的默认值之外的任何地方使用<code>集合</code>字面值。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.0: 报告关于注解类中嵌套对象中数组字面值的警告（或在渐进模式下报告错误）</li><li>1.9.0: 将警告提升为错误</li></ul></blockquote><h3 id="禁止在默认值表达式中向前引用形参" tabindex="-1">禁止在默认值表达式中向前引用<code>形参</code> <a class="header-anchor" href="#禁止在默认值表达式中向前引用形参" aria-label="Permalink to &quot;禁止在默认值表达式中向前引用`形参`&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-25694" target="_blank" rel="noreferrer">KT-25694</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.9 将禁止在其他<code>形参</code>的默认值表达式中向前引用<code>形参</code>。这确保了在<code>形参</code>被默认值表达式访问时，它已经通过<code>函数</code>传递了值或通过其自身的默认值表达式初始化了值。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.0: 当带有默认值的<code>形参</code>在它之前的另一个<code>形参</code>的默认值中被引用时，报告警告（或在渐进模式下报告错误）</li><li>1.9.0: 将警告提升为错误，<code>-XXLanguage:-ProhibitIllegalValueParameterUsageInDefaultArguments</code> 可用于暂时恢复到 1.9 之前的行为</li></ul></blockquote><h3 id="禁止对内联函数-形参进行扩展调用" tabindex="-1">禁止对内联<code>函数``形参</code>进行<code>扩展</code>调用 <a class="header-anchor" href="#禁止对内联函数-形参进行扩展调用" aria-label="Permalink to &quot;禁止对内联`函数``形参`进行`扩展`调用&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-52502" target="_blank" rel="noreferrer">KT-52502</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 尽管 Kotlin 允许将内联<code>函数``形参</code>作为<code>接收者</code>传递给另一个内联<code>函数</code>，但编译此类<code>代码块</code>时总是导致<code>编译器</code>异常。Kotlin 1.9 将禁止此行为，从而报告错误而不是导致<code>编译器</code>崩溃。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.20: 报告关于内联<code>函数``形参</code>上的内联<code>扩展</code>调用的警告（或在渐进模式下报告错误）</li><li>1.9.0: 将警告提升为错误</li></ul></blockquote><h3 id="禁止调用名为-suspend-且带有匿名函数-实参的中缀函数" tabindex="-1">禁止调用名为 <code>suspend</code> 且带有匿名<code>函数``实参</code>的<code>中缀函数</code> <a class="header-anchor" href="#禁止调用名为-suspend-且带有匿名函数-实参的中缀函数" aria-label="Permalink to &quot;禁止调用名为 `suspend` 且带有匿名`函数``实参`的`中缀函数`&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-49264" target="_blank" rel="noreferrer">KT-49264</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.9 将不再允许调用名为 <code>suspend</code> 且带有一个作为匿名<code>函数</code>字面值传递的<code>函数``类型``实参</code>的<code>中缀函数</code>。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.20: 报告关于 <code>suspend</code> <code>中缀函数</code>调用（带匿名<code>函数</code>字面值）的警告</li><li>1.9.0: 将警告提升为错误，<code>-XXLanguage:-ModifierNonBuiltinSuspendFunError</code> 可用于暂时恢复到 1.9 之前的行为</li><li>TODO: 更改解析器解释 <code>suspend fun</code> 令牌序列的方式</li></ul></blockquote><h3 id="禁止在内部类中违背型变规则使用捕获的类型形参" tabindex="-1">禁止在内部类中违背<code>型变</code>规则使用捕获的类型<code>形参</code> <a class="header-anchor" href="#禁止在内部类中违背型变规则使用捕获的类型形参" aria-label="Permalink to &quot;禁止在内部类中违背`型变`规则使用捕获的类型`形参`&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-50947" target="_blank" rel="noreferrer">KT-50947</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.9 将禁止在该类的内部类中，在违反该类型<code>形参``声明</code>的<code>型变</code>规则的位置使用具有 <code>in</code> 或 <code>out</code> <code>型变</code>的外部类的类型<code>形参</code>。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.0: 当外部类的类型<code>形参</code>使用位置违反该<code>形参</code>的<code>型变</code>规则时，报告警告（或在渐进模式下报告错误）</li><li>1.9.0: 将警告提升为错误，<code>-XXLanguage:-ReportTypeVarianceConflictOnQualifierArguments</code> 可用于暂时恢复到 1.9 之前的行为</li></ul></blockquote><h3 id="禁止在复合赋值操作符中递归调用无显式返回类型的函数" tabindex="-1">禁止在复合赋值<code>操作符</code>中递归调用无显式返回类型的<code>函数</code> <a class="header-anchor" href="#禁止在复合赋值操作符中递归调用无显式返回类型的函数" aria-label="Permalink to &quot;禁止在复合赋值`操作符`中递归调用无显式返回类型的`函数`&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48546" target="_blank" rel="noreferrer">KT-48546</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.9 将禁止在<code>函数</code>体内部的复合<code>赋值``操作符``实参</code>中调用无显式返回类型的<code>函数</code>，就像它目前在该<code>函数</code>体内部的其他表达式中那样。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.0: 当无显式返回类型的<code>函数</code>在该<code>函数</code>体内部的复合<code>赋值``操作符``实参</code>中被递归调用时，报告警告（或在渐进模式下报告错误）</li><li>1.9.0: 将警告提升为错误</li></ul></blockquote><h3 id="禁止-expected-notnull-t-和-given-kotlin-generic-parameter-with-nullable-bound-之间不健全的调用" tabindex="-1">禁止 <code>expected @NotNull T</code> 和 <code>given Kotlin generic parameter with nullable bound</code> 之间不健全的调用 <a class="header-anchor" href="#禁止-expected-notnull-t-和-given-kotlin-generic-parameter-with-nullable-bound-之间不健全的调用" aria-label="Permalink to &quot;禁止 `expected @NotNull T` 和 `given Kotlin generic parameter with nullable bound` 之间不健全的调用&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-36770" target="_blank" rel="noreferrer">KT-36770</a></p><p><strong>Component</strong>: Kotlin/JVM</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.9 将禁止<code>方法</code>调用，当将潜在<code>可空</code>泛型类型的值传递给 Java <code>方法</code>的 <code>@NotNull</code> 注解<code>形参</code>时。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.5.20: 当将无约束的泛型类型<code>形参</code>传递给预期为<code>非空</code>类型的位置时，报告警告</li><li>1.9.0: 报告类型不匹配错误而非上述警告，<code>-XXLanguage:-ProhibitUsingNullableTypeParameterAgainstNotNullAnnotated</code> 可用于暂时恢复到 1.8 之前的行为</li></ul></blockquote><h3 id="禁止在枚举类的条目初始化器中访问枚举伴生对象成员" tabindex="-1">禁止在<code>枚举类</code>的条目初始化器中访问<code>枚举</code>伴生对象成员 <a class="header-anchor" href="#禁止在枚举类的条目初始化器中访问枚举伴生对象成员" aria-label="Permalink to &quot;禁止在`枚举类`的条目初始化器中访问`枚举`伴生对象成员&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-49110" target="_blank" rel="noreferrer">KT-49110</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.9 将禁止从<code>枚举</code>条目初始化器中对<code>枚举``伴生对象</code>的所有类型访问。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.20: 报告关于此类<code>伴生对象</code>成员访问的警告（或在渐进模式下报告错误）</li><li>1.9.0: 将警告提升为错误，<code>-XXLanguage:-ProhibitAccessToEnumCompanionMembersInEnumConstructorCall</code> 可用于暂时恢复到 1.8 之前的行为</li></ul></blockquote><h3 id="废弃并移除-enum-declaringclass-合成属性" tabindex="-1"><code>废弃</code>并移除 <code>Enum.declaringClass</code> 合成属性 <a class="header-anchor" href="#废弃并移除-enum-declaringclass-合成属性" aria-label="Permalink to &quot;`废弃`并移除 `Enum.declaringClass` 合成属性&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-49653" target="_blank" rel="noreferrer">KT-49653</a></p><p><strong>Component</strong>: Kotlin/JVM</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 允许对从底层 Java 类 <code>java.lang.Enum</code> 的 <code>getDeclaringClass()</code> <code>方法</code>生成的 <code>Enum</code> 值使用合成属性 <code>declaringClass</code>，即使此<code>方法</code>对 Kotlin <code>Enum</code> 类型不可用。Kotlin 1.9 将禁止使用此属性，建议迁移到<code>扩展</code>属性 <code>declaringJavaClass</code>。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.0: 报告关于 <code>declaringClass</code> 属性用法的警告（或在渐进模式下报告错误），建议迁移到 <code>declaringJavaClass</code> <code>扩展</code></li><li>1.9.0: 将警告提升为错误，<code>-XXLanguage:-ProhibitEnumDeclaringClass</code> 可用于暂时恢复到 1.9 之前的行为</li><li>2.0.0: 移除 <code>declaringClass</code> 合成属性</li></ul></blockquote><h3 id="废弃-编译器选项-xjvm-default-的-enable-和-compatibility-模式" tabindex="-1"><code>废弃</code> <code>编译器</code>选项 <code>-Xjvm-default</code> 的 <code>enable</code> 和 <code>compatibility</code> 模式 <a class="header-anchor" href="#废弃-编译器选项-xjvm-default-的-enable-和-compatibility-模式" aria-label="Permalink to &quot;`废弃` `编译器`选项 `-Xjvm-default` 的 `enable` 和 `compatibility` 模式&quot;">​</a></h3><blockquote><p><strong>Issues</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-46329" target="_blank" rel="noreferrer">KT-46329</a>, <a href="https://youtrack.jetbrains.com/issue/KT-54746" target="_blank" rel="noreferrer">KT-54746</a></p><p><strong>Component</strong>: Kotlin/JVM</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.9 禁止使用 <code>编译器</code>选项 <code>-Xjvm-default</code> 的 <code>enable</code> 和 <code>compatibility</code> 模式。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.20: 对 <code>编译器</code>选项 <code>-Xjvm-default</code> 的 <code>enable</code> 和 <code>compatibility</code> 模式引入警告</li><li>1.9.0: 将此警告提升为错误</li></ul></blockquote><h3 id="禁止在构建器-推断上下文的上界中隐式推断类型变量" tabindex="-1">禁止在<code>构建器``推断</code>上下文的<code>上界</code>中隐式<code>推断</code>类型变量 <a class="header-anchor" href="#禁止在构建器-推断上下文的上界中隐式推断类型变量" aria-label="Permalink to &quot;禁止在`构建器``推断`上下文的`上界`中隐式`推断`类型变量&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-47986" target="_blank" rel="noreferrer">KT-47986</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 2.0 将禁止在<code>构建器``推断</code> <code>lambda 表达式</code>的<code>作用域</code>中，在没有任何使用点类型信息的情况下，将类型变量<code>推断</code>为相应类型<code>形参</code>的<code>上界</code>，其方式与当前在其他上下文中的方式相同。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.20: 当在没有使用点类型信息的情况下，类型<code>形参</code>被<code>推断</code>为<code>声明</code>的<code>上界</code>时，报告警告（或在渐进模式下报告错误）</li><li>2.0.0: 将警告提升为错误</li></ul></blockquote><h2 id="标准库" tabindex="-1">标准库 <a class="header-anchor" href="#标准库" aria-label="Permalink to &quot;标准库&quot;">​</a></h2><h3 id="range-progression-实现-collection-时警告潜在的重载决议更改" tabindex="-1"><code>Range</code>/<code>Progression</code> 实现 <code>Collection</code> 时警告潜在的重载决议更改 <a class="header-anchor" href="#range-progression-实现-collection-时警告潜在的重载决议更改" aria-label="Permalink to &quot;`Range`/`Progression` 实现 `Collection` 时警告潜在的重载决议更改&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-49276" target="_blank" rel="noreferrer">KT-49276</a></p><p><strong>Component</strong>: Core language / kotlin-stdlib</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 计划在 Kotlin 1.9 中在标准<code>数列</code>和从它们<code>继承</code>的具体<code>区间</code>中实现 <code>Collection</code> <code>接口</code>。如果某个<code>方法</code>有两个<code>重载</code>，一个接受<code>元素</code>，另一个接受<code>集合</code>，这可能会导致在<code>重载决议</code>中选择不同的<code>重载</code>。当使用<code>区间</code>或<code>数列``实参</code>调用此类<code>重载``方法</code>时，Kotlin 将通过报告警告或错误来使这种情况可见。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.20: 当<code>重载``方法</code>以标准<code>数列</code>或其<code>区间``继承者</code>作为<code>实参</code>调用时，如果此<code>数列</code>/<code>区间</code>实现 <code>Collection</code> <code>接口</code>导致将来在此调用中选择另一个<code>重载</code>，则报告警告</li><li>1.8.0: 将此警告提升为错误</li><li>2.1.0: 停止报告错误，在<code>数列</code>中实现 <code>Collection</code> <code>接口</code>，从而更改受影响情况下的<code>重载决议</code>结果</li></ul></blockquote><h3 id="将-kotlin-dom-和-kotlin-browser-包中的声明迁移到-kotlinx" tabindex="-1">将 <code>kotlin.dom</code> 和 <code>kotlin.browser</code> 包中的<code>声明</code>迁移到 <code>kotlinx.*</code> <a class="header-anchor" href="#将-kotlin-dom-和-kotlin-browser-包中的声明迁移到-kotlinx" aria-label="Permalink to &quot;将 `kotlin.dom` 和 `kotlin.browser` 包中的`声明`迁移到 `kotlinx.*`&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-39330" target="_blank" rel="noreferrer">KT-39330</a></p><p><strong>Component</strong>: kotlin-stdlib (JS)</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: <code>kotlin.dom</code> 和 <code>kotlin.browser</code> 包中的<code>声明</code>已移至相应的 <code>kotlinx.*</code> 包，以准备将其从标准库中提取。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.4.0: 在 <code>kotlinx.dom</code> 和 <code>kotlinx.browser</code> 包中引入替代 API</li><li>1.4.0: <code>废弃</code> <code>kotlin.dom</code> 和 <code>kotlin.browser</code> 包中的 API 并建议使用上述新 API 作为替代</li><li>1.6.0: 将<code>废弃</code>级别提升为错误</li><li>1.8.20: 为 JS-IR <code>target</code> 从标准库中移除<code>废弃</code>的<code>函数</code></li><li><blockquote><p>= 2.0: 将 <code>kotlinx.*</code> 包中的 API 移至单独的库</p></blockquote></li></ul></blockquote><h3 id="废弃一些仅限-js-的-api" tabindex="-1"><code>废弃</code>一些仅限 JS 的 API <a class="header-anchor" href="#废弃一些仅限-js-的-api" aria-label="Permalink to &quot;`废弃`一些仅限 JS 的 API&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48587" target="_blank" rel="noreferrer">KT-48587</a></p><p><strong>Component</strong>: kotlin-stdlib (JS)</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 标准库中一些仅限 JS 的<code>函数</code>已<code>废弃</code>以备移除。它们包括：<code>String.concat(String)</code>、<code>String.match(regex: String)</code>、<code>String.matches(regex: String)</code>，以及接受比较<code>函数</code>的数组<code>排序函数</code>，例如 <code>Array&lt;out T&gt;.sort(comparison: (a: T, b: T) -&gt; Int)</code>。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.0: <code>废弃</code>受影响的<code>函数</code>并发出警告</li><li>1.9.0: 将<code>废弃</code>级别提升为错误</li><li><blockquote><p>=2.0: 从公共 API 中移除<code>废弃</code>的<code>函数</code></p></blockquote></li></ul></blockquote><h2 id="工具" tabindex="-1">工具 <a class="header-anchor" href="#工具" aria-label="Permalink to &quot;工具&quot;">​</a></h2><h3 id="从-gradle-设置中移除-enableendorsedlibs-标志" tabindex="-1">从 Gradle 设置中移除 <code>enableEndorsedLibs</code> 标志 <a class="header-anchor" href="#从-gradle-设置中移除-enableendorsedlibs-标志" aria-label="Permalink to &quot;从 Gradle 设置中移除 `enableEndorsedLibs` 标志&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-54098" target="_blank" rel="noreferrer">KT-54098</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Gradle 设置不再支持 <code>enableEndorsedLibs</code> 标志。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>&lt; 1.9.0: Gradle 设置支持 <code>enableEndorsedLibs</code> 标志</li><li>1.9.0: Gradle 设置<strong>不</strong>支持 <code>enableEndorsedLibs</code> 标志</li></ul></blockquote><h3 id="移除-gradle-约定" tabindex="-1">移除 Gradle 约定 <a class="header-anchor" href="#移除-gradle-约定" aria-label="Permalink to &quot;移除 Gradle 约定&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-52976" target="_blank" rel="noreferrer">KT-52976</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Gradle 约定已在 Gradle 7.1 中<code>废弃</code>，并已在 Gradle 8 中移除。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.20: Gradle 约定已<code>废弃</code></li><li>1.9.0: Gradle 约定已移除</li></ul></blockquote><h3 id="移除-kotlincompile-任务的-classpath-属性" tabindex="-1">移除 <code>KotlinCompile</code> <code>任务</code>的 <code>classpath</code> 属性 <a class="header-anchor" href="#移除-kotlincompile-任务的-classpath-属性" aria-label="Permalink to &quot;移除 `KotlinCompile` `任务`的 `classpath` 属性&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-53748" target="_blank" rel="noreferrer">KT-53748</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: <code>KotlinCompile</code> <code>任务</code>的 <code>classpath</code> 属性已移除。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.0: <code>classpath</code> 属性已<code>废弃</code></li><li>1.8.0: 将<code>废弃</code>级别提升为错误</li><li>1.9.0: 从公共 API 中移除<code>废弃</code>的<code>函数</code></li></ul></blockquote><h3 id="废弃-kotlin-internal-single-build-metrics-file-属性" tabindex="-1"><code>废弃</code> <code>kotlin.internal.single.build.metrics.file</code> 属性 <a class="header-anchor" href="#废弃-kotlin-internal-single-build-metrics-file-属性" aria-label="Permalink to &quot;`废弃` `kotlin.internal.single.build.metrics.file` 属性&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-53357" target="_blank" rel="noreferrer">KT-53357</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: <code>废弃</code>用于<code>定义</code>单个<code>文件</code>以<code>构建</code>报告的 <code>kotlin.internal.single.build.metrics.file</code> 属性。请改用 <code>kotlin.build.report.single_file</code> 属性并设置 <code>kotlin.build.report.output=single_file</code>。</p><p><strong>Deprecation cycle:</strong></p><ul><li>1.8.0: 将<code>废弃</code>级别提升为警告</li><li><blockquote><p>= 1.9: 删除该属性</p></blockquote></li></ul></blockquote>',70)]))}const h=o(n,[["render",a]]);export{u as __pageData,h as default};
