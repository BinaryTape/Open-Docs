import{_ as a}from"./chunks/ksp-class-diagram.ClaR6pZl.js";import{_ as n,c as t,o as l,j as e,ag as o,a as s}from"./chunks/framework.Bksy39di.js";const f=JSON.parse('{"title":"KSP가 Kotlin 코드를 모델링하는 방법","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/ksp-additional-details.md","filePath":"ko/kotlin/ksp-additional-details.md","lastUpdated":1754307826000}'),p={name:"ko/kotlin/ksp-additional-details.md"};function r(d,i,c,k,h,g){return l(),t("div",null,i[0]||(i[0]=[e("h1",{id:"ksp가-kotlin-코드를-모델링하는-방법",tabindex:"-1"},[s("KSP가 Kotlin 코드를 모델링하는 방법 "),e("a",{class:"header-anchor",href:"#ksp가-kotlin-코드를-모델링하는-방법","aria-label":'Permalink to "KSP가 Kotlin 코드를 모델링하는 방법"'},"​")],-1),e("p",null,[s("API 정의는 "),e("a",{href:"https://github.com/google/ksp/tree/main/api/src/main/kotlin/com/google/devtools/ksp",target:"_blank",rel:"noreferrer"},"KSP GitHub 리포지토리"),s("에서 찾을 수 있습니다. 다음 다이어그램은 KSP에서 Kotlin이 "),e("a",{href:"https://github.com/google/ksp/tree/main/api/src/main/kotlin/com/google/devtools/ksp/symbol/",target:"_blank",rel:"noreferrer"},"모델링되는"),s(" 방식에 대한 개요를 보여줍니다.")],-1),e("p",null,[e("img",{src:a,alt:"클래스 다이어그램",thumbnail:"true",width:"800","thumbnail-same-file":"true"})],-1),o(`<div class="note custom-block"><p class="custom-block-title">NOTE</p><p><a href="https://kotlinlang.org/docs/images/ksp-class-diagram.svg" target="_blank" rel="noreferrer">전체 크기 다이어그램 보기</a>.</p></div><h2 id="타입-및-해석" tabindex="-1">타입 및 해석 <a class="header-anchor" href="#타입-및-해석" aria-label="Permalink to &quot;타입 및 해석&quot;">​</a></h2><p>해석(resolution)은 기본 API 구현의 비용 대부분을 차지합니다. 따라서 타입 참조는 (몇 가지 예외는 있지만) 프로세서에 의해 명시적으로 해석되도록 설계되었습니다. <code>_타입_</code>(<code>KSFunctionDeclaration.returnType</code> 또는 <code>KSAnnotation.annotationType</code> 등)이 참조될 때, 항상 <code>KSTypeReference</code>이며, 이는 어노테이션과 수정자를 포함하는 <code>KSReferenceElement</code>입니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> KSFunctionDeclaration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> returnType: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSTypeReference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> KSTypeReference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSAnnotated</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSModifierListOwner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> type: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSReferenceElement</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>KSTypeReference</code>는 <code>KSType</code>으로 해석될 수 있으며, 이는 Kotlin의 타입 시스템에 있는 타입을 나타냅니다.</p><p><code>KSTypeReference</code>는 <code>KSReferenceElement</code>를 가지고 있는데, 이는 Kotlin의 프로그램 구조, 즉 참조가 작성되는 방식을 모델링합니다. 이는 Kotlin 문법의 <a href="https://kotlinlang.org/docs/reference/grammar.html#type" target="_blank" rel="noreferrer"><code>type</code></a> 요소에 해당합니다.</p><p><code>KSReferenceElement</code>는 <code>KSClassifierReference</code> 또는 <code>KSCallableReference</code>가 될 수 있으며, 해석 없이도 많은 유용한 정보를 포함합니다. 예를 들어, <code>KSClassifierReference</code>는 <code>referencedName</code>을 가지고 있고, <code>KSCallableReference</code>는 <code>receiverType</code>, <code>functionArguments</code>, <code>returnType</code>을 가집니다.</p><p><code>KSTypeReference</code>에 의해 참조되는 원본 선언이 필요한 경우, 일반적으로 <code>KSType</code>으로 해석하고 <code>KSType.declaration</code>을 통해 접근하여 찾을 수 있습니다. 타입이 언급된 곳에서 해당 클래스가 정의된 곳으로 이동하는 방식은 다음과 같습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ksType: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSType</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ksTypeReference.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ksDeclaration: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSDeclaration</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ksType.declaration</span></span></code></pre></div><p>타입 해석은 비용이 많이 들며 따라서 명시적인 형태를 가집니다. 해석을 통해 얻을 수 있는 정보 중 일부는 이미 <code>KSReferenceElement</code>에서 사용 가능합니다. 예를 들어, <code>KSClassifierReference.referencedName</code>은 관심 없는 많은 요소를 걸러낼 수 있습니다. <code>KSDeclaration</code> 또는 <code>KSType</code>에서 특정 정보가 필요한 경우에만 타입을 해석해야 합니다.</p><p>함수 타입을 가리키는 <code>KSTypeReference</code>는 대부분의 정보를 자체 요소에 가지고 있습니다. <code>Function0</code>, <code>Function1</code> 등의 패밀리로 해석될 수 있지만, 이러한 해석은 <code>KSCallableReference</code>보다 더 많은 정보를 제공하지 않습니다. 함수 타입 참조를 해석하는 한 가지 사용 사례는 함수 프로토타입의 동일성(identity)을 다루는 것입니다.</p>`,11)]))}const m=n(p,[["render",r]]);export{f as __pageData,m as default};
