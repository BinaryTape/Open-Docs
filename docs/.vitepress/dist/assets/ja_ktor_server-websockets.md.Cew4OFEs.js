import{_ as F,C as t,c as b,o as m,G as a,ag as o,j as i,w as n,a as e}from"./chunks/framework.Bksy39di.js";const x=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ja/ktor/server-websockets.md","filePath":"ja/ktor/server-websockets.md","lastUpdated":1755457140000}'),v={name:"ja/ktor/server-websockets.md"};function C(f,s,S,B,w,q){const r=t("TopicTitle"),d=t("show-structure"),E=t("primary-label"),p=t("Links"),c=t("tldr"),g=t("link-summary"),y=t("snippet"),l=t("code-block"),k=t("TabItem"),h=t("Tabs"),u=t("list");return m(),b("div",null,[a(r,{labelRef:"server-plugin",title:"KtorサーバーにおけるWebSockets"}),a(d,{for:"chapter",depth:"2"}),a(E,{ref:"server-plugin"},null,512),a(c,null,{default:n(()=>[s[3]||(s[3]=i("p",null,[i("b",null,"必須の依存関係"),e(": "),i("code",null,"io.ktor:ktor-server-websockets")],-1)),s[4]||(s[4]=i("p",null,[i("b",null,"コード例"),e(": "),i("a",{href:"https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/server-websockets"}," server-websockets ")],-1)),i("p",null,[i("b",null,[a(p,{href:"/ktor/server-native",summary:"KtorはKotlin/Nativeをサポートしており、追加のランタイムや仮想マシンなしでサーバーを実行できます。"},{default:n(()=>s[0]||(s[0]=[e("ネイティブサーバー")])),_:1}),s[1]||(s[1]=e("のサポート"))]),s[2]||(s[2]=e(": ✅ "))])]),_:1}),a(g,null,{default:n(()=>s[5]||(s[5]=[e(" WebSocketsプラグインを使用すると、サーバーとクライアント間で多方向通信セッションを作成できます。 ")])),_:1}),a(y,{id:"websockets-description"},{default:n(()=>s[6]||(s[6]=[i("p",null,"WebSocketは、単一のTCP接続を介してユーザーのブラウザとサーバー間で全二重通信セッションを提供するプロトコルです。これは、サーバーとの間でリアルタイムのデータ転送を必要とするアプリケーションの作成に特に役立ちます。",-1),i("p",null,"Ktorは、サーバー側とクライアント側の両方でWebSocketプロトコルをサポートしています。",-1)])),_:1}),s[19]||(s[19]=o('<p>Ktorを使用すると、次のことができます。</p><ul><li>基本的なWebSocket設定（フレームサイズ、ping期間など）を構成できます。</li><li>サーバーとクライアント間でメッセージを交換するためのWebSocketセッションを処理できます。</li><li>WebSocket拡張機能を追加できます。例えば、<a href="./server-websocket-deflate">Deflate</a>拡張機能を使用したり、<a href="./server-websocket-extensions">カスタム拡張機能</a>を実装したりできます。</li></ul><blockquote><p>クライアント側でのWebSocketサポートについては、<a href="./client-websockets">WebSocketsクライアントプラグイン</a>を参照してください。</p></blockquote><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>一方向通信セッションの場合、<a href="./server-server-sent-events">Server-Sent Events (SSE)</a>の使用を検討してください。SSEは、サーバーがクライアントにイベントベースの更新を送信する必要がある場合に特に役立ちます。</p></div><h2 id="add_dependencies" tabindex="-1">依存関係を追加 <a class="header-anchor" href="#add_dependencies" aria-label="Permalink to &quot;依存関係を追加 {id=&quot;add_dependencies&quot;}&quot;">​</a></h2><p><code>WebSockets</code>を使用するには、ビルドスクリプトに<code>ktor-server-websockets</code>アーティファクトを含める必要があります。 </p>',6)),a(h,{group:"languages"},{default:n(()=>[a(k,{title:"Gradle (Kotlin)","group-key":"kotlin"},{default:n(()=>[a(l,{lang:"Kotlin",code:'            implementation("io.ktor:ktor-server-websockets:$ktor_version")'})]),_:1}),a(k,{title:"Gradle (Groovy)","group-key":"groovy"},{default:n(()=>[a(l,{lang:"Groovy",code:'            implementation "io.ktor:ktor-server-websockets:$ktor_version"'})]),_:1}),a(k,{title:"Maven","group-key":"maven"},{default:n(()=>[a(l,{lang:"XML",code:`            <dependency>
                <groupId>io.ktor</groupId>
                <artifactId>ktor-server-websockets-jvm</artifactId>
                <version>\${ktor_version}</version>
            </dependency>`})]),_:1})]),_:1}),s[20]||(s[20]=i("h2",{id:"install_plugin",tabindex:"-1"},[e("WebSocketsをインストールする "),i("a",{class:"header-anchor",href:"#install_plugin","aria-label":'Permalink to "WebSocketsをインストールする {id="install_plugin"}"'},"​")],-1)),i("p",null,[s[8]||(s[8]=e(" アプリケーションに")),s[9]||(s[9]=i("code",null,"WebSockets",-1)),s[10]||(s[10]=e("プラグインを")),s[11]||(s[11]=i("a",{href:"#install"},"インストール",-1)),s[12]||(s[12]=e("するには、指定された")),a(p,{href:"/ktor/server-modules",summary:"モジュールを使用すると、ルートをグループ化してアプリケーションを構造化できます。"},{default:n(()=>s[7]||(s[7]=[e("モジュール")])),_:1}),s[13]||(s[13]=e("内の")),s[14]||(s[14]=i("code",null,"install",-1)),s[15]||(s[15]=e("関数に渡します。 以下のコードスニペットは、")),s[16]||(s[16]=i("code",null,"WebSockets",-1)),s[17]||(s[17]=e("をインストールする方法を示しています... "))]),a(u,null,{default:n(()=>s[18]||(s[18]=[i("li",null,[e(" ... "),i("code",null,"embeddedServer"),e("関数呼び出しの内部。 ")],-1),i("li",null,[e(" ... 明示的に定義された"),i("code",null,"module"),e("（"),i("code",null,"Application"),e("クラスの拡張関数）の内部。 ")],-1)])),_:1}),a(h,null,{default:n(()=>[a(k,{title:"embeddedServer"},{default:n(()=>[a(l,{lang:"kotlin",code:`            import io.ktor.server.engine.*
            import io.ktor.server.netty.*
            import io.ktor.server.application.*
            import io.ktor.server.websocket.*

            fun main() {
                embeddedServer(Netty, port = 8080) {
                    install(WebSockets)
                    // ...
                }.start(wait = true)
            }`})]),_:1}),a(k,{title:"module"},{default:n(()=>[a(l,{lang:"kotlin",code:`            import io.ktor.server.application.*
            import io.ktor.server.websocket.*
            // ...
            fun Application.module() {
                install(WebSockets)
                // ...
            }`})]),_:1})]),_:1}),s[21]||(s[21]=o(`<h2 id="configure" tabindex="-1">WebSocketsを構成する <a class="header-anchor" href="#configure" aria-label="Permalink to &quot;WebSocketsを構成する {id=&quot;configure&quot;}&quot;">​</a></h2><p>オプションで、<a href="https://api.ktor.io/ktor-server/ktor-server-plugins/ktor-server-websockets/io.ktor.server.websocket/-web-sockets/-web-socket-options/index.html" target="_blank" rel="noreferrer">WebSocketOptions</a>を渡すことで、<code>install</code>ブロック内でプラグインを構成できます。</p><ul><li><code>pingPeriod</code>プロパティを使用して、ping間の期間を指定します。</li><li><code>timeout</code>プロパティを使用して、接続が閉じられるまでのタイムアウトを設定します。</li><li><code>maxFrameSize</code>プロパティを使用して、送受信できる最大フレームを設定します。</li><li><code>masking</code>プロパティを使用して、マスキングが有効になっているかどうかを指定します。</li><li><code>contentConverter</code>プロパティを使用して、シリアライゼーション/デシリアライゼーション用のコンバーターを設定します。</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(WebSockets) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pingPeriod </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.seconds</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    timeout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.seconds</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    maxFrameSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Long.MAX_VALUE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    masking </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="handle-sessions" tabindex="-1">WebSocketセッションを処理する <a class="header-anchor" href="#handle-sessions" aria-label="Permalink to &quot;WebSocketセッションを処理する {id=&quot;handle-sessions&quot;}&quot;">​</a></h2><h3 id="api-overview" tabindex="-1">APIの概要 <a class="header-anchor" href="#api-overview" aria-label="Permalink to &quot;APIの概要 {id=&quot;api-overview&quot;}&quot;">​</a></h3><p><code>WebSockets</code>プラグインをインストールして構成したら、WebSocketセッションを処理するエンドポイントを定義できます。サーバー上でWebSocketエンドポイントを定義するには、<a href="./server-routing#define_route">ルーティング</a>ブロック内で<code>webSocket</code>関数を呼び出します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    webSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/echo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // Handle a WebSocket session</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>この例では、<a href="./server-configuration-file">デフォルト構成</a>が使用されている場合、サーバーは<code>ws://localhost:8080/echo</code>へのWebSocketリクエストを受け入れます。</p><p><code>webSocket</code>ブロック内では、<a href="https://api.ktor.io/ktor-server/ktor-server-plugins/ktor-server-websockets/io.ktor.server.websocket/-default-web-socket-server-session/index.html" target="_blank" rel="noreferrer">DefaultWebSocketServerSession</a>クラスで表されるWebSocketセッションのハンドラーを定義します。 ブロック内で以下の関数とプロパティを使用できます。</p><ul><li><code>send</code>関数を使用して、テキストコンテンツをクライアントに送信します。</li><li><code>incoming</code>および<code>outgoing</code>プロパティを使用して、WebSocketフレームを受信および送信するためのチャネルにアクセスします。フレームは<code>Frame</code>クラスで表されます。</li><li><code>close</code>関数を使用して、指定された理由でクローズフレームを送信します。</li></ul><p>セッションを処理する際に、フレームタイプを確認できます。例えば：</p><ul><li><code>Frame.Text</code>はテキストフレームです。このフレームタイプの場合、<code>Frame.Text.readText()</code>を使用してその内容を読み取ることができます。</li><li><code>Frame.Binary</code>はバイナリフレームです。このタイプの場合、<code>Frame.Binary.readBytes()</code>を使用してその内容を読み取ることができます。</li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p><code>incoming</code>チャネルには、ping/pongやクローズフレームなどの制御フレームは含まれていないことに注意してください。 制御フレームを処理し、断片化されたフレームを再構築するには、<a href="https://api.ktor.io/ktor-server/ktor-server-plugins/ktor-server-websockets/io.ktor.server.websocket/web-socket-raw.html" target="_blank" rel="noreferrer">webSocketRaw</a>関数を使用してWebSocketセッションを処理します。</p></div><blockquote><p>クライアントに関する情報（クライアントのIPアドレスなど）を取得するには、<code>call</code>プロパティを使用します。<a href="./server-requests#request_information">一般的なリクエスト情報</a>について学びましょう。</p></blockquote><p>以下では、このAPIの使用例を見ていきます。</p><h3 id="handle-single-session" tabindex="-1">例: 単一セッションの処理 <a class="header-anchor" href="#handle-single-session" aria-label="Permalink to &quot;例: 単一セッションの処理 {id=&quot;handle-single-session&quot;}&quot;">​</a></h3><p>以下の例は、1つのクライアントとのセッションを処理する<code>echo</code> WebSocketエンドポイントを作成する方法を示しています。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    webSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/echo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Please enter your name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> incoming) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? Frame.Text ?: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">continue</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> receivedText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> frame.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (receivedText.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bye&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ignoreCase </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CloseReason</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CloseReason.Codes.NORMAL, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Client said BYE&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Frame.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hi, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$receivedText</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>完全な例については、<a href="https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/server-websockets" target="_blank" rel="noreferrer">server-websockets</a>を参照してください。</p><h3 id="handle-multiple-session" tabindex="-1">例: 複数セッションの処理 <a class="header-anchor" href="#handle-multiple-session" aria-label="Permalink to &quot;例: 複数セッションの処理 {id=&quot;handle-multiple-session&quot;}&quot;">​</a></h3><p>複数のWebSocketセッションを効率的に管理し、ブロードキャストを処理するには、Kotlinの<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/" target="_blank" rel="noreferrer"><code>SharedFlow</code></a>を利用できます。このアプローチは、WebSocket通信を管理するためのスケーラブルで並行処理に適した方法を提供します。このパターンを実装する方法を以下に示します。</p><ol><li>メッセージをブロードキャストするための<code>SharedFlow</code>を定義します。</li></ol><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> messageResponseFlow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MutableSharedFlow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MessageResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sharedFlow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> messageResponseFlow.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asSharedFlow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ol start="2"><li>WebSocketルートで、ブロードキャストとメッセージ処理ロジックを実装します。</li></ol><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        webSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/ws&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;You are connected to WebSocket!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> job </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                sharedFlow.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">collect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message.message)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            runCatching</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                incoming.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">consumeEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Frame.Text) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> receivedText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> frame.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> messageResponse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MessageResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(receivedText)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        messageResponseFlow.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(messageResponse)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onFailure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { exception </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;WebSocket exception: \${exception.localizedMessage}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                job.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cancel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span></code></pre></div><p><code>runCatching</code>ブロックは、受信メッセージを処理し、それらを<code>SharedFlow</code>に発行し、その後すべてのコレクターにブロードキャストします。</p><p>このパターンを使用することで、個々の接続を手動で追跡することなく、複数のWebSocketセッションを効率的に管理できます。このアプローチは、多数の同時WebSocket接続を持つアプリケーションでうまくスケールし、メッセージブロードキャストを処理するためのクリーンでリアクティブな方法を提供します。</p><p>完全な例については、<a href="https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/server-websockets-sharedflow" target="_blank" rel="noreferrer">server-websockets-sharedflow</a>を参照してください。</p><h2 id="websocket-api" tabindex="-1">WebSocket APIとKtor <a class="header-anchor" href="#websocket-api" aria-label="Permalink to &quot;WebSocket APIとKtor {id=&quot;websocket-api&quot;}&quot;">​</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" target="_blank" rel="noreferrer">WebSocket APIの標準イベント</a>は、Ktorでは次のようにマッピングされます。</p><ul><li><code>onConnect</code>はブロックの開始時に発生します。</li><li><code>onMessage</code>は、メッセージを正常に読み取った後（例: <code>incoming.receive()</code>を使用した場合）、または<code>for(frame in incoming)</code>でサスペンドされたイテレーションを使用した後に発生します。</li><li><code>onClose</code>は、<code>incoming</code>チャネルが閉じられたときに発生します。これにより、サスペンドされたイテレーションが完了するか、メッセージを受信しようとしたときに<code>ClosedReceiveChannelException</code>がスローされます。</li><li><code>onError</code>は他の例外と同等です。</li></ul><p><code>onClose</code>と<code>onError</code>の両方で、<code>closeReason</code>プロパティが設定されます。</p><p>以下の例では、無限ループは例外が発生した場合にのみ終了します（<code>ClosedReceiveChannelException</code>または他の例外）。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">webSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/echo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;onConnect&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> incoming){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> text </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Frame.Text).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;onMessage&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            received </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> text</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            outgoing.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Frame.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ClosedReceiveChannelException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;onClose \${closeReason.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Throwable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;onError \${closeReason.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,35))])}const _=F(v,[["render",C]]);export{x as __pageData,_ as default};
