import{_ as t,c as a,o as i,ag as o}from"./chunks/framework.Bksy39di.js";const m=JSON.parse('{"title":"簡潔","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/api-guidelines-simplicity.md","filePath":"zh-Hant/kotlin/api-guidelines-simplicity.md","lastUpdated":1754307826000}'),r={name:"zh-Hant/kotlin/api-guidelines-simplicity.md"};function l(n,e,p,s,c,d){return i(),a("div",null,e[0]||(e[0]=[o('<h1 id="簡潔" tabindex="-1">簡潔 <a class="header-anchor" href="#簡潔" aria-label="Permalink to &quot;簡潔&quot;">​</a></h1><p>使用者需要理解的概念越少，這些概念被傳達得越明確，他們的心智模型就越可能簡潔。這可以透過限制 API 中的操作和抽象數量來實現。</p><p>請確保程式庫中宣告的<a href="/zh-Hant/kotlin/visibility-modifiers">可見性</a>設定適當，以將內部實作細節排除在公開 API 之外。只有明確設計並文件化為公開使用的 API，才應供使用者存取。</p><p>在本指南的下一部分中，我們將討論一些提升簡潔性的指導方針。</p><h2 id="使用明確-api-模式" tabindex="-1">使用明確 API 模式 <a class="header-anchor" href="#使用明確-api-模式" aria-label="Permalink to &quot;使用明確 API 模式&quot;">​</a></h2><p>我們建議使用 Kotlin 編譯器的<a href="/zh-Hant/kotlin/whatsnew14#explicit-api-mode-for-library-authors">明確 API 模式</a>功能，這會強制您在設計程式庫的 API 時明確表明您的意圖。</p><p>在明確 API 模式下，您必須：</p><ul><li>為您的宣告新增可見性修飾符以將其公開，而非依賴預設的公開可見性。這可確保您已考慮要公開作為公開 API 一部分的內容。</li><li>為所有公開函數和屬性定義類型，以防止從推斷類型導致 API 發生非預期的變更。</li></ul><h2 id="重複使用現有概念" tabindex="-1">重複使用現有概念 <a class="header-anchor" href="#重複使用現有概念" aria-label="Permalink to &quot;重複使用現有概念&quot;">​</a></h2><p>限制 API 大小的一種方法是重複使用現有類型。例如，與其為持續時間建立新類型，您可以使用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/" target="_blank" rel="noreferrer"><code>kotlin.time.Duration</code></a>。這種方法不僅能簡化開發，還能提高與其他程式庫的互通性。</p><p>當依賴來自第三方程式庫或平台特定類型時，務必小心，因為它們可能會將您的程式庫與這些元素綁定。在這種情況下，成本可能超過收益。</p><p>重複使用 <code>String</code>、<code>Long</code>、<code>Pair</code> 和 <code>Triple</code> 等常見類型可能很有效，但這不應阻止您開發抽象資料類型，如果它們能更好地封裝領域特定邏輯。</p><h2 id="定義並建基於核心-api" tabindex="-1">定義並建基於核心 API <a class="header-anchor" href="#定義並建基於核心-api" aria-label="Permalink to &quot;定義並建基於核心 API&quot;">​</a></h2><p>達到簡潔的另一條途徑是定義一個小型概念模型，該模型基於有限的核心操作集合。一旦這些操作的行為被明確文件化，您就可以透過開發直接建基於這些核心函數或將其組合的新操作來擴展 API。</p><p>舉例來說：</p><ul><li>在 <a href="/zh-Hant/kotlin/flow">Kotlin Flows API</a> 中，<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/filter.html" target="_blank" rel="noreferrer"><code>filter</code></a> 和 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html" target="_blank" rel="noreferrer"><code>map</code></a> 等常見操作是建基於 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/transform.html" target="_blank" rel="noreferrer"><code>transform</code></a> 操作之上。</li><li>在 <a href="/zh-Hant/kotlin/time-measurement">Kotlin Time API</a> 中，<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/measure-time.html" target="_blank" rel="noreferrer"><code>measureTime</code></a> 函數利用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-time-source/-monotonic/" target="_blank" rel="noreferrer"><code>TimeSource.Monotonic</code></a>。</li></ul><p>儘管將額外操作建基於這些核心元件通常有益，但這並非總是必要。您可能會找到機會引入最佳化或平台特定變體，以擴展功能或更廣泛地適應不同輸入。</p><p>只要使用者能夠利用核心操作解決非平凡的問題，並且能夠在不改變任何行為的情況下，利用額外操作重構他們的解決方案，概念模型的簡潔性就能得到維護。</p><h2 id="下一步" tabindex="-1">下一步 <a class="header-anchor" href="#下一步" aria-label="Permalink to &quot;下一步&quot;">​</a></h2><p>在本指南的下一部分中，您將學習可讀性。</p><p><a href="/zh-Hant/kotlin/api-guidelines-readability">繼續前往下一部分</a></p>',21)]))}const u=t(r,[["render",l]]);export{m as __pageData,u as default};
