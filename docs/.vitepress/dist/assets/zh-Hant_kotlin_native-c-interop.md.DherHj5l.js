import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.Bksy39di.js";const E=JSON.parse('{"title":"與 C 的互通性","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/native-c-interop.md","filePath":"zh-Hant/kotlin/native-c-interop.md","lastUpdated":1754307826000}'),l={name:"zh-Hant/kotlin/native-c-interop.md"};function e(p,s,h,k,d,r){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="與-c-的互通性" tabindex="-1">與 C 的互通性 <a class="header-anchor" href="#與-c-的互通性" aria-label="Permalink to &quot;與 C 的互通性&quot;">​</a></h1><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>C 函式庫匯入處於 <a href="/zh-Hant/kotlin/native-c-interop-stability">Beta</a> 階段。所有由 cinterop 工具從 C 函式庫產生的 Kotlin 宣告都應具備 <code>@ExperimentalForeignApi</code> 註解。 隨 Kotlin/Native 附帶的原生平台函式庫（例如 Foundation、UIKit 和 POSIX）僅需針對部分 API 選擇啟用。</p></div><p>本文涵蓋 Kotlin 與 C 互通性的一般層面。Kotlin/Native 附帶一個 cinterop 工具，您可以使用它快速產生與外部 C 函式庫互動所需的一切。</p><p>該工具會分析 C 標頭檔，並將 C 類型、函數和字串直接對應到 Kotlin。產生的 stub 隨後可以匯入整合開發環境 (IDE) 中，以啟用程式碼自動完成和導覽功能。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Kotlin 也提供與 Objective-C 的互通性。Objective-C 函式庫也透過 cinterop 工具匯入。詳情請參閱 <a href="/zh-Hant/kotlin/native-objc-interop">Swift/Objective-C 互通性</a>。</p></div><h2 id="設定您的專案" tabindex="-1">設定您的專案 <a class="header-anchor" href="#設定您的專案" aria-label="Permalink to &quot;設定您的專案&quot;">​</a></h2><p>以下是處理需要使用 C 函式庫的專案時的一般工作流程：</p><ol><li>建立並設定<a href="/zh-Hant/kotlin/native-definition-file">定義檔</a>。它描述了 cinterop 工具應將哪些內容納入 Kotlin <a href="#bindings">繫結</a>。</li><li>設定您的 Gradle 建置檔，以將 cinterop 納入建置程序。</li><li>編譯並執行專案以產生最終的可執行檔。</li></ol><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>如需實際操作體驗，請完成<a href="/zh-Hant/kotlin/native-app-with-c-and-libcurl">使用 C 互通性建立應用程式</a>教學課程。</p></div><p>在許多情況下，無需設定與 C 函式庫的自訂互通性。相反地，您可以使用平台上稱為<a href="/zh-Hant/kotlin/native-platform-libs">平台函式庫</a>的標準化繫結中提供的 API。例如，Linux/macOS 平台上的 POSIX、Windows 平台上的 Win32 或 macOS/iOS 上的 Apple 框架均可透過這種方式使用。</p><h2 id="繫結" tabindex="-1">繫結 <a class="header-anchor" href="#繫結" aria-label="Permalink to &quot;繫結&quot;">​</a></h2><h3 id="基本互通類型" tabindex="-1">基本互通類型 <a class="header-anchor" href="#基本互通類型" aria-label="Permalink to &quot;基本互通類型&quot;">​</a></h3><p>所有受支援的 C 類型在 Kotlin 中都有對應的表示方式：</p><ul><li>有符號、無符號整數和浮點類型會對應到相同寬度的 Kotlin 對應類型。</li><li>指標和陣列會對應到 <code>CPointer&lt;T&gt;?</code>。</li><li>列舉可以對應到 Kotlin 列舉或整數值，具體取決於啟發式方法和<a href="/zh-Hant/kotlin/native-definition-file#configure-enums-generation">定義檔設定</a>。</li><li>結構和聯集會對應到透過點表示法（例如 <code>someStructInstance.field1</code>）可存取欄位的類型。</li><li><code>typedef</code> 會表示為 <code>typealias</code>。</li></ul><p>此外，任何 C 類型都具有代表該類型左值的 Kotlin 類型，亦即，位於記憶體中的值，而非簡單不可變的獨立值。可將 C++ 引用視為類似的概念。對於結構（以及 <code>typedef</code> 到結構的類型），此表示方式是主要的，並與結構本身具有相同的名稱。對於 Kotlin 列舉，它被命名為 <code>\${type}.Var</code>；對於 <code>CPointer&lt;T&gt;</code>，它被命名為 <code>CPointerVar&lt;T&gt;</code>；而對於大多數其他類型，它被命名為 <code>\${type}Var</code>。</p><p>對於同時具有兩種表示方式的類型，具有左值的類型具有可變的 <code>.value</code> 屬性用於存取值。</p><h4 id="指標類型" tabindex="-1">指標類型 <a class="header-anchor" href="#指標類型" aria-label="Permalink to &quot;指標類型&quot;">​</a></h4><p><code>CPointer&lt;T&gt;</code> 的類型引數 <code>T</code> 必須是上述左值類型之一。例如，C 類型 <code>struct S*</code> 會對應到 <code>CPointer&lt;S&gt;</code>，<code>int8_t*</code> 會對應到 <code>CPointer&lt;int_8tVar&gt;</code>，而 <code>char**</code> 會對應到 <code>CPointer&lt;CPointerVar&lt;ByteVar&gt;&gt;</code>。</p><p>C null 指標表示為 Kotlin 的 <code>null</code>，且指標類型 <code>CPointer&lt;T&gt;</code> 不可為 null，但 <code>CPointer&lt;T&gt;?</code> 可以。此類型的值支援所有與處理 <code>null</code> 相關的 Kotlin 操作，例如 <code>?:</code>、<code>?.</code>、<code>!!</code> 等：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getenv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;PATH&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)?.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toKString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() ?: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span></span></code></pre></div><p>由於陣列也對應到 <code>CPointer&lt;T&gt;</code>，因此它支援 <code>[]</code> 運算子，用於透過索引存取值：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shift</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ptr: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ByteVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, length: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ptr[index] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ptr[index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>CPointer&lt;T&gt;</code> 的 <code>.pointed</code> 屬性會回傳此指標指向的 <code>T</code> 類型左值。反向操作是 <code>.ptr</code>，它接受左值並回傳指向該左值的指標。</p><p><code>void*</code> 會對應到 <code>COpaquePointer</code> – 這是一種特殊指標類型，是任何其他指標類型的超類型。因此，如果 C 函數接受 <code>void*</code>，則 Kotlin 繫結會接受任何 <code>CPointer</code>。</p><p>指標（包括 <code>COpaquePointer</code>）的型別轉換可以使用 <code>.reinterpret&lt;T&gt;</code> 完成，例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intPtr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bytePtr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reinterpret</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IntVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span></code></pre></div><p>或者：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intPtr: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IntVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bytePtr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reinterpret</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>如同 C 語言，這些 <code>.reinterpret</code> 型別轉換是不安全的，可能導致應用程式中出現微妙的記憶體問題。</p><p>此外，<code>CPointer&lt;T&gt;?</code> 和 <code>Long</code> 之間還存在不安全的型別轉換，由 <code>.toLong()</code> 和 <code>.toCPointer&lt;T&gt;()</code> 擴充方法提供：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> longValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ptr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLong</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> originalPtr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> longValue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toCPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如果結果的類型從上下文可知，您可以利用類型推斷來省略類型引數。</p></div><h3 id="記憶體配置" tabindex="-1">記憶體配置 <a class="header-anchor" href="#記憶體配置" aria-label="Permalink to &quot;記憶體配置&quot;">​</a></h3><p>原生記憶體可以使用 <code>NativePlacement</code> 介面進行配置，例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> byteVar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> placement.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ByteVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span></code></pre></div><p>或者：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bytePtr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> placement.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">allocArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ByteVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>最合理的配置是在 <code>nativeHeap</code> 物件中。它對應於使用 <code>malloc</code> 配置原生記憶體，並提供額外的 <code>.free()</code> 操作來釋放已配置的記憶體：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kotlinx.cinterop.ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nativeHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">allocArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ByteVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(size)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nativeHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">free</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>nativeHeap</code> 需要手動釋放記憶體。然而，將記憶體配置為繫結到詞法作用域的生命週期通常很有用。如果此類記憶體能自動釋放，將會有所幫助。</p><p>為了解決這個問題，您可以使用 <code>memScoped { }</code>。在花括號內，臨時配置可作為隱式接收者使用，因此可以使用 alloc 和 allocArray 配置原生記憶體，並且配置的記憶體在離開作用域後將會自動釋放。</p><p>例如，可以像這樣使用透過指標參數回傳值的 C 函數：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> platform.posix.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fileSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> memScoped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> statBuf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> error </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> stat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, statBuf.ptr)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    statBuf.st_size</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="將指標傳遞給繫結" tabindex="-1">將指標傳遞給繫結 <a class="header-anchor" href="#將指標傳遞給繫結" aria-label="Permalink to &quot;將指標傳遞給繫結&quot;">​</a></h3><p>儘管 C 指標會對應到 <code>CPointer&lt;T&gt;</code> 類型，但 C 函數指標類型參數會對應到 <code>CValuesRef&lt;T&gt;</code>。當將 <code>CPointer&lt;T&gt;</code> 作為此類參數的值傳遞時，它會按原樣傳遞給 C 函數。然而，可以傳遞值序列而非指標。在這種情況下，序列會「按值」傳遞，亦即 C 函數會收到該序列臨時副本的指標，該指標僅在函數回傳前有效。</p><p>指標參數的 <code>CValuesRef&lt;T&gt;</code> 表示旨在支援 C 陣列字面值，而無需顯式原生記憶體配置。為了建構不可變的獨立 C 值序列，提供了以下方法：</p><ul><li><code>\${type}Array.toCValues()</code>，其中 <code>type</code> 是 Kotlin 基本類型</li><li><code>Array&lt;CPointer&lt;T&gt;?&gt;.toCValues()</code>, <code>List&lt;CPointer&lt;T&gt;?&gt;.toCValues()</code></li><li><code>cValuesOf(vararg elements: \${type})</code>，其中 <code>type</code> 是基本類型或指標</li></ul><p>例如：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// C:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> elements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elements</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cValuesOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="字串" tabindex="-1">字串 <a class="header-anchor" href="#字串" aria-label="Permalink to &quot;字串&quot;">​</a></h3><p>與其他指標不同，類型為 <code>const char*</code> 的參數會表示為 Kotlin <code>String</code>。因此，可以將任何 Kotlin 字串傳遞給預期 C 字串的繫結。</p><p>還有一些可用工具可以手動在 Kotlin 和 C 字串之間轉換：</p><ul><li><code>fun CPointer&lt;ByteVar&gt;.toKString(): String</code></li><li><code>val String.cstr: CValuesRef&lt;ByteVar&gt;</code>.</li></ul><p>要獲取指標，<code>.cstr</code> 應配置在原生記憶體中，例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cString </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlinString.cstr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nativeHeap)</span></span></code></pre></div><p>在所有情況下，C 字串都應編碼為 UTF-8。</p><p>若要跳過自動轉換並確保在繫結中使用原始指標，請將 <a href="/zh-Hant/kotlin/native-definition-file#set-up-string-conversion"><code>noStringConversion</code> 屬性</a>新增到 <code>.def</code> 檔：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">noStringConversion </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LoadCursorA LoadCursorW</span></span></code></pre></div><p>這樣，任何 <code>CPointer&lt;ByteVar&gt;</code> 類型的值都可以作為 <code>const char*</code> 類型的引數傳遞。如果應傳遞 Kotlin 字串，則可以使用以下程式碼：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kotlinx.cinterop.ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memScoped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    LoadCursorA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cursor.bmp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cstr.ptr)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// for ASCII or UTF-8 version</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    LoadCursorW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cursor.bmp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.wcstr.ptr) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// for UTF-16 version</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="作用域局部指標" tabindex="-1">作用域局部指標 <a class="header-anchor" href="#作用域局部指標" aria-label="Permalink to &quot;作用域局部指標&quot;">​</a></h3><p>可以使用 <code>CValues&lt;T&gt;.ptr</code> 擴充屬性，在 <code>memScoped {}</code> 範圍內為 <code>CValues&lt;T&gt;</code> 實例建立 C 表示的作用域穩定指標。它允許使用需要 C 指標且其生命週期繫結到特定 <code>MemScope</code> 的 API。例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kotlinx.cinterop.ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memScoped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrayOfNulls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ITEM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;?&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    arrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;one&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;two&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEachIndexed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { index, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> items[index] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cstr.ptr }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    menu </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> new_menu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Menu&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cstr.ptr, items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toCValues</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().ptr)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在此範例中，傳遞給 C API <code>new_menu()</code> 的所有值都具有其所屬最內層 <code>memScope</code> 的生命週期。一旦控制流離開 <code>memScoped</code> 作用域，C 指標就會變得無效。</p><h3 id="按值傳遞和接收結構" tabindex="-1">按值傳遞和接收結構 <a class="header-anchor" href="#按值傳遞和接收結構" aria-label="Permalink to &quot;按值傳遞和接收結構&quot;">​</a></h3><p>當 C 函數按值接受或回傳結構/聯集 <code>T</code> 時，相應的引數類型或回傳類型會表示為 <code>CValue&lt;T&gt;</code>。</p><p><code>CValue&lt;T&gt;</code> 是一個不透明類型，因此無法使用適當的 Kotlin 屬性存取結構欄位。如果 API 將結構用作不透明句柄，這可能沒問題。但是，如果需要欄位存取，則可以使用以下轉換方法：</p><ul><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/read-value.html" target="_blank" rel="noreferrer"><code>fun T.readValue(): CValue&lt;T&gt;</code></a> 會將 (左值) <code>T</code> 轉換為 <code>CValue&lt;T&gt;</code>。因此，要建構 <code>CValue&lt;T&gt;</code>，<code>T</code> 可以先配置、填充，然後轉換為 <code>CValue&lt;T&gt;</code>。</p></li><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/use-contents.html" target="_blank" rel="noreferrer"><code>CValue&lt;T&gt;.useContents(block: T.() -&gt; R): R</code></a> 會將 <code>CValue&lt;T&gt;</code> 暫時儲存在記憶體中，然後以這個已放置的值 <code>T</code> 作為接收者執行傳遞的 lambda。 因此，要讀取單個欄位，可以使用以下程式碼：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fieldValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> structValue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useContents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div></li><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/c-value.html" target="_blank" rel="noreferrer"><code>fun cValue(initialize: T.() -&gt; Unit): CValue&lt;T&gt;</code></a> 會應用提供的 <code>initialize</code> 函數在記憶體中配置 <code>T</code>，並將結果轉換為 <code>CValue&lt;T&gt;</code>。</p></li><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/copy.html" target="_blank" rel="noreferrer"><code>fun CValue&lt;T&gt;.copy(modify: T.() -&gt; Unit): CValue&lt;T&gt;</code></a> 會建立現有 <code>CValue&lt;T&gt;</code> 的修改副本。原始值會被放置在記憶體中，使用 <code>modify()</code> 函數進行修改，然後轉換回新的 <code>CValue&lt;T&gt;</code>。</p></li><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/place-to.html" target="_blank" rel="noreferrer"><code>fun CValues&lt;T&gt;.placeTo(scope: AutofreeScope): CPointer&lt;T&gt;</code></a> 會將 <code>CValues&lt;T&gt;</code> 放置到 <code>AutofreeScope</code> 中，回傳指向已配置記憶體的指標。當 <code>AutofreeScope</code> 被處置時，已配置的記憶體將會自動釋放。</p></li></ul><h3 id="回呼" tabindex="-1">回呼 <a class="header-anchor" href="#回呼" aria-label="Permalink to &quot;回呼&quot;">​</a></h3><p>要將 Kotlin 函數轉換為指向 C 函數的指標，可以使用 <code>staticCFunction(::kotlinFunction)</code>。也可以提供 lambda 而非函數引用。函數或 lambda 不得捕獲任何值。</p><h4 id="將使用者資料傳遞給回呼" tabindex="-1">將使用者資料傳遞給回呼 <a class="header-anchor" href="#將使用者資料傳遞給回呼" aria-label="Permalink to &quot;將使用者資料傳遞給回呼&quot;">​</a></h4><p>C API 通常允許將一些使用者資料傳遞給回呼。這些資料通常由使用者在設定回呼時提供。例如，它會作為 <code>void*</code> 傳遞給某些 C 函數（或寫入結構）。然而，Kotlin 物件的引用無法直接傳遞給 C。因此，在設定回呼之前需要進行包裝，然後在回呼本身中解包，以便安全地從 Kotlin 透過 C 世界傳遞到 Kotlin。這種包裝可以使用 <code>StableRef</code> 類別實現。</p><p>要包裝引用：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stableRef </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> StableRef.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kotlinReference)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> voidPtr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stableRef.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asCPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>在這裡，<code>voidPtr</code> 是一個 <code>COpaquePointer</code>，可以傳遞給 C 函數。</p><p>要解包引用：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stableRef </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> voidPtr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asStableRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KotlinClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlinReference </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stableRef.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>在這裡，<code>kotlinReference</code> 是原始的包裝引用。</p><p>建立的 <code>StableRef</code> 最終應使用 <code>.dispose()</code> 方法手動處置，以防止記憶體洩漏：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stableRef.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>之後它會變得無效，因此 <code>voidPtr</code> 無法再解包。</p><h3 id="巨集" tabindex="-1">巨集 <a class="header-anchor" href="#巨集" aria-label="Permalink to &quot;巨集&quot;">​</a></h3><p>每個擴展為常數的 C 巨集都會表示為 Kotlin 屬性。</p><p>在編譯器可以推斷類型的情況下，支援沒有參數的巨集：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FOO</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>在這種情況下，<code>FOO</code> 在 Kotlin 中可用。</p><p>要支援其他巨集，您可以透過將它們包裝在支援的宣告中來手動公開它們。例如，函數式巨集 <code>FOO</code> 可以透過<a href="/zh-Hant/kotlin/native-definition-file#add-custom-declarations">將自訂宣告新增</a>到函式庫中，將其公開為函數 <code>foo()</code>：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">headers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> library</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">base.h</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">---</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FOO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="可攜性" tabindex="-1">可攜性 <a class="header-anchor" href="#可攜性" aria-label="Permalink to &quot;可攜性&quot;">​</a></h3><p>有時 C 函式庫具有平台相關類型的函數參數或結構欄位，例如 <code>long</code> 或 <code>size_t</code>。Kotlin 本身不提供隱式整數型別轉換或 C 風格整數型別轉換（例如 <code>(size_t) intValue</code>），因此為了在此類情況下更容易編寫可攜式程式碼，提供了 <code>convert</code> 方法：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> \${type1}.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">convert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;\${</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">type2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}&gt;(): \${type2}</span></span></code></pre></div><p>在這裡，<code>type1</code> 和 <code>type2</code> 都必須是整數類型，無論是有符號還是無符號。</p><p><code>.convert&lt;\${type}&gt;</code> 與 <code>.toByte</code>、<code>.toShort</code>、<code>.toInt</code>、<code>.toLong</code>、<code>.toUByte</code>、<code>.toUShort</code>、<code>.toUInt</code> 或 <code>.toULong</code> 方法之一具有相同的語義，具體取決於 <code>type</code>。</p><p>使用 <code>convert</code> 的範例：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> platform.posix.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> zeroMemory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">COpaquePointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, size: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    memset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, size.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">convert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此外，類型參數可以自動推斷，因此在某些情況下可以省略。</p><h3 id="物件釘選" tabindex="-1">物件釘選 <a class="header-anchor" href="#物件釘選" aria-label="Permalink to &quot;物件釘選&quot;">​</a></h3><p>Kotlin 物件可以被釘選，亦即它們在記憶體中的位置保證穩定，直到被解除釘選為止，並且指向此類物件內部資料的指標可以傳遞給 C 函數。</p><p>有幾種方法可以採用：</p><ul><li><p>使用 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/use-pinned.html" target="_blank" rel="noreferrer"><code>.usePinned()</code></a> 擴充函數，該函數會釘選物件，執行區塊，並在正常和例外路徑上解除釘選：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> platform.posix.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ByteArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    buffer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">usePinned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { pinned </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> recv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd, pinned.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addressOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), buffer.size.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">convert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                break</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Now \`buffer\` has raw data obtained from the \`recv()\` call.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在這裡，<code>pinned</code> 是 <code>Pinned&lt;T&gt;</code> 特殊類型的物件。它提供了有用的擴充功能，例如 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/address-of.html" target="_blank" rel="noreferrer"><code>.addressOf()</code></a>，允許取得釘選陣列主體的位址。</p></li><li><p>使用 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/ref-to.html" target="_blank" rel="noreferrer"><code>.refTo()</code></a> 擴充函數，它在內部具有類似的功能，但在某些情況下可以幫助您減少樣板程式碼：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> platform.posix.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ByteArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> recv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd, buffer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">refTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), buffer.size.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">convert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            break</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Now \`buffer\` has raw data obtained from the \`recv()\` call.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在這裡，<code>buffer.refTo(0)</code> 具有 <code>CValuesRef</code> 類型，它會在進入 <code>recv()</code> 函數之前釘選陣列，將其第零個元素的位址傳遞給函數，並在退出後解除釘選陣列。</p></li></ul><h3 id="前置宣告" tabindex="-1">前置宣告 <a class="header-anchor" href="#前置宣告" aria-label="Permalink to &quot;前置宣告&quot;">​</a></h3><p>要匯入前置宣告，請使用 <code>cnames</code> 套件。例如，要匯入在具有 <code>library.package</code> 的 C 函式庫中宣告的 <code>cstructName</code> 前置宣告，請使用特殊的前置宣告套件：<code>import cnames.structs.cstructName</code>。</p><p>考慮兩個 cinterop 函式庫：一個具有結構的前置宣告，另一個在不同套件中具有實際實作：</p><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// First C library</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> consumeStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Struct consumed</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Second C library</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Header:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdlib.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Implementation:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> produceStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> malloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s-&gt;data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>要在兩個函式庫之間傳輸物件，請在您的 Kotlin 程式碼中使用顯式 <code>as</code> 轉換：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin code:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    consumeStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">produceStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CPointer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cnames.structs.ForwardDeclaredStruct</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="接下來" tabindex="-1">接下來 <a class="header-anchor" href="#接下來" aria-label="Permalink to &quot;接下來&quot;">​</a></h2><p>透過完成以下教學課程，了解類型、函數和字串如何在 Kotlin 和 C 之間對應：</p><ul><li><a href="/zh-Hant/kotlin/mapping-primitive-data-types-from-c">從 C 對應基本資料類型</a></li><li><a href="/zh-Hant/kotlin/mapping-struct-union-types-from-c">從 C 對應結構和聯集類型</a></li><li><a href="/zh-Hant/kotlin/mapping-function-pointers-from-c">從 C 對應函數指標</a></li><li><a href="/zh-Hant/kotlin/mapping-strings-from-c">從 C 對應字串</a></li></ul>`,111)]))}const c=i(l,[["render",e]]);export{E as __pageData,c as default};
