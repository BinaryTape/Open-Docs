import{_ as h}from"./chunks/native-gc-signposts.CmU4CX4K.js";import{_ as r,C as l,c as k,o,ag as i,j as n,G as t,a,w as d}from"./chunks/framework.Bksy39di.js";const f=JSON.parse('{"title":"Kotlin/Native 記憶體管理","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/native-memory-manager.md","filePath":"zh-Hant/kotlin/native-memory-manager.md","lastUpdated":1754307826000}'),c={name:"zh-Hant/kotlin/native-memory-manager.md"},g={start:"2"};function E(u,s,y,m,F,b){const p=l("shortcut"),e=l("TopicTitle");return o(),k("div",null,[s[8]||(s[8]=i('<h1 id="kotlin-native-記憶體管理" tabindex="-1">Kotlin/Native 記憶體管理 <a class="header-anchor" href="#kotlin-native-記憶體管理" aria-label="Permalink to &quot;Kotlin/Native 記憶體管理&quot;">​</a></h1><p>Kotlin/Native 使用現代記憶體管理器，其類似於 JVM、Go 和其他主流技術，包含以下功能：</p><ul><li>物件儲存在共享堆中，可從任何執行緒存取。</li><li>追蹤式垃圾收集會定期執行，以收集無法從「根」(roots) 觸及的物件，例如區域變數和全域變數。</li></ul><h2 id="垃圾收集器" tabindex="-1">垃圾收集器 <a class="header-anchor" href="#垃圾收集器" aria-label="Permalink to &quot;垃圾收集器&quot;">​</a></h2><p>Kotlin/Native 的垃圾收集器 (GC) 演算法持續演進。目前，其運作方式為「全域暫停標記並行清除」(stop-the-world mark and concurrent sweep) 收集器，不將堆區分為多個世代。</p><p>GC 在單獨的執行緒上執行，並根據記憶體壓力啟發法或計時器啟動。或者，也可以<a href="#enable-garbage-collection-manually">手動呼叫</a>。</p><p>GC 在多個執行緒中並行處理標記佇列，包括應用程式執行緒、GC 執行緒和選用的標記執行緒。應用程式執行緒和至少一個 GC 執行緒參與標記過程。預設情況下，當 GC 在堆中標記物件時，應用程式執行緒必須暫停。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>您可以使用 <code>kotlin.native.binary.gcMarkSingleThreaded=true</code> 編譯器選項來停用標記階段的並行處理。然而，這可能會增加垃圾收集器在大堆上的暫停時間。</p></div><p>當標記階段完成後，GC 處理弱引用，並將指向未標記物件的參考點設為 null。預設情況下，弱引用會並行處理，以減少 GC 暫停時間。</p><p>請參閱如何<a href="#monitor-gc-performance">監控</a>和<a href="#optimize-gc-performance">最佳化</a>垃圾收集。</p><h3 id="手動啟用垃圾收集" tabindex="-1">手動啟用垃圾收集 <a class="header-anchor" href="#手動啟用垃圾收集" aria-label="Permalink to &quot;手動啟用垃圾收集&quot;">​</a></h3><p>若要強制啟動垃圾收集器，請呼叫 <code>kotlin.native.internal.GC.collect()</code>。此方法會觸發新的收集並等待其完成。</p><h3 id="監控-gc-效能" tabindex="-1">監控 GC 效能 <a class="header-anchor" href="#監控-gc-效能" aria-label="Permalink to &quot;監控 GC 效能&quot;">​</a></h3><p>若要監控 GC 效能，您可以查閱其日誌並診斷問題。若要啟用日誌記錄，請在您的 Gradle 建置腳本中設定以下編譯器選項：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-Xruntime-logs=gc=info</span></span></code></pre></div><p>目前，日誌僅列印到 <code>stderr</code>。</p><p>在 Apple 平台上，您可以利用 Xcode Instruments 工具套件來偵錯 iOS 應用程式效能。垃圾收集器會透過 Instruments 中可用的標示 (signposts) 報告暫停。標示可在您的應用程式中啟用自訂日誌記錄，讓您檢查 GC 暫停是否對應於應用程式凍結。</p><p>若要追蹤應用程式中與 GC 相關的暫停：</p><ol><li>若要啟用此功能，請在您的 <code>gradle.properties</code> 檔案中設定以下編譯器選項：</li></ol><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.enableSafepointSignposts=true</span></span></code></pre></div>',20)),n("ol",g,[n("li",null,[s[1]||(s[1]=a("開啟 Xcode，前往 ")),s[2]||(s[2]=n("strong",null,"Product",-1)),s[3]||(s[3]=a(" | ")),s[4]||(s[4]=n("strong",null,"Profile",-1)),s[5]||(s[5]=a(" 或按下 ")),t(p,null,{default:d(()=>s[0]||(s[0]=[a("Cmd + I")])),_:1}),s[6]||(s[6]=a("。此動作會編譯您的應用程式並啟動 Instruments。"))]),s[7]||(s[7]=i("<li>在範本選取中，選取 <strong>os_signpost</strong>。</li><li>透過指定 <code>org.kotlinlang.native.runtime</code> 為 <strong>subsystem</strong> 並 <code>safepoint</code> 為 <strong>category</strong> 來進行配置。</li><li>按一下紅色錄製按鈕以執行您的應用程式並開始錄製標示事件：</li>",3))]),s[9]||(s[9]=i('<p><img src="'+h+`" alt="追蹤 GC 暫停作為標示" width="700"></p><p>在此，最下方圖表上的每個藍色點代表一個單獨的標示事件，即一個 GC 暫停。</p><h3 id="最佳化-gc-效能" tabindex="-1">最佳化 GC 效能 <a class="header-anchor" href="#最佳化-gc-效能" aria-label="Permalink to &quot;最佳化 GC 效能&quot;">​</a></h3><p>若要提升 GC 效能，您可以啟用並行標記以減少 GC 暫停時間。這允許垃圾收集的標記階段與應用程式執行緒同時運行。</p><p>此功能目前為<a href="/zh-Hant/kotlin/components-stability#stability-levels-explained">實驗性</a>。若要啟用它，請在您的 <code>gradle.properties</code> 檔案中設定以下編譯器選項：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.gc=cms</span></span></code></pre></div><h3 id="停用垃圾收集" tabindex="-1">停用垃圾收集 <a class="header-anchor" href="#停用垃圾收集" aria-label="Permalink to &quot;停用垃圾收集&quot;">​</a></h3><p>建議保持 GC 啟用。然而，在某些情況下您可以停用它，例如用於測試目的，或者如果您遇到問題且程式執行時間很短。為此，請在您的 <code>gradle.properties</code> 檔案中設定以下二進位選項：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.gc=noop</span></span></code></pre></div><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>啟用此選項後，GC 不會收集 Kotlin 物件，因此只要程式運行，記憶體消耗就會持續增加。請注意不要耗盡系統記憶體。</p></div><h2 id="記憶體消耗" tabindex="-1">記憶體消耗 <a class="header-anchor" href="#記憶體消耗" aria-label="Permalink to &quot;記憶體消耗&quot;">​</a></h2><p>Kotlin/Native 使用其自己的<a href="https://github.com/JetBrains/kotlin/blob/master/kotlin-native/runtime/src/alloc/custom/README.md" target="_blank" rel="noreferrer">記憶體分配器</a>。它將系統記憶體劃分為頁 (pages)，允許以連續順序獨立清除。每個分配都成為頁內的一個記憶體區塊，且該頁會追蹤區塊大小。不同頁類型針對各種分配大小進行了最佳化。記憶體區塊的連續排列確保了對所有已分配區塊的高效迭代。</p><p>當執行緒分配記憶體時，它會根據分配大小尋找合適的頁。執行緒會維護一組用於不同大小類別的頁。通常，給定大小的當前頁可以容納該分配。如果不行，執行緒會從共享分配空間請求不同的頁。此頁可能已經可用、需要清除或必須先建立。</p><p>Kotlin/Native 記憶體分配器帶有防止記憶體分配突然飆升的保護機制。它防止了突變器 (mutator) 開始快速分配大量垃圾而 GC 執行緒無法跟上的情況，導致記憶體使用量無限增長。在這種情況下，GC 會強制進入「全域暫停」(stop-the-world) 階段，直到迭代完成。</p><p>您可以自行監控記憶體消耗、檢查記憶體洩漏並調整記憶體消耗。</p><h3 id="監控記憶體消耗" tabindex="-1">監控記憶體消耗 <a class="header-anchor" href="#監控記憶體消耗" aria-label="Permalink to &quot;監控記憶體消耗&quot;">​</a></h3><p>若要偵錯記憶體問題，您可以檢查記憶體管理器指標。此外，也可以在 Apple 平台上追蹤 Kotlin 的記憶體消耗。</p><h4 id="檢查記憶體洩漏" tabindex="-1">檢查記憶體洩漏 <a class="header-anchor" href="#檢查記憶體洩漏" aria-label="Permalink to &quot;檢查記憶體洩漏&quot;">​</a></h4><p>若要存取記憶體管理器指標，請呼叫 <code>kotlin.native.internal.GC.lastGCInfo()</code>。此方法會回傳上次垃圾收集器運行的統計資訊。這些統計資訊可用於：</p><ul><li>偵錯使用全域變數時的記憶體洩漏</li><li>執行測試時檢查洩漏</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.native.internal.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.test.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Resource</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> global </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mutableListOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Resource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalStdlibApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getUsage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    GC.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">collect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GC.lastGCInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.memoryUsageAfter[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;heap&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.totalObjectsSizeBytes</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    global.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Resource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // The test will fail if you remove the next line</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    global.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> before </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getUsage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // A separate function is used to ensure that all temporary objects are cleared</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> after </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getUsage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assertEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(before, after)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="在-apple-平台上追蹤記憶體消耗" tabindex="-1">在 Apple 平台上追蹤記憶體消耗 <a class="header-anchor" href="#在-apple-平台上追蹤記憶體消耗" aria-label="Permalink to &quot;在 Apple 平台上追蹤記憶體消耗&quot;">​</a></h4><p>在 Apple 平台上偵錯記憶體問題時，您可以看到 Kotlin 程式碼保留了多少記憶體。Kotlin 的份額會被標記一個識別碼，並可透過 Xcode Instruments 中的 VM Tracker 等工具追蹤。</p><p>此功能僅適用於預設的 Kotlin/Native 記憶體分配器，當<strong>所有</strong>以下條件都滿足時：</p><ul><li><p><strong>標記已啟用</strong>。記憶體應使用有效的識別碼進行標記。Apple 建議使用 240 到 255 之間的數字；預設值為 246。</p><p>如果您設定 <code>kotlin.native.binary.mmapTag=0</code> Gradle 屬性，標記將停用。</p></li><li><p><strong>使用 mmap 分配</strong>。分配器應使用 <code>mmap</code> 系統呼叫將檔案映射到記憶體中。</p><p>如果您設定 <code>kotlin.native.binary.disableMmap=true</code> Gradle 屬性，預設分配器會使用 <code>malloc</code> 而非 <code>mmap</code>。</p></li><li><p><strong>分頁已啟用</strong>。應啟用分配的分頁（緩衝）。</p><p>如果您設定 <a href="#disable-allocator-paging"><code>kotlin.native.binary.pagedAllocator=false</code></a> Gradle 屬性，記憶體將改為按物件基礎保留。</p></li></ul><h3 id="調整記憶體消耗" tabindex="-1">調整記憶體消耗 <a class="header-anchor" href="#調整記憶體消耗" aria-label="Permalink to &quot;調整記憶體消耗&quot;">​</a></h3><p>如果您遇到意料之外的高記憶體消耗，嘗試以下解決方案：</p><h4 id="更新-kotlin" tabindex="-1">更新 Kotlin <a class="header-anchor" href="#更新-kotlin" aria-label="Permalink to &quot;更新 Kotlin&quot;">​</a></h4><p>將 Kotlin 更新到最新版本。我們正在持續改進記憶體管理器，因此即使是簡單的編譯器更新也可能改善記憶體消耗。</p>`,29)),t(e,{id:"停用分配器分頁",level:"4",title:"停用分配器分頁",labelRef:"experimental-opt-in"}),s[10]||(s[10]=i('<p>您可以停用分配的分頁（緩衝），以便記憶體分配器按物件基礎保留記憶體。在某些情況下，這可能幫助您滿足嚴格的記憶體限制或減少應用程式啟動時的記憶體消耗。</p><p>為此，請在您的 <code>gradle.properties</code> 檔案中設定以下選項：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.pagedAllocator=false</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>停用分配器分頁後，<a href="#track-memory-consumption-on-apple-platforms">在 Apple 平台上追蹤記憶體消耗</a>將不可能。</p></div>',4)),t(e,{id:"啟用-latin-1-字串支援",level:"4",title:"啟用 Latin-1 字串支援",labelRef:"experimental-opt-in"}),s[11]||(s[11]=i(`<p>預設情況下，Kotlin 中的字串使用 UTF-16 編碼儲存，其中每個字元由兩個位元組表示。在某些情況下，這會導致字串在二進位檔案中佔用比原始碼多兩倍的空間，並且讀取資料會佔用兩倍的記憶體。</p><p>為了減少應用程式的二進位檔案大小並調整記憶體消耗，您可以啟用對 Latin-1 編碼字串的支援。<a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" target="_blank" rel="noreferrer">Latin-1 (ISO 8859-1)</a> 編碼僅用一個位元組表示前 256 個 Unicode 字元。</p><p>若要啟用它，請在您的 <code>gradle.properties</code> 檔案中設定以下選項：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.latin1Strings=true</span></span></code></pre></div><p>啟用 Latin-1 支援後，只要所有字元都在其範圍內，字串就會以 Latin-1 編碼儲存。否則，將使用預設的 UTF-16 編碼。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>儘管此功能仍處於實驗階段，但 <code>cinterop</code> 擴充函數 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/pin.html" target="_blank" rel="noreferrer"><code>String.pin</code></a>、<a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/use-pinned.html" target="_blank" rel="noreferrer"><code>String.usePinned</code></a> 和 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/ref-to.html" target="_blank" rel="noreferrer"><code>String.refTo</code></a> 的效率會降低。每次呼叫它們都可能觸發自動將字串轉換為 UTF-16。</p></div><p>如果這些選項都沒有幫助，請在 <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack</a> 中建立一個問題。</p><h2 id="背景中的單元測試" tabindex="-1">背景中的單元測試 <a class="header-anchor" href="#背景中的單元測試" aria-label="Permalink to &quot;背景中的單元測試&quot;">​</a></h2><p>在單元測試中，沒有任何東西處理主執行緒佇列，因此除非已模擬 <code>Dispatchers.Main</code>，否則不要使用它。可以透過呼叫 <code>kotlinx-coroutines-test</code> 中的 <code>Dispatchers.setMain</code> 來模擬它。</p><p>如果您不依賴 <code>kotlinx.coroutines</code> 或者如果 <code>Dispatchers.setMain</code> 因某些原因無法正常運作，嘗試以下解決方案來實作測試啟動器：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testlauncher</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> platform.CoreFoundation.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.native.concurrent.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.native.internal.test.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.system.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mainBackground</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> worker </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Worker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;main-background&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    worker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(TransferMode.SAFE, { args.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">freeze</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testLauncherEntryPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(it)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        exitProcess</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    CFRunLoopRun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;CFRunLoopRun should never return&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>然後，使用 <code>-e testlauncher.mainBackground</code> 編譯器選項編譯測試二進位檔案。</p><h2 id="接下來" tabindex="-1">接下來 <a class="header-anchor" href="#接下來" aria-label="Permalink to &quot;接下來&quot;">​</a></h2><ul><li><a href="/zh-Hant/kotlin/native-migration-guide">從舊版記憶體管理器遷移</a></li><li><a href="/zh-Hant/kotlin/native-arc-integration">檢查與 Swift/Objective-C ARC 整合的細節</a></li></ul>`,14))])}const _=r(c,[["render",E]]);export{f as __pageData,_ as default};
