import{_ as t,c as i,o as a,ag as e}from"./chunks/framework.Bksy39di.js";const c=JSON.parse('{"title":"從 JavaScript 使用 Kotlin 程式碼","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/js-to-kotlin-interop.md","filePath":"zh-Hant/kotlin/js-to-kotlin-interop.md","lastUpdated":1754307826000}'),l={name:"zh-Hant/kotlin/js-to-kotlin-interop.md"};function n(p,s,d,h,k,o){return a(),i("div",null,s[0]||(s[0]=[e(`<h1 id="從-javascript-使用-kotlin-程式碼" tabindex="-1">從 JavaScript 使用 Kotlin 程式碼 <a class="header-anchor" href="#從-javascript-使用-kotlin-程式碼" aria-label="Permalink to &quot;從 JavaScript 使用 Kotlin 程式碼&quot;">​</a></h1><p>根據所選的 <a href="/zh-Hant/kotlin/js-modules">JavaScript 模組</a>系統，Kotlin/JS 編譯器會產生不同的輸出。但總體而言，Kotlin 編譯器會產生普通的 JavaScript 類別、函數和屬性，您可以自由地從 JavaScript 程式碼中使用它們。不過，有一些細微之處您應該記住。</p><h2 id="在-plain-模式下將宣告隔離到獨立的-javascript-物件中" tabindex="-1">在 plain 模式下將宣告隔離到獨立的 JavaScript 物件中 <a class="header-anchor" href="#在-plain-模式下將宣告隔離到獨立的-javascript-物件中" aria-label="Permalink to &quot;在 plain 模式下將宣告隔離到獨立的 JavaScript 物件中&quot;">​</a></h2><p>如果您明確將模組類型設定為 <code>plain</code>，Kotlin 會建立一個物件，其中包含當前模組中的所有 Kotlin 宣告。這樣做是為了防止汙染全域物件。這表示對於模組 <code>myModule</code>，所有宣告都可以透過 <code>myModule</code> 物件供 JavaScript 使用。例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello&quot;</span></span></code></pre></div><p>可以像這樣從 JavaScript 呼叫：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myModule.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><p>當您將 Kotlin 模組編譯為 UMD（這是 <code>browser</code> 和 <code>nodejs</code> 目標的預設設定）、CommonJS 或 AMD 等 JavaScript 模組時，此規則不適用。在這種情況下，您的宣告將以您所選 JavaScript 模組系統指定的格式公開。例如，當使用 UMD 或 CommonJS 時，您的呼叫點可能如下所示：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;myModule&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><p>請查閱關於 <a href="/zh-Hant/kotlin/js-modules">JavaScript 模組</a>的文章，以獲取有關 JavaScript 模組系統主題的更多資訊。</p><h2 id="套件結構" tabindex="-1">套件結構 <a class="header-anchor" href="#套件結構" aria-label="Permalink to &quot;套件結構&quot;">​</a></h2><p>Kotlin 將其套件結構公開給 JavaScript，因此除非您在根套件中定義您的宣告，否則您必須在 JavaScript 中使用完整合格名稱。例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> my.qualified.packagename</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello&quot;</span></span></code></pre></div><p>例如，當使用 UMD 或 CommonJS 時，您的呼叫點可能如下所示：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;myModule&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).my.qualified.packagename.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>或者，在使用 <code>plain</code> 作為模組系統設定的情況下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myModule.my.qualified.packagename.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><h3 id="jsname-註解" tabindex="-1">@JsName 註解 <a class="header-anchor" href="#jsname-註解" aria-label="Permalink to &quot;@JsName 註解&quot;">​</a></h3><p>在某些情況下（例如，為了支援多載），Kotlin 編譯器會混淆 JavaScript 程式碼中產生之函數和屬性的名稱。為了控制產生的名稱，您可以使用 <code>@JsName</code> 註解：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Module &#39;kjs&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @JsName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;helloWithGreeting&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(greeting: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$greeting</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>現在您可以以下列方式從 JavaScript 使用此類別：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// If necessary, import &#39;kjs&#39; according to chosen module system</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kjs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Dmitry&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// refers to module &#39;kjs&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">person.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();                          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// prints &quot;Hello Dmitry!&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">person.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">helloWithGreeting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Servus&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// prints &quot;Servus Dmitry!&quot;</span></span></code></pre></div><p>如果我們沒有指定 <code>@JsName</code> 註解，則相應函數的名稱將包含從函數簽章計算出的尾碼，例如 <code>hello_61zpoe</code>。</p><p>請注意，在某些情況下 Kotlin 編譯器不會應用名稱混淆：</p><ul><li><code>external</code> 宣告不會被混淆。</li><li>任何繼承自 <code>external</code> 類別的非 <code>external</code> 類別中被覆寫的函數不會被混淆。</li></ul><p><code>@JsName</code> 的參數必須是一個常數字串文字，且為有效的識別符號。如果嘗試將非識別符號字串傳遞給 <code>@JsName</code>，編譯器將會報告錯誤。以下範例會產生編譯時錯誤：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JsName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;new C()&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 此處錯誤</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> newC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h3 id="jsexport-註解" tabindex="-1">@JsExport 註解 <a class="header-anchor" href="#jsexport-註解" aria-label="Permalink to &quot;@JsExport 註解&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>此功能為 <a href="/zh-Hant/kotlin/components-stability#stability-levels-explained">實驗性</a>。其設計在未來版本中可能會變更。</p></div><p>透過將 <code>@JsExport</code> 註解應用於頂層宣告（例如類別或函數），您可以讓 Kotlin 宣告從 JavaScript 中可用。此註解會以 Kotlin 中給定的名稱匯出所有巢狀宣告。它也可以透過使用 <code>@file:JsExport</code> 應用於檔案層級。</p><p>為了解決匯出中的歧義（例如同名函數的多載），您可以將 <code>@JsExport</code> 註解與 <code>@JsName</code> 註解一起使用，以指定產生和匯出函數的名稱。</p><p>在目前的 <a href="/zh-Hant/kotlin/js-ir-compiler">IR 編譯器後端</a>中，<code>@JsExport</code> 註解是讓您的函數從 Kotlin 可見的唯一方式。</p><p>對於多平台專案，<code>@JsExport</code> 也可在通用程式碼中使用。它僅在編譯 JavaScript 目標時生效，並允許您匯出非平台特定的 Kotlin 宣告。</p><h3 id="jsstatic" tabindex="-1">@JsStatic <a class="header-anchor" href="#jsstatic" aria-label="Permalink to &quot;@JsStatic&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>此功能為 <a href="/zh-Hant/kotlin/components-stability#stability-levels-explained">實驗性</a>。它可能隨時被刪除或更改。僅用於評估目的。我們非常感謝您在 <a href="https://youtrack.jetbrains.com/issue/KT-18891/JS-provide-a-way-to-declare-static-members-JsStatic" target="_blank" rel="noreferrer">YouTrack</a> 上提供關於它的回饋。</p></div><p><code>@JsStatic</code> 註解指示編譯器為目標宣告產生額外的靜態方法。這有助於您直接在 JavaScript 中使用 Kotlin 程式碼中的靜態成員。</p><p>您可以將 <code>@JsStatic</code> 註解應用於命名物件中定義的函數，以及在類別和介面中宣告的伴隨物件。如果您使用此註解，編譯器將產生物件的靜態方法和物件本身的實例方法。例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    companion</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @JsStatic</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callNonStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>現在，<code>callStatic()</code> 函數在 JavaScript 中是靜態的，而 <code>callNonStatic()</code> 函數則不是：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JavaScript</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 運作正常，存取靜態函數</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callNonStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();           </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 錯誤，在產生的 JavaScript 中不是靜態函數</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.Companion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 實例方法保持不變</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.Companion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callNonStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 唯一運作方式</span></span></code></pre></div><p>也可以將 <code>@JsStatic</code> 註解應用於物件或伴隨物件的屬性，使其 getter 和 setter 方法成為該物件或包含伴隨物件的類別中的靜態成員。</p><h2 id="javascript-中的-kotlin-類型" tabindex="-1">JavaScript 中的 Kotlin 類型 <a class="header-anchor" href="#javascript-中的-kotlin-類型" aria-label="Permalink to &quot;JavaScript 中的 Kotlin 類型&quot;">​</a></h2><p>請參閱 Kotlin 類型如何映射到 JavaScript 類型：</p><table tabindex="0"><thead><tr><th style="text-align:left;">Kotlin</th><th style="text-align:left;">JavaScript</th><th style="text-align:left;">備註</th></tr></thead><tbody><tr><td style="text-align:left;"><code>Byte</code>, <code>Short</code>, <code>Int</code>, <code>Float</code>, <code>Double</code></td><td style="text-align:left;"><code>Number</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>Char</code></td><td style="text-align:left;"><code>Number</code></td><td style="text-align:left;">數字代表字元的程式碼。</td></tr><tr><td style="text-align:left;"><code>Long</code></td><td style="text-align:left;">Not supported</td><td style="text-align:left;">JavaScript 中沒有 64 位元整數數字類型，因此它由 Kotlin 類別模擬。</td></tr><tr><td style="text-align:left;"><code>Boolean</code></td><td style="text-align:left;"><code>Boolean</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>String</code></td><td style="text-align:left;"><code>String</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>Array</code></td><td style="text-align:left;"><code>Array</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>ByteArray</code></td><td style="text-align:left;"><code>Int8Array</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>ShortArray</code></td><td style="text-align:left;"><code>Int16Array</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>IntArray</code></td><td style="text-align:left;"><code>Int32Array</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>CharArray</code></td><td style="text-align:left;"><code>UInt16Array</code></td><td style="text-align:left;">帶有 <code>$type$ == &quot;CharArray&quot;</code> 屬性。</td></tr><tr><td style="text-align:left;"><code>FloatArray</code></td><td style="text-align:left;"><code>Float32Array</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>DoubleArray</code></td><td style="text-align:left;"><code>Float64Array</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>LongArray</code></td><td style="text-align:left;"><code>Array&lt;kotlin.Long&gt;</code></td><td style="text-align:left;">帶有 <code>$type$ == &quot;LongArray&quot;</code> 屬性。另請參閱 Kotlin 的 Long 類型備註。</td></tr><tr><td style="text-align:left;"><code>BooleanArray</code></td><td style="text-align:left;"><code>Int8Array</code></td><td style="text-align:left;">帶有 <code>$type$ == &quot;BooleanArray&quot;</code> 屬性。</td></tr><tr><td style="text-align:left;"><code>List</code>, <code>MutableList</code></td><td style="text-align:left;"><code>KtList</code>, <code>KtMutableList</code></td><td style="text-align:left;">透過 <code>KtList.asJsReadonlyArrayView</code> 或 <code>KtMutableList.asJsArrayView</code> 公開 <code>Array</code>。</td></tr><tr><td style="text-align:left;"><code>Map</code>, <code>MutableMap</code></td><td style="text-align:left;"><code>KtMap</code>, <code>KtMutableMap</code></td><td style="text-align:left;">透過 <code>KtMap.asJsReadonlyMapView</code> 或 <code>KtMutableMap.asJsMapView</code> 公開 ES2015 <code>Map</code>。</td></tr><tr><td style="text-align:left;"><code>Set</code>, <code>MutableSet</code></td><td style="text-align:left;"><code>KtSet</code>, <code>KtMutableSet</code></td><td style="text-align:left;">透過 <code>KtSet.asJsReadonlySetView</code> 或 <code>KtMutableSet.asJsSetView</code> 公開 ES2015 <code>Set</code>。</td></tr><tr><td style="text-align:left;"><code>Unit</code></td><td style="text-align:left;">Undefined</td><td style="text-align:left;">當用作回傳類型時可匯出，但當用作參數類型時則不可。</td></tr><tr><td style="text-align:left;"><code>Any</code></td><td style="text-align:left;"><code>Object</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>Throwable</code></td><td style="text-align:left;"><code>Error</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>enum class Type</code></td><td style="text-align:left;"><code>Type</code></td><td style="text-align:left;">列舉項目作為靜態類別屬性 (<code>Type.ENTRY</code>) 公開。</td></tr><tr><td style="text-align:left;">Nullable <code>Type?</code></td><td style="text-align:left;">\`Type</td><td style="text-align:left;">null</td></tr><tr><td style="text-align:left;">所有其他 Kotlin 類型，除了標記有 <code>@JsExport</code> 的</td><td style="text-align:left;">Not supported</td><td style="text-align:left;">包含 Kotlin 的 <a href="/zh-Hant/kotlin/unsigned-integer-types">無符號整數類型</a>。</td></tr></tbody></table><p>此外，重要的是要知道：</p><ul><li><p>Kotlin 為 <code>kotlin.Int</code>、<code>kotlin.Byte</code>、<code>kotlin.Short</code>、<code>kotlin.Char</code> 和 <code>kotlin.Long</code> 保留了溢位語義。</p></li><li><p>Kotlin 在執行時無法區分數字類型（<code>kotlin.Long</code> 除外），因此以下程式碼有效：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 23</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>Kotlin 在 JavaScript 中保留了延遲物件初始化。</p></li><li><p>Kotlin 不在 JavaScript 中實現頂層屬性的延遲初始化。</p></li></ul>`,46)]))}const g=t(l,[["render",n]]);export{c as __pageData,g as default};
