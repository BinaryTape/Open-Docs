import{_ as s,c as a,o as e,ag as t}from"./chunks/framework.Bksy39di.js";const r=JSON.parse('{"title":"動態類型","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/dynamic-type.md","filePath":"zh-Hant/kotlin/dynamic-type.md","lastUpdated":1754307826000}'),d={name:"zh-Hant/kotlin/dynamic-type.md"};function n(l,i,o,c,p,h){return e(),a("div",null,i[0]||(i[0]=[t(`<h1 id="動態類型" tabindex="-1">動態類型 <a class="header-anchor" href="#動態類型" aria-label="Permalink to &quot;動態類型&quot;">​</a></h1><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>目標 JVM 的程式碼不支援 <code>dynamic</code> 型別。</p></div><p>作為一種靜態型別語言，Kotlin 仍然需要與無型別或鬆散型別的環境（例如 JavaScript 生態系統）進行互通。為促進這些使用場景，語言中提供了 <code>dynamic</code> 型別：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dyn: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dynamic</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span></code></pre></div><p><code>dynamic</code> 型別基本上會關閉 Kotlin 的型別檢查器：</p><ul><li><code>dynamic</code> 型別的值可以賦值給任何變數或作為參數傳遞到任何地方。</li><li>任何值都可以賦值給 <code>dynamic</code> 型別的變數，或傳遞給接收 <code>dynamic</code> 作為參數的函式。</li><li>對於 <code>dynamic</code> 型別的值，<code>null</code> 檢查已停用。</li></ul><p><code>dynamic</code> 最獨特的功能是，我們被允許在 <code>dynamic</code> 變數上呼叫<strong>任何</strong>屬性或函式，並傳遞任何參數：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dyn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">whatever</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dyn) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &#39;whatever&#39; 未在任何地方定義</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dyn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">whatever</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">arrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p>在 JavaScript 平台，這段程式碼將「按原樣」編譯：Kotlin 中的 <code>dyn.whatever(1)</code> 在生成的 JavaScript 程式碼中會變成 <code>dyn.whatever(1)</code>。</p><p>當在 <code>dynamic</code> 型別的值上呼叫用 Kotlin 編寫的函式時，請記住 Kotlin 到 JavaScript 編譯器執行的名稱混淆。您可能需要使用 <a href="/zh-Hant/kotlin/js-to-kotlin-interop#jsname-annotation">@JsName 註解</a> 來為您需要呼叫的函式指定明確定義的名稱。</p><p>動態呼叫總是回傳 <code>dynamic</code> 作為結果，因此您可以自由地鏈接此類呼叫：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dyn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().bar.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">baz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>當您將 Lambda 傳遞給動態呼叫時，其所有參數預設都具有 <code>dynamic</code> 型別：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dyn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// x 是 dynamic 型別</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>使用 <code>dynamic</code> 型別值的表達式會「按原樣」翻譯成 JavaScript，並且不使用 Kotlin 運算子慣例。支援以下運算子：</p><ul><li>二元運算子: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code>, <code>&amp;&amp;</code>, <code>||</code></li><li>一元運算子 <ul><li>前置: <code>-</code>, <code>+</code>, <code>!</code></li><li>前置和後置: <code>++</code>, <code>--</code></li></ul></li><li>賦值運算子: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code></li><li>索引存取: <ul><li>讀取: <code>d[a]</code>，多於一個引數是錯誤</li><li>寫入: <code>d[a1] = a2</code>，<code>[]</code> 中多於一個引數是錯誤</li></ul></li></ul><p>使用 <code>dynamic</code> 型別值的 <code>in</code>、<code>!in</code> 和 <code>..</code> 運算被禁止。</p><p>有關更詳細的技術描述，請參閱<a href="https://github.com/JetBrains/kotlin/blob/master/spec-docs/dynamic-types.md" target="_blank" rel="noreferrer">規範文件</a>。</p>`,18)]))}const E=s(d,[["render",n]]);export{r as __pageData,E as default};
