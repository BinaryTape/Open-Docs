import{_ as k,C as d,c as h,o as c,j as i,G as l,ag as t,a as s,w as e}from"./chunks/framework.Bksy39di.js";const A=JSON.parse('{"title":"Kotlin Multiplatform 호환성 가이드","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kmp/multiplatform-compatibility-guide.md","filePath":"ko/kmp/multiplatform-compatibility-guide.md","lastUpdated":1755516278000}'),g={name:"ko/kmp/multiplatform-compatibility-guide.md"},E={colspan:"2"},u={colspan:"2"};function y(m,a,b,F,v,C){const r=d("show-structure"),n=d("code-block"),p=d("TabItem"),o=d("Tabs");return c(),h("div",null,[a[20]||(a[20]=i("h1",{id:"kotlin-multiplatform-호환성-가이드",tabindex:"-1"},[s("Kotlin Multiplatform 호환성 가이드 "),i("a",{class:"header-anchor",href:"#kotlin-multiplatform-호환성-가이드","aria-label":'Permalink to "Kotlin Multiplatform 호환성 가이드"'},"​")],-1)),l(r,{depth:"1"}),a[21]||(a[21]=t(`<p>이 가이드는 Kotlin Multiplatform 프로젝트를 개발할 때 발생할 수 있는 <a href="https://kotlinlang.org/docs/kotlin-evolution-principles.html#incompatible-changes" target="_blank" rel="noreferrer">호환되지 않는 변경 사항</a>을 요약합니다.</p><p>Kotlin의 현재 Stable 버전은 2.2.0입니다. 프로젝트에서 사용하는 Kotlin 버전에 따라 특정 변경 사항의 사용 중단 주기를 고려하세요. 예를 들어:</p><ul><li>Kotlin 1.7.0에서 Kotlin 1.9.0으로 업그레이드할 때, <a href="#kotlin-1-9-0-1-9-25">Kotlin 1.9.0</a> 및 <a href="#kotlin-1-7-0-1-8-22">Kotlin 1.7.0−1.8.22</a>에서 모두 적용된 호환되지 않는 변경 사항을 확인하세요.</li><li>Kotlin 1.9.0에서 Kotlin 2.0.0으로 업그레이드할 때, <a href="#kotlin-2-0-0-and-later">Kotlin 2.0.0</a> 및 <a href="#kotlin-1-9-0-1-9-25">Kotlin 1.9.0−1.9.25</a>에서 모두 적용된 호환되지 않는 변경 사항을 확인하세요.</li></ul><h2 id="버전-호환성" tabindex="-1">버전 호환성 <a class="header-anchor" href="#버전-호환성" aria-label="Permalink to &quot;버전 호환성&quot;">​</a></h2><p>프로젝트를 구성할 때, 특정 버전의 Kotlin Multiplatform Gradle 플러그인(프로젝트의 Kotlin 버전과 동일)과 Gradle, Xcode, Android Gradle 플러그인 버전의 호환성을 확인하세요:</p><table tabindex="0"><thead><tr><th>Kotlin Multiplatform plugin version</th><th>Gradle</th><th>Android Gradle plugin</th><th>Xcode</th></tr></thead><tbody><tr><td>2.2.0-2.2.10</td><td>7.6.3–8.14</td><td>7.3.1–8.10.0</td><td>16.3</td></tr><tr><td>2.1.21</td><td>7.6.3–8.12.1</td><td>7.3.1–8.7.2</td><td>16.3</td></tr><tr><td>2.1.20</td><td>7.6.3–8.11</td><td>7.4.2–8.7.2</td><td>16.0</td></tr><tr><td>2.1.0–2.1.10</td><td>7.6.3-8.10*</td><td>7.4.2–8.7.2</td><td>16.0</td></tr><tr><td>2.0.21</td><td>7.5-8.8*</td><td>7.4.2–8.5</td><td>16.0</td></tr><tr><td>2.0.20</td><td>7.5-8.8*</td><td>7.4.2–8.5</td><td>15.3</td></tr><tr><td>2.0.0</td><td>7.5-8.5</td><td>7.4.2–8.3</td><td>15.3</td></tr><tr><td>1.9.20</td><td>7.5-8.1.1</td><td>7.4.2–8.2</td><td>15.0</td></tr></tbody></table><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>*Kotlin 2.0.20–2.0.21 및 Kotlin 2.1.0–2.1.10은 Gradle 8.6까지 완전히 호환됩니다. Gradle 버전 8.7–8.10도 지원되지만, 한 가지 예외가 있습니다. Kotlin Multiplatform Gradle 플러그인을 사용하는 경우, 멀티플랫폼 프로젝트에서 JVM 타겟의 <code>withJava()</code> 함수 호출 시 사용 중단 경고가 표시될 수 있습니다. 자세한 내용은 <a href="#java-source-sets-created-by-default">기본적으로 생성되는 Java 소스 세트</a>를 참조하세요.</p></div><h2 id="kotlin-2-0-0-및-이후-버전" tabindex="-1">Kotlin 2.0.0 및 이후 버전 <a class="header-anchor" href="#kotlin-2-0-0-및-이후-버전" aria-label="Permalink to &quot;Kotlin 2.0.0 및 이후 버전&quot;">​</a></h2><p>이 섹션에서는 사용 중단 주기가 끝나고 Kotlin 2.0.0−2.2.0에 적용되는 호환되지 않는 변경 사항에 대해 다룹니다.</p><h3 id="bitcode-임베딩-사용-중단" tabindex="-1">Bitcode 임베딩 사용 중단 <a class="header-anchor" href="#bitcode-임베딩-사용-중단" aria-label="Permalink to &quot;Bitcode 임베딩 사용 중단&quot;">​</a></h3><p><strong>무엇이 변경되었나요?</strong></p><p>Bitcode 임베딩은 Xcode 14에서 사용이 중단되었고 Xcode 15에서는 모든 Apple 타겟에서 제거되었습니다. 이에 따라 프레임워크 구성의 <code>embedBitcode</code> 파라미터와 <code>-Xembed-bitcode</code>, <code>-Xembed-bitcode-marker</code> 명령줄 인수가 Kotlin에서 사용 중단되었습니다.</p><p><strong>현재의 모범 사례는 무엇인가요?</strong></p><p>이전 버전의 Xcode를 사용 중이지만 Kotlin 2.0.20 이상으로 업그레이드하려면 Xcode 프로젝트에서 bitcode 임베딩을 비활성화하세요.</p><p><strong>언제부터 변경 사항이 적용되나요?</strong></p><p>다음은 계획된 사용 중단 주기입니다:</p><ul><li>2.0.20: Kotlin/Native 컴파일러가 더 이상 bitcode 임베딩을 지원하지 않습니다.</li><li>2.1.0: <code>embedBitcode</code> DSL이 Kotlin Multiplatform Gradle 플러그인에서 경고와 함께 사용 중단됩니다.</li><li>2.2.0: 경고가 오류로 상향됩니다.</li><li>2.3.0: <code>embedBitcode</code> DSL이 제거됩니다.</li></ul><p>undefined</p><h3 id="기본적으로-생성되는-java-소스-세트" tabindex="-1">기본적으로 생성되는 Java 소스 세트 <a class="header-anchor" href="#기본적으로-생성되는-java-소스-세트" aria-label="Permalink to &quot;기본적으로 생성되는 Java 소스 세트&quot;">​</a></h3><p><strong>무엇이 변경되었나요?</strong></p><p>Kotlin Multiplatform을 다가오는 Gradle 변경 사항에 맞추기 위해 <code>withJava()</code> 함수를 단계적으로 제거하고 있습니다. <code>withJava()</code> 함수는 필요한 Java 소스 세트를 생성하여 Gradle의 Java 플러그인과의 통합을 가능하게 했습니다. Kotlin 2.1.20부터 이러한 Java 소스 세트는 기본적으로 생성됩니다.</p><p><strong>현재의 모범 사례는 무엇인가요?</strong></p><p>이전에는 <code>src/jvmMain/java</code> 및 <code>src/jvmTest/java</code> 소스 세트를 생성하기 위해 <code>withJava()</code> 함수를 명시적으로 사용해야 했습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        withJava</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Kotlin 2.1.20부터 빌드 스크립트에서 <code>withJava()</code> 함수를 제거할 수 있습니다.</p><p>또한, Gradle은 이제 Java 소스가 존재할 경우에만 Java 컴파일 작업을 실행하며, 이전에는 실행되지 않았던 JVM 유효성 검사 진단을 트리거합니다. 이 진단은 <code>KotlinJvmCompile</code> 작업 또는 <code>compilerOptions</code> 내부에서 호환되지 않는 JVM 타겟을 명시적으로 구성하는 경우 실패합니다. JVM 타겟 호환성을 보장하는 방법에 대한 지침은 <a href="https://kotlinlang.org/docs/gradle-configure-project.html#check-for-jvm-target-compatibility-of-related-compile-tasks" target="_blank" rel="noreferrer">관련 컴파일 작업의 JVM 타겟 호환성 확인</a>을 참조하세요.</p><p>프로젝트가 Gradle 버전 8.7보다 높은 버전을 사용하고 <a href="https://docs.gradle.org/current/userguide/java_plugin.html" target="_blank" rel="noreferrer">Java</a>, <a href="https://docs.gradle.org/current/userguide/java_library_plugin.html" target="_blank" rel="noreferrer">Java Library</a> 또는 <a href="https://docs.gradle.org/current/userguide/application_plugin.html" target="_blank" rel="noreferrer">Application</a>과 같은 Gradle Java 플러그인에 의존하지 않거나, Gradle Java 플러그인에 종속성이 있는 서드 파티 Gradle 플러그인을 사용하지 않는다면 <code>withJava()</code> 함수를 제거할 수 있습니다.</p><p>프로젝트가 <a href="https://docs.gradle.org/current/userguide/application_plugin.html" target="_blank" rel="noreferrer">Application</a> Gradle Java 플러그인을 사용하는 경우, <a href="https://kotlinlang.org/docs/whatsnew2120.html#kotlin-multiplatform-new-dsl-to-replace-gradle-s-application-plugin" target="_blank" rel="noreferrer">새로운 Experimental DSL</a>로 마이그레이션하는 것을 권장합니다. Gradle 8.7부터 Application 플러그인은 Kotlin Multiplatform Gradle 플러그인과 더 이상 함께 작동하지 않습니다.</p><p>멀티플랫폼 프로젝트에서 Kotlin Multiplatform Gradle 플러그인과 다른 Gradle Java 플러그인을 모두 사용하려면 <a href="./multiplatform-compatibility-guide#deprecated-compatibility-with-kotlin-multiplatform-gradle-plugin-and-gradle-java-plugins">Kotlin Multiplatform Gradle 플러그인 및 Gradle Java 플러그인과의 호환성 사용 중단</a>을 참조하세요.</p><p>Kotlin 2.1.20 및 Gradle 버전 8.7보다 높은 버전에서 <a href="https://docs.gradle.org/current/userguide/java_testing.html#sec:java_test_fixtures" target="_blank" rel="noreferrer">Java test fixtures</a> Gradle 플러그인을 사용하는 경우, 해당 플러그인은 작동하지 않습니다. 대신, 이 문제가 해결된 <a href="https://kotlinlang.org/docs/releases.html#release-details" target="_blank" rel="noreferrer">Kotlin 2.1.21</a>로 업그레이드하세요.</p><p>문제가 발생하면 <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">이슈 트래커</a>에 보고하거나 <a href="https://kotlinlang.slack.com/archives/C19FD9681" target="_blank" rel="noreferrer">공개 Slack 채널</a>에서 도움을 요청하세요.</p><p><strong>언제부터 변경 사항이 적용되나요?</strong></p><p>다음은 계획된 사용 중단 주기입니다:</p><ul><li>Gradle &gt;8.6: <code>withJava()</code> 함수를 사용하는 멀티플랫폼 프로젝트에서 이전 버전의 Kotlin에 대한 사용 중단 경고가 도입됩니다.</li><li>Gradle 9.0: 이 경고가 오류로 상향됩니다.</li><li>2.1.20: 어떤 Gradle 버전에서든 <code>withJava()</code> 함수 사용 시 사용 중단 경고가 도입됩니다.</li></ul><p>undefined</p><h3 id="android-타겟을-androidtarget으로-이름-변경" tabindex="-1"><code>android</code> 타겟을 <code>androidTarget</code>으로 이름 변경 <a class="header-anchor" href="#android-타겟을-androidtarget으로-이름-변경" aria-label="Permalink to &quot;\`android\` 타겟을 \`androidTarget\`으로 이름 변경&quot;">​</a></h3><p><strong>무엇이 변경되었나요?</strong></p><p>Kotlin Multiplatform을 더욱 안정화하기 위한 노력을 계속하고 있습니다. 이 방향의 필수적인 단계는 Android 타겟에 대한 일급(first-class) 지원을 제공하는 것입니다. 앞으로 이 지원은 Google의 Android 팀에서 개발한 별도의 플러그인을 통해 제공될 것입니다.</p><p>새로운 솔루션의 길을 열기 위해 현재 Kotlin DSL에서 <code>android</code> 블록의 이름을 <code>androidTarget</code>으로 변경하고 있습니다. 이것은 다가오는 Google의 DSL에 <code>android</code>라는 짧은 이름을 할당하기 위해 필요한 임시 변경 사항입니다.</p><p><strong>현재의 모범 사례는 무엇인가요?</strong></p><p><code>android</code> 블록의 모든 발생을 <code>androidTarget</code>으로 이름을 변경하세요. Android 타겟 지원을 위한 새로운 플러그인이 제공되면 Google의 DSL로 마이그레이션하세요. 이는 Kotlin Multiplatform 프로젝트에서 Android와 함께 작업하는 데 선호되는 옵션이 될 것입니다.</p><p><strong>언제부터 변경 사항이 적용되나요?</strong></p><p>다음은 계획된 사용 중단 주기입니다:</p><ul><li>1.9.0: Kotlin Multiplatform 프로젝트에서 <code>android</code> 이름 사용 시 사용 중단 경고가 도입됩니다.</li><li>2.1.0: 이 경고가 오류로 상향됩니다.</li><li>2.2.0: Kotlin Multiplatform Gradle 플러그인에서 <code>android</code> 타겟 DSL이 제거됩니다.</li></ul><p>undefined</p><h3 id="여러-유사-타겟-선언" tabindex="-1">여러 유사 타겟 선언 <a class="header-anchor" href="#여러-유사-타겟-선언" aria-label="Permalink to &quot;여러 유사 타겟 선언&quot;">​</a></h3><p><strong>무엇이 변경되었나요?</strong></p><p>단일 Gradle 프로젝트에서 여러 유사한 타겟을 선언하는 것은 권장되지 않습니다. 예를 들면:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;jvmKtor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;jvmOkHttp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 권장되지 않으며 사용 중단 경고를 발생시킵니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>한 가지 일반적인 경우는 두 개의 관련 코드를 함께 사용하는 것입니다. 예를 들어, <code>:shared</code> Gradle 프로젝트에서 <code>jvm(&quot;jvmKtor&quot;)</code> 및 <code>jvm(&quot;jvmOkHttp&quot;)</code>를 사용하여 Ktor 또는 OkHttp 라이브러리를 통해 네트워킹을 구현할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// shared/build.gradle.kts:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;jvmKtor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        attributes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;jvmOkHttp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        attributes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sourceSets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> commonMain </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> getting</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> commonJvmMain </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sourceSets.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">creating</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dependsOn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(commonMain)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // Shared dependencies</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jvmKtorMain </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dependsOn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(commonJvmMain)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // Ktor dependencies</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jvmOkHttpMain </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dependsOn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(commonJvmMain)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // OkHttp dependencies</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 구현은 간단하지 않은 구성 복잡성을 수반합니다:</p><ul><li><code>:shared</code> 측과 각 소비자 측에 Gradle 속성을 설정해야 합니다. 그렇지 않으면 추가 정보 없이는 소비자가 Ktor 기반 구현을 받아야 하는지 OkHttp 기반 구현을 받아야 하는지 명확하지 않기 때문에 Gradle이 이러한 프로젝트에서 종속성을 해결할 수 없습니다.</li><li><code>commonJvmMain</code> 소스 세트를 수동으로 설정해야 합니다.</li><li>이 구성은 여러 저수준 Gradle 및 Kotlin Gradle 플러그인 추상화 및 API를 포함합니다.</li></ul><p><strong>현재의 모범 사례는 무엇인가요?</strong></p><p>Ktor 기반 및 OkHttp 기반 구현이 _동일한 Gradle 프로젝트_에 있기 때문에 구성이 복잡합니다. 많은 경우, 해당 부분을 별도의 Gradle 프로젝트로 추출하는 것이 가능합니다. 다음은 이러한 리팩토링의 일반적인 개요입니다:</p><ol><li><p>원본 프로젝트에서 중복된 두 타겟을 단일 타겟으로 교체합니다. 이 타겟들 사이에 공유 소스 세트가 있었다면, 해당 소스와 구성을 새로 생성된 타겟의 기본 소스 세트로 이동합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// shared/build.gradle.kts:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sourceSets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        jvmMain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 여기에 jvmCommonMain의 구성을 복사</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>새로운 Gradle 프로젝트 두 개를 추가합니다. 일반적으로 <code>settings.gradle.kts</code> 파일에서 <code>include</code>를 호출하여 추가합니다. 예를 들면:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">include</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;:okhttp-impl&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">include</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;:ktor-impl&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div></li><li><p>각 새 Gradle 프로젝트를 구성합니다:</p><ul><li>대부분의 경우, 이 프로젝트들은 하나의 타겟으로만 컴파일되므로 <code>kotlin(&quot;multiplatform&quot;)</code> 플러그인을 적용할 필요가 없습니다. 이 예시에서는 <code>kotlin(&quot;jvm&quot;)</code>을 적용할 수 있습니다.</li><li>원본 타겟별 소스 세트의 내용을 해당 프로젝트로 이동합니다. 예를 들어, <code>jvmKtorMain</code>에서 <code>ktor-impl/src</code>로.</li><li>소스 세트의 구성(종속성, 컴파일러 옵션 등)을 복사합니다.</li><li>새 Gradle 프로젝트에서 원본 프로젝트로의 종속성을 추가합니다.</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ktor-impl/build.gradle.kts:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">plugins</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;jvm&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    project</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;:shared&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 원본 프로젝트에 대한 종속성 추가</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 여기에 jvmKtorMain의 종속성 복사</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 여기에 jvmKtorMain의 컴파일러 옵션 복사</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ol><p>이 접근 방식은 초기 설정에 더 많은 작업이 필요하지만, Gradle 및 Kotlin Gradle 플러그인의 저수준 엔티티를 사용하지 않아 결과 빌드를 사용하고 유지 관리하기가 더 쉽습니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>안타깝게도 각 경우에 대한 자세한 마이그레이션 단계를 제공할 수는 없습니다. 위 지침이 작동하지 않는 경우, 이 <a href="https://youtrack.jetbrains.com/issue/KT-59316" target="_blank" rel="noreferrer">YouTrack 이슈</a>에 사용 사례를 설명해 주세요.</p></div><p><strong>언제부터 변경 사항이 적용되나요?</strong></p><p>다음은 계획된 사용 중단 주기입니다:</p><ul><li>1.9.20: Kotlin Multiplatform 프로젝트에서 여러 유사한 타겟을 사용할 때 사용 중단 경고가 도입됩니다.</li><li>2.1.0: Kotlin/JS 타겟을 제외한 경우, 이러한 경우에 오류를 보고합니다. 이 예외에 대한 자세한 내용은 <a href="https://youtrack.jetbrains.com/issue/KT-47038/KJS-MPP-Split-JS-target-into-JsBrowser-and-JsNode" target="_blank" rel="noreferrer">YouTrack</a>의 이슈를 참조하세요.</li></ul><p>undefined</p><h3 id="레거시-모드로-게시된-멀티플랫폼-라이브러리-지원-중단" tabindex="-1">레거시 모드로 게시된 멀티플랫폼 라이브러리 지원 중단 <a class="header-anchor" href="#레거시-모드로-게시된-멀티플랫폼-라이브러리-지원-중단" aria-label="Permalink to &quot;레거시 모드로 게시된 멀티플랫폼 라이브러리 지원 중단&quot;">​</a></h3><p><strong>무엇이 변경되었나요?</strong></p><p>이전에 Kotlin Multiplatform 프로젝트에서 <a href="#deprecated-gradle-properties-for-hierarchical-structure-support">레거시 모드를 사용 중단</a>하여 &quot;레거시&quot; 바이너리 게시를 막고 프로젝트를 <a href="./multiplatform-hierarchy">계층 구조</a>로 마이그레이션하도록 권장했습니다.</p><p>생태계에서 &quot;레거시&quot; 바이너리를 단계적으로 제거하기 위해 Kotlin 1.9.0부터 레거시 라이브러리 사용 또한 권장되지 않습니다. 프로젝트가 레거시 라이브러리에 종속성을 사용하는 경우 다음과 같은 경고가 표시됩니다:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>The dependency group:artifact:1.0 was published in the legacy mode. Support for such dependencies will be removed in the future</span></span></code></pre></div><p><strong>현재의 모범 사례는 무엇인가요?</strong></p><p><em>멀티플랫폼 라이브러리를 사용하는 경우</em>, 대부분의 라이브러리는 이미 &quot;계층 구조&quot; 모드로 마이그레이션되었으므로 라이브러리 버전을 업데이트하기만 하면 됩니다. 자세한 내용은 해당 라이브러리의 문서를 참조하세요.</p><p>라이브러리가 아직 비-레거시 바이너리를 지원하지 않는 경우, 유지 관리자에게 연락하여 이 호환성 문제에 대해 알릴 수 있습니다.</p><p><em>라이브러리 작성자라면</em>, Kotlin Gradle 플러그인을 최신 버전으로 업데이트하고 <a href="#deprecated-gradle-properties-for-hierarchical-structure-support">사용 중단된 Gradle 속성</a>을 수정했는지 확인하세요.</p><p>Kotlin 팀은 생태계 마이그레이션을 돕기 위해 열심이므로, 문제가 발생하는 경우 주저하지 말고 <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack에 이슈를 생성</a>하세요.</p><p><strong>언제부터 변경 사항이 적용되나요?</strong></p><p>다음은 계획된 사용 중단 주기입니다:</p><ul><li>1.9.0: 레거시 라이브러리에 대한 종속성에 사용 중단 경고가 도입됩니다.</li><li>2.0.0: 레거시 라이브러리에 대한 종속성에 대한 경고가 오류로 상향됩니다.</li><li><blockquote><p>2.0.0: 레거시 라이브러리에 대한 종속성 지원이 제거됩니다. 이러한 종속성을 사용하면 빌드 실패가 발생할 수 있습니다.</p></blockquote></li></ul><p>undefined</p><h3 id="계층-구조-지원을-위한-gradle-속성-사용-중단" tabindex="-1">계층 구조 지원을 위한 Gradle 속성 사용 중단 <a class="header-anchor" href="#계층-구조-지원을-위한-gradle-속성-사용-중단" aria-label="Permalink to &quot;계층 구조 지원을 위한 Gradle 속성 사용 중단&quot;">​</a></h3><p><strong>무엇이 변경되었나요?</strong></p><p>Kotlin은 진화 과정에서 멀티플랫폼 프로젝트의 <a href="./multiplatform-hierarchy">계층 구조</a> 지원을 점진적으로 도입했습니다. 이는 <code>commonMain</code>과 <code>jvmMain</code>과 같은 플랫폼별 소스 세트 사이에 중간 소스 세트를 가질 수 있는 기능입니다.</p><p>전환 기간 동안, 도구 체인이 충분히 안정적이지 않았을 때, 세분화된 옵트인 및 옵트아웃을 허용하는 몇 가지 Gradle 속성이 도입되었습니다.</p><p>Kotlin 1.6.20부터 계층적 프로젝트 구조 지원이 기본적으로 활성화되었습니다. 그러나 차단 문제가 발생할 경우 옵트아웃을 위해 이러한 속성들이 유지되었습니다. 모든 피드백을 처리한 후, 이제 해당 속성들을 완전히 단계적으로 제거하기 시작했습니다.</p><p>다음 속성들은 이제 사용 중단되었습니다:</p><ul><li><code>kotlin.internal.mpp.hierarchicalStructureByDefault</code></li><li><code>kotlin.mpp.enableCompatibilityMetadataVariant</code></li><li><code>kotlin.mpp.hierarchicalStructureSupport</code></li><li><code>kotlin.mpp.enableGranularSourceSetsMetadata</code></li><li><code>kotlin.native.enableDependencyPropagation</code></li></ul><p><strong>현재의 모범 사례는 무엇인가요?</strong></p><ul><li><code>gradle.properties</code> 및 <code>local.properties</code> 파일에서 이러한 속성을 제거하세요.</li><li>Gradle 빌드 스크립트 또는 Gradle 플러그인에서 이러한 속성을 프로그래밍 방식으로 설정하지 마세요.</li><li>빌드에서 사용되는 서드 파티 Gradle 플러그인이 사용 중단된 속성을 설정하는 경우, 플러그인 유지 관리자에게 이러한 속성을 설정하지 않도록 요청하세요.</li></ul><p>Kotlin 1.6.20부터 Kotlin 도구 체인의 기본 동작에 이러한 속성이 포함되지 않으므로, 심각한 영향은 없을 것으로 예상됩니다. 대부분의 결과는 프로젝트를 다시 빌드한 직후에 나타날 것입니다.</p><p>라이브러리 작성자이고 추가적인 안전을 기하고 싶다면, 소비자가 라이브러리와 함께 작업할 수 있는지 확인하세요.</p><p><strong>언제부터 변경 사항이 적용되나요?</strong></p><p>다음은 계획된 사용 중단 주기입니다:</p><ul><li>1.8.20: 사용 중단된 Gradle 속성 사용 시 경고를 보고합니다.</li><li>1.9.20: 이 경고가 오류로 상향됩니다.</li><li>2.0.0: 사용 중단된 속성이 제거됩니다. Kotlin Gradle 플러그인은 해당 사용을 무시합니다.</li></ul><p>이러한 속성을 제거한 후 예기치 않은 문제가 발생할 경우, <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack에 이슈를 생성</a>하세요.</p><p>undefined</p><h3 id="타겟-프리셋-presets-api-사용-중단" tabindex="-1">타겟 프리셋(Presets) API 사용 중단 <a class="header-anchor" href="#타겟-프리셋-presets-api-사용-중단" aria-label="Permalink to &quot;타겟 프리셋(Presets) API 사용 중단&quot;">​</a></h3><p><strong>무엇이 변경되었나요?</strong></p><p>초기 개발 단계에서 Kotlin Multiplatform은 소위 _타겟 프리셋_과 함께 작동하는 API를 도입했습니다. 각 타겟 프리셋은 본질적으로 Kotlin Multiplatform 타겟을 위한 팩토리를 나타냈습니다. 이 API는 <code>jvm()</code> 또는 <code>iosSimulatorArm64()</code>와 같은 DSL 함수가 훨씬 더 간단하고 간결하게 동일한 사용 사례를 다루기 때문에 대체로 불필요한 것으로 판명되었습니다.</p><p>혼란을 줄이고 더 명확한 지침을 제공하기 위해, 모든 프리셋 관련 API가 Kotlin Gradle 플러그인의 공개 API에서 사용 중단되었습니다. 여기에는 다음이 포함됩니다:</p><ul><li><code>org.jetbrains.kotlin.gradle.dsl.KotlinMultiplatformExtension</code>의 <code>presets</code> 속성</li><li><code>org.jetbrains.kotlin.gradle.plugin.KotlinTargetPreset</code> 인터페이스 및 모든 상속자</li><li><code>fromPreset</code> 오버로드</li></ul><p><strong>현재의 모범 사례는 무엇인가요?</strong></p><p>대신 해당 <a href="./multiplatform-dsl-reference#targets">Kotlin 타겟</a>을 사용하세요. 예를 들면:</p>`,99)),i("table",null,[a[0]||(a[0]=i("tr",null,[i("td",null,"이전"),i("td",null,"현재")],-1)),i("tr",null,[i("td",null,[l(n,{lang:"kotlin",code:`kotlin {
    targets {
        fromPreset(presets.iosArm64, 'ios')
    }
}`})]),i("td",null,[l(n,{lang:"kotlin",code:`kotlin {
    iosArm64()
}`})])])]),a[22]||(a[22]=t('<p><strong>언제부터 변경 사항이 적용되나요?</strong></p><p>다음은 계획된 사용 중단 주기입니다:</p><ul><li>1.9.20: 프리셋 관련 API 사용 시 경고를 보고합니다.</li><li>2.0.0: 이 경고가 오류로 상향됩니다.</li><li>2.2.0: Kotlin Gradle 플러그인의 공개 API에서 프리셋 관련 API가 제거됩니다. 여전히 이를 사용하는 소스는 &quot;unresolved reference&quot; 오류로 실패하고, 바이너리(예: Gradle 플러그인)는 최신 버전의 Kotlin Gradle 플러그인을 대상으로 다시 컴파일되지 않으면 연결(linkage) 오류로 실패할 수 있습니다.</li></ul><p>undefined</p><h3 id="사용-중단된-apple-타겟-단축키" tabindex="-1">사용 중단된 Apple 타겟 단축키 <a class="header-anchor" href="#사용-중단된-apple-타겟-단축키" aria-label="Permalink to &quot;사용 중단된 Apple 타겟 단축키&quot;">​</a></h3><p><strong>무엇이 변경되었나요?</strong></p><p>Kotlin Multiplatform DSL에서 <code>ios()</code>, <code>watchos()</code>, <code>tvos()</code> 타겟 단축키가 사용 중단됩니다. 이 단축키는 Apple 타겟에 대한 소스 세트 계층 구조를 부분적으로 생성하도록 설계되었습니다. 그러나 확장하기 어렵고 때로는 혼란스러움을 유발하는 것으로 드러났습니다.</p><p>예를 들어, <code>ios()</code> 단축키는 <code>iosArm64</code> 및 <code>iosX64</code> 타겟을 모두 생성했지만, Apple M 칩을 사용하는 호스트에서 작업할 때 필요한 <code>iosSimulatorArm64</code> 타겟은 포함하지 않았습니다. 그러나 이 단축키를 변경하는 것은 구현하기 어려웠고 기존 사용자 프로젝트에 문제를 일으킬 수 있었습니다.</p><p><strong>현재의 모범 사례는 무엇인가요?</strong></p><p>Kotlin Gradle 플러그인은 이제 내장된 계층 구조 템플릿을 제공합니다. Kotlin 1.9.20부터 기본적으로 활성화되어 있으며, 일반적인 사용 사례를 위한 사전 정의된 중간 소스 세트를 포함합니다.</p><p>단축키 대신 타겟 목록을 지정해야 하며, 그러면 플러그인이 이 목록을 기반으로 중간 소스 세트를 자동으로 설정합니다.</p><p>예를 들어, 프로젝트에 <code>iosArm64</code> 및 <code>iosSimulatorArm64</code> 타겟이 있는 경우, 플러그인은 <code>iosMain</code> 및 <code>iosTest</code> 중간 소스 세트를 자동으로 생성합니다. <code>iosArm64</code> 및 <code>macosArm64</code> 타겟이 있는 경우, <code>appleMain</code> 및 <code>appleTest</code> 소스 세트가 생성됩니다.</p><p>자세한 내용은 <a href="./multiplatform-hierarchy">계층적 프로젝트 구조</a>를 참조하세요.</p><p><strong>언제부터 변경 사항이 적용되나요?</strong></p><p>다음은 계획된 사용 중단 주기입니다:</p><ul><li>1.9.20: <code>ios()</code>, <code>watchos()</code>, <code>tvos()</code> 타겟 단축키 사용 시 경고를 보고합니다. 대신 기본적으로 기본 계층 구조 템플릿이 활성화됩니다.</li><li>2.1.0: 타겟 단축키 사용 시 오류를 보고합니다.</li><li>2.2.0: Kotlin Multiplatform Gradle 플러그인에서 타겟 단축키 DSL이 제거됩니다.</li></ul><h3 id="kotlin-업그레이드-후-ios-프레임워크-버전이-잘못된-문제" tabindex="-1">Kotlin 업그레이드 후 iOS 프레임워크 버전이 잘못된 문제 <a class="header-anchor" href="#kotlin-업그레이드-후-ios-프레임워크-버전이-잘못된-문제" aria-label="Permalink to &quot;Kotlin 업그레이드 후 iOS 프레임워크 버전이 잘못된 문제&quot;">​</a></h3><p><strong>무엇이 문제인가요?</strong></p><p>직접 통합을 사용하는 경우 Xcode에서 iOS 앱에 Kotlin 코드 변경 사항이 반영되지 않을 수 있습니다. 직접 통합은 <code>embedAndSignAppleFrameworkForXcode</code> 작업을 통해 설정되며, 이는 멀티플랫폼 프로젝트의 iOS 프레임워크를 Xcode의 iOS 앱에 연결합니다.</p><p>이는 Kotlin 버전을 1.9.2x에서 2.0.0으로(또는 2.0.0에서 1.9.2x로 다운그레이드) 업그레이드한 후 Kotlin 파일을 변경하고 앱을 빌드하려고 할 때 Xcode가 이전 버전의 iOS 프레임워크를 잘못 사용할 수 있기 때문에 발생할 수 있습니다. 따라서 변경 사항이 Xcode의 iOS 앱에 표시되지 않습니다.</p><p><strong>해결 방법은 무엇인가요?</strong></p><ol><li><p>Xcode에서 <strong>Product</strong> | <strong>Clean Build Folder</strong>를 사용하여 빌드 디렉토리를 정리합니다.</p></li><li><p>터미널에서 다음 명령어를 실행합니다:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>./gradlew clean</span></span></code></pre></div></li><li><p>새 버전의 iOS 프레임워크가 사용되는지 확인하기 위해 앱을 다시 빌드합니다.</p></li></ol><p><strong>언제 문제가 해결될까요?</strong></p><p>이 문제는 Kotlin 2.0.10에서 해결될 예정입니다. Kotlin 2.0.10의 미리 보기 버전이 <a href="https://kotlinlang.org/docs/eap.html" target="_blank" rel="noreferrer">Kotlin Early Access Preview 참여</a> 섹션에서 이미 사용 가능한지 확인할 수 있습니다.</p><p>자세한 내용은 <a href="https://youtrack.jetbrains.com/issue/KT-68257" target="_blank" rel="noreferrer">YouTrack의 해당 이슈</a>를 참조하세요.</p><h2 id="kotlin-1-9-0−1-9-25" tabindex="-1">Kotlin 1.9.0−1.9.25 <a class="header-anchor" href="#kotlin-1-9-0−1-9-25" aria-label="Permalink to &quot;Kotlin 1.9.0−1.9.25&quot;">​</a></h2><p>이 섹션에서는 사용 중단 주기가 끝나고 Kotlin 1.9.0−1.9.25에 적용되는 호환되지 않는 변경 사항에 대해 다룹니다.</p><p>undefined</p>',28)),a[23]||(a[23]=i("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"kotlin-컴파일에-kotlin-소스-세트를-직접-추가하기-위한-api-사용-중단",tabindex:"-1"},[s("Kotlin 컴파일에 Kotlin 소스 세트를 직접 추가하기 위한 API 사용 중단 "),i("a",{class:"header-anchor",href:"#kotlin-컴파일에-kotlin-소스-세트를-직접-추가하기-위한-api-사용-중단","aria-label":'Permalink to "Kotlin 컴파일에 Kotlin 소스 세트를 직접 추가하기 위한 API 사용 중단 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),a[24]||(a[24]=t(`<p><strong>무엇이 변경되었나요?</strong></p><p><code>KotlinCompilation.source</code> 접근이 사용 중단되었습니다. 다음 코드와 같은 코드는 사용 중단 경고를 생성합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosSimulatorArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sourceSets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> commonMain </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> getting</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myCustomIntermediateSourceSet </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> creating</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dependsOn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(commonMain)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        targets[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;jvm&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].compilations[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">source</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myCustomIntermediateSourceSet)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>현재의 모범 사례는 무엇인가요?</strong></p><p><code>KotlinCompilation.source(someSourceSet)</code>를 대체하려면 <code>KotlinCompilation</code>의 기본 소스 세트에서 <code>someSourceSet</code>으로 <code>dependsOn</code> 관계를 추가하세요. <code>by getting</code>을 사용하여 소스를 직접 참조하는 것을 권장합니다. 이는 더 짧고 읽기 쉽습니다. 그러나 모든 경우에 적용 가능한 <code>KotlinCompilation.defaultSourceSet.dependsOn(someSourceSet)</code>도 사용할 수 있습니다.</p><p>위 코드를 다음 방법 중 하나로 변경할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosSimulatorArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sourceSets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> commonMain </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> getting</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myCustomIntermediateSourceSet </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> creating</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dependsOn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(commonMain)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 옵션 #1. 더 짧고 읽기 쉽습니다. 가능한 경우 사용하세요. </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 일반적으로 기본 소스 세트의 이름은 </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 타겟 이름과 컴파일 이름의 간단한 연결입니다:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jvmMain </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dependsOn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myCustomIntermediateSourceSet)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 옵션 #2. 일반적인 솔루션입니다. 빌드 스크립트에서 더 고급 접근 방식이 필요한 경우 사용하세요:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        targets[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;jvm&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].compilations[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].defaultSourceSet.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dependsOn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myCustomIntermediateSourceSet)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>언제부터 변경 사항이 적용되나요?</strong></p><p>다음은 계획된 사용 중단 주기입니다:</p><ul><li>1.9.0: <code>KotlinComplation.source</code> 사용 시 사용 중단 경고가 도입됩니다.</li><li>1.9.20: 이 경고가 오류로 상향됩니다.</li><li>2.2.0: Kotlin Gradle 플러그인에서 <code>KotlinComplation.source</code>가 제거되며, 사용 시도 시 빌드 스크립트 컴파일 중 &quot;unresolved reference&quot; 오류가 발생합니다.</li></ul><p>undefined</p>`,11)),a[25]||(a[25]=i("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"kotlin-js-gradle-플러그인에서-kotlin-multiplatform-gradle-플러그인으로-마이그레이션",tabindex:"-1"},[i("code",null,"kotlin-js"),s(" Gradle 플러그인에서 "),i("code",null,"kotlin-multiplatform"),s(" Gradle 플러그인으로 마이그레이션 "),i("a",{class:"header-anchor",href:"#kotlin-js-gradle-플러그인에서-kotlin-multiplatform-gradle-플러그인으로-마이그레이션","aria-label":'Permalink to "`kotlin-js` Gradle 플러그인에서 `kotlin-multiplatform` Gradle 플러그인으로 마이그레이션 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),a[26]||(a[26]=t("<p><strong>무엇이 변경되었나요?</strong></p><p>Kotlin 1.9.0부터 <code>kotlin-js</code> Gradle 플러그인은 사용 중단되었습니다. 기본적으로 이 플러그인은 <code>js()</code> 타겟을 가진 <code>kotlin-multiplatform</code> 플러그인의 기능을 복제했으며, 내부적으로 동일한 구현을 공유했습니다. 이러한 중복은 혼란을 야기하고 Kotlin 팀의 유지 보수 부담을 증가시켰습니다. 대신 <code>js()</code> 타겟과 함께 <code>kotlin-multiplatform</code> Gradle 플러그인으로 마이그레이션하는 것을 권장합니다.</p><p><strong>현재의 모범 사례는 무엇인가요?</strong></p>",3)),i("ol",null,[i("li",null,[a[3]||(a[3]=i("p",null,[s("프로젝트에서 "),i("code",null,"kotlin-js"),s(" Gradle 플러그인을 제거하고 "),i("code",null,"pluginManagement {}"),s(" 블록을 사용하는 경우 "),i("code",null,"settings.gradle.kts"),s(" 파일에 "),i("code",null,"kotlin-multiplatform"),s("을 적용합니다:")],-1)),l(o,null,{default:e(()=>[l(p,{title:"kotlin-js"},{default:e(()=>a[1]||(a[1]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"// settings.gradle.kts:")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"pluginManagement"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    plugins"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"        // 다음 줄을 제거합니다:")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"        kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"js"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") version "),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"1.9.0"')]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    ")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    repositories"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"        // ...")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),l(p,{title:"kotlin-multiplatform"},{default:e(()=>a[2]||(a[2]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"// settings.gradle.kts:")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"pluginManagement"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    plugins"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"        // 대신 다음 줄을 추가합니다:")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"        kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"multiplatform"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") version "),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"1.9.0"')]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    ")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    repositories"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"        // ...")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),a[4]||(a[4]=i("p",null,[s("다른 플러그인 적용 방식을 사용하는 경우, 마이그레이션 지침은 "),i("a",{href:"https://docs.gradle.org/current/userguide/plugins.html",target:"_blank",rel:"noreferrer"},"Gradle 문서"),s("를 참조하세요.")],-1))]),a[8]||(a[8]=i("li",null,[i("p",null,[s("소스 파일을 "),i("code",null,"main"),s(" 및 "),i("code",null,"test"),s(" 폴더에서 동일한 디렉토리의 "),i("code",null,"jsMain"),s(" 및 "),i("code",null,"jsTest"),s(" 폴더로 이동합니다.")])],-1)),i("li",null,[a[7]||(a[7]=t('<p>종속성 선언을 조정합니다:</p><ul><li><p><code>sourceSets {}</code> 블록을 사용하고 해당 소스 세트의 종속성을 구성하는 것을 권장합니다. 프로덕션 종속성의 경우 <code>jsMain {}</code>, 테스트 종속성의 경우 <code>jsTest {}</code>를 사용합니다. 자세한 내용은 <a href="./multiplatform-add-dependencies">종속성 추가</a>를 참조하세요.</p></li><li><p>그러나 최상위 블록에서 종속성을 선언하려면 <code>api(&quot;group:artifact:1.0&quot;)</code>에서 <code>add(&quot;jsMainApi&quot;, &quot;group:artifact:1.0&quot;)</code> 등으로 선언을 변경합니다.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>이 경우, 최상위 <code>dependencies {}</code> 블록이 <code>kotlin {}</code> 블록 <strong>뒤에</strong> 오는지 확인하세요. 그렇지 않으면 &quot;Configuration not found&quot; 오류가 발생합니다.</p></div></li></ul><p><code>build.gradle.kts</code> 파일의 코드를 다음 방법 중 하나로 변경할 수 있습니다:</p>',3)),l(o,null,{default:e(()=>[l(p,{title:"kotlin-js"},{default:e(()=>a[5]||(a[5]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"// build.gradle.kts:")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"plugins"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"js"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") version "),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"1.9.0"')]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"dependencies"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    testImplementation"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"test"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"))")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    implementation"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"org.jetbrains.kotlinx:kotlinx-html:0.8.0"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    js"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"        // ...")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),l(p,{title:"kotlin-multiplatform"},{default:e(()=>a[6]||(a[6]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"// build.gradle.kts:")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"plugins"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"multiplatform"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") version "),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"1.9.0"')]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    js"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"        // ...")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    ")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"    // 옵션 #1. sourceSets {} 블록에서 종속성을 선언합니다:")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    sourceSets"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"        val"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," jsMain "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"by"),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," getting"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"            dependencies"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"                // 여기에 js 접두사가 필요 없습니다. 최상위 블록에서 복사하여 붙여넣을 수 있습니다.")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"                implementation"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"org.jetbrains.kotlinx:kotlinx-html:0.8.0"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            }")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"       }")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"dependencies"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"    // 옵션 #2. 종속성 선언에 js 접두사를 추가합니다:")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    add"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"jsTestImplementation"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", "),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"test"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"))")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1})]),a[9]||(a[9]=i("li",null,[i("p",null,[i("code",null,"kotlin {}"),s(" 블록 내에서 Kotlin Gradle 플러그인이 제공하는 DSL은 대부분의 경우 변경되지 않습니다. 그러나 태스크 및 구성과 같은 저수준 Gradle 엔티티를 이름으로 참조했다면 이제 일반적으로 "),i("code",null,"js"),s(" 접두사를 추가하여 조정해야 합니다. 예를 들어, "),i("code",null,"browserTest"),s(" 태스크는 "),i("code",null,"jsBrowserTest"),s("라는 이름으로 찾을 수 있습니다.")])],-1))]),a[27]||(a[27]=i("p",null,[i("strong",null,"언제부터 변경 사항이 적용되나요?")],-1)),a[28]||(a[28]=i("p",null,[s("1.9.0에서는 "),i("code",null,"kotlin-js"),s(" Gradle 플러그인을 사용하면 사용 중단 경고가 발생합니다.")],-1)),a[29]||(a[29]=i("p",null,"undefined",-1)),a[30]||(a[30]=i("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"jvmwithjava-프리셋-사용-중단",tabindex:"-1"},[i("code",null,"jvmWithJava"),s(" 프리셋 사용 중단 "),i("a",{class:"header-anchor",href:"#jvmwithjava-프리셋-사용-중단","aria-label":'Permalink to "`jvmWithJava` 프리셋 사용 중단 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),a[31]||(a[31]=t('<p><strong>무엇이 변경되었나요?</strong></p><p><code>targetPresets.jvmWithJava</code>가 사용 중단되었으며 사용이 권장되지 않습니다.</p><p><strong>현재의 모범 사례는 무엇인가요?</strong></p><p>대신 <code>jvm { withJava() }</code> 타겟을 사용하세요. <code>jvm { withJava() }</code>로 전환한 후에는 <code>.java</code> 소스가 있는 소스 디렉토리의 경로를 조정해야 합니다.</p><p>예를 들어, 기본 이름 &quot;jvm&quot;을 가진 <code>jvm</code> 타겟을 사용하는 경우:</p><table tabindex="0"><thead><tr><th>이전</th><th>현재</th></tr></thead><tbody><tr><td><code>src/main/java</code></td><td><code>src/jvmMain/java</code></td></tr><tr><td><code>src/test/java</code></td><td><code>src/jvmTest/java</code></td></tr></tbody></table><p><strong>언제부터 변경 사항이 적용되나요?</strong></p><p>다음은 계획된 사용 중단 주기입니다:</p><ul><li>1.3.40: <code>targetPresets.jvmWithJava</code> 사용 시 경고가 도입됩니다.</li><li>1.9.20: 이 경고가 오류로 상향됩니다.</li><li><blockquote><p>1.9.20: <code>targetPresets.jvmWithJava</code> API가 제거됩니다. 사용 시도 시 빌드 스크립트 컴파일 실패로 이어집니다.</p></blockquote></li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>전체 <code>targetPresets</code> API가 사용 중단되었지만, <code>jvmWithJava</code> 프리셋은 사용 중단 타임라인이 다릅니다.</p></div><p>undefined</p>',11)),a[32]||(a[32]=i("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"레거시-android-소스-세트-레이아웃-사용-중단",tabindex:"-1"},[s("레거시 Android 소스 세트 레이아웃 사용 중단 "),i("a",{class:"header-anchor",href:"#레거시-android-소스-세트-레이아웃-사용-중단","aria-label":'Permalink to "레거시 Android 소스 세트 레이아웃 사용 중단 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),a[33]||(a[33]=t('<p><strong>무엇이 변경되었나요?</strong></p><p><a href="./multiplatform-android-layout">새로운 Android 소스 세트 레이아웃</a>은 Kotlin 1.9.0부터 기본적으로 사용됩니다. 레거시 레이아웃 지원은 사용 중단되었으며, <code>kotlin.mpp.androidSourceSetLayoutVersion</code> Gradle 속성 사용 시 사용 중단 진단이 트리거됩니다.</p><p><strong>언제부터 변경 사항이 적용되나요?</strong></p><p>다음은 계획된 사용 중단 주기입니다:</p><ul><li>&lt;=1.9.0: <code>kotlin.mpp.androidSourceSetLayoutVersion=1</code> 사용 시 경고를 보고합니다. 이 경고는 <code>kotlin.mpp.androidSourceSetLayoutVersion1.nowarn=true</code> Gradle 속성으로 억제할 수 있습니다.</li><li>1.9.20: 이 경고가 오류로 상향됩니다. 이 오류는 <strong>억제할 수 없습니다</strong>.</li><li><blockquote><p>1.9.20: <code>kotlin.mpp.androidSourceSetLayoutVersion=1</code> 지원이 제거됩니다. Kotlin Gradle 플러그인은 이 속성을 무시합니다.</p></blockquote></li></ul><p>undefined</p>',6)),a[34]||(a[34]=i("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"사용자-정의-dependson을-가진-commonmain-및-commontest-사용-중단",tabindex:"-1"},[s("사용자 정의 "),i("code",null,"dependsOn"),s("을 가진 "),i("code",null,"commonMain"),s(" 및 "),i("code",null,"commonTest"),s(" 사용 중단 "),i("a",{class:"header-anchor",href:"#사용자-정의-dependson을-가진-commonmain-및-commontest-사용-중단","aria-label":'Permalink to "사용자 정의 `dependsOn`을 가진 `commonMain` 및 `commonTest` 사용 중단 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),a[35]||(a[35]=t("<p><strong>무엇이 변경되었나요?</strong></p><p><code>commonMain</code> 및 <code>commonTest</code> 소스 세트는 일반적으로 각각 <code>main</code> 및 <code>test</code> 소스 세트 계층 구조의 루트를 나타냅니다. 그러나 이러한 소스 세트의 <code>dependsOn</code> 관계를 수동으로 구성하여 이를 재정의할 수 있었습니다.</p><p>이러한 구성을 유지하려면 멀티플랫폼 빌드 내부 에 대한 추가적인 노력과 지식이 필요합니다. 또한, <code>commonMain</code>이 <code>main</code> 소스 세트 계층 구조의 루트인지 확실히 하려면 특정 빌드 스크립트를 읽어야 하므로 코드 가독성과 재사용성이 떨어집니다.</p><p>따라서 <code>commonMain</code> 및 <code>commonTest</code>에서 <code>dependsOn</code>에 접근하는 것은 이제 사용 중단되었습니다.</p><p><strong>현재의 모범 사례는 무엇인가요?</strong></p><p><code>commonMain.dependsOn(customCommonMain)</code>을 사용하는 <code>customCommonMain</code> 소스 세트를 1.9.20으로 마이그레이션해야 한다고 가정해 봅시다. 대부분의 경우 <code>customCommonMain</code>은 <code>commonMain</code>과 동일한 컴파일에 참여하므로 <code>customCommonMain</code>을 <code>commonMain</code>으로 병합할 수 있습니다:</p><ol><li><code>customCommonMain</code>의 소스를 <code>commonMain</code>으로 복사합니다.</li><li><code>customCommonMain</code>의 모든 종속성을 <code>commonMain</code>에 추가합니다.</li><li><code>customCommonMain</code>의 모든 컴파일러 옵션 설정을 <code>commonMain</code>에 추가합니다.</li></ol><p>드문 경우지만, <code>customCommonMain</code>이 <code>commonMain</code>보다 더 많은 컴파일에 참여할 수 있습니다. 이러한 구성은 빌드 스크립트에 대한 추가적인 저수준 구성이 필요합니다. 이것이 귀하의 사용 사례인지 확실하지 않다면, 대부분의 경우 그렇지 않을 것입니다.</p><p>이것이 귀하의 사용 사례라면, <code>customCommonMain</code>의 소스와 설정을 <code>commonMain</code>으로 이동하고 그 반대로 하여 두 소스 세트를 &quot;교체&quot;합니다.</p><p><strong>언제부터 변경 사항이 적용되나요?</strong></p><p>다음은 계획된 사용 중단 주기입니다:</p><ul><li>1.9.0: <code>commonMain</code>에서 <code>dependsOn</code> 사용 시 경고를 보고합니다.</li><li><blockquote><p>=1.9.20: <code>commonMain</code> 또는 <code>commonTest</code>에서 <code>dependsOn</code> 사용 시 오류를 보고합니다.</p></blockquote></li></ul>",12)),a[36]||(a[36]=i("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"전방-선언에-대한-새로운-접근-방식",tabindex:"-1"},[s("전방 선언에 대한 새로운 접근 방식 "),i("a",{class:"header-anchor",href:"#전방-선언에-대한-새로운-접근-방식","aria-label":'Permalink to "전방 선언에 대한 새로운 접근 방식 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),a[37]||(a[37]=t(`<p><strong>무엇이 변경되었나요?</strong></p><p>JetBrains 팀은 예측 가능한 동작을 위해 Kotlin의 전방 선언(forward declarations) 접근 방식을 개선했습니다:</p><ul><li><code>cnames</code> 또는 <code>objcnames</code> 패키지를 사용해서만 전방 선언을 임포트할 수 있습니다.</li><li>해당 C 및 Objective-C 전방 선언으로의 명시적 캐스팅이 필요합니다.</li></ul><p><strong>현재의 모범 사례는 무엇인가요?</strong></p><ul><li><p><code>library.package</code>에 <code>cstructName</code> 전방 선언을 하는 C 라이브러리를 고려해 봅시다. 이전에는 <code>import library.package.cstructName</code>을 사용하여 라이브러리에서 직접 임포트하는 것이 가능했습니다. 이제는 이를 위해 특수 전방 선언 패키지만 사용할 수 있습니다: <code>import cnames.structs.cstructName</code>. <code>objcnames</code>도 마찬가지입니다.</p></li><li><p><code>objcnames.protocols.ForwardDeclaredProtocolProtocol</code>을 사용하는 objcinterop 라이브러리와 실제 정의를 가진 다른 라이브러리 두 개를 고려해 봅시다:</p><div class="language-ObjC vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ObjC</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 첫 번째 objcinterop 라이브러리</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;Foundation/Foundation.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@protocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredProtocol;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NSString</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> consumeProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;ForwardDeclaredProtocol&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NSString</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> stringWithUTF8String:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Protocol&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-ObjC vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ObjC</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 두 번째 objcinterop 라이브러리</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 헤더:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;Foundation/Foundation.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@protocol</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ForwardDeclaredProtocol</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@end</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 구현:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ForwardDeclaredProtocolImpl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NSObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;ForwardDeclaredProtocol&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;ForwardDeclaredProtocol&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">produceProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ForwardDeclaredProtocolImpl </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이전에는 객체들을 끊김 없이 전달하는 것이 가능했습니다. 이제 전방 선언에 대해 명시적인 <code>as</code> 캐스트가 필요합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin 코드:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    consumeProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">produceProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> objcnames.protocols.ForwardDeclaredProtocolProtocol)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p><code>objcnames.protocols.ForwardDeclaredProtocolProtocol</code>로의 캐스트는 해당 실제 클래스로부터만 가능합니다. 그렇지 않으면 오류가 발생합니다.</p></div></li></ul><p><strong>언제부터 변경 사항이 적용되나요?</strong></p><p>Kotlin 1.9.20부터 해당 C 및 Objective-C 전방 선언으로의 명시적 캐스팅이 필요합니다. 또한, 이제 특수 패키지를 사용해서만 전방 선언을 임포트하는 것이 가능합니다.</p><h2 id="kotlin-1-7-0−1-8-22" tabindex="-1">Kotlin 1.7.0−1.8.22 <a class="header-anchor" href="#kotlin-1-7-0−1-8-22" aria-label="Permalink to &quot;Kotlin 1.7.0−1.8.22&quot;">​</a></h2><p>이 섹션에서는 사용 중단 주기가 끝나고 Kotlin 1.7.0−1.8.22에 적용되는 호환되지 않는 변경 사항에 대해 다룹니다.</p><p>undefined</p>`,10)),a[38]||(a[38]=i("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"kotlin-multiplatform-gradle-플러그인-및-gradle-java-플러그인과의-호환성-사용-중단",tabindex:"-1"},[s("Kotlin Multiplatform Gradle 플러그인 및 Gradle Java 플러그인과의 호환성 사용 중단 "),i("a",{class:"header-anchor",href:"#kotlin-multiplatform-gradle-플러그인-및-gradle-java-플러그인과의-호환성-사용-중단","aria-label":'Permalink to "Kotlin Multiplatform Gradle 플러그인 및 Gradle Java 플러그인과의 호환성 사용 중단 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),a[39]||(a[39]=t(`<p><strong>무엇이 변경되었나요?</strong></p><p>Kotlin Multiplatform Gradle 플러그인과 Gradle 플러그인인 <a href="https://docs.gradle.org/current/userguide/java_plugin.html" target="_blank" rel="noreferrer">Java</a>, <a href="https://docs.gradle.org/current/userguide/java_library_plugin.html" target="_blank" rel="noreferrer">Java Library</a>, <a href="https://docs.gradle.org/current/userguide/application_plugin.html" target="_blank" rel="noreferrer">Application</a> 사이의 호환성 문제로 인해, 이제 이 플러그인들을 동일한 프로젝트에 적용할 때 사용 중단 경고가 발생합니다. 이 경고는 멀티플랫폼 프로젝트의 다른 Gradle 플러그인이 Gradle Java 플러그인을 적용할 때도 나타납니다. 예를 들어, <a href="https://docs.spring.io/spring-boot/gradle-plugin/index.html" target="_blank" rel="noreferrer">Spring Boot Gradle 플러그인</a>은 자동으로 Application 플러그인을 적용합니다.</p><p>Kotlin Multiplatform의 프로젝트 모델과 Gradle의 Java 에코시스템 플러그인 사이의 근본적인 호환성 문제로 인해 이 사용 중단 경고를 추가했습니다. Gradle의 Java 에코시스템 플러그인들은 현재 다른 플러그인이 다음을 수행할 수 있다는 점을 고려하지 않습니다:</p><ul><li>Java 에코시스템 플러그인과 다른 방식으로 JVM 타겟을 게시하거나 컴파일합니다.</li><li>동일한 프로젝트에 JVM과 Android 같은 두 개의 다른 JVM 타겟을 가집니다.</li><li>잠재적으로 여러 비-JVM 타겟을 포함하는 복잡한 멀티플랫폼 프로젝트 구조를 가집니다.</li></ul><p>안타깝게도 Gradle은 현재 이러한 문제를 해결하기 위한 API를 제공하지 않습니다.</p><p>이전에 Kotlin Multiplatform에서는 Java 에코시스템 플러그인 통합을 돕기 위해 일부 해결 방법을 사용했습니다. 그러나 이러한 해결 방법은 호환성 문제를 진정으로 해결한 적이 없으며, Gradle 8.8 출시 이후에는 이러한 해결 방법이 더 이상 불가능합니다. 자세한 내용은 <a href="https://youtrack.jetbrains.com/issue/KT-66542/Gradle-JVM-target-with-withJava-produces-a-deprecation-warning" target="_blank" rel="noreferrer">YouTrack 이슈</a>를 참조하세요.</p><p>이 호환성 문제를 정확히 어떻게 해결해야 할지는 아직 알 수 없지만, Kotlin Multiplatform 프로젝트에서 Java 소스 컴파일의 일부 형태를 계속 지원하기 위해 노력하고 있습니다. 최소한, Gradle의 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/plugins/JavaBasePlugin.html" target="_blank" rel="noreferrer"><code>java-base</code></a> 플러그인을 멀티플랫폼 프로젝트 내에서 Java 소스 컴파일 및 사용을 지원할 것입니다.</p><p><strong>현재의 모범 사례는 무엇인가요?</strong></p><p>멀티플랫폼 프로젝트에서 이 사용 중단 경고가 표시되면 다음을 권장합니다:</p><ol><li>프로젝트에 Gradle Java 플러그인이 실제로 필요한지 결정합니다. 필요하지 않다면 제거를 고려합니다.</li><li>Gradle Java 플러그인이 단일 작업에만 사용되는지 확인합니다. 그렇다면 큰 노력 없이 플러그인을 제거할 수 있습니다. 예를 들어, 작업이 Javadoc JAR 파일을 생성하기 위해 Gradle Java 플러그인을 사용하는 경우, Javadoc 작업을 수동으로 정의할 수 있습니다.</li></ol><p>그렇지 않고 멀티플랫폼 프로젝트에서 Kotlin Multiplatform Gradle 플러그인과 Gradle Java 플러그인을 모두 사용하려면 다음을 권장합니다:</p><ol><li>Gradle 프로젝트에 별도의 서브프로젝트를 생성합니다.</li><li>별도의 서브프로젝트에 Gradle Java 플러그인을 적용합니다.</li><li>별도의 서브프로젝트에 상위 멀티플랫폼 프로젝트에 대한 종속성을 추가합니다.</li></ol><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>별도의 서브프로젝트는 멀티플랫폼 프로젝트가 <strong>아니어야</strong> 하며, 멀티플랫폼 프로젝트에 대한 종속성을 설정하는 데만 사용해야 합니다.</p></div><p>예를 들어, <code>my-main-project</code>라는 멀티플랫폼 프로젝트가 있고 <a href="https://docs.gradle.org/current/userguide/java_library_plugin.html" target="_blank" rel="noreferrer">Java Library</a> Gradle 플러그인을 사용하고 싶다고 가정해 봅시다.</p><p><code>subproject-A</code>라는 서브프로젝트를 생성하면 상위 프로젝트 구조는 다음과 같아야 합니다:</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.</span></span>
<span class="line"><span>├── build.gradle</span></span>
<span class="line"><span>├── settings.gradle.kts</span></span>
<span class="line"><span>├── subproject-A</span></span>
<span class="line"><span>    └── build.gradle.kts</span></span>
<span class="line"><span>    └── src</span></span>
<span class="line"><span>        └── Main.java</span></span></code></pre></div><p>서브프로젝트의 <code>build.gradle.kts</code> 파일에서 <code>plugins {}</code> 블록에 Java Library 플러그인을 적용합니다:</p>`,17)),l(o,{group:"build-script"},{default:e(()=>[l(p,{title:"Kotlin","group-key":"kotlin"},{default:e(()=>a[10]||(a[10]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"plugins"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    id"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"java-library"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),l(p,{title:"Groovy","group-key":"groovy"},{default:e(()=>a[11]||(a[11]=[i("div",{class:"language-groovy vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"groovy"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"plugins {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    id("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},"'java-library'"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),a[40]||(a[40]=i("p",null,[s("서브프로젝트의 "),i("code",null,"build.gradle.kts"),s(" 파일에서 상위 멀티플랫폼 프로젝트에 대한 종속성을 추가합니다:")],-1)),l(o,{group:"build-script"},{default:e(()=>[l(p,{title:"Kotlin","group-key":"kotlin"},{default:e(()=>a[12]||(a[12]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"dependencies"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    implementation"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"project"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'":my-main-project"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")) "),i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"// 상위 멀티플랫폼 프로젝트의 이름")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),l(p,{title:"Groovy","group-key":"groovy"},{default:e(()=>a[13]||(a[13]=[i("div",{class:"language-groovy vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"groovy"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"dependencies {")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    implementation project("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},"':my-main-project'"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") "),i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"// 상위 멀티플랫폼 프로젝트의 이름")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),a[41]||(a[41]=i("p",null,"이제 상위 프로젝트는 두 플러그인과 모두 작동하도록 설정되었습니다.",-1)),a[42]||(a[42]=i("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"자동-생성된-타겟에-대한-새로운-접근-방식",tabindex:"-1"},[s("자동 생성된 타겟에 대한 새로운 접근 방식 "),i("a",{class:"header-anchor",href:"#자동-생성된-타겟에-대한-새로운-접근-방식","aria-label":'Permalink to "자동 생성된 타겟에 대한 새로운 접근 방식 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),a[43]||(a[43]=t("<p><strong>무엇이 변경되었나요?</strong></p><p>Gradle에 의해 자동 생성된 타겟 접근자는 더 이상 <code>kotlin.targets {}</code> 블록 내에서 사용할 수 없습니다. 대신 <code>findByName(&quot;targetName&quot;)</code> 메서드를 사용하세요.</p><p>이러한 접근자는 <code>kotlin.targets {}</code>의 경우, 예를 들어 <code>kotlin.targets.linuxX64</code>와 같이 여전히 사용할 수 있습니다.</p><p><strong>현재의 모범 사례는 무엇인가요?</strong></p>",4)),i("table",null,[a[14]||(a[14]=i("tr",null,[i("td",null,"이전"),i("td",null,"현재")],-1)),i("tr",null,[i("td",null,[l(n,{lang:"kotlin",code:`kotlin {
    targets {
        configure(['windows',
            'linux']) {
        }
    }
}`})]),i("td",null,[l(n,{lang:"kotlin",code:`kotlin {
    targets {
        configure([findByName('windows'),
            findByName('linux')]) {
        }
    }
}`})])])]),a[44]||(a[44]=i("p",null,[i("strong",null,"언제부터 변경 사항이 적용되나요?")],-1)),a[45]||(a[45]=i("p",null,[s("Kotlin 1.7.20에서는 "),i("code",null,"kotlin.targets {}"),s(" 블록에서 타겟 접근자를 사용할 때 오류가 도입됩니다.")],-1)),a[46]||(a[46]=i("p",null,[s("자세한 내용은 "),i("a",{href:"https://youtrack.jetbrains.com/issue/KT-47047",target:"_blank",rel:"noreferrer"},"YouTrack의 해당 이슈"),s("를 참조하세요.")],-1)),a[47]||(a[47]=i("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"gradle-입력-및-출력-컴파일-작업의-변경-사항",tabindex:"-1"},[s("Gradle 입력 및 출력 컴파일 작업의 변경 사항 "),i("a",{class:"header-anchor",href:"#gradle-입력-및-출력-컴파일-작업의-변경-사항","aria-label":'Permalink to "Gradle 입력 및 출력 컴파일 작업의 변경 사항 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),a[48]||(a[48]=t('<p><strong>무엇이 변경되었나요?</strong></p><p>Kotlin 컴파일 작업은 더 이상 <code>sourceCompatibility</code> 및 <code>targetCompatibility</code> 입력을 가진 Gradle <code>AbstractCompile</code> 작업을 상속하지 않으므로 Kotlin 사용자 스크립트에서는 사용할 수 없습니다.</p><p>컴파일 작업의 다른 주요 변경 사항:</p><p><strong>현재의 모범 사례는 무엇인가요?</strong></p><table tabindex="0"><thead><tr><th>이전</th><th>현재</th></tr></thead><tbody><tr><td><code>SourceTask.stableSources</code> 입력은 더 이상 사용할 수 없습니다.</td><td>대신 <code>sources</code> 입력을 사용하세요. 또한 <code>setSource()</code> 메서드는 여전히 사용할 수 있습니다.</td></tr><tr><td><code>sourceFilesExtensions</code> 입력이 제거되었습니다.</td><td>컴파일 작업은 여전히 <code>PatternFilterable</code> 인터페이스를 구현합니다. Kotlin 소스를 필터링하려면 해당 메서드를 사용하세요.</td></tr><tr><td><code>Gradle destinationDir: File</code> 출력이 사용 중단되었습니다.</td><td>대신 <code>destinationDirectory: DirectoryProperty</code> 출력을 사용하세요.</td></tr><tr><td><code>KotlinCompile</code> 작업의 <code>classpath</code> 속성이 사용 중단되었습니다.</td><td>모든 컴파일 작업은 이제 컴파일에 필요한 라이브러리 목록에 <code>libraries</code> 입력을 사용합니다.</td></tr></tbody></table><p><strong>언제부터 변경 사항이 적용되나요?</strong></p><p>Kotlin 1.7.20에서는 입력이 사용할 수 없게 되고, 출력이 대체되며, <code>classpath</code> 속성이 사용 중단됩니다.</p><p>자세한 내용은 <a href="https://youtrack.jetbrains.com/issue/KT-32805" target="_blank" rel="noreferrer">YouTrack의 해당 이슈</a>를 참조하세요.</p>',8)),a[49]||(a[49]=i("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"컴파일에-대한-종속성-새-구성-이름",tabindex:"-1"},[s("컴파일에 대한 종속성 새 구성 이름 "),i("a",{class:"header-anchor",href:"#컴파일에-대한-종속성-새-구성-이름","aria-label":'Permalink to "컴파일에 대한 종속성 새 구성 이름 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),a[50]||(a[50]=t("<p><strong>무엇이 변경되었나요?</strong></p><p>Kotlin Multiplatform Gradle 플러그인에 의해 생성된 컴파일 구성에 새로운 이름이 부여되었습니다.</p><p>Kotlin Multiplatform 프로젝트의 타겟에는 <code>main</code>과 <code>test</code>라는 두 가지 기본 컴파일이 있습니다. 이러한 각 컴파일에는 <code>jvmMain</code>과 <code>jvmTest</code>와 같은 자체 기본 소스 세트가 있습니다. 이전에는 테스트 컴파일과 해당 기본 소스 세트의 구성 이름이 동일하여 이름 충돌을 일으킬 수 있었고, 이는 플랫폼별 속성으로 표시된 구성이 다른 구성에 포함될 때 문제를 유발했습니다.</p><p>이제 컴파일 구성에는 추가 <code>Compilation</code> 접미사가 붙습니다. 반면 이전의 하드 코딩된 구성 이름을 사용하는 프로젝트 및 플러그인은 더 이상 컴파일되지 않습니다.</p><p>해당 소스 세트에 대한 종속성 구성 이름은 동일하게 유지됩니다.</p><p><strong>현재의 모범 사례는 무엇인가요?</strong></p>",6)),i("table",null,[a[19]||(a[19]=i("tr",null,[i("td"),i("td",null,"이전"),i("td",null,"현재")],-1)),i("tr",null,[a[15]||(a[15]=i("td",{rowspan:"2"},[i("code",null,"jvmMain"),s(" 컴파일의 종속성")],-1)),i("td",null,[l(n,{lang:"kotlin",code:"jvm<Scope>"})]),i("td",null,[l(n,{lang:"kotlin",code:"jvmCompilation<Scope>"})])]),i("tr",null,[i("td",null,[l(n,{lang:"kotlin",code:`dependencies {
    add("jvmImplementation",
        "foo.bar.baz:1.2.3")
}`})]),i("td",null,[l(n,{lang:"kotlin",code:`dependencies {
    add("jvmCompilationImplementation",
        "foo.bar.baz:1.2.3")
}`})])]),i("tr",null,[a[16]||(a[16]=i("td",null,[i("code",null,"jvmMain"),s(" 소스 세트의 종속성")],-1)),i("td",E,[l(n,{lang:"kotlin",code:"jvmMain<Scope>"})])]),i("tr",null,[a[17]||(a[17]=i("td",null,[i("code",null,"jvmTest"),s(" 컴파일의 종속성")],-1)),i("td",null,[l(n,{lang:"kotlin",code:"jvmTest<Scope>"})]),i("td",null,[l(n,{lang:"kotlin",code:"jvmTestCompilation<Scope>"})])]),i("tr",null,[a[18]||(a[18]=i("td",null,[i("code",null,"jvmTest"),s(" 소스 세트의 종속성")],-1)),i("td",u,[l(n,{lang:"kotlin",code:"jvmTest<Scope>"})])])]),a[51]||(a[51]=t('<p>사용 가능한 범위는 <code>Api</code>, <code>Implementation</code>, <code>CompileOnly</code>, <code>RuntimeOnly</code>입니다.</p><p><strong>언제부터 변경 사항이 적용되나요?</strong></p><p>Kotlin 1.8.0에서는 하드 코딩된 문자열에서 이전 구성 이름을 사용할 때 오류가 도입됩니다.</p><p>자세한 내용은 <a href="https://youtrack.jetbrains.com/issue/KT-35916/" target="_blank" rel="noreferrer">YouTrack의 해당 이슈</a>를 참조하세요.</p>',4))])}const j=k(g,[["render",y]]);export{A as __pageData,j as default};
