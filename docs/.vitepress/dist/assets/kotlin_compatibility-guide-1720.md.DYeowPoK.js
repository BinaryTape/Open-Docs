import{_ as e,c as a,o,ag as r}from"./chunks/framework.Bksy39di.js";const m=JSON.parse('{"title":"Kotlin 1.7.20 兼容性指南","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/compatibility-guide-1720.md","filePath":"kotlin/compatibility-guide-1720.md","lastUpdated":1754307826000}'),i={name:"kotlin/compatibility-guide-1720.md"};function l(n,t,s,p,c,d){return o(),a("div",null,t[0]||(t[0]=[r('<h1 id="kotlin-1-7-20-兼容性指南" tabindex="-1">Kotlin 1.7.20 兼容性指南 <a class="header-anchor" href="#kotlin-1-7-20-兼容性指南" aria-label="Permalink to &quot;Kotlin 1.7.20 兼容性指南&quot;">​</a></h1><p><em><a href="/kotlin/kotlin-evolution-principles">保持语言现代性</a></em> 和 <em><a href="/kotlin/kotlin-evolution-principles">舒适的更新</a></em> 是 Kotlin 语言设计中的基本原则之一。前者指出，阻碍语言演进的结构应该被移除，后者则表示这种移除应该事先充分沟通，以便使代码迁移尽可能顺畅。</p><p>通常，不兼容变更只发生在特性发布版本中，但这次我们必须在增量发布版本中引入两项此类变更，以限制 Kotlin 1.7 中变更所引入问题的蔓延。</p><p>本文总结了这些变更，为从 Kotlin 1.7.0 和 1.7.10 迁移到 Kotlin 1.7.20 提供参考。</p><h2 id="基本术语" tabindex="-1">基本术语 <a class="header-anchor" href="#基本术语" aria-label="Permalink to &quot;基本术语&quot;">​</a></h2><p>本文介绍了以下几种兼容性：</p><ul><li><em>源兼容性</em>：源不兼容变更会使原本可以正常编译（无错误或警告）的代码无法再编译。</li><li><em>二进制兼容性</em>：如果两个二进制 artifact 互换时不会导致加载或链接错误，则称它们是二进制兼容的。</li><li><em>行为兼容性</em>：如果同一程序在应用变更前后表现出不同的行为，则称该变更是行为不兼容的。</li></ul><p>请记住，这些定义仅针对纯 Kotlin 代码。从其他语言的角度（例如，从 Java）来看，Kotlin 代码的兼容性超出了本文档的范围。</p><h2 id="语言" tabindex="-1">语言 <a class="header-anchor" href="#语言" aria-label="Permalink to &quot;语言&quot;">​</a></h2><h3 id="回滚以修复正确的约束处理" tabindex="-1">回滚以修复正确的约束处理 <a class="header-anchor" href="#回滚以修复正确的约束处理" aria-label="Permalink to &quot;回滚以修复正确的约束处理&quot;">​</a></h3><blockquote><p><strong>问题</strong>：<a href="https://youtrack.jetbrains.com/issue/KT-53813" target="_blank" rel="noreferrer">KT-53813</a></p><p><strong>组件</strong>：核心语言</p><p><strong>不兼容变更类型</strong>：源</p><p><strong>简要概述</strong>：回滚修复类型推断约束处理中问题的尝试。这些问题是在实现 <a href="https://youtrack.jetbrains.com/issue/KT-52668" target="_blank" rel="noreferrer">KT-52668</a> 中描述的变更后在 1.7.0 中出现的。该尝试是在 1.7.10 中进行的，但它反过来又引入了新问题。</p><p><strong>弃用周期</strong>：</p><ul><li>1.7.20：回滚到 1.7.0 行为</li></ul></blockquote><h3 id="禁止某些构建器推断情况以避免与多个-lambda-表达式和解析产生问题交互" tabindex="-1">禁止某些构建器推断情况以避免与多个 lambda 表达式和解析产生问题交互 <a class="header-anchor" href="#禁止某些构建器推断情况以避免与多个-lambda-表达式和解析产生问题交互" aria-label="Permalink to &quot;禁止某些构建器推断情况以避免与多个 lambda 表达式和解析产生问题交互&quot;">​</a></h3><blockquote><p><strong>问题</strong>：<a href="https://youtrack.jetbrains.com/issue/KT-53797" target="_blank" rel="noreferrer">KT-53797</a></p><p><strong>组件</strong>：核心语言</p><p><strong>不兼容变更类型</strong>：源</p><p><strong>简要概述</strong>：Kotlin 1.7 引入了一项名为“不受限制的构建器推断”的特性，即使是传递给未用 <code>@BuilderInference</code> 注解的形参的 lambda 表达式也能从构建器推断中受益。然而，如果一个函数调用中出现多个此类 lambda 表达式，则可能导致几个问题。</p><p>如果存在多个 lambda 函数，其对应的形参未用 <code>@BuilderInference</code> 注解，并且需要使用构建器推断来完成该 lambda 表达式中的类型推断，则 Kotlin 1.7.20 将报告错误。</p><p><strong>弃用周期</strong>：</p><ul><li>1.7.20：对此类 lambda 函数报告错误，可以使用 <code>-XXLanguage:+NoBuilderInferenceWithoutAnnotationRestriction</code> 暂时恢复到 1.7.20 之前的行为</li></ul></blockquote>',13)]))}const h=e(i,[["render",l]]);export{m as __pageData,h as default};
