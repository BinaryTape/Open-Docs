import{_ as t,c as i,o as a,ag as o}from"./chunks/framework.Bksy39di.js";const m=JSON.parse('{"title":"简洁性","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/api-guidelines-simplicity.md","filePath":"kotlin/api-guidelines-simplicity.md","lastUpdated":1754307826000}'),r={name:"kotlin/api-guidelines-simplicity.md"};function l(n,e,p,s,c,d){return a(),i("div",null,e[0]||(e[0]=[o('<h1 id="简洁性" tabindex="-1">简洁性 <a class="header-anchor" href="#简洁性" aria-label="Permalink to &quot;简洁性&quot;">​</a></h1><p>用户需要理解的概念越少，这些概念的传达越显式，他们的心智模型就可能越简单。这可以通过限制 API 中的操作和抽象数量来实现。</p><p>确保库中声明的<a href="/kotlin/visibility-modifiers">可见性</a>设置适当，以使内部实现细节不暴露在公共 API 中。只有显式设计并为公共使用而文档化的 API 才应该对用户可访问。</p><p>在指南的下一部分，我们将讨论一些促进简洁性的指导原则。</p><h2 id="使用显式-api-模式" tabindex="-1">使用显式 API 模式 <a class="header-anchor" href="#使用显式-api-模式" aria-label="Permalink to &quot;使用显式 API 模式&quot;">​</a></h2><p>我们建议使用 Kotlin 编译器的<a href="/kotlin/whatsnew14#explicit-api-mode-for-library-authors">显式 API 模式</a>特性，它强制你在设计库的 API 时显式声明你的意图。</p><p>使用显式 API 模式时，你必须：</p><ul><li>为你的声明添加可见性修饰符使其公共化，而不是依赖默认的公共可见性。这确保你已经考虑过作为公共 API 一部分所暴露的内容。</li><li>定义所有公共函数和属性的类型，以防止推断类型对你的 API 造成意外更改。</li></ul><h2 id="复用现有概念" tabindex="-1">复用现有概念 <a class="header-anchor" href="#复用现有概念" aria-label="Permalink to &quot;复用现有概念&quot;">​</a></h2><p>限制 API 大小的一种方法是复用现有类型。例如，你可以使用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/" target="_blank" rel="noreferrer"><code>kotlin.time.Duration</code></a> 而不是为持续时间创建新类型。这种方法不仅简化了开发，还提高了与其他库的互操作性。</p><p>依赖第三方库或平台特有类型时请谨慎，因为它们可能将你的库与这些元素绑定。在这种情况下，成本可能大于收益。</p><p>复用 <code>String</code>、<code>Long</code>、<code>Pair</code> 和 <code>Triple</code> 等常见类型是有效的，但这不应该阻止你开发抽象数据类型，如果它们能更好地封装领域特有逻辑。</p><h2 id="定义并基于核心-api-构建" tabindex="-1">定义并基于核心 API 构建 <a class="header-anchor" href="#定义并基于核心-api-构建" aria-label="Permalink to &quot;定义并基于核心 API 构建&quot;">​</a></h2><p>实现简洁性的另一途径是定义一个基于有限核心操作集的微小概念模型。一旦这些操作的行为被清晰地文档化，你就可以通过开发直接基于或组合这些核心函数的新操作来扩展 API。</p><p>例如：</p><ul><li>在 <a href="/kotlin/flow">Kotlin Flows API</a> 中，<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/filter.html" target="_blank" rel="noreferrer"><code>filter</code></a> 和 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html" target="_blank" rel="noreferrer"><code>map</code></a> 等常见操作都是基于 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/transform.html" target="_blank" rel="noreferrer"><code>transform</code></a> 操作构建的。</li><li>在 <a href="/kotlin/time-measurement">Kotlin Time API</a> 中，<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/measure-time.html" target="_blank" rel="noreferrer"><code>measureTime</code></a> 函数利用了 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-time-source/-monotonic/" target="_blank" rel="noreferrer"><code>TimeSource.Monotonic</code></a>。</li></ul><p>尽管基于这些核心组件构建附加操作通常是有益的，但这并非总是必要的。你可能会发现机会引入优化过的或平台特有变体，以扩展功能或更广泛地适应不同的输入。</p><p>只要用户能够使用核心操作解决非平凡问题，并可以在不改变任何行为的情况下，用附加操作重构他们的解决方案，那么概念模型的简洁性就能得以保持。</p><h2 id="下一步" tabindex="-1">下一步 <a class="header-anchor" href="#下一步" aria-label="Permalink to &quot;下一步&quot;">​</a></h2><p>在指南的下一部分，你将学习可读性。</p><p><a href="/kotlin/api-guidelines-readability">继续阅读下一部分</a></p>',21)]))}const u=t(r,[["render",l]]);export{m as __pageData,u as default};
