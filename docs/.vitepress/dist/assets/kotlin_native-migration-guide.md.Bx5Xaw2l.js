import{_ as s,C as n,c as f,o as h,ag as i,G as a,w as l,j as e,a as r}from"./chunks/framework.Bksy39di.js";const T=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/native-migration-guide.md","filePath":"kotlin/native-migration-guide.md","lastUpdated":1754307826000}'),p={name:"kotlin/native-migration-guide.md"};function u(k,t,g,m,b,v){const d=n("list"),o=n("def"),c=n("deflist");return h(),f("div",null,[t[5]||(t[5]=i('<h1 id="迁移到新的内存管理器" tabindex="-1">迁移到新的内存管理器 <a class="header-anchor" href="#迁移到新的内存管理器" aria-label="Permalink to &quot;迁移到新的内存管理器&quot;">​</a></h1><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Kotlin 1.9.20 已完全移除对旧内存管理器的支持。请将项目迁移到当前内存模型，该模型自 Kotlin 1.7.20 起默认启用。</p></div><p>本指南将比较新的 <a href="/kotlin/native-memory-manager">Kotlin/Native 内存管理器</a>与旧内存管理器，并描述如何迁移项目。</p><p>新内存管理器中最显著的变化是取消了对象共享的限制。你不再需要冻结对象即可在线程间共享它们，具体而言：</p><ul><li>顶层属性可由任何线程访问和修改，无需使用 <code>@SharedImmutable</code>。</li><li>通过互操作（interop）传递的对象可由任何线程访问和修改，无需冻结。</li><li><code>Worker.executeAfter</code> 不再要求操作被冻结。</li><li><code>Worker.execute</code> 不再要求生产者返回隔离的对象子图。</li><li>包含 <code>AtomicReference</code> 和 <code>FreezableAtomicReference</code> 的引用循环不会导致内存泄漏。</li></ul><p>除了轻松的对象共享，新内存管理器还带来了其他主要变化：</p><ul><li>全局属性在首次访问定义它们的文件时惰性初始化。以前，全局属性在程序启动时初始化。作为一种变通方法，你可以使用 <code>@EagerInitialization</code> 注解标记那些必须在程序启动时初始化的属性。使用前，请查阅其<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native/-eager-initialization/" target="_blank" rel="noreferrer">文档</a>。</li><li><code>by lazy {}</code> 属性支持线程安全模式，但不处理无界递归。</li><li><code>Worker.executeAfter</code> 中逃逸出 <code>operation</code> 的异常，像在其他运行时部分一样处理，即尝试执行用户定义的未处理异常钩子；如果未找到钩子或钩子本身执行失败并抛出异常，则终止程序。</li><li>冻结已弃用，并且始终禁用。</li></ul><p>请遵循以下指南，将项目从旧内存管理器迁移过来：</p><h2 id="更新-kotlin" tabindex="-1">更新 Kotlin <a class="header-anchor" href="#更新-kotlin" aria-label="Permalink to &quot;更新 Kotlin&quot;">​</a></h2><p>新的 Kotlin/Native 内存管理器自 Kotlin 1.7.20 起默认启用。检查 Kotlin 版本，如有必要，请<a href="/kotlin/releases#update-to-a-new-kotlin-version">更新到最新版本</a>。</p><h2 id="更新依赖项" tabindex="-1">更新依赖项 <a class="header-anchor" href="#更新依赖项" aria-label="Permalink to &quot;更新依赖项&quot;">​</a></h2>',11)),a(c,{style:{}},{default:l(()=>[a(o,{title:"kotlinx.coroutines"},{default:l(()=>[t[1]||(t[1]=e("p",null,[r("更新到 1.6.0 或更高版本。请勿使用带有 "),e("code",null,"native-mt"),r(" 后缀的版本。")],-1)),t[2]||(t[2]=e("p",null,"新的内存管理器还有一些需要注意的特殊之处：",-1)),a(d,null,{default:l(()=>t[0]||(t[0]=[e("li",null,"所有常见的原语（channels、flows、coroutines）都可以跨越 Worker 边界工作，因为不再需要冻结。",-1),e("li",null,[e("code",null,"Dispatchers.Default"),r(" 在 Linux 和 Windows 上由 Worker 池提供支持，在 Apple 目标平台 (target) 上由全局队列提供支持。")],-1),e("li",null,[r("使用 "),e("code",null,"newSingleThreadContext"),r(" 创建由 Worker 支持的协程调度器。")],-1),e("li",null,[r("使用 "),e("code",null,"newFixedThreadPoolContext"),r(" 创建由 "),e("code",null,"N"),r(" 个 Worker 池支持的协程调度器。")],-1),e("li",null,[e("code",null,"Dispatchers.Main"),r(" 在 Darwin 上由主队列提供支持，在其他平台由独立的 Worker 提供支持。")],-1)])),_:1})]),_:1}),a(o,{title:"Ktor"},{default:l(()=>t[3]||(t[3]=[r(" 更新到 2.0 或更高版本。 ")])),_:1}),a(o,{title:"其他依赖项"},{default:l(()=>t[4]||(t[4]=[e("p",null,"大多数库无需任何更改即可工作，但可能存在例外。",-1),e("p",null,"请确保将依赖项更新到最新版本，并且旧内存管理器和新内存管理器的库版本之间没有差异。",-1)])),_:1})]),_:1}),t[6]||(t[6]=i('<h2 id="更新代码" tabindex="-1">更新代码 <a class="header-anchor" href="#更新代码" aria-label="Permalink to &quot;更新代码&quot;">​</a></h2><p>为了支持新的内存管理器，请移除受影响的 API 用法：</p><table tabindex="0"><thead><tr><th>旧 API</th><th>操作</th></tr></thead><tbody><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-shared-immutable/" target="_blank" rel="noreferrer"><code>@SharedImmutable</code></a></td><td>你可以移除所有用法，尽管在新内存管理器中使用此 API 不会有警告。</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-freezable-atomic-reference/" target="_blank" rel="noreferrer">The <code>FreezableAtomicReference</code> class</a></td><td>请改用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-atomic-reference/" target="_blank" rel="noreferrer"><code>AtomicReference</code></a>。</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-freezing-exception/" target="_blank" rel="noreferrer">The <code>FreezingException</code> class</a></td><td>移除所有用法。</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-invalid-mutability-exception/" target="_blank" rel="noreferrer">The <code>InvalidMutabilityException</code> class</a></td><td>移除所有用法。</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native/-incorrect-dereference-exception/" target="_blank" rel="noreferrer">The <code>IncorrectDereferenceException</code> class</a></td><td>移除所有用法。</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/freeze.html" target="_blank" rel="noreferrer">The <code>freeze()</code> function</a></td><td>移除所有用法。</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/is-frozen.html" target="_blank" rel="noreferrer">The <code>isFrozen</code> property</a></td><td>你可以移除所有用法。由于冻结已弃用，此属性始终返回 <code>false</code>。</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/ensure-never-frozen.html" target="_blank" rel="noreferrer">The <code>ensureNeverFrozen()</code> function</a></td><td>移除所有用法。</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/atomic-lazy.html" target="_blank" rel="noreferrer">The <code>atomicLazy()</code> function</a></td><td>请改用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html" target="_blank" rel="noreferrer"><code>lazy()</code></a>。</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-mutable-data/" target="_blank" rel="noreferrer">The <code>MutableData</code> class</a></td><td>请改用任何常规集合。</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-worker-bound-reference/" target="_blank" rel="noreferrer">The <code>WorkerBoundReference&lt;out T : Any&gt;</code> class</a></td><td>直接使用 <code>T</code>。</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-detached-object-graph/" target="_blank" rel="noreferrer">The <code>DetachedObjectGraph&lt;T&gt;</code> class</a></td><td>直接使用 <code>T</code>。要通过 C 互操作（interop）传递值，请使用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlinx.cinterop/-stable-ref/" target="_blank" rel="noreferrer">StableRef 类</a>。</td></tr></tbody></table><h2 id="接下来" tabindex="-1">接下来 <a class="header-anchor" href="#接下来" aria-label="Permalink to &quot;接下来&quot;">​</a></h2><ul><li><a href="/kotlin/native-memory-manager">了解更多关于新内存管理器</a></li><li><a href="/kotlin/native-arc-integration">检查与 Swift/Objective-C ARC 集成的具体细节</a></li><li><a href="/kotlin/native-faq#how-do-i-reference-objects-safely-from-different-coroutines">了解如何在不同协程中安全地引用对象</a></li></ul>',5))])}const x=s(p,[["render",u]]);export{T as __pageData,x as default};
