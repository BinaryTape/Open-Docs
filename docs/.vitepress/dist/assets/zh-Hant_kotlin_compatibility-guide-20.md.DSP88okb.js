import{_ as o,c as t,o as r,ag as a}from"./chunks/framework.Bksy39di.js";const h=JSON.parse('{"title":"Kotlin 2.0 兼容性指南","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/compatibility-guide-20.md","filePath":"zh-Hant/kotlin/compatibility-guide-20.md","lastUpdated":1754307826000}'),n={name:"zh-Hant/kotlin/compatibility-guide-20.md"};function l(s,e,c,p,i,g){return r(),t("div",null,e[0]||(e[0]=[a('<h1 id="kotlin-2-0-兼容性指南" tabindex="-1">Kotlin 2.0 兼容性指南 <a class="header-anchor" href="#kotlin-2-0-兼容性指南" aria-label="Permalink to &quot;Kotlin 2.0 兼容性指南&quot;">​</a></h1><p><em>讓語言保持現代化 (Keeping the Language Modern)</em> 和 <em>舒適的更新 (Comfortable Updates)</em> 是 Kotlin 語言設計中的基本原則。前者指出阻礙語言演進的結構應被移除，後者則要求此類移除應事先充分溝通，以使程式碼遷移盡可能順暢。</p><p>儘管大多數語言變更已透過其他管道（例如更新的變更日誌或編譯器警告）發布，但本文件提供了一份從 Kotlin 1.9 遷移至 Kotlin 2.0 的完整參考。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Kotlin K2 編譯器作為 Kotlin 2.0 的一部分被引入。有關新編譯器的好處、遷移過程中可能遇到的變更以及如何回溯到舊版編譯器的資訊，請參閱 <a href="/zh-Hant/kotlin/k2-compiler-migration-guide">K2 編譯器遷移指南</a>。</p></div><h2 id="基本術語" tabindex="-1">基本術語 <a class="header-anchor" href="#基本術語" aria-label="Permalink to &quot;基本術語&quot;">​</a></h2><p>在本文件中，我們介紹了幾種兼容性：</p><ul><li><em>源 (source)</em>：源不兼容變更會導致原本能正常編譯（無錯誤或警告）的程式碼不再編譯。</li><li><em>二進制 (binary)</em>：如果兩個二進制工件在互換後不會導致加載或連結錯誤，則稱它們為二進制兼容。</li><li><em>行為 (behavioral)</em>：如果同一程式在應用變更前後展現出不同的行為，則稱該變更為行為不兼容。</li></ul><p>請記住，這些定義僅適用於純 Kotlin。從其他語言角度（例如，從 Java）來看的 Kotlin 程式碼兼容性不在本文檔的範圍內。</p><h2 id="語言" tabindex="-1">語言 <a class="header-anchor" href="#語言" aria-label="Permalink to &quot;語言&quot;">​</a></h2><h3 id="棄用對投射接收者使用合成設定器" tabindex="-1">棄用對投射接收者使用合成設定器 <a class="header-anchor" href="#棄用對投射接收者使用合成設定器" aria-label="Permalink to &quot;棄用對投射接收者使用合成設定器&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-54309" target="_blank" rel="noreferrer">KT-54309</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 如果您使用 Java 類別的合成設定器來賦值一個與該類別的投射類型衝突的類型，將觸發錯誤。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.8.20: 當合成屬性設定器在逆變位置具有投射參數類型，導致呼叫點引數類型不兼容時，報告警告。</li><li>2.0.0: 將警告提升為錯誤。</li></ul></blockquote><h3 id="在-java-子類中重載的函式-當呼叫帶有內聯類別參數的函式時-修正名稱修飾" tabindex="-1">在 Java 子類中重載的函式，當呼叫帶有內聯類別參數的函式時，修正名稱修飾 <a class="header-anchor" href="#在-java-子類中重載的函式-當呼叫帶有內聯類別參數的函式時-修正名稱修飾" aria-label="Permalink to &quot;在 Java 子類中重載的函式，當呼叫帶有內聯類別參數的函式時，修正名稱修飾&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-56545" target="_blank" rel="noreferrer">KT-56545</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: behavioral</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 在函式調用中使用正確的名稱修飾行為；要恢復到之前的行為，請使用 <code>-XXLanguage:-MangleCallsToJavaMethodsWithValueClasses</code> 編譯器選項。</li></ul></blockquote><h3 id="修正逆變捕獲類型的類型近似演算法" tabindex="-1">修正逆變捕獲類型的類型近似演算法 <a class="header-anchor" href="#修正逆變捕獲類型的類型近似演算法" aria-label="Permalink to &quot;修正逆變捕獲類型的類型近似演算法&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-49404" target="_blank" rel="noreferrer">KT-49404</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.8.20: 對有問題的呼叫報告警告。</li><li>2.0.0: 將警告提升為錯誤。</li></ul></blockquote><h3 id="禁止在屬性初始化前存取屬性值" tabindex="-1">禁止在屬性初始化前存取屬性值 <a class="header-anchor" href="#禁止在屬性初始化前存取屬性值" aria-label="Permalink to &quot;禁止在屬性初始化前存取屬性值&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-56408" target="_blank" rel="noreferrer">KT-56408</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 當屬性在受影響的上下文中初始化前被存取時，報告錯誤。</li></ul></blockquote><h3 id="報告導入類別中名稱相同時的歧義錯誤" tabindex="-1">報告導入類別中名稱相同時的歧義錯誤 <a class="header-anchor" href="#報告導入類別中名稱相同時的歧義錯誤" aria-label="Permalink to &quot;報告導入類別中名稱相同時的歧義錯誤&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-57750" target="_blank" rel="noreferrer">KT-57750</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 當解析一個在多個通過星號導入的套件中存在的類別名稱時，報告錯誤。</li></ul></blockquote><h3 id="預設透過-invokedynamic-和-lambdametafactory-生成-kotlin-lambda-表達式" tabindex="-1">預設透過 invokedynamic 和 LambdaMetafactory 生成 Kotlin lambda 表達式 <a class="header-anchor" href="#預設透過-invokedynamic-和-lambdametafactory-生成-kotlin-lambda-表達式" aria-label="Permalink to &quot;預設透過 invokedynamic 和 LambdaMetafactory 生成 Kotlin lambda 表達式&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-45375" target="_blank" rel="noreferrer">KT-45375</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: behavioral</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 實施新行為；lambda 表達式預設使用 <code>invokedynamic</code> 和 <code>LambdaMetafactory</code> 生成。</li></ul></blockquote><h3 id="當需要表達式時-禁止-if-條件只有一個分支" tabindex="-1">當需要表達式時，禁止 if 條件只有一個分支 <a class="header-anchor" href="#當需要表達式時-禁止-if-條件只有一個分支" aria-label="Permalink to &quot;當需要表達式時，禁止 if 條件只有一個分支&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-57871" target="_blank" rel="noreferrer">KT-57871</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 在 <code>if</code> 條件只有一個分支的情況下報告錯誤。</li></ul></blockquote><h3 id="禁止透過傳遞泛型類型的星號投射來違反自身上界" tabindex="-1">禁止透過傳遞泛型類型的星號投射來違反自身上界 <a class="header-anchor" href="#禁止透過傳遞泛型類型的星號投射來違反自身上界" aria-label="Permalink to &quot;禁止透過傳遞泛型類型的星號投射來違反自身上界&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-61718" target="_blank" rel="noreferrer">KT-61718</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 當透過傳遞泛型類型的星號投射違反自身上界時，報告錯誤。</li></ul></blockquote><h3 id="近似私有內聯函式返回類型中的匿名類型" tabindex="-1">近似私有內聯函式返回類型中的匿名類型 <a class="header-anchor" href="#近似私有內聯函式返回類型中的匿名類型" aria-label="Permalink to &quot;近似私有內聯函式返回類型中的匿名類型&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-54862" target="_blank" rel="noreferrer">KT-54862</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.9.0: 當推斷的返回類型包含匿名類型時，對私有內聯函式報告警告。</li><li>2.0.0: 將此類私有內聯函式的返回類型近似為超類型。</li></ul></blockquote><h3 id="變更重載解析行為-優先考慮局部擴展函式呼叫而非局部函式類型屬性的調用慣例" tabindex="-1">變更重載解析行為，優先考慮局部擴展函式呼叫而非局部函式類型屬性的調用慣例 <a class="header-anchor" href="#變更重載解析行為-優先考慮局部擴展函式呼叫而非局部函式類型屬性的調用慣例" aria-label="Permalink to &quot;變更重載解析行為，優先考慮局部擴展函式呼叫而非局部函式類型屬性的調用慣例&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-37592" target="_blank" rel="noreferrer">KT-37592</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: behavioral</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 新的重載解析行為；函式呼叫始終優先於調用慣例。</li></ul></blockquote><h3 id="當由於二進制依賴中的超類型變更而導致繼承成員衝突時-報告錯誤" tabindex="-1">當由於二進制依賴中的超類型變更而導致繼承成員衝突時，報告錯誤 <a class="header-anchor" href="#當由於二進制依賴中的超類型變更而導致繼承成員衝突時-報告錯誤" aria-label="Permalink to &quot;當由於二進制依賴中的超類型變更而導致繼承成員衝突時，報告錯誤&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-51194" target="_blank" rel="noreferrer">KT-51194</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.0: 當二進制依賴中的超類型發生繼承成員衝突時，對聲明報告警告 CONFLICTING_INHERITED_MEMBERS_WARNING。</li><li>2.0.0: 將警告提升為錯誤：CONFLICTING_INHERITED_MEMBERS。</li></ul></blockquote><h3 id="忽略不變類型中參數上的-unsafevariance-註解" tabindex="-1">忽略不變類型中參數上的 @UnsafeVariance 註解 <a class="header-anchor" href="#忽略不變類型中參數上的-unsafevariance-註解" aria-label="Permalink to &quot;忽略不變類型中參數上的 @UnsafeVariance 註解&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-57609" target="_blank" rel="noreferrer">KT-57609</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 實施新行為；當報告逆變參數中類型不匹配的錯誤時，<code>@UnsafeVariance</code> 註解將被忽略。</li></ul></blockquote><h3 id="變更伴隨物件成員的外部呼叫引用的類型" tabindex="-1">變更伴隨物件成員的外部呼叫引用的類型 <a class="header-anchor" href="#變更伴隨物件成員的外部呼叫引用的類型" aria-label="Permalink to &quot;變更伴隨物件成員的外部呼叫引用的類型&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-54316" target="_blank" rel="noreferrer">KT-54316</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.8.20: 當伴隨物件函式引用類型被推斷為未綁定引用時，報告警告。</li><li>2.0.0: 變更行為，使伴隨物件函式引用在所有使用上下文中被推斷為綁定引用。</li></ul></blockquote><h3 id="禁止從私有內聯函式暴露匿名類型" tabindex="-1">禁止從私有內聯函式暴露匿名類型 <a class="header-anchor" href="#禁止從私有內聯函式暴露匿名類型" aria-label="Permalink to &quot;禁止從私有內聯函式暴露匿名類型&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-33917" target="_blank" rel="noreferrer">KT-33917</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.3.0: 對於從私有內聯函式返回的匿名物件的自身成員呼叫報告警告。</li><li>2.0.0: 將此類私有內聯函式的返回類型近似為超類型，且不解析對匿名物件成員的呼叫。</li></ul></blockquote><h3 id="在-while-循環中斷後-對不健全的智能轉換報告錯誤" tabindex="-1">在 while 循環中斷後，對不健全的智能轉換報告錯誤 <a class="header-anchor" href="#在-while-循環中斷後-對不健全的智能轉換報告錯誤" aria-label="Permalink to &quot;在 while 循環中斷後，對不健全的智能轉換報告錯誤&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-22379" target="_blank" rel="noreferrer">KT-22379</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 實施新行為；舊行為可以透過切換到語言版本 1.9 來恢復。</li></ul></blockquote><h3 id="當交集類型的變數被賦予的值不是該交集類型的子類型時-報告錯誤" tabindex="-1">當交集類型的變數被賦予的值不是該交集類型的子類型時，報告錯誤 <a class="header-anchor" href="#當交集類型的變數被賦予的值不是該交集類型的子類型時-報告錯誤" aria-label="Permalink to &quot;當交集類型的變數被賦予的值不是該交集類型的子類型時，報告錯誤&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-53752" target="_blank" rel="noreferrer">KT-53752</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 當具有交集類型的變數被賦予的值不是該交集類型的子類型時，報告錯誤。</li></ul></blockquote><h3 id="當透過-sam-構造函數構建的介面包含需要選擇啟用的方法時-要求選擇啟用" tabindex="-1">當透過 SAM 構造函數構建的介面包含需要選擇啟用的方法時，要求選擇啟用 <a class="header-anchor" href="#當透過-sam-構造函數構建的介面包含需要選擇啟用的方法時-要求選擇啟用" aria-label="Permalink to &quot;當透過 SAM 構造函數構建的介面包含需要選擇啟用的方法時，要求選擇啟用&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-52628" target="_blank" rel="noreferrer">KT-52628</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.20: 對於透過 SAM 構造函數使用 <code>OptIn</code> 的情況報告警告。</li><li>2.0.0: 對於透過 SAM 構造函數使用 <code>OptIn</code> 的情況，將警告提升為錯誤（如果 <code>OptIn</code> 標記嚴重性為警告，則保持報告警告）。</li></ul></blockquote><h3 id="禁止類型別名構造函數中的上界違反" tabindex="-1">禁止類型別名構造函數中的上界違反 <a class="header-anchor" href="#禁止類型別名構造函數中的上界違反" aria-label="Permalink to &quot;禁止類型別名構造函數中的上界違反&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-54066" target="_blank" rel="noreferrer">KT-54066</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.8.0: 對於類型別名構造函數中違反上界的情況引入警告。</li><li>2.0.0: 在 K2 編譯器中將警告提升為錯誤。</li></ul></blockquote><h3 id="使解構變數的實際類型與指定時的顯式類型保持一致" tabindex="-1">使解構變數的實際類型與指定時的顯式類型保持一致 <a class="header-anchor" href="#使解構變數的實際類型與指定時的顯式類型保持一致" aria-label="Permalink to &quot;使解構變數的實際類型與指定時的顯式類型保持一致&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-57011" target="_blank" rel="noreferrer">KT-57011</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 實施新行為；當指定時，解構變數的實際類型現在與顯式類型保持一致。</li></ul></blockquote><h3 id="當呼叫的構造函數具有需要選擇啟用的預設值參數類型時-要求選擇啟用" tabindex="-1">當呼叫的構造函數具有需要選擇啟用的預設值參數類型時，要求選擇啟用 <a class="header-anchor" href="#當呼叫的構造函數具有需要選擇啟用的預設值參數類型時-要求選擇啟用" aria-label="Permalink to &quot;當呼叫的構造函數具有需要選擇啟用的預設值參數類型時，要求選擇啟用&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-55111" target="_blank" rel="noreferrer">KT-55111</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.8.20: 對於具有需要選擇啟用參數類型的構造函數呼叫報告警告。</li><li>2.0.0: 將警告提升為錯誤（如果 <code>OptIn</code> 標記嚴重性為警告，則保持報告警告）。</li></ul></blockquote><h3 id="在相同作用域級別下-當屬性和列舉條目同名時-報告歧義錯誤" tabindex="-1">在相同作用域級別下，當屬性和列舉條目同名時，報告歧義錯誤 <a class="header-anchor" href="#在相同作用域級別下-當屬性和列舉條目同名時-報告歧義錯誤" aria-label="Permalink to &quot;在相同作用域級別下，當屬性和列舉條目同名時，報告歧義錯誤&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-52802" target="_blank" rel="noreferrer">KT-52802</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.20: 當編譯器解析到屬性而非相同作用域級別的列舉條目時，報告警告。</li><li>2.0.0: 在 K2 編譯器中，當編譯器在相同作用域級別遇到同名的屬性和列舉條目時，報告歧義（在舊版編譯器中保持警告不變）。</li></ul></blockquote><h3 id="變更限定符解析行為-優先選擇伴隨屬性而非列舉條目" tabindex="-1">變更限定符解析行為，優先選擇伴隨屬性而非列舉條目 <a class="header-anchor" href="#變更限定符解析行為-優先選擇伴隨屬性而非列舉條目" aria-label="Permalink to &quot;變更限定符解析行為，優先選擇伴隨屬性而非列舉條目&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-47310" target="_blank" rel="noreferrer">KT-47310</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 實施新的解析行為；伴隨屬性優先於列舉條目。</li></ul></blockquote><h3 id="解析調用接收者類型和調用函式類型-如同它們以去糖化形式編寫一樣" tabindex="-1">解析調用接收者類型和調用函式類型，如同它們以去糖化形式編寫一樣 <a class="header-anchor" href="#解析調用接收者類型和調用函式類型-如同它們以去糖化形式編寫一樣" aria-label="Permalink to &quot;解析調用接收者類型和調用函式類型，如同它們以去糖化形式編寫一樣&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-58260" target="_blank" rel="noreferrer">KT-58260</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 獨立解析調用呼叫接收者類型和調用函式類型，如同它們以去糖化形式編寫一樣。</li></ul></blockquote><h3 id="禁止透過非私有內聯函式暴露私有類別成員" tabindex="-1">禁止透過非私有內聯函式暴露私有類別成員 <a class="header-anchor" href="#禁止透過非私有內聯函式暴露私有類別成員" aria-label="Permalink to &quot;禁止透過非私有內聯函式暴露私有類別成員&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-55179" target="_blank" rel="noreferrer">KT-55179</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.9.0: 當從內部內聯函式呼叫私有類別伴隨物件成員時，報告 <code>PRIVATE_CLASS_MEMBER_FROM_INLINE_WARNING</code> 警告。</li><li>2.0.0: 將此警告提升為 <code>PRIVATE_CLASS_MEMBER_FROM_INLINE</code> 錯誤。</li></ul></blockquote><h3 id="修正投射泛型類型中確定非空類型的可空性" tabindex="-1">修正投射泛型類型中確定非空類型的可空性 <a class="header-anchor" href="#修正投射泛型類型中確定非空類型的可空性" aria-label="Permalink to &quot;修正投射泛型類型中確定非空類型的可空性&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-54663" target="_blank" rel="noreferrer">KT-54663</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 實施新行為；投射類型將考慮所有就地非空類型。</li></ul></blockquote><h3 id="變更前綴遞增的推斷類型-使其與-getter-的返回類型匹配-而非-inc-運算子的返回類型" tabindex="-1">變更前綴遞增的推斷類型，使其與 getter 的返回類型匹配，而非 <code>inc()</code> 運算子的返回類型 <a class="header-anchor" href="#變更前綴遞增的推斷類型-使其與-getter-的返回類型匹配-而非-inc-運算子的返回類型" aria-label="Permalink to &quot;變更前綴遞增的推斷類型，使其與 getter 的返回類型匹配，而非 `inc()` 運算子的返回類型&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-57178" target="_blank" rel="noreferrer">KT-57178</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 實施新行為；前綴遞增的推斷類型已變更為匹配 getter 的返回類型，而非 <code>inc()</code> 運算子的返回類型。</li></ul></blockquote><h3 id="繼承超類中聲明的泛型內部類別時-強制執行邊界檢查" tabindex="-1">繼承超類中聲明的泛型內部類別時，強制執行邊界檢查 <a class="header-anchor" href="#繼承超類中聲明的泛型內部類別時-強制執行邊界檢查" aria-label="Permalink to &quot;繼承超類中聲明的泛型內部類別時，強制執行邊界檢查&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-61749" target="_blank" rel="noreferrer">KT-61749</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 當違反泛型內部超類別的類型參數上界時，報告錯誤。</li></ul></blockquote><h3 id="禁止將帶有-sam-類型的可呼叫引用賦值給預期類型為帶有函式類型參數的函式類型" tabindex="-1">禁止將帶有 SAM 類型的可呼叫引用賦值給預期類型為帶有函式類型參數的函式類型 <a class="header-anchor" href="#禁止將帶有-sam-類型的可呼叫引用賦值給預期類型為帶有函式類型參數的函式類型" aria-label="Permalink to &quot;禁止將帶有 SAM 類型的可呼叫引用賦值給預期類型為帶有函式類型參數的函式類型&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-64342" target="_blank" rel="noreferrer">KT-64342</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 當帶有 SAM 類型的可呼叫引用，而預期類型為帶有函式類型參數的函式類型時，報告編譯錯誤。</li></ul></blockquote><h3 id="在伴隨物件上的註解解析中考慮伴隨物件作用域" tabindex="-1">在伴隨物件上的註解解析中考慮伴隨物件作用域 <a class="header-anchor" href="#在伴隨物件上的註解解析中考慮伴隨物件作用域" aria-label="Permalink to &quot;在伴隨物件上的註解解析中考慮伴隨物件作用域&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-64299" target="_blank" rel="noreferrer">KT-64299</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: behavioral</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 實施新行為；在伴隨物件上的註解解析期間，伴隨物件作用域將不再被忽略。</li></ul></blockquote><h3 id="變更安全呼叫和慣例運算子組合的求值語義" tabindex="-1">變更安全呼叫和慣例運算子組合的求值語義 <a class="header-anchor" href="#變更安全呼叫和慣例運算子組合的求值語義" aria-label="Permalink to &quot;變更安全呼叫和慣例運算子組合的求值語義&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-41034" target="_blank" rel="noreferrer">KT-41034</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: behavioral</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.4.0: 對每個不正確的呼叫報告警告。</li><li>2.0.0: 實施新的解析行為。</li></ul></blockquote><h3 id="要求帶有支持欄位和自定義設定器的屬性立即初始化" tabindex="-1">要求帶有支持欄位和自定義設定器的屬性立即初始化 <a class="header-anchor" href="#要求帶有支持欄位和自定義設定器的屬性立即初始化" aria-label="Permalink to &quot;要求帶有支持欄位和自定義設定器的屬性立即初始化&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-58589" target="_blank" rel="noreferrer">KT-58589</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: behavioral</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.9.20: 對於沒有主構造函數的情況引入 <code>MUST_BE_INITIALIZED</code> 警告。</li><li>2.0.0: 將警告提升為錯誤。</li></ul></blockquote><h3 id="禁止在調用運算子慣例呼叫中對任意表達式進行-unit-轉換" tabindex="-1">禁止在調用運算子慣例呼叫中對任意表達式進行 Unit 轉換 <a class="header-anchor" href="#禁止在調用運算子慣例呼叫中對任意表達式進行-unit-轉換" aria-label="Permalink to &quot;禁止在調用運算子慣例呼叫中對任意表達式進行 Unit 轉換&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-61182" target="_blank" rel="noreferrer">KT-61182</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: behavioral</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 當 Unit 轉換應用於變數和調用解析中的任意表達式時，報告錯誤；使用 <code>-XXLanguage:+UnitConversionsOnArbitraryExpressions</code> 編譯器選項可保留受影響表達式的先前行為。</li></ul></blockquote><h3 id="禁止在安全呼叫存取-java-欄位時-將可空值賦值給非空-java-欄位" tabindex="-1">禁止在安全呼叫存取 Java 欄位時，將可空值賦值給非空 Java 欄位 <a class="header-anchor" href="#禁止在安全呼叫存取-java-欄位時-將可空值賦值給非空-java-欄位" aria-label="Permalink to &quot;禁止在安全呼叫存取 Java 欄位時，將可空值賦值給非空 Java 欄位&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-62998" target="_blank" rel="noreferrer">KT-62998</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 當將可空值賦值給非空 Java 欄位時，報告錯誤。</li></ul></blockquote><h3 id="覆寫包含原始類型參數的-java-方法時-要求星號投射類型" tabindex="-1">覆寫包含原始類型參數的 Java 方法時，要求星號投射類型 <a class="header-anchor" href="#覆寫包含原始類型參數的-java-方法時-要求星號投射類型" aria-label="Permalink to &quot;覆寫包含原始類型參數的 Java 方法時，要求星號投射類型&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-57600" target="_blank" rel="noreferrer">KT-57600</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 實施新行為；對於原始類型參數禁止覆寫。</li></ul></blockquote><h3 id="變更-v-foo-引用解析-當-v-具有伴隨物件時" tabindex="-1">變更 (V)::foo 引用解析，當 V 具有伴隨物件時 <a class="header-anchor" href="#變更-v-foo-引用解析-當-v-具有伴隨物件時" aria-label="Permalink to &quot;變更 (V)::foo 引用解析，當 V 具有伴隨物件時&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-47313" target="_blank" rel="noreferrer">KT-47313</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: behavioral</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.0: 對於目前綁定到伴隨物件實例的可呼叫引用報告警告。</li><li>2.0.0: 實施新行為；在類型周圍添加圓括號不再使其成為該類型伴隨物件實例的引用。</li></ul></blockquote><h3 id="禁止在實際上的公共內聯函式中隱式存取非公共-api" tabindex="-1">禁止在實際上的公共內聯函式中隱式存取非公共 API <a class="header-anchor" href="#禁止在實際上的公共內聯函式中隱式存取非公共-api" aria-label="Permalink to &quot;禁止在實際上的公共內聯函式中隱式存取非公共 API&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-54997" target="_blank" rel="noreferrer">KT-54997</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.8.20: 當在公共內聯函式中隱式存取非公共 API 時，報告編譯警告。</li><li>2.0.0: 將警告提升為錯誤。</li></ul></blockquote><h3 id="禁止在屬性-getter-上使用點-get-註解" tabindex="-1">禁止在屬性 getter 上使用點 get 註解 <a class="header-anchor" href="#禁止在屬性-getter-上使用點-get-註解" aria-label="Permalink to &quot;禁止在屬性 getter 上使用點 get 註解&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-57422" target="_blank" rel="noreferrer">KT-57422</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.9.0: 在 getter 上使用點 <code>get</code> 註解時報告警告（在漸進模式下為錯誤）。</li><li>2.0.0: 將警告提升為 <code>INAPPLICABLE_TARGET_ON_PROPERTY</code> 錯誤；使用 <code>-XXLanguage:-ProhibitUseSiteGetTargetAnnotations</code> 可恢復為警告。</li></ul></blockquote><h3 id="防止在構建器推斷-lambda-函式中將類型參數隱式推斷為上界" tabindex="-1">防止在構建器推斷 lambda 函式中將類型參數隱式推斷為上界 <a class="header-anchor" href="#防止在構建器推斷-lambda-函式中將類型參數隱式推斷為上界" aria-label="Permalink to &quot;防止在構建器推斷 lambda 函式中將類型參數隱式推斷為上界&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-47986" target="_blank" rel="noreferrer">KT-47986</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.20: 當類型引數的類型參數無法推斷為聲明的上界時，報告警告（或在漸進模式下為錯誤）。</li><li>2.0.0: 將警告提升為錯誤。</li></ul></blockquote><h3 id="在公共簽名中近似局部類型時保持可空性" tabindex="-1">在公共簽名中近似局部類型時保持可空性 <a class="header-anchor" href="#在公共簽名中近似局部類型時保持可空性" aria-label="Permalink to &quot;在公共簽名中近似局部類型時保持可空性&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-53982" target="_blank" rel="noreferrer">KT-53982</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.8.0: 彈性類型由彈性超類型近似；當聲明被推斷為非空類型但應為可空類型時，報告警告，提示明確指定類型以避免 NPEs。</li><li>2.0.0: 可空類型由可空超類型近似。</li></ul></blockquote><h3 id="移除-false-和-false-在智能轉換目的中的特殊處理" tabindex="-1">移除 <code>false &amp;&amp; ...</code> 和 <code>false || ...</code> 在智能轉換目的中的特殊處理 <a class="header-anchor" href="#移除-false-和-false-在智能轉換目的中的特殊處理" aria-label="Permalink to &quot;移除 `false &amp;&amp; ...` 和 `false || ...` 在智能轉換目的中的特殊處理&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-65776" target="_blank" rel="noreferrer">KT-65776</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 實施新行為；對 <code>false &amp;&amp; ...</code> 和 <code>false || ...</code> 沒有特殊處理。</li></ul></blockquote><h3 id="禁止列舉中的內聯開放函式" tabindex="-1">禁止列舉中的內聯開放函式 <a class="header-anchor" href="#禁止列舉中的內聯開放函式" aria-label="Permalink to &quot;禁止列舉中的內聯開放函式&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-34372" target="_blank" rel="noreferrer">KT-34372</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.8.0: 對列舉中的內聯開放函式報告警告。</li><li>2.0.0: 將警告提升為錯誤。</li></ul></blockquote><h2 id="工具" tabindex="-1">工具 <a class="header-anchor" href="#工具" aria-label="Permalink to &quot;工具&quot;">​</a></h2><h3 id="gradle-中的可見性變更" tabindex="-1">Gradle 中的可見性變更 <a class="header-anchor" href="#gradle-中的可見性變更" aria-label="Permalink to &quot;Gradle 中的可見性變更&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-64653" target="_blank" rel="noreferrer">KT-64653</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 以前，某些原本用於特定 DSL 上下文的 Kotlin DSL 函式和屬性會無意中洩漏到其他 DSL 上下文。我們添加了 <code>@KotlinGradlePluginDsl</code> 註解，它阻止了 Kotlin Gradle 外掛程式 DSL 函式和屬性暴露到它們不應可用的層級。以下層級彼此獨立：</p><ul><li>Kotlin extension</li><li>Kotlin target</li><li>Kotlin compilation</li><li>Kotlin compilation task</li></ul><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 對於大多數常見情況，如果您的建置腳本配置不正確，編譯器會報告警告並提供修復建議；否則，編譯器會報告錯誤。</li></ul></blockquote><h3 id="棄用-kotlinoptions-dsl" tabindex="-1">棄用 kotlinOptions DSL <a class="header-anchor" href="#棄用-kotlinoptions-dsl" aria-label="Permalink to &quot;棄用 kotlinOptions DSL&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-63419" target="_blank" rel="noreferrer">KT-63419</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 透過 <code>kotlinOptions</code> DSL 和相關的 <code>KotlinCompile&lt;KotlinOptions&gt;</code> 任務介面配置編譯器選項的功能已被棄用。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 報告警告。</li></ul></blockquote><h3 id="棄用-kotlincompilation-dsl-中的-compileroptions" tabindex="-1">棄用 KotlinCompilation DSL 中的 compilerOptions <a class="header-anchor" href="#棄用-kotlincompilation-dsl-中的-compileroptions" aria-label="Permalink to &quot;棄用 KotlinCompilation DSL 中的 compilerOptions&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-65568" target="_blank" rel="noreferrer">KT-65568</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 在 <code>KotlinCompilation</code> DSL 中配置 <code>compilerOptions</code> 屬性的功能已被棄用。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: 報告警告。</li></ul></blockquote><h3 id="棄用-cinteropprocess-處理的舊方法" tabindex="-1">棄用 CInteropProcess 處理的舊方法 <a class="header-anchor" href="#棄用-cinteropprocess-處理的舊方法" aria-label="Permalink to &quot;棄用 CInteropProcess 處理的舊方法&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-62795" target="_blank" rel="noreferrer">KT-62795</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: <code>CInteropProcess</code> 任務和 <code>CInteropSettings</code> 類別現在使用 <code>definitionFile</code> 屬性而非 <code>defFile</code> 和 <code>defFileProperty</code>。</p><p>這消除了當 <code>defFile</code> 動態生成時，需要在 <code>CInteropProcess</code> 任務和生成 <code>defFile</code> 的任務之間添加額外的 <code>dependsOn</code> 關係。</p><p>在 Kotlin/Native 專案中，Gradle 現在會在連接任務在建置過程後期運行後，延遲驗證 <code>definitionFile</code> 屬性的存在。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>2.0.0: <code>defFile</code> 和 <code>defFileProperty</code> 參數已棄用。</li></ul></blockquote><h3 id="移除-kotlin-usek2-gradle-屬性" tabindex="-1">移除 kotlin.useK2 Gradle 屬性 <a class="header-anchor" href="#移除-kotlin-usek2-gradle-屬性" aria-label="Permalink to &quot;移除 kotlin.useK2 Gradle 屬性&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-64379" target="_blank" rel="noreferrer">KT-64379</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: behavioral</p><p><strong>Short summary</strong>: <code>kotlin.useK2</code> Gradle 屬性已被移除。在 Kotlin 1.9.* 中，它可以用來啟用 K2 編譯器。在 Kotlin 2.0.0 及更高版本中，K2 編譯器預設啟用，因此該屬性無效，也不能用於切換回舊版編譯器。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.8.20: <code>kotlin.useK2</code> Gradle 屬性已棄用。</li><li>2.0.0: <code>kotlin.useK2</code> Gradle 屬性已移除。</li></ul></blockquote><h3 id="移除棄用的平台外掛程式-id" tabindex="-1">移除棄用的平台外掛程式 ID <a class="header-anchor" href="#移除棄用的平台外掛程式-id" aria-label="Permalink to &quot;移除棄用的平台外掛程式 ID&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-65187" target="_blank" rel="noreferrer">KT-65187</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 對這些平台外掛程式 ID 的支持已被移除：</p><ul><li><code>kotlin-platform-android</code></li><li><code>kotlin-platform-jvm</code></li><li><code>kotlin-platform-js</code></li><li><code>org.jetbrains.kotlin.platform.android</code></li><li><code>org.jetbrains.kotlin.platform.jvm</code></li><li><code>org.jetbrains.kotlin.platform.js</code></li></ul><p><strong>Deprecation cycle</strong>:</p><ul><li>1.3: 平台外掛程式 ID 已棄用。</li><li>2.0.0: 平台外掛程式 ID 不再受支持。</li></ul></blockquote><h3 id="移除-outputfile-javascript-編譯器選項" tabindex="-1">移除 outputFile JavaScript 編譯器選項 <a class="header-anchor" href="#移除-outputfile-javascript-編譯器選項" aria-label="Permalink to &quot;移除 outputFile JavaScript 編譯器選項&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-61116" target="_blank" rel="noreferrer">KT-61116</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: <code>outputFile</code> JavaScript 編譯器選項已被移除。您可以改用 <code>Kotlin2JsCompile</code> 任務的 <code>destinationDirectory</code> 屬性來指定編譯後的 JavaScript 輸出檔案寫入的目錄。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.9.25: <code>outputFile</code> 編譯器選項已棄用。</li><li>2.0.0: <code>outputFile</code> 編譯器選項已移除。</li></ul></blockquote>',106)]))}const d=o(n,[["render",l]]);export{h as __pageData,d as default};
