import{_ as i,c as o,o as a,ag as t}from"./chunks/framework.Bksy39di.js";const k=JSON.parse('{"title":"iOS 迁移指南","description":"","frontmatter":{},"headers":[],"relativePath":"kmp/compose-ios-migration.md","filePath":"kmp/compose-ios-migration.md","lastUpdated":1755516278000}'),s={name:"kmp/compose-ios-migration.md"};function l(c,e,d,r,n,p){return a(),o("div",null,e[0]||(e[0]=[t(`<h1 id="ios-迁移指南" tabindex="-1">iOS 迁移指南 <a class="header-anchor" href="#ios-迁移指南" aria-label="Permalink to &quot;iOS 迁移指南&quot;">​</a></h1><p>本页面将引导您了解在项目中将 Compose Multiplatform 库升级到更高版本（从 1.7.0 开始）时，iOS 方面的考量事项。</p><h2 id="compose-multiplatform-1-6-11-到-1-7-0" tabindex="-1">Compose Multiplatform 1.6.11 到 1.7.0 <a class="header-anchor" href="#compose-multiplatform-1-6-11-到-1-7-0" aria-label="Permalink to &quot;Compose Multiplatform 1.6.11 到 1.7.0&quot;">​</a></h2><h3 id="移除了-uikitview-和-uikitviewcontroller-中的-background-形参" tabindex="-1">移除了 UIKitView 和 UIKitViewController 中的 background 形参 <a class="header-anchor" href="#移除了-uikitview-和-uikitviewcontroller-中的-background-形参" aria-label="Permalink to &quot;移除了 UIKitView 和 UIKitViewController 中的 background 形参&quot;">​</a></h3><p>已弃用的 <code>UIKitView</code> 和 <code>UIKitViewController</code> API 包含 <code>background</code> 形参，而新 API 则没有。该形参被视为冗余并已移除：</p><ul><li>如果您需要为新实例设置互操作视图背景，您可以使用 <code>factory</code> 形参来完成。</li><li>如果您需要背景可更新，请将相应的代码放入 <code>update</code> lambda 表达式中。</li></ul><h3 id="触摸或手势可能无法按预期工作" tabindex="-1">触摸或手势可能无法按预期工作 <a class="header-anchor" href="#触摸或手势可能无法按预期工作" aria-label="Permalink to &quot;触摸或手势可能无法按预期工作&quot;">​</a></h3><p>新的默认<a href="./compose-ios-touch">触摸行为</a>使用延迟来判断触摸是针对互操作视图，还是针对该视图的 Compose 容器：用户必须静止至少 150 毫秒，互操作视图才会接收到触摸。</p><p>如果您需要 Compose Multiplatform 像以前一样处理触摸，请考虑使用新的实验性 <code>UIKitInteropProperties</code> 构造函数。它包含 <code>interactionMode</code> 形参，您可以将其设置为 <code>UIKitInteropInteractionMode.NonCooperative</code>，使 Compose 直接将触摸传递给互操作视图。</p><p>该构造函数被标记为实验性的，因为我们最终打算让互操作视图的交互性由单个布尔标志来描述。<code>interactionMode</code> 形参中明确描述的行为，未来很可能将自动派生。</p><h3 id="accessibilityenabled-被-isnativeaccessibilityenabled-取代-并默认关闭" tabindex="-1">accessibilityEnabled 被 isNativeAccessibilityEnabled 取代，并默认关闭 <a class="header-anchor" href="#accessibilityenabled-被-isnativeaccessibilityenabled-取代-并默认关闭" aria-label="Permalink to &quot;accessibilityEnabled 被 isNativeAccessibilityEnabled 取代，并默认关闭&quot;">​</a></h3><p>旧 <code>UIKitView</code> 和 <code>UIKitViewController</code> 构造函数的 <code>accessibilityEnabled</code> 形参已被移动并重命名为 <code>UIKitInteropProperties.isNativeAccessibilityEnabled</code> 属性。它也默认设置为 <code>false</code>。</p><p><code>isNativeAccessibilityEnabled</code> 属性会使合并的 Compose 子树受到原生无障碍解析的影响。因此，除非您需要互操作视图（例如 Web 视图）的丰富无障碍功能，否则不建议将其设置为 <code>true</code>。</p><p>关于此属性及其默认值的原理，请参见 <a href="https://github.com/JetBrains/compose-multiplatform-core/blob/jb-main/compose/ui/ui/src/uikitMain/kotlin/androidx/compose/ui/viewinterop/UIKitInteropProperties.uikit.kt" target="_blank" rel="noreferrer">UIKitInteropProperties 类的代码内文档</a>。</p><h3 id="onresize-形参已移除" tabindex="-1">onResize 形参已移除 <a class="header-anchor" href="#onresize-形参已移除" aria-label="Permalink to &quot;onResize 形参已移除&quot;">​</a></h3><p>旧 <code>UIKitView</code> 和 <code>UIKitViewController</code> 构造函数的 <code>onResize</code> 形参设置了一个基于 <code>rect</code> 实参的自定义 frame，但不影响 Compose 布局本身，因此使用起来不直观。此外，<code>onResize</code> 形参的默认实现需要正确设置互操作视图的 frame，并且包含一些关于正确剪裁视图的实现细节。</p><p>如何在没有 <code>onResize</code> 的情况下实现：</p><ul><li>如果您需要响应互操作视图 frame 变更，您可以： <ul><li>覆盖互操作 <code>UIView</code> 的 <a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="noreferrer"><code>layoutSubviews</code></a>，</li><li>覆盖互操作 <code>UIViewController</code> 的 <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621398-viewdidlayoutsubviews" target="_blank" rel="noreferrer"><code>viewDidLayoutSubviews</code></a>，</li><li>或者将 <code>onGloballyPositioned</code> 添加到 <code>Modifier</code> 链中。</li></ul></li><li>如果您需要设置互操作视图的 frame，请使用相应的 Compose 修饰符：<code>size</code>、<code>fillMaxSize</code> 等。</li></ul><h3 id="某些-onreset-使用模式已失效" tabindex="-1">某些 onReset 使用模式已失效 <a class="header-anchor" href="#某些-onreset-使用模式已失效" aria-label="Permalink to &quot;某些 onReset 使用模式已失效&quot;">​</a></h3><p>将非空 <code>onReset</code> lambda 表达式与 <code>remember { UIView() }</code> 一起使用是不正确的。</p><p>考虑以下代码：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> view </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> remember</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UIView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UIKitView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(factory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { view }, onReset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p>当 <code>UIKitView</code> 进入组合时，<code>factory</code> 或 <code>onReset</code> 会被调用，但不会同时调用。因此，如果 <code>onReset</code> 非空，记住的视图可能与屏幕上显示的视图不同：可组合项可以离开组合，并留下一个视图实例，该实例将在 <code>onReset</code> 中重置后被重用，而不是使用 <code>factory</code> 分配一个新视图。</p><p>为避免此类错误，请不要在构造函数中指定 <code>onReset</code> 值。您可能需要根据发出回调的函数进入组合的上下文，在互操作视图内部执行回调：在这种情况下，考虑将回调存储在视图内部，并在 <code>onReset</code> 时通过 <code>update</code> 进行更新。</p>`,24)]))}const u=i(s,[["render",l]]);export{k as __pageData,u as default};
