import{_ as k,a as r,b as d,c as E,d as o,e as g,f as c,g as y,h as F,i as u,j as C,k as b,l as B,m as D,n as A,o as v,p as m,q as f,r as q,s as _}from"./chunks/time-comparison.B6DZdO43.js";import{_ as T,C as e,c as x,o as R,ag as n,j as i,G as l,a,w as t}from"./chunks/framework.Bksy39di.js";const V=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ja/kotlin/coroutines-and-channels.md","filePath":"ja/kotlin/coroutines-and-channels.md","lastUpdated":1754307826000}'),S={name:"ja/kotlin/coroutines-and-channels.md"};function P(I,s,U,w,L,N){const p=e("def"),h=e("deflist");return R(),x("div",null,[s[4]||(s[4]=n('<h1 id="コルーチンとチャネル-−-チュートリアル" tabindex="-1">コルーチンとチャネル − チュートリアル <a class="header-anchor" href="#コルーチンとチャネル-−-チュートリアル" aria-label="Permalink to &quot;コルーチンとチャネル − チュートリアル&quot;">​</a></h1><p>このチュートリアルでは、IntelliJ IDEA でコルーチンを使用して、基になるスレッドやコールバックをブロックせずにネットワークリクエストを実行する方法を学びます。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>コルーチンに関する事前の知識は不要ですが、Kotlin の基本的な構文に精通していることが求められます。</p></div><p>学ぶこと：</p><ul><li>サスペンド関数を使用してネットワークリクエストを実行する理由と方法。</li><li>コルーチンを使用してリクエストを並行して送信する方法。</li><li>チャネルを使用して異なるコルーチン間で情報を共有する方法。</li></ul><p>ネットワークリクエストには <a href="https://square.github.io/retrofit/" target="_blank" rel="noreferrer">Retrofit</a> ライブラリが必要ですが、このチュートリアルで示すアプローチは、コルーチンをサポートする他のライブラリでも同様に機能します。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>すべてのタスクの解決策は、<a href="http://github.com/kotlin-hands-on/intro-coroutines" target="_blank" rel="noreferrer">プロジェクトのリポジトリ</a>の <code>solutions</code> ブランチにあります。</p></div><h2 id="始める前に" tabindex="-1">始める前に <a class="header-anchor" href="#始める前に" aria-label="Permalink to &quot;始める前に&quot;">​</a></h2><ol><li><p><a href="https://www.jetbrains.com/idea/download/index.html" target="_blank" rel="noreferrer">IntelliJ IDEA</a> の最新バージョンをダウンロードしてインストールします。</p></li><li><p>ウェルカム画面で <strong>Get from VCS</strong> を選択するか、<strong>File | New | Project from Version Control</strong> を選択して、<a href="http://github.com/kotlin-hands-on/intro-coroutines" target="_blank" rel="noreferrer">プロジェクトテンプレート</a>をクローンします。</p><p>コマンドラインからクローンすることもできます：</p><div class="language-Bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clone</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://github.com/kotlin-hands-on/intro-coroutines</span></span></code></pre></div></li></ol><h3 id="github-開発者トークンを生成する" tabindex="-1">GitHub 開発者トークンを生成する <a class="header-anchor" href="#github-開発者トークンを生成する" aria-label="Permalink to &quot;GitHub 開発者トークンを生成する&quot;">​</a></h3><p>プロジェクトで GitHub API を使用します。アクセスするには、GitHub アカウント名とパスワードまたはトークンを提供する必要があります。二段階認証を有効にしている場合は、トークンだけで十分です。</p><p><a href="https://github.com/settings/tokens/new" target="_blank" rel="noreferrer">あなたのアカウント</a>で GitHub API を使用するための新しい GitHub トークンを生成します：</p><ol><li><p>トークンの名前を指定します。例えば、<code>coroutines-tutorial</code>：</p><p><img src="'+o+'" alt="Generate a new GitHub token" width="700"></p></li><li><p>スコープは何も選択しないでください。ページの下部にある <strong>Generate token</strong> をクリックします。</p></li><li><p>生成されたトークンをコピーします。</p></li></ol><h3 id="コードを実行する" tabindex="-1">コードを実行する <a class="header-anchor" href="#コードを実行する" aria-label="Permalink to &quot;コードを実行する&quot;">​</a></h3><p>このプログラムは、指定された組織（デフォルトでは「kotlin」と命名）の下にあるすべてのリポジトリのコントリビューターをロードします。後で、ユーザーを貢献数でソートするロジックを追加します。</p><ol><li><p><code>src/contributors/main.kt</code> ファイルを開き、<code>main()</code> 関数を実行します。次のウィンドウが表示されます：</p><p><img src="'+g+`" alt="First window" width="500"></p><p>フォントが小さすぎる場合は、<code>main()</code> 関数内の <code>setDefaultFontSize(18f)</code> の値を変更して調整してください。</p></li><li><p>対応するフィールドに GitHub のユーザー名とトークン（またはパスワード）を入力します。</p></li><li><p><em>Variant</em> ドロップダウンメニューで <em>BLOCKING</em> オプションが選択されていることを確認します。</p></li><li><p><em>Load contributors</em> をクリックします。UI がしばらくフリーズし、その後コントリビューターのリストが表示されます。</p></li><li><p>プログラムの出力を開き、データがロードされたことを確認します。コントリビューターのリストは、各リクエストが成功するたびにログに記録されます。</p></li></ol><p>このロジックを実装する方法はいくつかあります。例えば、<a href="#blocking-requests">ブロッキングリクエスト</a>や<a href="#callbacks">コールバック</a>を使用する方法です。これらの解決策を<a href="#coroutines">コルーチン</a>を使用する解決策と比較し、<a href="#channels">チャネル</a>を使用して異なるコルーチン間で情報を共有する方法を確認します。</p><h2 id="ブロッキングリクエスト" tabindex="-1">ブロッキングリクエスト <a class="header-anchor" href="#ブロッキングリクエスト" aria-label="Permalink to &quot;ブロッキングリクエスト&quot;">​</a></h2><p>GitHub への HTTP リクエストを実行するために、<a href="https://square.github.io/retrofit/" target="_blank" rel="noreferrer">Retrofit</a> ライブラリを使用します。これにより、指定された組織の下にあるリポジトリのリストと、各リポジトリのコントリビューターのリストをリクエストできます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;orgs/{org}/repos?per_page=100&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getOrgReposCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) org: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Repo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;repos/{owner}/{repo}/contributors?per_page=100&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getRepoContributorsCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;owner&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) owner: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;repo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) repo: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>この API は <code>loadContributorsBlocking()</code> 関数によって使用され、指定された組織のコントリビューターのリストをフェッチします。</p><ol><li><p><code>src/tasks/Request1Blocking.kt</code> を開いてその実装を確認します：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> service</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrgReposCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org)   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req, it) } </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() ?: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emptyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #4</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">flatMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        service</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributorsCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                                   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, it) }                 </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                                  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>まず、指定された組織の下にあるリポジトリのリストを取得し、<code>repos</code> リストに保存します。次に、各リポジトリに対してコントリビューターのリストをリクエストし、すべてのリストを1つの最終的なコントリビューターリストにマージします。</li><li><code>getOrgReposCall()</code> と <code>getRepoContributorsCall()</code> はどちらも <code>*Call</code> クラスのインスタンスを返します (<code>#1</code>)。この時点では、リクエストは送信されません。</li><li><code>*Call.execute()</code> が呼び出されてリクエストが実行されます (<code>#2</code>)。<code>execute()</code> は基になるスレッドをブロックする同期呼び出しです。</li><li>応答を受け取ると、特定の <code>logRepos()</code> と <code>logUsers()</code> 関数を呼び出して結果がログに記録されます (<code>#3</code>)。HTTP 応答にエラーが含まれている場合、このエラーはここにログに記録されます。</li><li>最後に、必要なデータを含む応答の本文を取得します。このチュートリアルでは、エラーが発生した場合の戻り値として空のリストを使用し、対応するエラーをログに記録します (<code>#4</code>)。</li></ul></li><li><p><code>.body() ?: emptyList()</code> の繰り返しを避けるため、拡張関数 <code>bodyList()</code> が宣言されています：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() ?: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emptyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>プログラムを再度実行し、IntelliJ IDEA のシステム出力を確認します。次のような内容が表示されるはずです：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1770 [AWT-EventQueue-0] INFO  Contributors - kotlin: loaded 40 repos</span></span>
<span class="line"><span>2025 [AWT-EventQueue-0] INFO  Contributors - kotlin-examples: loaded 23 contributors</span></span>
<span class="line"><span>2229 [AWT-EventQueue-0] INFO  Contributors - kotlin-koans: loaded 45 contributors</span></span>
<span class="line"><span>...</span></span></code></pre></div><ul><li>各行の最初の項目は、プログラム開始からのミリ秒数、次に角括弧内のスレッド名です。ロードリクエストがどのスレッドから呼び出されたかを確認できます。</li><li>各行の最後の項目は、実際のアメッセージです。ロードされたリポジトリまたはコントリビューターの数を示します。</li></ul><p>このログ出力は、すべての結果がメインスレッドからログに記録されたことを示しています。<code>_BLOCKING_</code> オプションでコードを実行すると、UI はフリーズし、ロードが完了するまで入力に反応しません。すべてのリクエストは <code>loadContributorsBlocking()</code> が呼び出されたスレッドと同じスレッド（Swing では AWT イベントディスパッチスレッド）から実行され、このメインスレッドがブロックされるため、UI がフリーズします：</p><p><img src="`+c+`" alt="The blocked main thread" width="700"></p><p>コントリビューターのリストがロードされた後、結果が更新されます。</p></li><li><p><code>src/contributors/Contributors.kt</code> で、コントリビューターのロード方法を選択する <code>loadContributors()</code> 関数を見つけ、<code>loadContributorsBlocking()</code> がどのように呼び出されているかを確認します：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getSelectedVariant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    BLOCKING </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Blocking UI thread</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service, req)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users, startTime)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>updateResults()</code> の呼び出しは <code>loadContributorsBlocking()</code> の呼び出しのすぐ後に行われます。</li><li><code>updateResults()</code> は UI を更新するため、常に UI スレッドから呼び出す必要があります。</li><li><code>loadContributorsBlocking()</code> も UI スレッドから呼び出されるため、UI スレッドがブロックされ、UI がフリーズします。</li></ul></li></ol><h3 id="タスク-1" tabindex="-1">タスク 1 <a class="header-anchor" href="#タスク-1" aria-label="Permalink to &quot;タスク 1&quot;">​</a></h3><p>最初のタスクは、タスクドメインに慣れるのに役立ちます。現在、各コントリビューターの名前は、参加したすべてのプロジェクトで複数回繰り返されています。各コントリビューターが一度だけ追加されるように、ユーザーを結合する <code>aggregate()</code> 関数を実装してください。<code>User.contributions</code> プロパティには、指定されたユーザーの<strong>すべての</strong>プロジェクトへの総貢献数が含まれるべきです。結果のリストは、貢献数の降順でソートされるべきです。</p><p><code>src/tasks/Aggregation.kt</code> を開き、<code>List&lt;User&gt;.aggregate()</code> 関数を実装してください。ユーザーは総貢献数でソートされるべきです。</p><p>対応するテストファイル <code>test/tasks/AggregationKtTest.kt</code> には、期待される結果の例が示されています。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><a href="https://www.jetbrains.com/help/idea/create-tests.html#test-code-navigation" target="_blank" rel="noreferrer">IntelliJ IDEA のショートカット</a> <code>Ctrl+Shift+T</code> / <code>⇧ ⌘ T</code> を使用して、ソースコードとテストクラス間を自動的にジャンプできます。</p></div><p>このタスクを実装した後、「kotlin」組織の結果リストは次のようになるはずです：</p><p><img src="`+y+'" alt="The list for the &quot;kotlin&quot; organization" width="500"></p>',29)),s[5]||(s[5]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"タスク-1-の解決策",tabindex:"-1"},[a("タスク 1 の解決策 "),i("a",{class:"header-anchor",href:"#タスク-1-の解決策","aria-label":'Permalink to "タスク 1 の解決策 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[6]||(s[6]=n(`<ol><li><p>ユーザーをログイン名でグループ化するには、<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/group-by.html" target="_blank" rel="noreferrer"><code>groupBy()</code></a> を使用します。これは、ログイン名から、このログイン名を持つユーザーの異なるリポジトリでのすべての出現へのマップを返します。</p></li><li><p>各マップエントリに対して、各ユーザーの総貢献数をカウントし、指定された名前と総貢献数を持つ <code>User</code> クラスの新しいインスタンスを作成します。</p></li><li><p>結果のリストを降順にソートします：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">User</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    groupBy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.login }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { (login, group) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(login, group.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sumOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.contributions }) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sortedByDescending</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.contributions }</span></span></code></pre></div></li></ol><p>代替の解決策として、<code>groupBy()</code> の代わりに <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/grouping-by.html" target="_blank" rel="noreferrer"><code>groupingBy()</code></a> 関数を使用することもできます。</p><h2 id="コールバック" tabindex="-1">コールバック <a class="header-anchor" href="#コールバック" aria-label="Permalink to &quot;コールバック&quot;">​</a></h2><p>前の解決策は機能しますが、スレッドをブロックするため、UI をフリーズさせます。これを回避する伝統的なアプローチは、<em>コールバック</em> を使用することです。</p><p>操作が完了した直後に呼び出されるべきコードを呼び出す代わりに、それを別のコールバック（多くの場合ラムダ）に抽出し、後で呼び出すためにそのラムダを呼び出し元に渡すことができます。</p><p>UI を応答性のある状態にするには、計算全体を別のスレッドに移動するか、ブロッキング呼び出しの代わりにコールバックを使用する Retrofit API に切り替えるかのいずれかです。</p><h3 id="バックグラウンドスレッドを使用する" tabindex="-1">バックグラウンドスレッドを使用する <a class="header-anchor" href="#バックグラウンドスレッドを使用する" aria-label="Permalink to &quot;バックグラウンドスレッドを使用する&quot;">​</a></h3><ol><li><p><code>src/tasks/Request2Background.kt</code> を開いて、その実装を確認します。まず、計算全体が別のスレッドに移動されます。<code>thread()</code> 関数は新しいスレッドを開始します：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    loadContributorsBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service, req)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>これで、すべてのロードが別のスレッドに移動されたため、メインスレッドは空きになり、他のタスクで使用できるようになります：</p><p><img src="`+F+`" alt="The freed main thread" width="700"></p></li><li><p><code>loadContributorsBackground()</code> 関数のシグネチャが変更されます。すべてのロードが完了した後に呼び出すために、<code>updateResults()</code> コールバックを最後の引数として取ります：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsBackground</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    updateResults: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div></li><li><p><code>loadContributorsBackground()</code> が呼び出されると、<code>updateResults()</code> の呼び出しは以前のように直後ではなく、コールバック内で行われます：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loadContributorsBackground</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service, req) { users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SwingUtilities.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invokeLater</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users, startTime)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>SwingUtilities.invokeLater</code> を呼び出すことで、結果を更新する <code>updateResults()</code> の呼び出しがメイン UI スレッド (AWT イベントディスパッチスレッド) で行われることを保証します。</p></li></ol><p>ただし、<code>BACKGROUND</code> オプションを介してコントリビューターをロードしようとすると、リストは更新されますが、何も変更されないことがわかります。</p><h3 id="タスク-2" tabindex="-1">タスク 2 <a class="header-anchor" href="#タスク-2" aria-label="Permalink to &quot;タスク 2&quot;">​</a></h3><p><code>src/tasks/Request2Background.kt</code> の <code>loadContributorsBackground()</code> 関数を修正し、結果のリストが UI に表示されるようにします。</p>`,11)),s[7]||(s[7]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"タスク-2-の解決策",tabindex:"-1"},[a("タスク 2 の解決策 "),i("a",{class:"header-anchor",href:"#タスク-2-の解決策","aria-label":'Permalink to "タスク 2 の解決策 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[8]||(s[8]=n(`<p>コントリビューターをロードしようとすると、ログにコントリビューターがロードされたことが示されますが、結果は表示されません。これを修正するには、結果のユーザーリストで <code>updateResults()</code> を呼び出します：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loadContributorsBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service, req))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>コールバックで渡されたロジックを明示的に呼び出すことを確認してください。そうしないと何も起こりません。</p><h3 id="retrofit-コールバック-api-を使用する" tabindex="-1">Retrofit コールバック API を使用する <a class="header-anchor" href="#retrofit-コールバック-api-を使用する" aria-label="Permalink to &quot;Retrofit コールバック API を使用する&quot;">​</a></h3><p>前の解決策では、すべてのロードロジックがバックグラウンドスレッドに移動されましたが、それでもリソースの最適な使用法ではありません。すべてのロードリクエストは順次実行され、ロード結果を待つ間スレッドがブロックされますが、他のタスクで使用することもできました。具体的には、スレッドは別のリクエストのロードを開始して、全体の結果をより早く受け取ることができました。</p><p>各リポジトリのデータを処理することは、ロードと結果応答の処理の 2 つの部分に分ける必要があります。2 番目の_処理_部分は、コールバックに抽出する必要があります。</p><p>各リポジトリのロードは、前のリポジトリの結果が受信される前（および対応するコールバックが呼び出される前）に開始できます：</p><p><img src="`+u+`" alt="Using callback API" width="700"></p><p>Retrofit コールバック API がこれを実現するのに役立ちます。<code>Call.enqueue()</code> 関数は HTTP リクエストを開始し、引数としてコールバックを取ります。このコールバックでは、各リクエスト後に何をする必要があるかを指定する必要があります。</p><p><code>src/tasks/Request3Callbacks.kt</code> を開いて、この API を使用する <code>loadContributorsCallbacks()</code> の実装を確認します：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsCallbacks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    updateResults: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrgReposCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { responseRepos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // #1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        logRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req, responseRepos)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> responseRepos.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mutableListOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributorsCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { responseUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // #2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, responseUsers)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> responseUsers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // TODO: Why doesn&#39;t this code work? How to fix that?</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allUsers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><ul><li>便宜上、このコードフラグメントは同じファイルで宣言されている <code>onResponse()</code> 拡張関数を使用しています。これはオブジェクト式ではなく、ラムダを引数として取ります。</li><li>応答を処理するロジックはコールバックに抽出されています。対応するラムダは行 <code>#1</code> と <code>#2</code> から始まります。</li></ul><p>しかし、提供された解決策は機能しません。プログラムを実行し、<em>CALLBACKS</em> オプションを選択してコントリビューターをロードしても、何も表示されません。しかし、<code>Request3CallbacksKtTest</code> のテストはすぐに結果を返し、正常に合格したと表示されます。</p><p>与えられたコードが期待どおりに機能しない理由を考えて、それを修正してみてください。または、以下の解決策を参照してください。</p><h3 id="タスク-3-オプション" tabindex="-1">タスク 3 (オプション) <a class="header-anchor" href="#タスク-3-オプション" aria-label="Permalink to &quot;タスク 3 (オプション)&quot;">​</a></h3><p><code>src/tasks/Request3Callbacks.kt</code> ファイルのコードを書き直し、ロードされたコントリビューターのリストが表示されるようにします。</p>`,16)),s[9]||(s[9]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"タスク-3-の最初の試み解決策",tabindex:"-1"},[a("タスク 3 の最初の試み解決策 "),i("a",{class:"header-anchor",href:"#タスク-3-の最初の試み解決策","aria-label":'Permalink to "タスク 3 の最初の試み解決策 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[10]||(s[10]=n(`<p>現在のソリューションでは、多くのリクエストが並行して開始され、全体のロード時間が短縮されます。しかし、結果はロードされません。これは、<code>updateResults()</code> コールバックがすべてのロードリクエストが開始された直後に呼び出され、<code>allUsers</code> リストにデータがまだ入力されていないためです。</p><p>次のように変更してこれを修正してみることができます：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mutableListOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((index, repo) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withIndex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributorsCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { responseUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, responseUsers)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> responseUsers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.lastIndex) {    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allUsers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>まず、インデックス付きでリポジトリのリストをイテレートします (<code>#1</code>)。</li><li>次に、各コールバックから、それが最後のイテレーションであるかどうかを確認します (<code>#2</code>)。</li><li>そして、そうである場合は、結果が更新されます。</li></ul><p>しかし、このコードも目的を達成できません。自分で答えを見つけるか、以下の解決策を参照してください。</p>`,5)),s[11]||(s[11]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"タスク-3-の-2-番目の試み解決策",tabindex:"-1"},[a("タスク 3 の 2 番目の試み解決策 "),i("a",{class:"header-anchor",href:"#タスク-3-の-2-番目の試み解決策","aria-label":'Permalink to "タスク 3 の 2 番目の試み解決策 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[12]||(s[12]=n(`<p>ロードリクエストは並行して開始されるため、最後のリクエストの結果が最後に届く保証はありません。結果は任意の順序で届く可能性があります。</p><p>したがって、完了条件として現在のインデックスを <code>lastIndex</code> と比較すると、一部のリポジトリの結果を失うリスクがあります。</p><p>もし最後のリポジトリを処理するリクエストが以前のいくつかのリクエストよりも早く返された場合（これは起こり得ます）、より時間がかかるリクエストのすべての結果は失われます。</p><p>これを修正する1つの方法は、インデックスを導入し、すべてのリポジトリがすでに処理されたかどうかを確認することです：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Collections.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">synchronizedList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mutableListOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;())</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numberOfProcessed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AtomicInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributorsCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { responseUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, responseUsers)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> responseUsers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (numberOfProcessed.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">incrementAndGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.size) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allUsers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>このコードは、同期バージョンのリストと <code>AtomicInteger()</code> を使用しています。なぜなら、一般に、<code>getRepoContributors()</code> リクエストを処理する異なるコールバックが常に同じスレッドから呼び出される保証がないからです。</p>`,6)),s[13]||(s[13]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"タスク-3-の-3-番目の試み解決策",tabindex:"-1"},[a("タスク 3 の 3 番目の試み解決策 "),i("a",{class:"header-anchor",href:"#タスク-3-の-3-番目の試み解決策","aria-label":'Permalink to "タスク 3 の 3 番目の試み解決策 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[14]||(s[14]=n(`<p>さらに良い解決策は、<code>CountDownLatch</code> クラスを使用することです。これは、リポジトリの数で初期化されたカウンターを保持します。このカウンターは、各リポジトリを処理した後でデクリメントされます。そして、ラッチがゼロにカウントダウンされるまで待機してから結果を更新します：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> countDownLatch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CountDownLatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repos.size)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributorsCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { responseUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // processing repository</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            countDownLatch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">countDown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">countDownLatch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allUsers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>結果はメインスレッドから更新されます。これは、ロジックを子スレッドに委譲するよりも直接的です。</p><p>これら 3 つの解決策の試みを確認すると、コールバックで正しいコードを書くことは、特に複数の基になるスレッドと同期が発生する場合に、非自明でエラーが発生しやすいことがわかります。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>追加の演習として、RxJava ライブラリを使用してリアクティブなアプローチで同じロジックを実装することもできます。必要なすべての依存関係と RxJava を使用するための解決策は、別の <code>rx</code> ブランチにあります。このチュートリアルを完了し、適切な比較のために提案された Rx バージョンを実装または確認することも可能です。</p></div><h2 id="サスペンド関数" tabindex="-1">サスペンド関数 <a class="header-anchor" href="#サスペンド関数" aria-label="Permalink to &quot;サスペンド関数&quot;">​</a></h2><p>同じロジックをサスペンド関数を使用して実装できます。<code>Call&lt;List&lt;Repo&gt;&gt;</code> を返す代わりに、API 呼び出しを<a href="/ja/kotlin/composing-suspending-functions">サスペンド関数</a>として次のように定義します：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;orgs/{org}/repos?per_page=100&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getOrgRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) org: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Repo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>getOrgRepos()</code> は <code>suspend</code> 関数として定義されています。サスペンド関数を使用してリクエストを実行する場合、基になるスレッドはブロックされません。この仕組みの詳細については、後続のセクションで説明します。</li><li><code>getOrgRepos()</code> は <code>Call</code> を返す代わりに直接結果を返します。結果が失敗した場合は、例外がスローされます。</li></ul><p>あるいは、Retrofit は結果を <code>Response</code> でラップして返すこともできます。この場合、結果ボディが提供され、手動でエラーをチェックすることが可能です。このチュートリアルでは、<code>Response</code> を返すバージョンを使用します。</p><p><code>src/contributors/GitHubService.kt</code> に、<code>GitHubService</code> インターフェースに次の宣言を追加します：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // getOrgReposCall &amp; getRepoContributorsCall declarations</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;orgs/{org}/repos?per_page=100&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getOrgRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) org: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Response</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Repo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;repos/{owner}/{repo}/contributors?per_page=100&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getRepoContributors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;owner&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) owner: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;repo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) repo: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Response</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="タスク-4" tabindex="-1">タスク 4 <a class="header-anchor" href="#タスク-4" aria-label="Permalink to &quot;タスク 4&quot;">​</a></h3><p>あなたのタスクは、コントリビューターをロードする関数のコードを変更して、2 つの新しいサスペンド関数 <code>getOrgRepos()</code> と <code>getRepoContributors()</code> を使用することです。新しい <code>loadContributorsSuspend()</code> 関数は、新しい API を使用するために <code>suspend</code> とマークされています。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>サスペンド関数はどこからでも呼び出せるわけではありません。<code>loadContributorsBlocking()</code> からサスペンド関数を呼び出すと、「Suspend function &#39;getOrgRepos&#39; should be called only from a coroutine or another suspend function」というメッセージのエラーが発生します。</p></div><ol><li><code>src/tasks/Request1Blocking.kt</code> で定義されている <code>loadContributorsBlocking()</code> の実装を、<code>src/tasks/Request4Suspend.kt</code> で定義されている <code>loadContributorsSuspend()</code> にコピーします。</li><li><code>Call</code> を返す関数ではなく、新しいサスペンド関数が使用されるようにコードを修正します。</li><li><em>SUSPEND</em> オプションを選択してプログラムを実行し、GitHub リクエストが実行されている間も UI が応答性があることを確認します。</li></ol>`,16)),s[15]||(s[15]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"タスク-4-の解決策",tabindex:"-1"},[a("タスク 4 の解決策 "),i("a",{class:"header-anchor",href:"#タスク-4-の解決策","aria-label":'Permalink to "タスク 4 の解決策 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[16]||(s[16]=n(`<p><code>.getOrgReposCall(req.org).execute()</code> を <code>.getOrgRepos(req.org)</code> に置き換え、2 番目の「コントリビューター」リクエストについても同じ置き換えを繰り返します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsSuspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> service</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrgRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">flatMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>loadContributorsSuspend()</code> は <code>suspend</code> 関数として定義する必要があります。</li><li>以前 <code>Response</code> を返していた <code>execute</code> を呼び出す必要はなくなりました。なぜなら、API 関数が直接 <code>Response</code> を返すようになったからです。この詳細は Retrofit ライブラリに特有のものであることに注意してください。他のライブラリでは API は異なりますが、概念は同じです。</li></ul><h2 id="コルーチン" tabindex="-1">コルーチン <a class="header-anchor" href="#コルーチン" aria-label="Permalink to &quot;コルーチン&quot;">​</a></h2><p>サスペンド関数を使ったコードは、「ブロッキング」バージョンと似ています。ブロッキングバージョンとの大きな違いは、スレッドをブロックする代わりに、コルーチンがサスペンドされる点です。</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ブロック -&gt; サスペンド</span></span>
<span class="line"><span>スレッド -&gt; コルーチン</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>コルーチンは、スレッド上でコードを実行するのと同様にコルーチン上でコードを実行できるため、しばしば軽量スレッドと呼ばれます。以前はブロックされていた（そして避ける必要があった）操作は、代わりにコルーチンをサスペンドできるようになりました。</p></div><h3 id="新しいコルーチンの開始" tabindex="-1">新しいコルーチンの開始 <a class="header-anchor" href="#新しいコルーチンの開始" aria-label="Permalink to &quot;新しいコルーチンの開始&quot;">​</a></h3><p><code>src/contributors/Contributors.kt</code> で <code>loadContributorsSuspend()</code> がどのように使われているかを見ると、<code>launch</code> の内部で呼び出されていることがわかります。<code>launch</code> はラムダを引数として取るライブラリ関数です。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsSuspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users, startTime)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>ここで <code>launch</code> は、データのロードと結果の表示を担当する新しい計算を開始します。この計算はサスペンド可能で、ネットワークリクエストを実行している間はサスペンドされ、基になるスレッドを解放します。ネットワークリクエストが結果を返すと、計算は再開されます。</p><p>このようなサスペンド可能な計算は <em>コルーチン</em> と呼ばれます。したがって、この場合、<code>launch</code> はデータをロードして結果を表示する新しいコルーチンを <em>開始します</em>。</p><p>コルーチンはスレッド上で実行され、サスペンドすることができます。コルーチンがサスペンドされると、対応する計算は一時停止され、スレッドから削除されてメモリに保存されます。その間、スレッドは他のタスクに占有されることができます：</p><p><img src="`+C+'" alt="Suspending coroutines" width="700"></p><p>計算の続行準備ができると、それはスレッド（必ずしも同じスレッドとは限らない）に戻されます。</p><p><code>loadContributorsSuspend()</code> の例では、各「コントリビューター」リクエストは、サスペンションメカニズムを使用して結果を待機します。まず、新しいリクエストが送信されます。次に、応答を待っている間、<code>launch</code> 関数によって開始された「コントリビューターをロードする」コルーチン全体がサスペンドされます。</p><p>コルーチンは、対応する応答が受信された後にのみ再開されます。</p><p><img src="'+b+`" alt="Suspending request" width="700"></p><p>応答の受信を待っている間、スレッドは他のタスクに占有されることができます。すべてのリクエストがメイン UI スレッドで実行されているにもかかわらず、UI は応答性を維持します。</p><ol><li><p><em>SUSPEND</em> オプションを使用してプログラムを実行します。ログは、すべてのリクエストがメイン UI スレッドに送信されていることを確認します：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>2538 [AWT-EventQueue-0 @coroutine#1] INFO  Contributors - kotlin: loaded 30 repos</span></span>
<span class="line"><span>2729 [AWT-EventQueue-0 @coroutine#1] INFO  Contributors - ts2kt: loaded 11 contributors</span></span>
<span class="line"><span>3029 [AWT-EventQueue-0 @coroutine#1] INFO  Contributors - kotlin-koans: loaded 45 contributors</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>11252 [AWT-EventQueue-0 @coroutine#1] INFO  Contributors - kotlin-coroutines-workshop: loaded 1 contributors</span></span></code></pre></div></li><li><p>ログは、対応するコードがどのコルーチンで実行されているかを表示できます。これを有効にするには、<strong>Run | Edit configurations</strong> を開き、<code>-Dkotlinx.coroutines.debug</code> VM オプションを追加します：</p><p><img src="`+B+`" alt="Edit run configuration" width="500"></p><p>このオプションで <code>main()</code> を実行すると、コルーチン名がスレッド名に付加されます。また、すべての Kotlin ファイルを実行するためのテンプレートを変更し、このオプションをデフォルトで有効にすることもできます。</p></li></ol><p>これで、すべてのコードは単一のコルーチン、上記の「コントリビューターをロードする」コルーチン、<code>@coroutine#1</code> で実行されます。結果を待っている間、コードが順次書かれているため、スレッドを他のリクエストの送信に再利用すべきではありません。新しいリクエストは、前の結果が受信された後にのみ送信されます。</p><p>サスペンド関数はスレッドを公平に扱い、「待機」のためにブロックすることはありません。しかし、これはまだ並行性をもたらしていません。</p><h2 id="並行性" tabindex="-1">並行性 <a class="header-anchor" href="#並行性" aria-label="Permalink to &quot;並行性&quot;">​</a></h2><p>Kotlin のコルーチンはスレッドよりもはるかにリソース集約的ではありません。新しい計算を非同期に開始したいときはいつでも、新しいコルーチンを作成できます。</p><p>新しいコルーチンを開始するには、主要な_コルーチンビルダー_のいずれか、<code>launch</code>、<code>async</code>、または <code>runBlocking</code> を使用します。異なるライブラリは追加のコルーチンビルダーを定義できます。</p><p><code>async</code> は新しいコルーチンを開始し、<code>Deferred</code> オブジェクトを返します。<code>Deferred</code> は <code>Future</code> や <code>Promise</code> などの他の名前で知られる概念を表します。これは計算を保存しますが、最終結果を取得するタイミングを_遅延させます_。つまり、<em>将来_のある時点で結果を_約束します</em>。</p><p><code>async</code> と <code>launch</code> の主な違いは、<code>launch</code> が特定の結果を返すことを期待されない計算を開始するために使用されることです。<code>launch</code> はコルーチンを表す <code>Job</code> を返します。<code>Job.join()</code> を呼び出すことで、完了するまで待機することが可能です。</p><p><code>Deferred</code> は <code>Job</code> を継承するジェネリック型です。<code>async</code> 呼び出しは、ラムダが何を返すか（ラムダ内の最後の式が結果）に応じて、<code>Deferred&lt;Int&gt;</code> または <code>Deferred&lt;CustomType&gt;</code> を返すことができます。</p><p>コルーチンの結果を取得するには、<code>Deferred</code> インスタンスで <code>await()</code> を呼び出すことができます。結果を待つ間、この <code>await()</code> が呼び出されたコルーチンはサスペンドされます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deferred: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Deferred</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        loadData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;waiting...&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(deferred.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;loading...&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;loaded!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>runBlocking</code> は通常の関数とサスペンド関数との間の、あるいはブロッキングと非ブロッキングの世界との間の架け橋として使用されます。これは、トップレベルのメインコルーチンを開始するためのアダプターとして機能します。主に <code>main()</code> 関数やテストでの使用を意図しています。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>コルーチンをよりよく理解するために、<a href="https://www.youtube.com/watch?v=zEZc5AmHQhk" target="_blank" rel="noreferrer">このビデオ</a>をご覧ください。</p></div><p>遅延オブジェクトのリストがある場合、<code>awaitAll()</code> を呼び出して、それらすべての結果を待機できます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deferreds: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Deferred</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000L</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> it)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Loading </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$it</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            it</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deferreds.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">awaitAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$sum</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>各「コントリビューター」リクエストが新しいコルーチンで開始されると、すべてのリクエストが非同期に開始されます。新しいリクエストは、前のリクエストの結果が受信される前に送信できます。</p><p><img src="`+D+'" alt="Concurrent coroutines" width="700"></p><p>合計ロード時間は <em>CALLBACKS</em> バージョンとほぼ同じですが、コールバックは不要です。さらに、<code>async</code> はコード内でどの部分が並行して実行されるかを明確に強調します。</p><h3 id="タスク-5" tabindex="-1">タスク 5 <a class="header-anchor" href="#タスク-5" aria-label="Permalink to &quot;タスク 5&quot;">​</a></h3><p><code>Request5Concurrent.kt</code> ファイルで、以前の <code>loadContributorsSuspend()</code> 関数を使用して <code>loadContributorsConcurrent()</code> 関数を実装します。</p>',39)),s[17]||(s[17]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"タスク-5-のヒント",tabindex:"-1"},[a("タスク 5 のヒント "),i("a",{class:"header-anchor",href:"#タスク-5-のヒント","aria-label":'Permalink to "タスク 5 のヒント {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[18]||(s[18]=n(`<p>コルーチンはコルーチンスコープ内でしか開始できません。<code>loadContributorsSuspend()</code> の内容を <code>coroutineScope</code> 呼び出しにコピーして、そこで <code>async</code> 関数を呼び出せるようにします。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> coroutineScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>以下のスキームに基づいて解決策を作成してください：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deferreds: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Deferred</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // load contributors for each repo</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">deferreds.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">awaitAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// List&lt;List&lt;User&gt;&gt;</span></span></code></pre></div>`,4)),s[19]||(s[19]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"タスク-5-の解決策",tabindex:"-1"},[a("タスク 5 の解決策 "),i("a",{class:"header-anchor",href:"#タスク-5-の解決策","aria-label":'Permalink to "タスク 5 の解決策 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[20]||(s[20]=n(`<p>各「コントリビューター」リクエストを <code>async</code> でラップして、リポジトリの数だけコルーチンを作成します。<code>async</code> は <code>Deferred&lt;List&lt;User&gt;&gt;</code> を返します。これは問題ありません。なぜなら、新しいコルーチンの作成はリソース集約的ではないため、必要なだけ作成できるからです。</p><ol><li><p><code>flatMap</code> はもう使えません。なぜなら、<code>map</code> の結果はリストのリストではなく、<code>Deferred</code> オブジェクトのリストになったからです。<code>awaitAll()</code> は <code>List&lt;List&lt;User&gt;&gt;</code> を返すので、<code>flatten().aggregate()</code> を呼び出して結果を取得します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> coroutineScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> service</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrgRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deferreds: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Deferred</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    deferreds.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">awaitAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">flatten</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>コードを実行し、ログを確認します。マルチスレッド処理はまだ採用されていませんが、すべてのコルーチンがメイン UI スレッドで実行されていることがわかりますが、コルーチンを並行して実行することの利点はすでに確認できます。</p></li><li><p>このコードを変更して、共通スレッドプールから異なるスレッドで「コントリビューター」コルーチンを実行するには、<code>async</code> 関数のコンテキスト引数として <code>Dispatchers.Default</code> を指定します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dispatchers.Default) { }</span></span></code></pre></div><ul><li><code>CoroutineDispatcher</code> は、対応するコルーチンがどのスレッドで実行されるべきかを決定します。引数として指定しない場合、<code>async</code> は外側のスコープからディスパッチャーを使用します。</li><li><code>Dispatchers.Default</code> は JVM 上の共有スレッドプールを表します。このプールは並列実行の手段を提供します。利用可能な CPU コアの数と同じ数のスレッドで構成されますが、コアが1つしかない場合でも2つのスレッドを持ちます。</li></ul></li><li><p><code>loadContributorsConcurrent()</code> 関数のコードを修正して、共通スレッドプールから異なるスレッドで新しいコルーチンを開始するようにします。また、リクエストを送信する前に追加のログを追加します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dispatchers.Default) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;starting loading for \${repo.name}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>プログラムをもう一度実行します。ログでは、各コルーチンがスレッドプールから1つのスレッドで開始され、別のスレッドで再開されることがわかります。</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1946 [DefaultDispatcher-worker-2 @coroutine#4] INFO  Contributors - starting loading for kotlin-koans</span></span>
<span class="line"><span>1946 [DefaultDispatcher-worker-3 @coroutine#5] INFO  Contributors - starting loading for dokka</span></span>
<span class="line"><span>1946 [DefaultDispatcher-worker-1 @coroutine#3] INFO  Contributors - starting loading for ts2kt</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>2178 [DefaultDispatcher-worker-1 @coroutine#4] INFO  Contributors - kotlin-koans: loaded 45 contributors</span></span>
<span class="line"><span>2569 [DefaultDispatcher-worker-1 @coroutine#5] INFO  Contributors - dokka: loaded 36 contributors</span></span>
<span class="line"><span>2821 [DefaultDispatcher-worker-2 @coroutine#3] INFO  Contributors - ts2kt: loaded 11 contributors</span></span></code></pre></div><p>たとえば、このログ抜粋では、<code>coroutine#4</code> は <code>worker-2</code> スレッドで開始され、<code>worker-1</code> スレッドで継続されています。</p></li></ol><p><code>src/contributors/Contributors.kt</code> で、<em>CONCURRENT</em> オプションの実装を確認します。</p><ol><li><p>コルーチンをメイン UI スレッドでのみ実行するには、<code>Dispatchers.Main</code> を引数として指定します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dispatchers.Main) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>メインスレッドがビジー状態のときに新しいコルーチンをそのスレッドで開始すると、コルーチンはサスペンドされ、そのスレッドでの実行がスケジュールされます。コルーチンはスレッドが空きになるまで再開されません。</li><li>各エンドポイントで明示的にディスパッチャーを指定するよりも、外側のスコープからディスパッチャーを使用するのが良いプラクティスとされています。<code>loadContributorsConcurrent()</code> を <code>Dispatchers.Default</code> を引数として渡さずに定義した場合、この関数を任意のコンテキストで呼び出すことができます。<code>Default</code> ディスパッチャー、メイン UI スレッド、またはカスタムディスパッチャーを使用できます。</li><li>後で説明するように、テストから <code>loadContributorsConcurrent()</code> を呼び出す場合、<code>TestDispatcher</code> のコンテキストで呼び出すことができ、これによりテストが簡素化されます。これにより、この解決策ははるかに柔軟になります。</li></ul></li><li><p>呼び出し元側でディスパッチャーを指定するには、<code>loadContributorsConcurrent</code> が継承されたコンテキストでコルーチンを開始できるようにプロジェクトに次の変更を適用します：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dispatchers.Default) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service, req)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    withContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dispatchers.Main) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users, startTime)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>updateResults()</code> はメイン UI スレッドで呼び出す必要があるため、<code>Dispatchers.Main</code> のコンテキストで呼び出します。</li><li><code>withContext()</code> は、指定されたコルーチンコンテキストで与えられたコードを呼び出し、完了するまでサスペンドされ、結果を返します。これを表現するもう一つの方法として、新しいコルーチンを開始し、完了するまで明示的に待機（サスペンド）するという、より冗長な方法があります：<code>launch(context) { ... }.join()</code>。</li></ul></li><li><p>コードを実行し、コルーチンがスレッドプールからスレッド上で実行されることを確認します。</p></li></ol><h2 id="構造化並行性" tabindex="-1">構造化並行性 <a class="header-anchor" href="#構造化並行性" aria-label="Permalink to &quot;構造化並行性&quot;">​</a></h2><ul><li>_コルーチンスコープ_は、異なるコルーチン間の構造と親子関係を担当します。新しいコルーチンは通常、スコープ内で開始する必要があります。</li><li>_コルーチンコンテキスト_は、コルーチンのカスタム名や、コルーチンがスケジュールされるスレッドを指定するディスパッチャーなど、特定のコルーチンを実行するために使用される追加の技術情報を格納します。</li></ul><p><code>launch</code>、<code>async</code>、または <code>runBlocking</code> を使用して新しいコルーチンを開始すると、それらは自動的に対応するスコープを作成します。これらの関数はすべてレシーバー付きラムダを引数として取り、<code>CoroutineScope</code> は暗黙的なレシーバー型です。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* this: CoroutineScope */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><ul><li>新しいコルーチンはスコープ内でのみ開始できます。</li><li><code>launch</code> と <code>async</code> は <code>CoroutineScope</code> の拡張として宣言されているため、呼び出す際には常に暗黙的または明示的なレシーバーを渡す必要があります。</li><li><code>runBlocking</code> によって開始されたコルーチンは唯一の例外です。なぜなら、<code>runBlocking</code> はトップレベル関数として定義されているからです。しかし、これは現在のスレッドをブロックするため、主に <code>main()</code> 関数やテストでブリッジ関数として使用することを目的としています。</li></ul><p><code>runBlocking</code>、<code>launch</code>、<code>async</code> の内部で新しいコルーチンは自動的にスコープ内で開始されます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* this: CoroutineScope */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // the same as:   </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>runBlocking</code> 内で <code>launch</code> を呼び出すと、それは <code>CoroutineScope</code> 型の暗黙的なレシーバーの拡張として呼び出されます。あるいは、明示的に <code>this.launch</code> と書くこともできます。</p><p>ネストされたコルーチン（この例では <code>launch</code> によって開始されたもの）は、外側のコルーチン（<code>runBlocking</code> によって開始されたもの）の子と見なすことができます。この「親子」関係はスコープを介して機能します。子コルーチンは親コルーチンに対応するスコープから開始されます。</p><p><code>coroutineScope</code> 関数を使用して、新しいコルーチンを開始せずに新しいスコープを作成することが可能です。<code>suspend</code> 関数内で外側のスコープにアクセスせずに構造化された方法で新しいコルーチンを開始するには、<code>suspend</code> 関数が呼び出された外側のスコープの子として自動的になる新しいコルーチンスコープを作成できます。<code>loadContributorsConcurrent()</code> は良い例です。</p><p><code>GlobalScope.async</code> や <code>GlobalScope.launch</code> を使用して、グローバルスコープから新しいコルーチンを開始することもできます。これにより、トップレベルの「独立した」コルーチンが作成されます。</p><p>コルーチンの構造の背後にあるメカニズムは、_構造化並行性_と呼ばれます。これはグローバルスコープと比較して以下の利点を提供します。</p><ul><li>スコープは通常、子のコルーチンを管理し、そのライフタイムはスコープのライフタイムに結びつけられます。</li><li>何らかの異常が発生した場合や、ユーザーが心変わりして操作を取り消すことにした場合、スコープは子のコルーチンを自動的にキャンセルできます。</li><li>スコープは、すべての子コルーチンの完了を自動的に待ちます。したがって、スコープがコルーチンに対応する場合、そのスコープで起動されたすべてのコルーチンが完了するまで、親コルーチンは完了しません。</li></ul><p><code>GlobalScope.async</code> を使用する場合、いくつかのコルーチンをより小さなスコープにバインドする構造はありません。グローバルスコープから開始されたコルーチンはすべて独立しており、そのライフタイムはアプリケーション全体のライフタイムによってのみ制限されます。グローバルスコープから開始されたコルーチンへの参照を保存し、その完了を待つか、明示的にキャンセルすることは可能ですが、構造化並行性の場合のように自動的には行われません。</p><h3 id="コントリビューターのロードをキャンセルする" tabindex="-1">コントリビューターのロードをキャンセルする <a class="header-anchor" href="#コントリビューターのロードをキャンセルする" aria-label="Permalink to &quot;コントリビューターのロードをキャンセルする&quot;">​</a></h3><p>コントリビューターのリストをロードする関数の2つのバージョンを作成します。親コルーチンをキャンセルしようとしたときに、両方のバージョンがどのように動作するかを比較します。最初のバージョンは <code>coroutineScope</code> を使用してすべての子コルーチンを開始し、2番目のバージョンは <code>GlobalScope</code> を使用します。</p><ol><li><p><code>Request5Concurrent.kt</code> に、<code>loadContributorsConcurrent()</code> 関数に 3 秒の遅延を追加します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> coroutineScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;starting loading for \${repo.name}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // load repo contributors</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>この遅延は、リクエストを送信するすべてのコルーチンに影響を与えるため、コルーチンが開始された後、リクエストが送信される前にロードをキャンセルするのに十分な時間があります。</p></li><li><p>ロード関数の2番目のバージョンを作成します。<code>loadContributorsConcurrent()</code> の実装を <code>Request5NotCancellable.kt</code> の <code>loadContributorsNotCancellable()</code> にコピーし、新しい <code>coroutineScope</code> の作成を削除します。</p></li><li><p><code>async</code> 呼び出しは解決に失敗するため、<code>GlobalScope.async</code> を使用して開始します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsNotCancellable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    GlobalScope.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;starting loading for \${repo.name}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // load repo contributors</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deferreds.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">awaitAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">flatten</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>この関数は、ラムダ内の最後の式としてではなく、直接結果を返します（行 <code>#1</code> と <code>#3</code>）。</li><li>すべての「コントリビューター」コルーチンは、コルーチンスコープの子としてではなく、<code>GlobalScope</code> 内で開始されます（行 <code>#2</code>）。</li></ul></li><li><p>プログラムを実行し、<em>CONCURRENT</em> オプションを選択してコントリビューターをロードします。</p></li><li><p>すべての「コントリビューター」コルーチンが開始されるまで待機し、<em>Cancel</em> をクリックします。ログには新しい結果が表示されず、すべてのリクエストが実際にキャンセルされたことを意味します。</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>2896 [AWT-EventQueue-0 @coroutine#1] INFO  Contributors - kotlin: loaded 40 repos</span></span>
<span class="line"><span>2901 [DefaultDispatcher-worker-2 @coroutine#4] INFO  Contributors - starting loading for kotlin-koans</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>2909 [DefaultDispatcher-worker-5 @coroutine#36] INFO  Contributors - starting loading for mpp-example</span></span>
<span class="line"><span>/* &#39;cancel&#39; をクリック */</span></span>
<span class="line"><span>/* リクエストは送信されない */</span></span></code></pre></div></li><li><p>ステップ 5 を繰り返しますが、今回は <code>NOT_CANCELLABLE</code> オプションを選択します。</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>2570 [AWT-EventQueue-0 @coroutine#1] INFO  Contributors - kotlin: loaded 30 repos</span></span>
<span class="line"><span>2579 [DefaultDispatcher-worker-1 @coroutine#4] INFO  Contributors - starting loading for kotlin-koans</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>2586 [DefaultDispatcher-worker-6 @coroutine#36] INFO  Contributors - starting loading for mpp-example</span></span>
<span class="line"><span>/* &#39;cancel&#39; をクリック */</span></span>
<span class="line"><span>/* しかし、すべてのリクエストはまだ送信されている: */</span></span>
<span class="line"><span>6402 [DefaultDispatcher-worker-5 @coroutine#4] INFO  Contributors - kotlin-koans: loaded 45 contributors</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>9555 [DefaultDispatcher-worker-8 @coroutine#36] INFO  Contributors - mpp-example: loaded 8 contributors</span></span></code></pre></div><p>この場合、コルーチンはキャンセルされず、すべてのリクエストは引き続き送信されます。</p></li><li><p>「コントリビューター」プログラムでキャンセルがどのようにトリガーされるかを確認します。<em>Cancel</em> ボタンがクリックされると、メインの「ローディング」コルーチンが明示的にキャンセルされ、子コルーチンが自動的にキャンセルされます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Contributors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getSelectedVariant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            CONCURRENT </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service, req)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users, startTime)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setUpCancellation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Job</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setUpCancellation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loadingJob </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // #2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // cancel the loading job if the &#39;cancel&#39; button was clicked:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> listener </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ActionListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            loadingJob.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cancel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()            </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #3</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            updateLoadingStatus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CANCELED)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // add a listener to the &#39;cancel&#39; button:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        addCancelListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(listener)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // update the status and remove the listener</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // after the loading job is completed</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ol><p><code>launch</code> 関数は <code>Job</code> のインスタンスを返します。<code>Job</code> は、すべてのデータをロードし、結果を更新する「ローディングコルーチン」への参照を格納します。<code>setUpCancellation()</code> 拡張関数をレシーバーとして <code>Job</code> のインスタンスを渡して呼び出すことができます（行 <code>#1</code>）。</p><p>これを表現する別の方法は、明示的に次のように書くことです。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> job </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">job.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setUpCancellation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li>可読性を高めるために、関数内で <code>setUpCancellation()</code> 関数のレシーバーを新しい <code>loadingJob</code> 変数で参照できます（行 <code>#2</code>）。</li><li>次に、<em>Cancel</em> ボタンにリスナーを追加して、クリックされたときに <code>loadingJob</code> がキャンセルされるようにします（行 <code>#3</code>）。</li></ul><p>構造化並行性を使用すると、親コルーチンをキャンセルするだけで、自動的にすべての子コルーチンにキャンセルが伝播されます。</p><h3 id="外側のスコープのコンテキストを使用する" tabindex="-1">外側のスコープのコンテキストを使用する <a class="header-anchor" href="#外側のスコープのコンテキストを使用する" aria-label="Permalink to &quot;外側のスコープのコンテキストを使用する&quot;">​</a></h3><p>与えられたスコープ内で新しいコルーチンを開始すると、それらすべてが同じコンテキストで実行されることを確認するのがはるかに簡単になります。また、必要に応じてコンテキストを置き換えることもはるかに簡単です。</p><p>さて、外側のスコープからディスパッチャーを使用する方法を学ぶ時です。<code>coroutineScope</code> またはコルーチンビルダーによって作成された新しいスコープは、常に外側のスコープからコンテキストを継承します。この場合、外側のスコープは <code>suspend loadContributorsConcurrent()</code> 関数が呼び出されたスコープです。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dispatchers.Default) {  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// outer scope</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service, req)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>すべてのネストされたコルーチンは、継承されたコンテキストで自動的に開始されます。ディスパッチャーはこのコンテキストの一部です。そのため、<code>async</code> によって開始されたすべてのコルーチンは、デフォルトディスパッチャーのコンテキストで開始されます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> coroutineScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // this scope inherits the context from the outer scope</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// nested coroutine started with the inherited context</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>構造化並行性を使用すると、トップレベルのコルーチンを作成するときに、主要なコンテキスト要素（ディスパッチャーなど）を一度だけ指定できます。その後、すべてのネストされたコルーチンはコンテキストを継承し、必要に応じてのみ変更します。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>UI アプリケーション（例えば Android アプリケーション）でコルーチンを使ったコードを書く場合、トップコルーチンにはデフォルトで <code>CoroutineDispatchers.Main</code> を使い、異なるスレッドでコードを実行する必要がある場合にのみ別のディスパッチャーを明示的に指定するのが一般的なプラクティスです。</p></div><h2 id="進行状況の表示" tabindex="-1">進行状況の表示 <a class="header-anchor" href="#進行状況の表示" aria-label="Permalink to &quot;進行状況の表示&quot;">​</a></h2><p>いくつかのリポジトリの情報はかなり迅速にロードされるにもかかわらず、ユーザーはすべてのデータがロードされて初めて結果リストを見ることができます。それまで、ローダーアイコンは進行状況を表示し続けますが、現在の状態や既にロードされたコントリビューターに関する情報はありません。</p><p>中間結果を早期に表示し、各リポジトリのデータがロードされた後、すべてのコントリビューターを表示することができます。</p><p><img src="`+A+`" alt="Loading data" width="500"></p><p>この機能を実装するには、<code>src/tasks/Request6Progress.kt</code> で UI を更新するロジックをコールバックとして渡し、各中間状態が呼ばれるようにする必要があります。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsProgress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    updateResults: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">suspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">completed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // loading the data</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // calling \`updateResults()\` on intermediate states</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>Contributors.kt</code> の呼び出しサイトでは、<em>PROGRESS</em> オプションのために <code>Main</code> スレッドから結果を更新するようにコールバックが渡されます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dispatchers.Default) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    loadContributorsProgress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service, req) { users, completed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        withContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dispatchers.Main) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users, startTime, completed)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>updateResults()</code> パラメーターは <code>loadContributorsProgress()</code> で <code>suspend</code> と宣言されています。対応するラムダ引数内で <code>suspend</code> 関数である <code>withContext</code> を呼び出す必要があります。</li><li><code>updateResults()</code> コールバックは、ロードが完了し、結果が最終的なものであるかどうかを指定する追加の Boolean パラメーターを引数として取ります。</li></ul><h3 id="タスク-6" tabindex="-1">タスク 6 <a class="header-anchor" href="#タスク-6" aria-label="Permalink to &quot;タスク 6&quot;">​</a></h3><p><code>Request6Progress.kt</code> ファイルで、中間進行状況を表示する <code>loadContributorsProgress()</code> 関数を実装します。<code>Request4Suspend.kt</code> の <code>loadContributorsSuspend()</code> 関数をベースにしてください。</p><ul><li>並行性のない単純なバージョンを使用してください。並行性は次のセクションで追加します。</li><li>コントリビューターの中間リストは、「集計された」状態で表示されるべきであり、各リポジトリにロードされたユーザーのリストだけではありません。</li><li>各ユーザーの総貢献数は、新しいリポジトリのデータがロードされるときに増加させる必要があります。</li></ul>`,46)),s[21]||(s[21]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"タスク-6-の解決策",tabindex:"-1"},[a("タスク 6 の解決策 "),i("a",{class:"header-anchor",href:"#タスク-6-の解決策","aria-label":'Permalink to "タスク 6 の解決策 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[22]||(s[22]=n(`<p>ロードされたコントリビューターの中間リストを「集計された」状態で保存するには、ユーザーのリストを保存する <code>allUsers</code> 変数を定義し、新しいリポジトリのコントリビューターがロードされた後にそれを更新します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsProgress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    updateResults: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">suspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">completed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> service</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrgRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> emptyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((index, repo) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withIndex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allUsers, index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.lastIndex)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="連続-vs-並行" tabindex="-1">連続 vs 並行 <a class="header-anchor" href="#連続-vs-並行" aria-label="Permalink to &quot;連続 vs 並行&quot;">​</a></h4><p><code>updateResults()</code> コールバックは、各リクエストが完了した後に呼び出されます。</p><p><img src="`+v+'" alt="Progress on requests" width="700"></p><p>このコードには並行性は含まれていません。シーケンシャルなので、同期は必要ありません。</p><p>最良のオプションは、リクエストを並行して送信し、各リポジトリの応答を受け取った後で中間結果を更新することです。</p><p><img src="'+m+'" alt="Concurrent requests" width="700"></p><p>並行性を追加するには、_チャネル_を使用します。</p><h2 id="チャネル" tabindex="-1">チャネル <a class="header-anchor" href="#チャネル" aria-label="Permalink to &quot;チャネル&quot;">​</a></h2><p>共有可能な可変状態を持つコードを書くことは非常に難しく、エラーが発生しやすい（コールバックを使用する解決策のように）。より簡単な方法は、共通の可変状態を使用するのではなく、コミュニケーションによって情報を共有することです。コルーチンは_チャネル_を介して互いに通信できます。</p><p>チャネルは、コルーチン間でデータを渡すことを可能にする通信プリミティブです。1つのコルーチンはチャネルに情報を_送信_でき、別のコルーチンはそこからその情報を_受信_できます。</p><p><img src="'+f+'" alt="Using channels"></p><p>情報を送信（生成）するコルーチンはプロデューサーと呼ばれることが多く、情報を受信（消費）するコルーチンはコンシューマーと呼ばれます。1つまたは複数のコルーチンが同じチャネルに情報を送信でき、1つまたは複数のコルーチンがそこからデータを受信できます。</p><p><img src="'+q+`" alt="Using channels with many coroutines"></p><p>多くのコルーチンが同じチャネルから情報を受信する場合、各要素はコンシューマーのいずれかによって一度だけ処理されます。要素が処理されると、すぐにチャネルから削除されます。</p><p>チャネルは要素のコレクション、より正確にはキューに似ていると考えることができます。要素は一方の端に追加され、もう一方の端から受信されます。ただし、重要な違いがあります。同期バージョンであっても、コレクションとは異なり、チャネルは <code>send()</code> と <code>receive()</code> 操作を_サスペンド_できます。これは、チャネルが空または満杯の場合に発生します。チャネルのサイズに上限がある場合、チャネルは満杯になる可能性があります。</p><p><code>Channel</code> は、<code>SendChannel</code>、<code>ReceiveChannel</code>、そして後者 2 つを拡張する <code>Channel</code> の 3 つの異なるインターフェースによって表現されます。通常、チャネルを作成し、プロデューサーには <code>SendChannel</code> インスタンスとして渡して、それだけがチャネルに情報を送信できるようにします。コンシューマーには <code>ReceiveChannel</code> インスタンスとして渡して、それだけがチャネルからデータを受信できるようにします。<code>send</code> と <code>receive</code> の両方のメソッドは <code>suspend</code> として宣言されています。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SendChannel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">in</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> E</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(element: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReceiveChannel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">out</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> E</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> receive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">E</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SendChannel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, ReceiveChannel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">E</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>プロデューサーはチャネルを閉じて、これ以上要素が来ないことを示すことができます。</p><p>ライブラリにはいくつかのチャネル型が定義されています。これらは、内部に格納できる要素の数と、<code>send()</code> 呼び出しがサスペンドできるかどうかが異なります。すべてのチャネル型で、<code>receive()</code> 呼び出しは同様に動作します。チャネルが空でなければ要素を受信し、そうでなければサスペンドされます。</p>`,21)),l(h,{collapsible:"true"},{default:t(()=>[l(p,{title:"無制限チャネル (Unlimited channel)"},{default:t(()=>s[0]||(s[0]=[i("p",null,[a("無制限チャネルはキューに最も近いアナログです。プロデューサーはこのチャネルに要素を送信でき、それは無制限に増え続けます。"),i("code",null,"send()"),a(" 呼び出しは決してサスペンドされません。プログラムがメモリ不足になると、"),i("code",null,"OutOfMemoryException"),a(" が発生します。無制限チャネルとキューの違いは、コンシューマーが空のチャネルから受信しようとすると、新しい要素が送信されるまでサスペンドされることです。")],-1),i("img",{src:k,alt:"Unlimited channel",width:"500"},null,-1)])),_:1}),l(p,{title:"バッファリングされたチャネル (Buffered channel)"},{default:t(()=>s[1]||(s[1]=[i("p",null,[a("バッファリングされたチャネルのサイズは、指定された数によって制約されます。プロデューサーはサイズ制限に達するまでこのチャネルに要素を送信できます。すべての要素は内部に保存されます。チャネルが満杯になると、次の "),i("code",null,"send"),a(" 呼び出しは、より多くの空きスペースが利用可能になるまでサスペンドされます。")],-1),i("img",{src:r,alt:"Buffered channel",width:"500"},null,-1)])),_:1}),l(p,{title:"ランデブーチャネル (Rendezvous channel)"},{default:t(()=>s[2]||(s[2]=[i("p",null,[a("「ランデブー」チャネルはバッファのないチャネルで、サイズゼロのバッファリングされたチャネルと同じです。一方の関数（"),i("code",null,"send()"),a(" または "),i("code",null,"receive()"),a("）は、もう一方が呼び出されるまで常にサスペンドされます。")],-1),i("p",null,[i("code",null,"send()"),a(" 関数が呼び出され、要素を処理する準備ができているサスペンドされた "),i("code",null,"receive()"),a(" 呼び出しがない場合、"),i("code",null,"send()"),a(" はサスペンドされます。同様に、"),i("code",null,"receive()"),a(" 関数が呼び出され、チャネルが空であるか、言い換えれば要素を送信する準備ができているサスペンドされた "),i("code",null,"send()"),a(" 呼び出しがない場合、"),i("code",null,"receive()"),a(" 呼び出しはサスペンドされます。")],-1),i("p",null,[a("「ランデブー」という名前（「合意された日時と場所での会合」）は、"),i("code",null,"send()"),a(" と "),i("code",null,"receive()"),a(" が「時間通りに会う」べきであるという事実に言及しています。")],-1),i("img",{src:d,alt:"Rendezvous channel",width:"500"},null,-1)])),_:1}),l(p,{title:"コンフラクテッドチャネル (Conflated channel)"},{default:t(()=>s[3]||(s[3]=[i("p",null,[a("コンフラクテッドチャネルに送信された新しい要素は、以前に送信された要素を上書きするため、レシーバーは常に最新の要素のみを取得します。"),i("code",null,"send()"),a(" 呼び出しは決してサスペンドされません。")],-1),i("img",{src:E,alt:"Conflated channel",width:"500"},null,-1)])),_:1})]),_:1}),s[23]||(s[23]=n(`<p>チャネルを作成する際には、その型またはバッファサイズ（バッファ付きが必要な場合）を指定します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rendezvousChannel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bufferedChannel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> conflatedChannel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(CONFLATED)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unlimitedChannel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(UNLIMITED)</span></span></code></pre></div><p>デフォルトでは、「ランデブー」チャネルが作成されます。</p><p>次のタスクでは、「ランデブー」チャネル、2つのプロデューサーコルーチン、および1つのコンシューマーコルーチンを作成します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.channels.Channel</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> channel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A done&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;B1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;B done&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">receive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;[\${Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">().name}] </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$message</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>チャネルについてさらに理解を深めるには、<a href="https://www.youtube.com/watch?v=HpWQUoVURWQ" target="_blank" rel="noreferrer">このビデオ</a>をご覧ください。</p></div><h3 id="タスク-7" tabindex="-1">タスク 7 <a class="header-anchor" href="#タスク-7" aria-label="Permalink to &quot;タスク 7&quot;">​</a></h3><p><code>src/tasks/Request7Channels.kt</code> で、すべての GitHub コントリビューターを並行してリクエストし、同時に中間進行状況を表示する <code>loadContributorsChannels()</code> 関数を実装します。</p><p>以前の関数、<code>Request5Concurrent.kt</code> の <code>loadContributorsConcurrent()</code> と <code>Request6Progress.kt</code> の <code>loadContributorsProgress()</code> を使用してください。</p>`,9)),s[24]||(s[24]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"タスク-7-のヒント",tabindex:"-1"},[a("タスク 7 のヒント "),i("a",{class:"header-anchor",href:"#タスク-7-のヒント","aria-label":'Permalink to "タスク 7 のヒント {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[25]||(s[25]=n(`<p>異なるリポジトリのコントリビューターリストを並行して受信する異なるコルーチンは、受信したすべての結果を同じチャネルに送信できます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> channel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TODO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>次に、このチャネルからの要素を1つずつ受信して処理できます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repos.size) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">receive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>receive()</code> 呼び出しは順次行われるため、追加の同期は必要ありません。</p>`,5)),s[26]||(s[26]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"タスク-7-の解決策",tabindex:"-1"},[a("タスク 7 の解決策 "),i("a",{class:"header-anchor",href:"#タスク-7-の解決策","aria-label":'Permalink to "タスク 7 の解決策 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[27]||(s[27]=n(`<p><code>loadContributorsProgress()</code> 関数と同様に、「すべてのコントリビューター」リストの中間状態を保存するための <code>allUsers</code> 変数を作成できます。チャネルから受信した新しいリストは、すべてのユーザーのリストに追加されます。結果を集計し、<code>updateResults</code> コールバックを使用して状態を更新します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsChannels</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    updateResults: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">suspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">completed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> coroutineScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> service</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrgRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> channel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> emptyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repos.size) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">receive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allUsers, it </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.lastIndex)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>異なるリポジトリの結果は、準備が整い次第チャネルに追加されます。まず、すべてのリクエストが送信され、データが受信されていない場合、<code>receive()</code> 呼び出しはサスペンドされます。この場合、「コントリビューターをロードする」コルーチン全体がサスペンドされます。</li><li>次に、ユーザーのリストがチャネルに送信されると、「コントリビューターをロードする」コルーチンは再開され、<code>receive()</code> 呼び出しはこのリストを返し、結果はすぐに更新されます。</li></ul><p>これで、プログラムを実行し、<em>CHANNELS</em> オプションを選択してコントリビューターをロードし、結果を確認できます。</p><p>コルーチンもチャネルも、並行性に伴う複雑さを完全に排除するわけではありませんが、何が起こっているかを理解する必要がある場合には、生活を楽にしてくれます。</p><h2 id="コルーチンのテスト" tabindex="-1">コルーチンのテスト <a class="header-anchor" href="#コルーチンのテスト" aria-label="Permalink to &quot;コルーチンのテスト&quot;">​</a></h2><p>コルーチンを用いた並行処理の解決策がサスペンド関数を用いた解決策よりも速いこと、そしてチャネルを用いた解決策が単純な「進行状況」の解決策よりも速いことを確認するために、すべての解決策をテストしてみましょう。</p><p>次のタスクでは、解決策の総実行時間を比較します。GitHub サービスをモックし、このサービスが指定されたタイムアウト後に結果を返すようにします。</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>リポジトリリクエスト - 1000 ミリ秒の遅延で応答を返す</span></span>
<span class="line"><span>リポジトリ-1 - 1000 ミリ秒の遅延</span></span>
<span class="line"><span>リポジトリ-2 - 1200 ミリ秒の遅延</span></span>
<span class="line"><span>リポジトリ-3 - 800 ミリ秒の遅延</span></span></code></pre></div><p><code>suspend</code> 関数を使用したシーケンシャルな解決策は、約 4000 ミリ秒（4000 = 1000 + (1000 + 1200 + 800)）かかるはずです。並行処理の解決策は、約 2200 ミリ秒（2200 = 1000 + max(1000, 1200, 800)）かかるはずです。</p><p>進行状況を表示する解決策の場合、タイムスタンプ付きの中間結果も確認できます。</p><p>対応するテストデータは <code>test/contributors/testData.kt</code> に定義されており、<code>Request4SuspendKtTest</code>、<code>Request7ChannelsKtTest</code> などには、モックサービス呼び出しを使用する簡単なテストが含まれています。</p><p>しかし、ここには 2 つの問題があります。</p><ul><li>これらのテストは実行に時間がかかりすぎます。各テストは約 2 ～ 4 秒かかり、毎回結果を待つ必要があります。これは非常に効率が悪いです。</li><li>コードの準備と実行に余分な時間がかかるため、解決策が実行される正確な時間に頼ることはできません。定数を追加することはできますが、その場合、時間はマシンごとに異なります。モックサービスの遅延は、違いを確認できるように、この定数よりも高くする必要があります。定数が 0.5 秒の場合、遅延を 0.1 秒にしても十分ではありません。</li></ul><p>より良い方法は、特殊なフレームワークを使用して、同じコードを複数回実行しながらタイミングをテストすることですが（これにより合計時間はさらに増加します）、これは学習とセットアップが複雑です。</p><p>これらの問題を解決し、提供されたテスト遅延を持つ解決策が期待どおりに動作することを確認するために、特に一方が他方よりも高速であるということを確認するために、特殊なテストディスパッチャーを使用した_仮想時間_を使用します。このディスパッチャーは、開始からの仮想時間を追跡し、すべてをリアルタイムで即座に実行します。このディスパッチャーでコルーチンを実行すると、<code>delay</code> はすぐに戻り、仮想時間を進めます。</p><p>このメカニズムを使用するテストは高速で実行されますが、仮想時間の異なる瞬間に何が起こるかを確認できます。総実行時間は劇的に減少します。</p><p><img src="`+_+`" alt="Comparison for total running time" width="700"></p><p>仮想時間を使用するには、<code>runBlocking</code> の呼び出しを <code>runTest</code> に置き換えます。<code>runTest</code> は <code>TestScope</code> への拡張ラムダを引数として取ります。この特殊なスコープ内で <code>suspend</code> 関数で <code>delay</code> を呼び出すと、<code>delay</code> はリアルタイムで遅延する代わりに仮想時間を進めます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testDelayInSuspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> realStartTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentTimeMillis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> virtualStartTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\${System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentTimeMillis</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> realStartTime} ms&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ~ 6 ms</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\${currentTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> virtualStartTime} ms&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)             </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1000 ms</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// auto-advances without delay</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// executes eagerly when foo() is called</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>この例での実際の実行時間は数ミリ秒ですが、仮想時間は遅延引数と同じ 1000 ミリ秒です。</p><p>子のコルーチンで「仮想」<code>delay</code> の完全な効果を得るには、すべての子コルーチンを <code>TestDispatcher</code> で開始します。そうしないと機能しません。このディスパッチャーは、異なるディスパッチャーを提供しない限り、他の <code>TestScope</code> から自動的に継承されます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testDelayInLaunch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> realStartTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentTimeMillis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> virtualStartTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\${System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentTimeMillis</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> realStartTime} ms&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ~ 11 ms</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\${currentTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> virtualStartTime} ms&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)             </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1000 ms</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> coroutineScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// auto-advances without delay</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// executes eagerly when bar() is called</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>上記の例で <code>launch</code> が <code>Dispatchers.Default</code> のコンテキストで呼び出された場合、テストは失敗します。ジョブがまだ完了していないという例外が発生します。</p><p><code>loadContributorsConcurrent()</code> 関数は、子コルーチンを <code>Dispatchers.Default</code> ディスパッチャーを使用して変更せずに、継承されたコンテキストで開始する場合にのみ、このようにテストできます。</p><p>ディスパッチャーのようなコンテキスト要素は、関数を_定義する_ときではなく、_呼び出す_ときに指定できます。これにより、柔軟性が増し、テストが容易になります。</p><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>仮想時間をサポートするテスト API は <a href="/ja/kotlin/components-stability">Experimental</a> であり、将来変更される可能性があります。</p></div><p>デフォルトでは、コンパイラは実験的なテスト API を使用している場合に警告を表示します。これらの警告を抑制するには、テスト関数またはテストを含むクラス全体に <code>@OptIn(ExperimentalCoroutinesApi::class)</code> をアノテーションします。コンパイラに実験的な API を使用していることを指示するコンパイラ引数を追加します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compileTestKotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    kotlinOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeCompilerArgs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;-Xuse-experimental=kotlin.Experimental&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>このチュートリアルに対応するプロジェクトでは、コンパイラ引数はすでに Gradle スクリプトに追加されています。</p><h3 id="タスク-8" tabindex="-1">タスク 8 <a class="header-anchor" href="#タスク-8" aria-label="Permalink to &quot;タスク 8&quot;">​</a></h3><p><code>tests/tasks/</code> にある以下のテストを、実時間ではなく仮想時間を使用するようにリファクタリングします。</p><ul><li>Request4SuspendKtTest.kt</li><li>Request5ConcurrentKtTest.kt</li><li>Request6ProgressKtTest.kt</li><li>Request7ChannelsKtTest.kt</li></ul><p>リファクタリング適用前と後の総実行時間を比較してください。</p>`,34)),s[28]||(s[28]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"タスク-8-のヒント",tabindex:"-1"},[a("タスク 8 のヒント "),i("a",{class:"header-anchor",href:"#タスク-8-のヒント","aria-label":'Permalink to "タスク 8 のヒント {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[29]||(s[29]=n(`<ol><li><p><code>runBlocking</code> 呼び出しを <code>runTest</code> に、<code>System.currentTimeMillis()</code> を <code>currentTime</code> に置き換えます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // action</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> totalTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startTime</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // testing result</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>正確な仮想時間をチェックするアサーションのコメントを解除します。</p></li><li><p><code>@UseExperimental(ExperimentalCoroutinesApi::class)</code> を追加することを忘れないでください。</p></li></ol>`,1)),s[30]||(s[30]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"タスク-8-の解決策",tabindex:"-1"},[a("タスク 8 の解決策 "),i("a",{class:"header-anchor",href:"#タスク-8-の解決策","aria-label":'Permalink to "タスク 8 の解決策 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[31]||(s[31]=n(`<p>並行処理とチャネルのケースの解決策を以下に示します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MockGithubService, testRequestData)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Assert.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">assertEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Wrong result for &#39;loadContributorsConcurrent&#39;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, expectedConcurrentResults.users, result)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> totalTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startTime</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Assert.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">assertEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;The calls run concurrently, so the total virtual time should be 2200 ms: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                &quot;1000 for repos request plus max(1000, 1200, 800) = 1200 for concurrent contributors requests)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        expectedConcurrentResults.timeFromStart, totalTime</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>まず、結果が期待される仮想時間に正確に利用可能であることを確認し、次に結果自体を確認します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testChannels</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    loadContributorsChannels</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MockGithubService, testRequestData) { users, _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> expected </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> concurrentProgressResults[index</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> time </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startTime</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Assert.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">assertEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            &quot;Expected intermediate results after \${expected.timeFromStart} ms:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            expected.timeFromStart, time</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Assert.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">assertEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Wrong intermediate results after </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$time</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, expected.users, users)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>チャネルを使用する最後のバージョンの中間結果は、プログレスバージョンよりも早く利用可能になり、仮想時間を使用するテストでその違いを確認できます。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>残りの「サスペンド」および「プログレス」タスクのテストは非常に似ています。プロジェクトの <code>solutions</code> ブランチでそれらを見つけることができます。</p></div><h2 id="次に学ぶこと" tabindex="-1">次に学ぶこと <a class="header-anchor" href="#次に学ぶこと" aria-label="Permalink to &quot;次に学ぶこと&quot;">​</a></h2><ul><li>KotlinConf の <a href="https://kotlinconf.com/workshops/" target="_blank" rel="noreferrer">Asynchronous Programming with Kotlin</a> ワークショップをチェックしてください。</li><li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/" target="_blank" rel="noreferrer">仮想時間と実験的なテストパッケージ</a>の使用についてさらに詳しく調べてください。</li></ul>`,8))])}const H=T(S,[["render",P]]);export{V as __pageData,H as default};
