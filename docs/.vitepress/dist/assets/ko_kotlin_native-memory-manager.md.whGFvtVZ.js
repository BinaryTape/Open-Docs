import{_ as h}from"./chunks/native-gc-signposts.CmU4CX4K.js";import{_ as r,C as l,c as k,o,ag as i,j as a,G as t,a as n,w as d}from"./chunks/framework.Bksy39di.js";const v=JSON.parse('{"title":"Kotlin/Native 메모리 관리","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/native-memory-manager.md","filePath":"ko/kotlin/native-memory-manager.md","lastUpdated":1754307826000}'),c={name:"ko/kotlin/native-memory-manager.md"};function g(E,s,u,y,m,F){const p=l("shortcut"),e=l("TopicTitle");return o(),k("div",null,[s[9]||(s[9]=i('<h1 id="kotlin-native-메모리-관리" tabindex="-1">Kotlin/Native 메모리 관리 <a class="header-anchor" href="#kotlin-native-메모리-관리" aria-label="Permalink to &quot;Kotlin/Native 메모리 관리&quot;">​</a></h1><p>Kotlin/Native는 JVM, Go 및 기타 주류 기술과 유사한 최신 메모리 관리자를 사용하며, 다음과 같은 특징을 포함합니다:</p><ul><li>객체는 공유 힙에 저장되며 모든 스레드에서 접근할 수 있습니다.</li><li>&quot;루트(roots)&quot;(예: 지역 변수 및 전역 변수)에서 접근할 수 없는 객체를 수집하기 위해 추적 가비지 컬렉션(tracing garbage collection)이 주기적으로 수행됩니다.</li></ul><h2 id="가비지-컬렉터" tabindex="-1">가비지 컬렉터 <a class="header-anchor" href="#가비지-컬렉터" aria-label="Permalink to &quot;가비지 컬렉터&quot;">​</a></h2><p>Kotlin/Native의 가비지 컬렉터(GC) 알고리즘은 지속적으로 발전하고 있습니다. 현재, 이는 힙을 세대별로 분리하지 않는 스톱-더-월드(stop-the-world) 마크 및 동시 스윕(concurrent sweep) 컬렉터로 작동합니다.</p><p>GC는 별도의 스레드에서 실행되며 메모리 압력 휴리스틱(heuristics) 또는 타이머에 따라 시작됩니다. 또는 <a href="#enable-garbage-collection-manually">수동으로 호출</a>할 수도 있습니다.</p><p>GC는 애플리케이션 스레드, GC 스레드 및 선택적 마커 스레드를 포함하여 여러 스레드에서 마크 큐를 병렬로 처리합니다. 애플리케이션 스레드와 최소 하나의 GC 스레드가 마킹 프로세스에 참여합니다. 기본적으로 GC가 힙의 객체를 마킹할 때 애플리케이션 스레드는 일시 중지되어야 합니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>kotlin.native.binary.gcMarkSingleThreaded=true</code> 컴파일러 옵션으로 마크 단계의 병렬화를 비활성화할 수 있습니다. 하지만 이는 대규모 힙에서 가비지 컬렉터의 일시 중지 시간을 증가시킬 수 있습니다.</p></div><p>마킹 단계가 완료되면 GC는 약한 참조(weak references)를 처리하고 마크되지 않은 객체를 가리키는 참조 포인트를 무효화합니다. 기본적으로 약한 참조는 GC 일시 중지 시간을 줄이기 위해 동시에 처리됩니다.</p><p>가비지 컬렉션을 <a href="#monitor-gc-performance">모니터링</a>하고 <a href="#optimize-gc-performance">최적화</a>하는 방법을 알아보세요.</p><h3 id="수동으로-가비지-컬렉션-활성화" tabindex="-1">수동으로 가비지 컬렉션 활성화 <a class="header-anchor" href="#수동으로-가비지-컬렉션-활성화" aria-label="Permalink to &quot;수동으로 가비지 컬렉션 활성화&quot;">​</a></h3><p>가비지 컬렉터를 강제로 시작하려면 <code>kotlin.native.internal.GC.collect()</code>를 호출합니다. 이 메서드는 새 컬렉션을 트리거하고 완료를 기다립니다.</p><h3 id="gc-성능-모니터링" tabindex="-1">GC 성능 모니터링 <a class="header-anchor" href="#gc-성능-모니터링" aria-label="Permalink to &quot;GC 성능 모니터링&quot;">​</a></h3><p>GC 성능을 모니터링하려면 로그를 살펴보고 문제를 진단할 수 있습니다. 로깅을 활성화하려면 Gradle 빌드 스크립트에서 다음 컴파일러 옵션을 설정하세요:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-Xruntime-logs=gc=info</span></span></code></pre></div><p>현재 로그는 <code>stderr</code>로만 출력됩니다.</p><p>Apple 플랫폼에서는 Xcode Instruments 툴킷을 활용하여 iOS 앱 성능을 디버그할 수 있습니다. 가비지 컬렉터는 Instruments에서 사용 가능한 사인포스트(signposts)를 통해 일시 중지를 보고합니다. 사인포스트는 앱 내에서 사용자 정의 로깅을 가능하게 하여 GC 일시 중지가 애플리케이션 정지와 일치하는지 확인할 수 있도록 합니다.</p><p>앱에서 GC 관련 일시 중지를 추적하려면:</p>',18)),a("ol",null,[s[7]||(s[7]=i('<li><p>이 기능을 활성화하려면 <code>gradle.properties</code> 파일에 다음 컴파일러 옵션을 설정하세요:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.enableSafepointSignposts=true</span></span></code></pre></div></li>',1)),a("li",null,[a("p",null,[s[1]||(s[1]=n("Xcode를 열고 ")),s[2]||(s[2]=a("strong",null,"Product",-1)),s[3]||(s[3]=n(" | ")),s[4]||(s[4]=a("strong",null,"Profile",-1)),s[5]||(s[5]=n("로 이동하거나 ")),t(p,null,{default:d(()=>s[0]||(s[0]=[n("Cmd + I")])),_:1}),s[6]||(s[6]=n("를 누르세요. 이 동작은 앱을 컴파일하고 Instruments를 시작합니다."))])]),s[8]||(s[8]=i('<li><p>템플릿 선택에서 <strong>os_signpost</strong>를 선택합니다.</p></li><li><p><strong>subsystem</strong>을 <code>org.kotlinlang.native.runtime</code>으로, <strong>category</strong>를 <code>safepoint</code>으로 지정하여 구성합니다.</p></li><li><p>빨간색 기록 버튼을 클릭하여 앱을 실행하고 사인포스트 이벤트 기록을 시작합니다:</p><p><img src="'+h+'" alt="Tracking GC pauses as signposts" width="700"></p><p>여기서 가장 아래 그래프의 각 파란색 점(blob)은 GC 일시 중지인 별도의 사인포스트 이벤트를 나타냅니다.</p></li>',3))]),s[10]||(s[10]=i(`<h3 id="gc-성능-최적화" tabindex="-1">GC 성능 최적화 <a class="header-anchor" href="#gc-성능-최적화" aria-label="Permalink to &quot;GC 성능 최적화&quot;">​</a></h3><p>GC 성능을 향상시키려면 동시 마킹(concurrent marking)을 활성화하여 GC 일시 중지 시간을 줄일 수 있습니다. 이를 통해 가비지 컬렉션의 마킹 단계가 애플리케이션 스레드와 동시에 실행될 수 있습니다.</p><p>이 기능은 현재 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적(Experimental)</a>입니다. 활성화하려면 <code>gradle.properties</code> 파일에 다음 컴파일러 옵션을 설정하세요:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.gc=cms</span></span></code></pre></div><h3 id="가비지-컬렉션-비활성화" tabindex="-1">가비지 컬렉션 비활성화 <a class="header-anchor" href="#가비지-컬렉션-비활성화" aria-label="Permalink to &quot;가비지 컬렉션 비활성화&quot;">​</a></h3><p>GC를 활성화 상태로 유지하는 것이 좋습니다. 하지만 테스트 목적이거나 문제가 발생하여 프로그램 실행 시간이 짧은 경우와 같이 특정 상황에서는 비활성화할 수 있습니다. 그렇게 하려면 <code>gradle.properties</code> 파일에 다음 바이너리 옵션을 설정하세요:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.gc=noop</span></span></code></pre></div><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>이 옵션을 활성화하면 GC가 Kotlin 객체를 수집하지 않으므로 프로그램이 실행되는 동안 메모리 소비가 계속 증가합니다. 시스템 메모리가 고갈되지 않도록 주의하세요.</p></div><h2 id="메모리-소비" tabindex="-1">메모리 소비 <a class="header-anchor" href="#메모리-소비" aria-label="Permalink to &quot;메모리 소비&quot;">​</a></h2><p>Kotlin/Native는 자체 <a href="https://github.com/JetBrains/kotlin/blob/master/kotlin-native/runtime/src/alloc/custom/README.md" target="_blank" rel="noreferrer">메모리 할당자</a>를 사용합니다. 이 할당자는 시스템 메모리를 페이지로 나누어 연속적인 순서로 독립적인 스윕(sweeping)을 허용합니다. 각 할당은 페이지 내의 메모리 블록이 되며, 페이지는 블록 크기를 추적합니다. 다양한 페이지 유형은 다양한 할당 크기에 최적화되어 있습니다. 메모리 블록의 연속적인 배열은 할당된 모든 블록을 효율적으로 반복할 수 있도록 보장합니다.</p><p>스레드가 메모리를 할당할 때, 할당 크기에 따라 적합한 페이지를 검색합니다. 스레드는 다양한 크기 범주에 대한 페이지 집합을 유지합니다. 일반적으로 주어진 크기에 대한 현재 페이지는 할당을 수용할 수 있습니다. 그렇지 않으면 스레드는 공유 할당 공간에서 다른 페이지를 요청합니다. 이 페이지는 이미 사용 가능하거나, 스윕이 필요하거나, 먼저 생성되어야 할 수 있습니다.</p><p>Kotlin/Native 메모리 할당자에는 급작스러운 메모리 할당 급증에 대한 보호 기능이 있습니다. 이 기능은 뮤테이터(mutator)가 많은 가비지를 빠르게 할당하기 시작하고 GC 스레드가 이를 따라잡지 못하여 메모리 사용량이 끝없이 증가하는 상황을 방지합니다. 이 경우 GC는 반복이 완료될 때까지 스톱-더-월드 단계를 강제합니다.</p><p>메모리 소비를 직접 모니터링하고, 메모리 누수를 확인하고, 메모리 소비를 조정할 수 있습니다.</p><h3 id="메모리-소비-모니터링" tabindex="-1">메모리 소비 모니터링 <a class="header-anchor" href="#메모리-소비-모니터링" aria-label="Permalink to &quot;메모리 소비 모니터링&quot;">​</a></h3><p>메모리 문제를 디버그하려면 메모리 관리자 메트릭을 확인할 수 있습니다. 또한 Apple 플랫폼에서 Kotlin의 메모리 소비를 추적할 수 있습니다.</p><h4 id="메모리-누수-확인" tabindex="-1">메모리 누수 확인 <a class="header-anchor" href="#메모리-누수-확인" aria-label="Permalink to &quot;메모리 누수 확인&quot;">​</a></h4><p>메모리 관리자 메트릭에 접근하려면 <code>kotlin.native.internal.GC.lastGCInfo()</code>를 호출합니다. 이 메서드는 가비지 컬렉터의 마지막 실행에 대한 통계를 반환합니다. 이 통계는 다음 용도로 유용합니다:</p><ul><li>전역 변수를 사용할 때 메모리 누수 디버깅</li><li>테스트 실행 시 누수 확인</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.native.internal.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.test.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Resource</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> global </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mutableListOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Resource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalStdlibApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getUsage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    GC.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">collect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GC.lastGCInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.memoryUsageAfter[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;heap&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.totalObjectsSizeBytes</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    global.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Resource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // The test will fail if you remove the next line</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    global.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> before </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getUsage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // A separate function is used to ensure that all temporary objects are cleared</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> after </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getUsage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assertEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(before, after)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="apple-플랫폼에서-메모리-소비-추적" tabindex="-1">Apple 플랫폼에서 메모리 소비 추적 <a class="header-anchor" href="#apple-플랫폼에서-메모리-소비-추적" aria-label="Permalink to &quot;Apple 플랫폼에서 메모리 소비 추적&quot;">​</a></h4><p>Apple 플랫폼에서 메모리 문제를 디버그할 때 Kotlin 코드에 의해 예약된 메모리 양을 확인할 수 있습니다. Kotlin의 점유율은 식별자로 태그되며 Xcode Instruments의 VM Tracker와 같은 도구를 통해 추적할 수 있습니다.</p><p>이 기능은 다음 조건이 <em>모두</em> 충족될 때 기본 Kotlin/Native 메모리 할당자에만 사용할 수 있습니다:</p><ul><li><p><strong>태깅 활성화</strong>. 메모리는 유효한 식별자로 태그되어야 합니다. Apple은 240에서 255 사이의 숫자를 권장하며, 기본값은 246입니다.</p><p><code>kotlin.native.binary.mmapTag=0</code> Gradle 속성을 설정하면 태깅이 비활성화됩니다.</p></li><li><p><strong>mmap을 이용한 할당</strong>. 할당자는 <code>mmap</code> 시스템 호출을 사용하여 파일을 메모리로 매핑해야 합니다.</p><p><code>kotlin.native.binary.disableMmap=true</code> Gradle 속성을 설정하면 기본 할당자는 <code>mmap</code> 대신 <code>malloc</code>을 사용합니다.</p></li><li><p><strong>페이징 활성화</strong>. 할당의 페이징(버퍼링)이 활성화되어야 합니다.</p><p><code>kotlin.native.binary.pagedAllocator=false</code> Gradle 속성을 설정하면 메모리가 객체당(per-object)으로 예약됩니다.</p></li></ul><h3 id="메모리-소비-조정" tabindex="-1">메모리 소비 조정 <a class="header-anchor" href="#메모리-소비-조정" aria-label="Permalink to &quot;메모리 소비 조정&quot;">​</a></h3><p>예상치 않게 높은 메모리 소비를 겪고 있다면 다음 해결책을 시도해 보세요:</p><h4 id="kotlin-업데이트" tabindex="-1">Kotlin 업데이트 <a class="header-anchor" href="#kotlin-업데이트" aria-label="Permalink to &quot;Kotlin 업데이트&quot;">​</a></h4><p>Kotlin을 최신 버전으로 업데이트하세요. 저희는 메모리 관리자를 지속적으로 개선하고 있으므로, 간단한 컴파일러 업데이트만으로도 메모리 소비를 개선할 수 있습니다.</p>`,27)),t(e,{id:"할당자-페이징-비활성화",level:"4",title:"할당자 페이징 비활성화",labelRef:"experimental-opt-in"}),s[11]||(s[11]=i('<p>할당의 페이징(버퍼링)을 비활성화하여 메모리 할당자가 객체당 메모리를 예약하도록 할 수 있습니다. 경우에 따라 엄격한 메모리 제한을 충족하거나 애플리케이션 시작 시 메모리 소비를 줄이는 데 도움이 될 수 있습니다.</p><p>그러려면 <code>gradle.properties</code> 파일에 다음 옵션을 설정하세요:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.pagedAllocator=false</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>할당자 페이징을 비활성화하면 <a href="#track-memory-consumption-on-apple-platforms">Apple 플랫폼에서 메모리 소비를 추적</a>할 수 없습니다.</p></div>',4)),t(e,{id:"latin-1-문자열-지원-활성화",level:"4",title:"Latin-1 문자열 지원 활성화",labelRef:"experimental-opt-in"}),s[12]||(s[12]=i(`<p>기본적으로 Kotlin의 문자열은 UTF-16 인코딩을 사용하여 저장되며, 각 문자는 2바이트로 표현됩니다. 경우에 따라 이는 문자열이 소스 코드보다 바이너리에서 두 배 많은 공간을 차지하고 데이터를 읽는 데 두 배 많은 메모리를 사용하는 결과를 초래합니다.</p><p>애플리케이션의 바이너리 크기를 줄이고 메모리 소비를 조정하려면 Latin-1 인코딩 문자열 지원을 활성화할 수 있습니다. <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" target="_blank" rel="noreferrer">Latin-1 (ISO 8859-1)</a> 인코딩은 처음 256개의 유니코드 문자를 단 1바이트로 표현합니다.</p><p>활성화하려면 <code>gradle.properties</code> 파일에 다음 옵션을 설정하세요:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.latin1Strings=true</span></span></code></pre></div><p>Latin-1 지원을 활성화하면 모든 문자가 해당 범위 내에 있는 한 문자열은 Latin-1 인코딩으로 저장됩니다. 그렇지 않은 경우 기본 UTF-16 인코딩이 사용됩니다.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>이 기능은 실험적(Experimental)이지만, cinterop 확장 함수인 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/pin.html" target="_blank" rel="noreferrer"><code>String.pin</code></a>, <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/use-pinned.html" target="_blank" rel="noreferrer"><code>String.usePinned</code></a>, 그리고 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/ref-to.html" target="_blank" rel="noreferrer"><code>String.refTo</code></a>의 효율성이 떨어집니다. 이러한 각 호출은 자동 문자열 변환을 UTF-16으로 트리거할 수 있습니다.</p></div><p>이러한 옵션 중 어느 것도 도움이 되지 않았다면, <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack</a>에 이슈를 생성하세요.</p><h2 id="백그라운드에서-단위-테스트" tabindex="-1">백그라운드에서 단위 테스트 <a class="header-anchor" href="#백그라운드에서-단위-테스트" aria-label="Permalink to &quot;백그라운드에서 단위 테스트&quot;">​</a></h2><p>단위 테스트에서는 메인 스레드 큐를 처리하는 것이 없으므로, 모의(mock)되지 않았다면 <code>Dispatchers.Main</code>을 사용하지 마세요. 모의는 <code>kotlinx-coroutines-test</code>에서 <code>Dispatchers.setMain</code>을 호출하여 수행할 수 있습니다.</p><p><code>kotlinx.coroutines</code>에 의존하지 않거나 어떤 이유로든 <code>Dispatchers.setMain</code>이 작동하지 않는다면, 테스트 런처 구현을 위해 다음 해결 방법을 시도해 보세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testlauncher</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> platform.CoreFoundation.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.native.concurrent.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.native.internal.test.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.system.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mainBackground</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> worker </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Worker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;main-background&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    worker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(TransferMode.SAFE, { args.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">freeze</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testLauncherEntryPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(it)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        exitProcess</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    CFRunLoopRun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;CFRunLoopRun should never return&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>그런 다음 <code>-e testlauncher.mainBackground</code> 컴파일러 옵션으로 테스트 바이너리를 컴파일하세요.</p><h2 id="다음-단계" tabindex="-1">다음 단계 <a class="header-anchor" href="#다음-단계" aria-label="Permalink to &quot;다음 단계&quot;">​</a></h2><ul><li><a href="/ko/kotlin/native-migration-guide">레거시 메모리 관리자에서 마이그레이션</a></li><li><a href="/ko/kotlin/native-arc-integration">Swift/Objective-C ARC 통합 세부 정보 확인</a></li></ul>`,14))])}const f=r(c,[["render",g]]);export{v as __pageData,f as default};
