import{_ as e,c as d,o as a,ag as o}from"./chunks/framework.Bksy39di.js";const k=JSON.parse('{"title":"Java 註解處理與 KSP 的對照","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/ksp-reference.md","filePath":"zh-Hant/kotlin/ksp-reference.md","lastUpdated":1754307826000}'),r={name:"zh-Hant/kotlin/ksp-reference.md"};function s(i,t,n,c,l,h){return a(),d("div",null,t[0]||(t[0]=[o(`<h1 id="java-註解處理與-ksp-的對照" tabindex="-1">Java 註解處理與 KSP 的對照 <a class="header-anchor" href="#java-註解處理與-ksp-的對照" aria-label="Permalink to &quot;Java 註解處理與 KSP 的對照&quot;">​</a></h1><h2 id="程式元素" tabindex="-1">程式元素 <a class="header-anchor" href="#程式元素" aria-label="Permalink to &quot;程式元素&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 中的對應功能</strong></th><th><strong>備註</strong></th></tr></thead><tbody><tr><td><code>AnnotationMirror</code></td><td><code>KSAnnotation</code></td><td></td></tr><tr><td><code>AnnotationValue</code></td><td><code>KSValueArguments</code></td><td></td></tr><tr><td><code>Element</code></td><td><code>KSDeclaration</code> / <code>KSDeclarationContainer</code></td><td></td></tr><tr><td><code>ExecutableElement</code></td><td><code>KSFunctionDeclaration</code></td><td></td></tr><tr><td><code>PackageElement</code></td><td><code>KSFile</code></td><td>KSP 不將套件建模為程式元素</td></tr><tr><td><code>Parameterizable</code></td><td><code>KSDeclaration</code></td><td></td></tr><tr><td><code>QualifiedNameable</code></td><td><code>KSDeclaration</code></td><td></td></tr><tr><td><code>TypeElement</code></td><td><code>KSClassDeclaration</code></td><td></td></tr><tr><td><code>TypeParameterElement</code></td><td><code>KSTypeParameter</code></td><td></td></tr><tr><td><code>VariableElement</code></td><td><code>KSValueParameter</code> / <code>KSPropertyDeclaration</code></td><td></td></tr></tbody></table><h2 id="類型" tabindex="-1">類型 <a class="header-anchor" href="#類型" aria-label="Permalink to &quot;類型&quot;">​</a></h2><p>KSP 需要明確的類型解析，因此 Java 中的某些功能只能透過 <code>KSType</code> 及解析前對應的元素來實現。</p><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 中的對應功能</strong></th><th><strong>備註</strong></th></tr></thead><tbody><tr><td><code>ArrayType</code></td><td><code>KSBuiltIns.arrayType</code></td><td></td></tr><tr><td><code>DeclaredType</code></td><td><code>KSType</code> / <code>KSClassifierReference</code></td><td></td></tr><tr><td><code>ErrorType</code></td><td><code>KSType.isError</code></td><td></td></tr><tr><td><code>ExecutableType</code></td><td><code>KSType</code> / <code>KSCallableReference</code></td><td></td></tr><tr><td><code>IntersectionType</code></td><td><code>KSType</code> / <code>KSTypeParameter</code></td><td></td></tr><tr><td><code>NoType</code></td><td><code>KSType.isError</code></td><td>KSP 中不適用</td></tr><tr><td><code>NullType</code></td><td></td><td>KSP 中不適用</td></tr><tr><td><code>PrimitiveType</code></td><td><code>KSBuiltIns</code></td><td>與 Java 中的原始類型不完全相同</td></tr><tr><td><code>ReferenceType</code></td><td><code>KSTypeReference</code></td><td></td></tr><tr><td><code>TypeMirror</code></td><td><code>KSType</code></td><td></td></tr><tr><td><code>TypeVariable</code></td><td><code>KSTypeParameter</code></td><td></td></tr><tr><td><code>UnionType</code></td><td>N/A</td><td>Kotlin 每個 catch 區塊只有一種類型。<code>UnionType</code> 即使是 Java 註解處理器也無法觀察到。</td></tr><tr><td><code>WildcardType</code></td><td><code>KSType</code> / <code>KSTypeArgument</code></td><td></td></tr></tbody></table><h2 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 中的對應功能</strong></th><th><strong>備註</strong></th></tr></thead><tbody><tr><td><code>Name</code></td><td><code>KSName</code></td><td></td></tr><tr><td><code>ElementKind</code></td><td><code>ClassKind</code> / <code>FunctionKind</code></td><td></td></tr><tr><td><code>Modifier</code></td><td><code>Modifier</code></td><td></td></tr><tr><td><code>NestingKind</code></td><td><code>ClassKind</code> / <code>FunctionKind</code></td><td></td></tr><tr><td><code>AnnotationValueVisitor</code></td><td></td><td></td></tr><tr><td><code>ElementVisitor</code></td><td><code>KSVisitor</code></td><td></td></tr><tr><td><code>AnnotatedConstruct</code></td><td><code>KSAnnotated</code></td><td></td></tr><tr><td><code>TypeVisitor</code></td><td></td><td></td></tr><tr><td><code>TypeKind</code></td><td><code>KSBuiltIns</code></td><td>部分可在內建類型中找到，否則請檢查 <code>DeclaredType</code> 的 <code>KSClassDeclaration</code></td></tr><tr><td><code>ElementFilter</code></td><td><code>Collection.filterIsInstance</code></td><td></td></tr><tr><td><code>ElementKindVisitor</code></td><td><code>KSVisitor</code></td><td></td></tr><tr><td><code>ElementScanner</code></td><td><code>KSTopDownVisitor</code></td><td></td></tr><tr><td><code>SimpleAnnotationValueVisitor</code></td><td></td><td>KSP 中不需要</td></tr><tr><td><code>SimpleElementVisitor</code></td><td><code>KSVisitor</code></td><td></td></tr><tr><td><code>SimpleTypeVisitor</code></td><td></td><td></td></tr><tr><td><code>TypeKindVisitor</code></td><td></td><td></td></tr><tr><td><code>Types</code></td><td><code>Resolver</code> / <code>utils</code></td><td>部分公用程式也整合到符號介面中</td></tr><tr><td><code>Elements</code></td><td><code>Resolver</code> / <code>utils</code></td><td></td></tr></tbody></table><h2 id="細節" tabindex="-1">細節 <a class="header-anchor" href="#細節" aria-label="Permalink to &quot;細節&quot;">​</a></h2><p>了解 Java 註解處理 API 的功能如何透過 KSP 來實現。</p><h3 id="annotationmirror" tabindex="-1">AnnotationMirror <a class="header-anchor" href="#annotationmirror" aria-label="Permalink to &quot;AnnotationMirror&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 對等物</strong></th></tr></thead><tbody><tr><td><code>getAnnotationType</code></td><td><code>ksAnnotation.annotationType</code></td></tr><tr><td><code>getElementValues</code></td><td><code>ksAnnotation.arguments</code></td></tr></tbody></table><h3 id="annotationvalue" tabindex="-1">AnnotationValue <a class="header-anchor" href="#annotationvalue" aria-label="Permalink to &quot;AnnotationValue&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 對等物</strong></th></tr></thead><tbody><tr><td><code>getValue</code></td><td><code>ksValueArgument.value</code></td></tr></tbody></table><h3 id="element" tabindex="-1">Element <a class="header-anchor" href="#element" aria-label="Permalink to &quot;Element&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 對等物</strong></th></tr></thead><tbody><tr><td><code>asType</code></td><td><code>ksClassDeclaration.asType(...)</code> 僅適用於 <code>KSClassDeclaration</code>。需要提供類型參數。</td></tr><tr><td><code>getAnnotation</code></td><td>待實作</td></tr><tr><td><code>getAnnotationMirrors</code></td><td><code>ksDeclaration.annotations</code></td></tr><tr><td><code>getEnclosedElements</code></td><td><code>ksDeclarationContainer.declarations</code></td></tr><tr><td><code>getEnclosingElements</code></td><td><code>ksDeclaration.parentDeclaration</code></td></tr><tr><td><code>getKind</code></td><td>依照 <code>ClassKind</code> 或 <code>FunctionKind</code> 進行類型檢查和轉換</td></tr><tr><td><code>getModifiers</code></td><td><code>ksDeclaration.modifiers</code></td></tr><tr><td><code>getSimpleName</code></td><td><code>ksDeclaration.simpleName</code></td></tr></tbody></table><h3 id="executableelement" tabindex="-1">ExecutableElement <a class="header-anchor" href="#executableelement" aria-label="Permalink to &quot;ExecutableElement&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 對等物</strong></th></tr></thead><tbody><tr><td><code>getDefaultValue</code></td><td>待實作</td></tr><tr><td><code>getParameters</code></td><td><code>ksFunctionDeclaration.parameters</code></td></tr><tr><td><code>getReceiverType</code></td><td><code>ksFunctionDeclaration.parentDeclaration</code></td></tr><tr><td><code>getReturnType</code></td><td><code>ksFunctionDeclaration.returnType</code></td></tr><tr><td><code>getSimpleName</code></td><td><code>ksFunctionDeclaration.simpleName</code></td></tr><tr><td><code>getThrownTypes</code></td><td>Kotlin 中不需要</td></tr><tr><td><code>getTypeParameters</code></td><td><code>ksFunctionDeclaration.typeParameters</code></td></tr><tr><td><code>isDefault</code></td><td>檢查父宣告是否為介面</td></tr><tr><td><code>isVarArgs</code></td><td><code>ksFunctionDeclaration.parameters.any { it.isVarArg }</code></td></tr></tbody></table><h3 id="parameterizable" tabindex="-1">Parameterizable <a class="header-anchor" href="#parameterizable" aria-label="Permalink to &quot;Parameterizable&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 對等物</strong></th></tr></thead><tbody><tr><td><code>getTypeParameters</code></td><td><code>ksFunctionDeclaration.typeParameters</code></td></tr></tbody></table><h3 id="qualifiednameable" tabindex="-1">QualifiedNameable <a class="header-anchor" href="#qualifiednameable" aria-label="Permalink to &quot;QualifiedNameable&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 對等物</strong></th></tr></thead><tbody><tr><td><code>getQualifiedName</code></td><td><code>ksDeclaration.qualifiedName</code></td></tr></tbody></table><h3 id="typeelement" tabindex="-1">TypeElement <a class="header-anchor" href="#typeelement" aria-label="Permalink to &quot;TypeElement&quot;">​</a></h3><table><tr><td><b>Java</b></td><td><b>KSP 對等物</b></td></tr><tr><td><code>getEnclosedElements</code></td><td><code>ksClassDeclaration.declarations</code></td></tr><tr><td><code>getEnclosingElement</code></td><td><code>ksClassDeclaration.parentDeclaration</code></td></tr><tr><td><code>getInterfaces</code></td><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Should be able to do without resolution</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ksClassDeclaration.superTypes</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { (it?.declaration </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? KSClassDeclaration)?.classKind </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ClassKind.INTERFACE }</span></span></code></pre></div></td></tr><tr><td><code>getNestingKind</code></td><td>檢查 <code>KSClassDeclaration.parentDeclaration</code> 和 <code>inner</code> 修飾符</td></tr><tr><td><code>getQualifiedName</code></td><td><code>ksClassDeclaration.qualifiedName</code></td></tr><tr><td><code>getSimpleName</code></td><td><code>ksClassDeclaration.simpleName</code></td></tr><tr><td><code>getSuperclass</code></td><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Should be able to do without resolution</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ksClassDeclaration.superTypes</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { (it?.declaration </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? KSClassDeclaration)?.classKind </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ClassKind.CLASS }</span></span></code></pre></div></td></tr><tr><td><code>getTypeParameters</code></td><td><code>ksClassDeclaration.typeParameters</code></td></tr></table><h3 id="typeparameterelement" tabindex="-1">TypeParameterElement <a class="header-anchor" href="#typeparameterelement" aria-label="Permalink to &quot;TypeParameterElement&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 對等物</strong></th></tr></thead><tbody><tr><td><code>getBounds</code></td><td><code>ksTypeParameter.bounds</code></td></tr><tr><td><code>getEnclosingElement</code></td><td><code>ksTypeParameter.parentDeclaration</code></td></tr><tr><td><code>getGenericElement</code></td><td><code>ksTypeParameter.parentDeclaration</code></td></tr></tbody></table><h3 id="variableelement" tabindex="-1">VariableElement <a class="header-anchor" href="#variableelement" aria-label="Permalink to &quot;VariableElement&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 對等物</strong></th></tr></thead><tbody><tr><td><code>getConstantValue</code></td><td>待實作</td></tr><tr><td><code>getEnclosingElement</code></td><td><code>ksValueParameter.parentDeclaration</code></td></tr><tr><td><code>getSimpleName</code></td><td><code>ksValueParameter.simpleName</code></td></tr></tbody></table><h3 id="arraytype" tabindex="-1">ArrayType <a class="header-anchor" href="#arraytype" aria-label="Permalink to &quot;ArrayType&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 對等物</strong></th></tr></thead><tbody><tr><td><code>getComponentType</code></td><td><code>ksType.arguments.first()</code></td></tr></tbody></table><h3 id="declaredtype" tabindex="-1">DeclaredType <a class="header-anchor" href="#declaredtype" aria-label="Permalink to &quot;DeclaredType&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 對等物</strong></th></tr></thead><tbody><tr><td><code>asElement</code></td><td><code>ksType.declaration</code></td></tr><tr><td><code>getEnclosingType</code></td><td><code>ksType.declaration.parentDeclaration</code></td></tr><tr><td><code>getTypeArguments</code></td><td><code>ksType.arguments</code></td></tr></tbody></table><h3 id="executabletype" tabindex="-1">ExecutableType <a class="header-anchor" href="#executabletype" aria-label="Permalink to &quot;ExecutableType&quot;">​</a></h3><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>函數的 <code>KSType</code> 只是由 <code>FunctionN&lt;R, T1, T2, ..., TN&gt;</code> 家族表示的簽名。</p></div><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 對等物</strong></th></tr></thead><tbody><tr><td><code>getParameterTypes</code></td><td><code>ksType.declaration.typeParameters</code>, <code>ksFunctionDeclaration.parameters.map { it.type }</code></td></tr><tr><td><code>getReceiverType</code></td><td><code>ksFunctionDeclaration.parentDeclaration.asType(...)</code></td></tr><tr><td><code>getReturnType</code></td><td><code>ksType.declaration.typeParameters.last()</code></td></tr><tr><td><code>getThrownTypes</code></td><td>Kotlin 中不需要</td></tr><tr><td><code>getTypeVariables</code></td><td><code>ksFunctionDeclaration.typeParameters</code></td></tr></tbody></table><h3 id="intersectiontype" tabindex="-1">IntersectionType <a class="header-anchor" href="#intersectiontype" aria-label="Permalink to &quot;IntersectionType&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 對等物</strong></th></tr></thead><tbody><tr><td><code>getBounds</code></td><td><code>ksTypeParameter.bounds</code></td></tr></tbody></table><h3 id="typemirror" tabindex="-1">TypeMirror <a class="header-anchor" href="#typemirror" aria-label="Permalink to &quot;TypeMirror&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 對等物</strong></th></tr></thead><tbody><tr><td><code>getKind</code></td><td>與 <code>KSBuiltIns</code> 中的類型比較，適用於原始類型、<code>Unit</code> 類型，否則為宣告類型</td></tr></tbody></table><h3 id="typevariable" tabindex="-1">TypeVariable <a class="header-anchor" href="#typevariable" aria-label="Permalink to &quot;TypeVariable&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 對等物</strong></th></tr></thead><tbody><tr><td><code>asElement</code></td><td><code>ksType.declaration</code></td></tr><tr><td><code>getLowerBound</code></td><td>待定。僅在提供捕獲且需要明確的界限檢查時才需要。</td></tr><tr><td><code>getUpperBound</code></td><td><code>ksTypeParameter.bounds</code></td></tr></tbody></table><h3 id="wildcardtype" tabindex="-1">WildcardType <a class="header-anchor" href="#wildcardtype" aria-label="Permalink to &quot;WildcardType&quot;">​</a></h3><table><tr><td><b>Java</b></td><td><b>KSP 對等物</b></td></tr><tr><td><code>getExtendsBound</code></td><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ksTypeArgument.variance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Variance.COVARIANT) ksTypeArgument.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span></code></pre></div></td></tr><tr><td><code>getSuperBound</code></td><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ksTypeArgument.variance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Variance.CONTRAVARIANT) ksTypeArgument.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span></code></pre></div></td></tr></table><h3 id="elements" tabindex="-1">Elements <a class="header-anchor" href="#elements" aria-label="Permalink to &quot;Elements&quot;">​</a></h3><table><tr><td><b>Java</b></td><td><b>KSP 對等物</b></td></tr><tr><td><code>getAllAnnotationMirrors</code></td><td><code>KSDeclarations.annotations</code></td></tr><tr><td><code>getAllMembers</code></td><td><code>getAllFunctions</code>, <code>getAllProperties</code> 待實作</td></tr><tr><td><code>getBinaryName</code></td><td>待定，參閱 <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-13.html#jls-13.1">Java 規範</a></td></tr><tr><td><code>getConstantExpression</code></td><td>存在常數值，而非表達式</td></tr><tr><td><code>getDocComment</code></td><td>待實作</td></tr><tr><td><code>getElementValuesWithDefaults</code></td><td>待實作</td></tr><tr><td><code>getName</code></td><td><code>resolver.getKSNameFromString</code></td></tr><tr><td><code>getPackageElement</code></td><td>不支援套件，但套件資訊可被檢索。KSP 無法對套件執行操作。</td></tr><tr><td><code>getPackageOf</code></td><td>不支援套件</td></tr><tr><td><code>getTypeElement</code></td><td><code>Resolver.getClassDeclarationByName</code></td></tr><tr><td><code>hides</code></td><td>待實作</td></tr><tr><td><code>isDeprecated</code></td><td><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">KsDeclaration.annotations.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    it.annotationType.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.declaration.qualifiedName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Deprecated::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.qualifiedName</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></td></tr><tr><td><code>overrides</code></td><td><code>KSFunctionDeclaration.overrides</code> / <code>KSPropertyDeclaration.overrides</code> (各自類別的成員函數)</td></tr><tr><td><code>printElements</code></td><td>KSP 在大多數類別上具有基本的 <code>toString()</code> 實作</td></tr></table><h3 id="types" tabindex="-1">Types <a class="header-anchor" href="#types" aria-label="Permalink to &quot;Types&quot;">​</a></h3><p id="type-operations"></p><table tabindex="0"><thead><tr><th><strong>Java</strong></th><th><strong>KSP 對等物</strong></th></tr></thead><tbody><tr><td><code>asElement</code></td><td><code>ksType.declaration</code></td></tr><tr><td><code>asMemberOf</code></td><td><code>resolver.asMemberOf</code></td></tr><tr><td><code>boxedClass</code></td><td>不需要</td></tr><tr><td><code>capture</code></td><td>待定</td></tr><tr><td><code>contains</code></td><td><code>KSType.isAssignableFrom</code></td></tr><tr><td><code>directSuperTypes</code></td><td><code>(ksType.declaration as KSClassDeclaration).superTypes</code></td></tr><tr><td><code>erasure</code></td><td><code>ksType.starProjection()</code></td></tr><tr><td><code>getArrayType</code></td><td><code>ksBuiltIns.arrayType.replace(...)</code></td></tr><tr><td><code>getDeclaredType</code></td><td><code>ksClassDeclaration.asType</code></td></tr><tr><td><code>getNoType</code></td><td><code>ksBuiltIns.nothingType</code> / <code>null</code></td></tr><tr><td><code>getNullType</code></td><td>取決於上下文，<code>KSType.markNullable</code> 可能有用</td></tr><tr><td><code>getPrimitiveType</code></td><td>不需要，檢查 <code>KSBuiltins</code></td></tr><tr><td><code>getWildcardType</code></td><td>在預期 <code>KSTypeArgument</code> 的位置使用 <code>Variance</code></td></tr><tr><td><code>isAssignable</code></td><td><code>ksType.isAssignableFrom</code></td></tr><tr><td><code>isSameType</code></td><td><code>ksType.equals</code></td></tr><tr><td><code>isSubsignature</code></td><td><code>functionTypeA == functionTypeB</code> / <code>functionTypeA == functionTypeB.starProjection()</code></td></tr><tr><td><code>isSubtype</code></td><td><code>ksType.isAssignableFrom</code></td></tr><tr><td><code>unboxedType</code></td><td>不需要</td></tr></tbody></table>`,48)]))}const y=e(r,[["render",s]]);export{k as __pageData,y as default};
