import{_ as t}from"./chunks/gradle-sync.DiZmeJUl.js";import{_ as a,c as i,o as l,ag as o}from"./chunks/framework.Bksy39di.js";const u=JSON.parse('{"title":"定义文件","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/native-definition-file.md","filePath":"kotlin/native-definition-file.md","lastUpdated":1754307826000}'),n={name:"kotlin/native-definition-file.md"};function s(d,e,c,r,p,h){return l(),i("div",null,e[0]||(e[0]=[o(`<h1 id="定义文件" tabindex="-1">定义文件 <a class="header-anchor" href="#定义文件" aria-label="Permalink to &quot;定义文件&quot;">​</a></h1><p>Kotlin/Native 允许你使用 C 和 Objective-C 库，从而在 Kotlin 中利用它们的功能性。一个名为 cinterop 的专用工具会接收 C 或 Objective-C 库，并生成相应的 Kotlin 绑定，以便该库的方法能像往常一样在你的 Kotlin 代码中使用。</p><p>为了生成这些绑定，每个库都需要一个定义文件，通常与库同名。这是一个属性文件，它精确描述了库应如何被使用。关于更多信息，请参见 <a href="#properties">可用属性的完整列表</a>。</p><p>以下是处理项目时的通用工作流程：</p><ol><li>创建一个 <code>.def</code> 文件，描述要包含在绑定中的内容。</li><li>在你的 Kotlin 代码中使用生成的绑定。</li><li>运行 Kotlin/Native 编译器以生成最终的可执行文件。</li></ol><h2 id="创建并配置定义文件" tabindex="-1">创建并配置定义文件 <a class="header-anchor" href="#创建并配置定义文件" aria-label="Permalink to &quot;创建并配置定义文件&quot;">​</a></h2><p>让我们创建一个定义文件并为 C 库生成绑定：</p><ol><li><p>在你的 IDE 中，选择 <code>src</code> 文件夹并通过 <strong>File | New | Directory</strong> 创建一个新目录。</p></li><li><p>将新目录命名为 <code>nativeInterop/cinterop</code>。</p><p>这是 <code>.def</code> 文件位置的默认约定，但如果你使用不同的位置，可以在 <code>build.gradle.kts</code> 文件中覆盖它。</p></li><li><p>选择新子文件夹并通过 <strong>File | New | File</strong> 创建一个 <code>png.def</code> 文件。</p></li><li><p>添加必要的属性：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>headers = png.h</span></span>
<span class="line"><span>headerFilter = png.h</span></span>
<span class="line"><span>package = png</span></span>
<span class="line"><span></span></span>
<span class="line"><span>compilerOpts.linux = -I/usr/include -I/usr/include/x86_64-linux-gnu</span></span>
<span class="line"><span>linkerOpts.osx = -L/opt/local/lib -L/usr/local/opt/png/lib -lpng</span></span>
<span class="line"><span>linkerOpts.linux = -L/usr/lib/x86_64-linux-gnu -lpng</span></span></code></pre></div><ul><li><p><code>headers</code> 是用于生成 Kotlin 存根的头文件列表。你可以将多个文件添加到此条目，每个文件用空格分隔。在此例中，它只有 <code>png.h</code>。引用的文件需要位于指定的路径（在此例中为 <code>/usr/include/png</code>）上。</p></li><li><p><code>headerFilter</code> 显示具体包含哪些内容。在 C 语言中，当一个文件使用 <code>#include</code> 指令引用另一个文件时，所有头文件也会被包含。有时这并非必要，你可以 <a href="https://en.wikipedia.org/wiki/Glob_(programming)" target="_blank" rel="noreferrer">使用 glob 模式</a> 添加此参数进行调整。</p><p>如果你不想将外部依赖项（例如系统 <code>stdint.h</code> 头文件）获取到互操作库中，可以使用 <code>headerFilter</code>。此外，它可能有助于优化库大小，并解决系统与所提供的 Kotlin/Native 编译环境之间潜在的冲突。</p></li><li><p>如果需要修改某个平台特有的行为，你可以使用 <code>compilerOpts.osx</code> 或 <code>compilerOpts.linux</code> 等格式为选项提供平台特有的值。在此例中，它们是 macOS（<code>.osx</code> 后缀）和 Linux（<code>.linux</code> 后缀）。不带后缀的参数也是可能的（例如，<code>linkerOpts=</code>），并应用于所有平台。</p></li></ul></li><li><p>要生成绑定，请在通知中点击 <strong>Sync Now</strong> 以同步 Gradle 文件。</p><p><img src="`+t+`" alt="Synchronize the Gradle files"></p></li></ol><p>绑定生成后，IDE 可以将它们用作原生库的代理视图。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>你也可以通过在命令行中使用 <a href="#generate-bindings-using-command-line">cinterop 工具</a> 来配置绑定生成。</p></div><h2 id="属性" tabindex="-1">属性 <a class="header-anchor" href="#属性" aria-label="Permalink to &quot;属性&quot;">​</a></h2><p>以下是可在定义文件中使用的完整属性列表，用于调整生成的二进制文件的内容。关于更多信息，请参见以下相应章节。</p><table tabindex="0"><thead><tr><th style="text-align:left;"><strong>属性</strong></th><th style="text-align:left;"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><a href="#import-headers"><code>headers</code></a></td><td style="text-align:left;">要包含在绑定中的库头文件列表。</td></tr><tr><td style="text-align:left;"><a href="#import-modules"><code>modules</code></a></td><td style="text-align:left;">要包含在绑定中的 Objective-C 库的 Clang 模块列表。</td></tr><tr><td style="text-align:left;"><code>language</code></td><td style="text-align:left;">指定语言。默认为 C；如有必要，更改为 <code>Objective-C</code>。</td></tr><tr><td style="text-align:left;"><a href="#pass-compiler-and-linker-options"><code>compilerOpts</code></a></td><td style="text-align:left;">cinterop 工具传递给 C 编译器的编译选项。</td></tr><tr><td style="text-align:left;"><a href="#pass-compiler-and-linker-options"><code>linkerOpts</code></a></td><td style="text-align:left;">cinterop 工具传递给链接器的链接选项。</td></tr><tr><td style="text-align:left;"><a href="#ignore-specific-functions"><code>excludedFunctions</code></a></td><td style="text-align:left;">一个空格分隔的函数名称列表，应被忽略。</td></tr><tr><td style="text-align:left;"><a href="#include-a-static-library"><code>staticLibraries</code></a></td><td style="text-align:left;"><a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>。将静态库包含到 <code>.klib</code> 中。</td></tr><tr><td style="text-align:left;"><a href="#include-a-static-library"><code>libraryPaths</code></a></td><td style="text-align:left;"><a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>。一个空格分隔的目录列表，cinterop 工具在此搜索要包含在 <code>.klib</code> 中的库。</td></tr><tr><td style="text-align:left;"><code>packageName</code></td><td style="text-align:left;">生成的 Kotlin API 的包前缀。</td></tr><tr><td style="text-align:left;"><a href="#filter-headers-by-globs"><code>headerFilter</code></a></td><td style="text-align:left;">通过 glob 模式过滤头文件，在导入库时仅包含它们。</td></tr><tr><td style="text-align:left;"><a href="#exclude-headers"><code>excludeFilter</code></a></td><td style="text-align:left;">在导入库时排除特有的头文件，并优先于 <code>headerFilter</code>。</td></tr><tr><td style="text-align:left;"><a href="#configure-enums-generation"><code>strictEnums</code></a></td><td style="text-align:left;">一个空格分隔的枚举列表，应生成为 <a href="/kotlin/enum-classes">Kotlin 枚举</a>。</td></tr><tr><td style="text-align:left;"><a href="#configure-enums-generation"><code>nonStrictEnums</code></a></td><td style="text-align:left;">一个空格分隔的枚举列表，应生成为整型值。</td></tr><tr><td style="text-align:left;"><a href="#set-up-string-conversion"><code>noStringConversion</code></a></td><td style="text-align:left;">一个空格分隔的函数列表，其 <code>const char*</code> 形参不应自动转换为 Kotlin <code>String</code>。</td></tr><tr><td style="text-align:left;"><code>allowedOverloadsForCFunctions</code></td><td style="text-align:left;">默认情况下，假定 C 函数具有唯一的名称。如果有多个函数同名，则只选择一个。但是，你可以通过在 <code>allowedOverloadsForCFunctions</code> 中指定这些函数来更改此行为。</td></tr><tr><td style="text-align:left;"><a href="#allow-calling-a-non-designated-initializer"><code>disableDesignatedInitializerChecks</code></a></td><td style="text-align:left;">禁用编译器检测，该检测不允许将非指定 Objective-C 初始化器作为 <code>super()</code> 构造函数调用。</td></tr><tr><td style="text-align:left;"><a href="#handle-objective-c-exceptions"><code>foreignExceptionMode</code></a></td><td style="text-align:left;">将 Objective-C 代码中的异常包装为 <code>ForeignException</code> 类型的 Kotlin 异常。</td></tr><tr><td style="text-align:left;"><a href="#help-resolve-linker-errors"><code>userSetupHint</code></a></td><td style="text-align:left;">添加自定义消息，例如，帮助用户解决链接器错误。</td></tr></tbody></table><p>除了属性列表，你还可以在定义文件中包含 <a href="#add-custom-declarations">自定义声明</a>。</p><h3 id="导入头文件" tabindex="-1">导入头文件 <a class="header-anchor" href="#导入头文件" aria-label="Permalink to &quot;导入头文件&quot;">​</a></h3><p>如果 C 库没有 Clang 模块，而是由一组头文件集合组成，请使用 <code>headers</code> 属性指定应导入的头文件：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>headers = curl/curl.h</span></span></code></pre></div><h4 id="通过-glob-模式过滤头文件" tabindex="-1">通过 glob 模式过滤头文件 <a class="header-anchor" href="#通过-glob-模式过滤头文件" aria-label="Permalink to &quot;通过 glob 模式过滤头文件&quot;">​</a></h4><p>你可以使用 <code>.def</code> 文件中的过滤属性通过 glob 模式过滤头文件。要包含来自头文件的声明，请使用 <code>headerFilter</code> 属性。如果头文件与任何 glob 模式匹配，其声明将包含在绑定中。</p><p>Glob 模式应用于相对于相应包含路径元素的头文件路径，例如 <code>time.h</code> 或 <code>curl/curl.h</code>。因此，如果库通常使用 <code>#include &lt;SomeLibrary/Header.h&gt;</code> 包含，你可能可以使用以下过滤器过滤头文件：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>headerFilter = SomeLibrary/**</span></span></code></pre></div><p>如果未提供 <code>headerFilter</code>，则会包含所有头文件。但是，我们鼓励你使用 <code>headerFilter</code> 并尽可能精确地指定 glob 模式。在这种情况下，生成的库仅包含必要的声明。这有助于避免在升级 Kotlin 或开发环境中的工具时遇到的各种问题。</p><h4 id="排除头文件" tabindex="-1">排除头文件 <a class="header-anchor" href="#排除头文件" aria-label="Permalink to &quot;排除头文件&quot;">​</a></h4><p>要排除特有的头文件，请使用 <code>excludeFilter</code> 属性。这有助于删除冗余或有问题的头文件并优化编译，因为指定头文件中的声明不会包含在绑定中：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>excludeFilter = SomeLibrary/time.h</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>如果同一个头文件既通过 <code>headerFilter</code> 包含，又通过 <code>excludeFilter</code> 排除，则该指定头文件将不会包含在绑定中。</p></div><h3 id="导入模块" tabindex="-1">导入模块 <a class="header-anchor" href="#导入模块" aria-label="Permalink to &quot;导入模块&quot;">​</a></h3><p>如果 Objective-C 库具有 Clang 模块，请使用 <code>modules</code> 属性指定要导入的模块：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>modules = UIKit</span></span></code></pre></div><h3 id="传递编译器和链接器选项" tabindex="-1">传递编译器和链接器选项 <a class="header-anchor" href="#传递编译器和链接器选项" aria-label="Permalink to &quot;传递编译器和链接器选项&quot;">​</a></h3><p>使用 <code>compilerOpts</code> 属性将选项传递给 C 编译器，C 编译器在底层用于分析头文件。要将选项传递给用于链接最终可执行文件的链接器，请使用 <code>linkerOpts</code>。例如：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>compilerOpts = -DFOO=bar</span></span>
<span class="line"><span>linkerOpts = -lpng</span></span></code></pre></div><p>你还可以指定仅适用于某个目标特有的选项：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>compilerOpts = -DBAR=bar</span></span>
<span class="line"><span>compilerOpts.linux_x64 = -DFOO=foo1</span></span>
<span class="line"><span>compilerOpts.macos_x64 = -DFOO=foo2</span></span></code></pre></div><p>有了此配置，头文件在 Linux 上使用 <code>-DBAR=bar -DFOO=foo1</code> 进行分析，在 macOS 上使用 <code>-DBAR=bar -DFOO=foo2</code> 进行分析。请注意，任何定义文件选项都可以同时包含通用部分和平台特有部分。</p><h3 id="忽略特有的函数" tabindex="-1">忽略特有的函数 <a class="header-anchor" href="#忽略特有的函数" aria-label="Permalink to &quot;忽略特有的函数&quot;">​</a></h3><p>使用 <code>excludedFunctions</code> 属性指定应忽略的函数名称列表。如果头文件中声明的函数不保证可调用，并且很难或不可能自动确定，这会很有用。你也可以使用此属性来解决互操作本身中的错误。</p><h3 id="包含静态库" tabindex="-1">包含静态库 <a class="header-anchor" href="#包含静态库" aria-label="Permalink to &quot;包含静态库&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>此特性是 <a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>。它可能随时被删除或更改。 仅用于评估目的。</p></div><p>有时，将静态库与你的产品一起交付比假定它在用户环境中可用更为方便。要将静态库包含到 <code>.klib</code> 中，请使用 <code>staticLibrary</code> 和 <code>libraryPaths</code> 属性：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>headers = foo.h</span></span>
<span class="line"><span>staticLibraries = libfoo.a</span></span>
<span class="line"><span>libraryPaths = /opt/local/lib /usr/local/opt/curl/lib</span></span></code></pre></div><p>当给定上述代码片段时，cinterop 工具会在 <code>/opt/local/lib</code> 和 <code>/usr/local/opt/curl/lib</code> 中搜索 <code>libfoo.a</code>，如果找到，则将库二进制文件包含在 <code>klib</code> 中。</p><p>在你的程序中以这种方式使用 <code>klib</code> 时，库会自动链接。</p><h3 id="配置枚举生成" tabindex="-1">配置枚举生成 <a class="header-anchor" href="#配置枚举生成" aria-label="Permalink to &quot;配置枚举生成&quot;">​</a></h3><p>使用 <code>strictEnums</code> 属性将枚举生成为 Kotlin 枚举，或使用 <code>nonStrictEnums</code> 将它们生成为整型值。如果枚举不包含在这两个列表中的任何一个，它将基于启发式方法生成。</p><h3 id="设置字符串转换" tabindex="-1">设置字符串转换 <a class="header-anchor" href="#设置字符串转换" aria-label="Permalink to &quot;设置字符串转换&quot;">​</a></h3><p>使用 <code>noStringConversion</code> 属性禁用 <code>const char*</code> 函数形参自动转换为 Kotlin <code>String</code>。</p><h3 id="允许调用非指定初始化器" tabindex="-1">允许调用非指定初始化器 <a class="header-anchor" href="#允许调用非指定初始化器" aria-label="Permalink to &quot;允许调用非指定初始化器&quot;">​</a></h3><p>默认情况下，Kotlin/Native 编译器不允许将非指定 Objective-C 初始化器作为 <code>super()</code> 构造函数调用。如果库中未正确标记指定的 Objective-C 初始化器，此行为可能会带来不便。要禁用这些编译器检测，请使用 <code>disableDesignatedInitializerChecks</code> 属性。</p><h3 id="处理-objective-c-异常" tabindex="-1">处理 Objective-C 异常 <a class="header-anchor" href="#处理-objective-c-异常" aria-label="Permalink to &quot;处理 Objective-C 异常&quot;">​</a></h3><p>默认情况下，如果 Objective-C 异常到达 Objective-C 到 Kotlin 的互操作边界并进入 Kotlin 代码，程序将崩溃。</p><p>要将 Objective-C 异常传播到 Kotlin，请使用 <code>foreignExceptionMode = objc-wrap</code> 属性启用包装。在这种情况下，Objective-C 异常会转换为获得 <code>ForeignException</code> 类型的 Kotlin 异常。</p><h3 id="帮助解决链接器错误" tabindex="-1">帮助解决链接器错误 <a class="header-anchor" href="#帮助解决链接器错误" aria-label="Permalink to &quot;帮助解决链接器错误&quot;">​</a></h3><p>当 Kotlin 库依赖于 C 或 Objective-C 库时，可能会发生链接器错误，例如，使用 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-overview.html" target="_blank" rel="noreferrer">CocoaPods 集成</a> 时。如果依赖库未本地安装在机器上或未在项目构建脚本中显式配置，则会发生“Framework not found”错误。</p><p>如果你是一位库作者，你可以通过自定义消息帮助用户解决链接器错误。为此，请将 <code>userSetupHint=message</code> 属性添加到你的 <code>.def</code> 文件中，或将 <code>-Xuser-setup-hint</code> 编译器选项传递给 <code>cinterop</code>。</p><h3 id="添加自定义声明" tabindex="-1">添加自定义声明 <a class="header-anchor" href="#添加自定义声明" aria-label="Permalink to &quot;添加自定义声明&quot;">​</a></h3><p>有时需要在生成绑定之前将自定义 C 声明添加到库中（例如，对于 <a href="/kotlin/native-c-interop#macros">宏</a>）。与其创建一个额外的头文件来放置这些声明，你可以直接将这些声明包含在 <code>.def</code> 文件的末尾，位于仅包含分隔符序列 <code>---</code> 的分隔行之后：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>headers = errno.h</span></span>
<span class="line"><span>---</span></span>
<span class="line"><span></span></span>
<span class="line"><span>static inline int getErrno() {</span></span>
<span class="line"><span>    return errno;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>请注意，<code>.def</code> 文件的这一部分被视为头文件的一部分，因此带有函数体的函数应声明为 <code>static</code>。声明会在包含 <code>headers</code> 列表中的文件后进行解析。</p><h2 id="通过命令行生成绑定" tabindex="-1">通过命令行生成绑定 <a class="header-anchor" href="#通过命令行生成绑定" aria-label="Permalink to &quot;通过命令行生成绑定&quot;">​</a></h2><p>除了定义文件，你还可以通过在 <code>cinterop</code> 调用中将相应的属性作为选项传递来指定绑定中要包含的内容。</p><p>以下是生成 <code>png.klib</code> 编译库的命令示例：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cinterop</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -def</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> png.def</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -compiler-option</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -I/usr/local/include</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> png</span></span></code></pre></div><p>请注意，生成的绑定通常是平台特有的，因此如果你正在为多个目标平台开发，则需要重新生成绑定。</p><ul><li>对于未包含在 sysroot 搜索路径中的宿主库，可能需要头文件。</li><li>对于带有配置脚本的典型 UNIX 库，<code>compilerOpts</code> 可能包含带有 <code>--cflags</code> 选项的配置脚本输出（可能不包含确切路径）。</li><li>带有 <code>--libs</code> 的配置脚本输出可以传递给 <code>linkerOpts</code> 属性。</li></ul><h2 id="下一步" tabindex="-1">下一步 <a class="header-anchor" href="#下一步" aria-label="Permalink to &quot;下一步&quot;">​</a></h2><ul><li><a href="/kotlin/native-c-interop#bindings">C 互操作性绑定</a></li><li><a href="/kotlin/native-objc-interop">与 Swift/Objective-C 的互操作性</a></li></ul>`,67)]))}const f=a(n,[["render",s]]);export{u as __pageData,f as default};
