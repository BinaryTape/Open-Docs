import{_ as C,C as t,c as y,o as m,G as s,ag as p,j as l,w as a,a as e}from"./chunks/framework.Bksy39di.js";const T=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ktor/client-call-id.md","filePath":"ktor/client-call-id.md","lastUpdated":1755457140000}'),I={name:"ktor/client-call-id.md"};function b(v,i,f,_,F,D){const r=t("TopicTitle"),k=t("show-structure"),h=t("primary-label"),c=t("tldr"),u=t("link-summary"),n=t("code-block"),o=t("TabItem"),d=t("Tabs"),g=t("Links"),E=t("list");return m(),y("div",null,[s(r,{labelRef:"client-plugin",title:"在 Ktor 客户端中追踪请求"}),s(k,{for:"chapter",depth:"2"}),s(h,{ref:"client-plugin"},null,512),s(c,null,{default:a(()=>i[0]||(i[0]=[l("p",null,[l("b",null,"所需依赖项"),e(": "),l("code",null,"io.ktor:ktor-client-call-id")],-1),l("p",null,[l("b",null,"代码示例"),e(": "),l("a",{href:"https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/client-call-id"}," client-call-id ")],-1)])),_:1}),s(u,null,{default:a(()=>i[1]||(i[1]=[e(" CallId 客户端插件允许你通过使用唯一调用 ID 来追踪客户端请求。 ")])),_:1}),i[14]||(i[14]=p('<p>CallId 插件允许你通过使用唯一的调用 ID 来端到端地追踪客户端请求。它在微服务架构中尤其有用，可以帮助追踪调用，无论请求经过多少服务。</p><p>调用作用域在其协程上下文中可能已经包含一个调用 ID。默认情况下，该插件使用当前上下文检索调用 ID，并使用 <code>HttpHeaders.XRequestId</code> 请求头将其添加到特定调用的上下文中。</p><p>此外，如果某个作用域没有调用 ID，你可以<a href="#configure">配置该插件</a>以生成并应用一个新的调用 ID。</p><blockquote><p>在服务端，Ktor 提供了 <a href="./server-call-id">CallId</a> 插件来追踪客户端请求。</p></blockquote><h2 id="add_dependencies" tabindex="-1">添加依赖项 <a class="header-anchor" href="#add_dependencies" aria-label="Permalink to &quot;添加依赖项 {id=&quot;add_dependencies&quot;}&quot;">​</a></h2><p> 要使用 <code>CallId</code>，你需要在构建脚本中包含 <code>ktor-client-call-id</code> artifact： </p>',6)),s(d,{group:"languages"},{default:a(()=>[s(o,{title:"Gradle (Kotlin)","group-key":"kotlin"},{default:a(()=>[s(n,{lang:"Kotlin",code:'            implementation("io.ktor:ktor-client-call-id:$ktor_version")'})]),_:1}),s(o,{title:"Gradle (Groovy)","group-key":"groovy"},{default:a(()=>[s(n,{lang:"Groovy",code:'            implementation "io.ktor:ktor-client-call-id:$ktor_version"'})]),_:1}),s(o,{title:"Maven","group-key":"maven"},{default:a(()=>[s(n,{lang:"XML",code:`            <dependency>
                <groupId>io.ktor</groupId>
                <artifactId>ktor-client-call-id-jvm</artifactId>
                <version>\${ktor_version}</version>
            </dependency>`})]),_:1})]),_:1}),i[15]||(i[15]=l("h2",{id:"install_plugin",tabindex:"-1"},[e("安装 CallId "),l("a",{class:"header-anchor",href:"#install_plugin","aria-label":'Permalink to "安装 CallId {id="install_plugin"}"'},"​")],-1)),l("p",null,[i[3]||(i[3]=e(" 要将 ")),i[4]||(i[4]=l("code",null,"CallId",-1)),i[5]||(i[5]=e(" 插件")),i[6]||(i[6]=l("a",{href:"#install"},"安装",-1)),i[7]||(i[7]=e("到应用程序中， 请将其传递给指定")),s(g,{href:"/ktor/server-modules",summary:"模块允许你通过对路由进行分组来组织应用程序。"},{default:a(()=>i[2]||(i[2]=[e("模块")])),_:1}),i[8]||(i[8]=e("中的 ")),i[9]||(i[9]=l("code",null,"install",-1)),i[10]||(i[10]=e(" 函数。 下面的代码片段展示了如何安装 ")),i[11]||(i[11]=l("code",null,"CallId",-1)),i[12]||(i[12]=e(" ... "))]),s(E,null,{default:a(()=>i[13]||(i[13]=[l("li",null,[e(" ... 在 "),l("code",null,"embeddedServer"),e(" 函数调用内部。 ")],-1),l("li",null,[e(" ... 在显式定义的 "),l("code",null,"module"),e(" 内部，后者是 "),l("code",null,"Application"),e(" 类的扩展函数。 ")],-1)])),_:1}),s(d,null,{default:a(()=>[s(o,{title:"embeddedServer"},{default:a(()=>[s(n,{lang:"kotlin",code:`            import io.ktor.server.engine.*
            import io.ktor.server.netty.*
            import io.ktor.server.application.*
            import io.ktor.client.plugins.callid.*

            fun main() {
                embeddedServer(Netty, port = 8080) {
                    install(CallId)
                    // ...
                }.start(wait = true)
            }`})]),_:1}),s(o,{title:"module"},{default:a(()=>[s(n,{lang:"kotlin",code:`            import io.ktor.server.application.*
            import io.ktor.client.plugins.callid.*
            // ...
            fun Application.module() {
                install(CallId)
                // ...
            }`})]),_:1})]),_:1}),i[16]||(i[16]=p(`<h2 id="configure" tabindex="-1">配置 CallId <a class="header-anchor" href="#configure" aria-label="Permalink to &quot;配置 CallId {id=&quot;configure&quot;}&quot;">​</a></h2><p>CallId 插件配置由 <a href="https://api.ktor.io/ktor-client/ktor-client-plugins/ktor-client-call-id/io.ktor.client.plugins.callid/-call-id-config/index.html" target="_blank" rel="noreferrer">CallIdConfig</a> 类提供， 允许你生成调用 ID 并将其添加到调用上下文。</p><h3 id="生成调用-id" tabindex="-1">生成调用 ID <a class="header-anchor" href="#生成调用-id" aria-label="Permalink to &quot;生成调用 ID&quot;">​</a></h3><p>通过以下方式之一为特定请求生成调用 ID：</p><ul><li><code>useCoroutineContext</code> 属性（默认启用）会添加一个生成器，该生成器使用当前的 <code>CoroutineContext</code> 来检索调用 ID。要禁用此功能，请将 <code>useCoroutineContext</code> 设置为 <code>false</code>：</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CallId) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    useCoroutineContext </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>在 Ktor 服务端，使用 <a href="./server-call-id">CallId 插件</a>将调用 ID 添加到 <code>CoroutineContext</code>。</p></blockquote><ul><li><code>generate()</code> 函数允许你为出站请求生成一个调用 ID。如果未能生成调用 ID，它将返回 <code>null</code>。</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CallId) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    generate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;call-id-client-2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>你可以使用多种方法来生成调用 ID。这样，第一个非 <code>null</code> 值将被应用。</p><h3 id="添加调用-id" tabindex="-1">添加调用 ID <a class="header-anchor" href="#添加调用-id" aria-label="Permalink to &quot;添加调用 ID&quot;">​</a></h3><p>检索到调用 ID 后，你可以使用以下可用选项将其添加到请求中：</p><ul><li><code>intercept()</code> 函数允许你使用 <code>CallIdInterceptor</code> 将调用 ID 添加到请求中。</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ClientCallId) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    intercept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { request, callId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        request.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(HttpHeaders.XRequestId, callId)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>addToHeader()</code> 函数将调用 ID 添加到指定的请求头。它接受一个请求头作为参数，默认值为 <code>HttpHeaders.XRequestId</code>。</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CallId) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    addToHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(HttpHeaders.XRequestId)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><p>在以下示例中，Ktor 客户端的 <code>CallId</code> 插件被配置为生成新的调用 ID 并将其添加到请求头：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> client </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HttpClient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CIO) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CallId) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        generate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;call-id-client&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        addToHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(HttpHeaders.XRequestId)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>该插件使用协程上下文获取调用 ID，并利用 <code>generate()</code> 函数生成一个新的。然后，第一个非 <code>null</code> 调用 ID 将通过 <code>addToHeader()</code> 函数应用到请求头。</p><p>在 Ktor 服务端，调用 ID 可以使用 <a href="./server-call-id">服务器 CallId 插件</a>中的 <a href="./server-call-id#retrieve">retrieve</a> 函数从请求头中检索。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CallId) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    retrieveFromHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(HttpHeaders.XRequestId)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这样，Ktor 服务端会检索请求的指定请求头中的 ID，并将其应用到调用的 <code>callId</code> 属性。</p><p>有关完整示例，请参见 <a href="https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/client-call-id" target="_blank" rel="noreferrer">client-call-id</a>。</p>`,24))])}const x=C(I,[["render",b]]);export{T as __pageData,x as default};
