import{_ as k,C as l,c as r,o as p,ag as o,G as e,w as t,j as i,a}from"./chunks/framework.Bksy39di.js";const v=JSON.parse('{"title":"Kotlin/Native 常见问题解答","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/native-faq.md","filePath":"kotlin/native-faq.md","lastUpdated":1754307826000}'),d={name:"kotlin/native-faq.md"};function c(E,s,g,y,m,b){const n=l("tab"),h=l("tabs");return p(),r("div",null,[s[2]||(s[2]=o(`<h1 id="kotlin-native-常见问题解答" tabindex="-1">Kotlin/Native 常见问题解答 <a class="header-anchor" href="#kotlin-native-常见问题解答" aria-label="Permalink to &quot;Kotlin/Native 常见问题解答&quot;">​</a></h1><h2 id="如何运行我的程序" tabindex="-1">如何运行我的程序？ <a class="header-anchor" href="#如何运行我的程序" aria-label="Permalink to &quot;如何运行我的程序？&quot;">​</a></h2><p>定义一个顶层函数 <code>fun main(args: Array&lt;String&gt;)</code>，或者如果你对传入的实参不感兴趣，则定义 <code>fun main()</code>，请确保它不位于任何包中。 此外，还可以使用编译器选项 <code>-entry</code> 将任何接受 <code>Array&lt;String&gt;</code> 或不接受实参并返回 <code>Unit</code> 的函数设置为入口点。</p><h2 id="kotlin-native-的内存管理模型是什么" tabindex="-1">Kotlin/Native 的内存管理模型是什么？ <a class="header-anchor" href="#kotlin-native-的内存管理模型是什么" aria-label="Permalink to &quot;Kotlin/Native 的内存管理模型是什么？&quot;">​</a></h2><p>Kotlin/Native 采用一种自动化内存管理方案，与 Java 或 Swift 提供的类似。</p><p><a href="/kotlin/native-memory-manager">了解 Kotlin/Native 内存管理器</a></p><h2 id="如何创建共享库" tabindex="-1">如何创建共享库？ <a class="header-anchor" href="#如何创建共享库" aria-label="Permalink to &quot;如何创建共享库？&quot;">​</a></h2><p>使用 <code>-produce dynamic</code> 编译器选项或在你的 Gradle 构建文件中使用 <code>binaries.sharedLib()</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mylib&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        binaries.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sharedLib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>它会生成一个平台特有的共享对象（在 Linux 上是 <code>.so</code>，在 macOS 上是 <code>.dylib</code>，在 Windows 目标平台上是 <code>.dll</code>）和一个 C 语言头文件，允许 C/C++ 代码使用你的 Kotlin/Native 程序中所有可用的公共 API。</p><p><a href="/kotlin/native-dynamic-libraries">完成 Kotlin/Native 作为动态库教程</a></p><h2 id="如何创建静态库或对象文件" tabindex="-1">如何创建静态库或对象文件？ <a class="header-anchor" href="#如何创建静态库或对象文件" aria-label="Permalink to &quot;如何创建静态库或对象文件？&quot;">​</a></h2><p>使用 <code>-produce static</code> 编译器选项或在你的 Gradle 构建文件中使用 <code>binaries.staticLib()</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mylib&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        binaries.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">staticLib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>它会生成一个平台特有的静态对象（<code>.a</code> 库格式）和一个 C 语言头文件，允许你使用 Kotlin/Native 程序中所有可用的公共 API。</p><h2 id="如何在企业代理后运行-kotlin-native" tabindex="-1">如何在企业代理后运行 Kotlin/Native？ <a class="header-anchor" href="#如何在企业代理后运行-kotlin-native" aria-label="Permalink to &quot;如何在企业代理后运行 Kotlin/Native？&quot;">​</a></h2><p>由于 Kotlin/Native 需要下载平台特有的工具链，你需要将 <code>-Dhttp.proxyHost=xxx -Dhttp.proxyPort=xxx</code> 指定为编译器或 <code>gradlew</code> 的实参，或者通过 <code>JAVA_OPTS</code> 环境变量进行设置。</p><h2 id="如何为我的-kotlin-framework-指定自定义的-objective-c-前缀-名称" tabindex="-1">如何为我的 Kotlin framework 指定自定义的 Objective-C 前缀/名称？ <a class="header-anchor" href="#如何为我的-kotlin-framework-指定自定义的-objective-c-前缀-名称" aria-label="Permalink to &quot;如何为我的 Kotlin framework 指定自定义的 Objective-C 前缀/名称？&quot;">​</a></h2><p>使用 <code>-module-name</code> 编译器选项或匹配的 Gradle DSL 语句。</p>`,19)),e(h,{group:"build-script"},{default:t(()=>[e(n,{title:"Kotlin","group-key":"kotlin"},{default:t(()=>s[0]||(s[0]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    iosArm64"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"myapp"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        binaries."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"framework"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            freeCompilerArgs "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"+="),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," listOf"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"-module-name"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", "),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"TheName"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),e(n,{title:"Groovy","group-key":"groovy"},{default:t(()=>s[1]||(s[1]=[i("div",{class:"language-groovy vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"groovy"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"kotlin {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    iosArm64("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"myapp"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        binaries"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"framework {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            freeCompilerArgs "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"+="),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," ["),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"-module-name"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", "),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"TheName"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"]")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),s[3]||(s[3]=o(`<h2 id="如何重命名-ios-framework" tabindex="-1">如何重命名 iOS framework？ <a class="header-anchor" href="#如何重命名-ios-framework" aria-label="Permalink to &quot;如何重命名 iOS framework？&quot;">​</a></h2><p>iOS framework 的默认名称是 <code>&lt;项目名&gt;.framework</code>。 要设置自定义名称，请使用 <code>baseName</code> 选项。这也会设置模块名称。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myapp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       binaries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          framework</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              baseName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;TheName&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="如何为我的-kotlin-framework-启用-bitcode" tabindex="-1">如何为我的 Kotlin framework 启用 Bitcode？ <a class="header-anchor" href="#如何为我的-kotlin-framework-启用-bitcode" aria-label="Permalink to &quot;如何为我的 Kotlin framework 启用 Bitcode？&quot;">​</a></h2><p>Bitcode 嵌入在 Xcode 14 中已弃用，并在 Xcode 15 中针对所有 Apple 目标平台移除。 Kotlin/Native 编译器自 Kotlin 2.0.20 起不再支持 Bitcode 嵌入。</p><p>如果你正在使用较早版本的 Xcode 但希望升级到 Kotlin 2.0.20 或更高版本，请在你的 Xcode 项目中禁用 Bitcode 嵌入。</p><h2 id="如何安全地从不同的协程引用对象" tabindex="-1">如何安全地从不同的协程引用对象？ <a class="header-anchor" href="#如何安全地从不同的协程引用对象" aria-label="Permalink to &quot;如何安全地从不同的协程引用对象？&quot;">​</a></h2><p>要在 Kotlin/Native 中安全地跨多个协程访问或更新对象，请考虑使用并发安全的构造，例如 <code>@Volatile</code> 和 <code>AtomicReference</code>。</p><p>使用 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.concurrent/-volatile/" target="_blank" rel="noreferrer"><code>@Volatile</code></a> 注解 <code>var</code> 属性。这使得对该属性幕后字段的所有读写都成为原子操作。此外，写入会立即对其他线程可见。当其他线程访问此属性时，它不仅会观察到更新后的值，还会观察到在更新之前发生的所有更改。</p><p>或者，使用 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.concurrent.atomics/-atomic-reference/" target="_blank" rel="noreferrer">AtomicReference</a>，它支持原子读写和更新。在 Kotlin/Native 上，它封装了一个 volatile 变量并执行原子操作。Kotlin 还提供了一组针对特定数据类型量身定制的原子操作类型。你可以使用 <code>AtomicInt</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code>、<code>AtomicArray</code>，以及 <code>AtomicIntArray</code> 和 <code>AtomicLongArray</code>。</p><p>有关访问共享可变状态的更多信息，请参阅<a href="/kotlin/shared-mutable-state-and-concurrency">协程文档</a>。</p><h2 id="如何使用未发布的-kotlin-native-版本编译我的项目" tabindex="-1">如何使用未发布的 Kotlin/Native 版本编译我的项目？ <a class="header-anchor" href="#如何使用未发布的-kotlin-native-版本编译我的项目" aria-label="Permalink to &quot;如何使用未发布的 Kotlin/Native 版本编译我的项目？&quot;">​</a></h2><p>首先，请考虑尝试<a href="/kotlin/eap">抢先体验预览版本</a>。</p><p>如果你需要更近期的开发版本，你可以从源代码构建 Kotlin/Native：克隆 <a href="https://github.com/JetBrains/kotlin" target="_blank" rel="noreferrer">Kotlin 版本库</a>并遵循<a href="https://github.com/JetBrains/kotlin/blob/master/kotlin-native/README.md#building-from-source" target="_blank" rel="noreferrer">这些步骤</a>。</p>`,14))])}const f=k(d,[["render",c]]);export{v as __pageData,f as default};
