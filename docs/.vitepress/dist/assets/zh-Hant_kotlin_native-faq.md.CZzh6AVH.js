import{_ as k,C as l,c as p,o as r,ag as h,G as t,w as e,j as i,a}from"./chunks/framework.Bksy39di.js";const v=JSON.parse('{"title":"Kotlin/Native 常見問題","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/native-faq.md","filePath":"zh-Hant/kotlin/native-faq.md","lastUpdated":1754307826000}'),d={name:"zh-Hant/kotlin/native-faq.md"};function c(E,s,g,y,b,m){const n=l("tab"),o=l("tabs");return r(),p("div",null,[s[2]||(s[2]=h(`<h1 id="kotlin-native-常見問題" tabindex="-1">Kotlin/Native 常見問題 <a class="header-anchor" href="#kotlin-native-常見問題" aria-label="Permalink to &quot;Kotlin/Native 常見問題&quot;">​</a></h1><h2 id="如何執行我的程式" tabindex="-1">如何執行我的程式？ <a class="header-anchor" href="#如何執行我的程式" aria-label="Permalink to &quot;如何執行我的程式？&quot;">​</a></h2><p>若您不關心傳入的參數，請定義一個頂層函數 <code>fun main(args: Array&lt;String&gt;)</code> 或僅定義 <code>fun main()</code>，並請確保它不在任何套件中。 此外，編譯器開關 <code>-entry</code> 也可用於將任何接受 <code>Array&lt;String&gt;</code> 或不接受參數並傳回 <code>Unit</code> 的函數作為進入點。</p><h2 id="什麼是-kotlin-native-記憶體管理模型" tabindex="-1">什麼是 Kotlin/Native 記憶體管理模型？ <a class="header-anchor" href="#什麼是-kotlin-native-記憶體管理模型" aria-label="Permalink to &quot;什麼是 Kotlin/Native 記憶體管理模型？&quot;">​</a></h2><p>Kotlin/Native 使用一種自動化記憶體管理方案，類似於 Java 或 Swift 所提供的。</p><p><a href="/zh-Hant/kotlin/native-memory-manager">了解 Kotlin/Native 記憶體管理器</a></p><h2 id="如何建立共用程式庫" tabindex="-1">如何建立共用程式庫？ <a class="header-anchor" href="#如何建立共用程式庫" aria-label="Permalink to &quot;如何建立共用程式庫？&quot;">​</a></h2><p>在您的 Gradle 建構檔案中使用 <code>-produce dynamic</code> 編譯器選項或 <code>binaries.sharedLib()</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mylib&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        binaries.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sharedLib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>它會產生一個平台特定的共用物件（Linux 上為 <code>.so</code>，macOS 上為 <code>.dylib</code>，Windows 目標上為 <code>.dll</code>）以及一個 C 語言標頭檔，允許您從 C/C++ 程式碼中使用 Kotlin/Native 程式中所有公開的 API。</p><p><a href="/zh-Hant/kotlin/native-dynamic-libraries">完成 Kotlin/Native 作為動態程式庫的教學</a></p><h2 id="如何建立靜態程式庫或物件檔" tabindex="-1">如何建立靜態程式庫或物件檔？ <a class="header-anchor" href="#如何建立靜態程式庫或物件檔" aria-label="Permalink to &quot;如何建立靜態程式庫或物件檔？&quot;">​</a></h2><p>在您的 Gradle 建構檔案中使用 <code>-produce static</code> 編譯器選項或 <code>binaries.staticLib()</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mylib&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        binaries.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">staticLib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>它會產生一個平台特定的靜態物件（<code>.a</code> 程式庫格式）以及一個 C 語言標頭檔，允許您從 C/C++ 程式碼中使用 Kotlin/Native 程式中所有公開的 API。</p><h2 id="如何在企業代理後面執行-kotlin-native" tabindex="-1">如何在企業代理後面執行 Kotlin/Native？ <a class="header-anchor" href="#如何在企業代理後面執行-kotlin-native" aria-label="Permalink to &quot;如何在企業代理後面執行 Kotlin/Native？&quot;">​</a></h2><p>由於 Kotlin/Native 需要下載平台特定的工具鏈，您需要將 <code>-Dhttp.proxyHost=xxx -Dhttp.proxyPort=xxx</code> 指定為編譯器或 <code>gradlew</code> 參數， 或者透過 <code>JAVA_OPTS</code> 環境變數來設定。</p><h2 id="如何為我的-kotlin-框架指定自訂的-objective-c-前綴-名稱" tabindex="-1">如何為我的 Kotlin 框架指定自訂的 Objective-C 前綴/名稱？ <a class="header-anchor" href="#如何為我的-kotlin-框架指定自訂的-objective-c-前綴-名稱" aria-label="Permalink to &quot;如何為我的 Kotlin 框架指定自訂的 Objective-C 前綴/名稱？&quot;">​</a></h2><p>使用 <code>-module-name</code> 編譯器選項或相應的 Gradle DSL 語句。</p>`,19)),t(o,{group:"build-script"},{default:e(()=>[t(n,{title:"Kotlin","group-key":"kotlin"},{default:e(()=>s[0]||(s[0]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    iosArm64"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"myapp"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        binaries."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"framework"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            freeCompilerArgs "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"+="),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," listOf"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"-module-name"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", "),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"TheName"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),t(n,{title:"Groovy","group-key":"groovy"},{default:e(()=>s[1]||(s[1]=[i("div",{class:"language-groovy vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"groovy"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"kotlin {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    iosArm64("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"myapp"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        binaries"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"framework {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            freeCompilerArgs "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"+="),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," ["),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"-module-name"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", "),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"TheName"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"]")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),s[3]||(s[3]=h(`<h2 id="如何重新命名-ios-框架" tabindex="-1">如何重新命名 iOS 框架？ <a class="header-anchor" href="#如何重新命名-ios-框架" aria-label="Permalink to &quot;如何重新命名 iOS 框架？&quot;">​</a></h2><p>iOS 框架的預設名稱為 <code>&lt;project name&gt;.framework</code>。 要設定自訂名稱，請使用 <code>baseName</code> 選項。這也將設定模組名稱。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myapp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       binaries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          framework</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              baseName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;TheName&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="如何為我的-kotlin-框架啟用-bitcode" tabindex="-1">如何為我的 Kotlin 框架啟用 Bitcode？ <a class="header-anchor" href="#如何為我的-kotlin-框架啟用-bitcode" aria-label="Permalink to &quot;如何為我的 Kotlin 框架啟用 Bitcode？&quot;">​</a></h2><p>從 Xcode 14 開始，Bitcode 嵌入功能已被棄用，並在 Xcode 15 中針對所有 Apple 目標平台移除。 自 Kotlin 2.0.20 起，Kotlin/Native 編譯器不再支援 Bitcode 嵌入。</p><p>如果您正在使用較早版本的 Xcode 但想升級到 Kotlin 2.0.20 或更高版本，請在您的 Xcode 專案中停用 Bitcode 嵌入。</p><h2 id="如何安全地從不同協程參考物件" tabindex="-1">如何安全地從不同協程參考物件？ <a class="header-anchor" href="#如何安全地從不同協程參考物件" aria-label="Permalink to &quot;如何安全地從不同協程參考物件？&quot;">​</a></h2><p>為了在 Kotlin/Native 中跨多個協程安全地存取或更新物件，請考慮使用並行安全建構，例如 <code>@Volatile</code> 和 <code>AtomicReference</code>。</p><p>使用 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.concurrent/-volatile/" target="_blank" rel="noreferrer"><code>@Volatile</code></a> 來標註 <code>var</code> 屬性。 這使得對屬性後備欄位的所有讀取和寫入都具有原子性。此外，寫入會立即對其他執行緒可見。當另一個執行緒存取此屬性時，它不僅觀察到更新值，還觀察到更新之前發生的變更。</p><p>或者，使用 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.concurrent.atomics/-atomic-reference/" target="_blank" rel="noreferrer">AtomicReference</a>，它支援原子讀取和更新。在 Kotlin/Native 上，它包裹一個 volatile 變數並執行原子操作。 Kotlin 還提供了一組針對特定資料類型量身打造的原子操作類型。您可以使用 <code>AtomicInt</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code>、<code>AtomicArray</code>，以及 <code>AtomicIntArray</code> 和 <code>AtomicLongArray</code>。</p><p>有關共用可變狀態存取的更多資訊，請參閱 <a href="/zh-Hant/kotlin/shared-mutable-state-and-concurrency">協程文件</a>。</p><h2 id="如何使用未發布的-kotlin-native-版本編譯我的專案" tabindex="-1">如何使用未發布的 Kotlin/Native 版本編譯我的專案？ <a class="header-anchor" href="#如何使用未發布的-kotlin-native-版本編譯我的專案" aria-label="Permalink to &quot;如何使用未發布的 Kotlin/Native 版本編譯我的專案？&quot;">​</a></h2><p>首先，請考慮嘗試 <a href="/zh-Hant/kotlin/eap">預覽版本</a>。</p><p>如果您需要更新的開發版本，您可以從原始碼建構 Kotlin/Native：克隆 <a href="https://github.com/JetBrains/kotlin" target="_blank" rel="noreferrer">Kotlin 儲存庫</a> 並遵循 <a href="https://github.com/JetBrains/kotlin/blob/master/kotlin-native/README.md#building-from-source" target="_blank" rel="noreferrer">這些步驟</a>。</p>`,14))])}const F=k(d,[["render",c]]);export{v as __pageData,F as default};
