import{_ as c,a as p,b as r}from"./chunks/tutorial_persistence_database_tool_window.CIMhXNzI.js";import{_ as h,C as t,c as k,o as u,j as e,G as i,ag as g,a as s,w as o}from"./chunks/framework.Bksy39di.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ktor/db-persistence.md","filePath":"ktor/db-persistence.md","lastUpdated":1755457140000}'),b={name:"ktor/db-persistence.md"};function m(v,a,E,y,q,C){const d=t("show-structure"),l=t("tldr"),n=t("link-summary");return u(),k("div",null,[a[2]||(a[2]=e("h1",{id:"数据库持久化与-exposed",tabindex:"-1"},[s("数据库持久化与 Exposed "),e("a",{class:"header-anchor",href:"#数据库持久化与-exposed","aria-label":'Permalink to "数据库持久化与 Exposed"'},"​")],-1)),i(d,{for:"chapter",depth:"2"}),i(l,null,{default:o(()=>a[0]||(a[0]=[e("p",null,[e("b",null,"代码示例"),s(": "),e("a",{href:"https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/tutorial-website-interactive-persistence"}," tutorial-website-interactive-persistence ")],-1),e("p",null,[e("b",null,"所用库"),s(": "),e("a",{href:"https://github.com/JetBrains/Exposed"},"Exposed"),s(", "),e("a",{href:"https://github.com/h2database/h2database"},"h2database")],-1)])),_:1}),i(n,null,{default:o(()=>a[1]||(a[1]=[s("学习如何使用 Exposed ORM 框架为网站添加持久化。")])),_:1}),a[3]||(a[3]=g(`<p>在本系列教程中，我们将向你展示如何在 Ktor 中创建一个简单的博客应用程序：</p><ul><li>在第一个教程中，我们展示了如何托管图片和 HTML 页面等静态内容。</li><li>在第二个教程中，我们使用 FreeMarker 模板引擎为应用程序添加了交互性。</li><li>在<strong>本教程</strong>中，我们将使用 Exposed 框架为网站添加持久化。我们将使用 H2 本地数据库存储文章。</li><li>在<a href="./db-connection-pooling-caching">下一篇教程</a>中，我们将分别探讨如何使用 HikariCP 和 Ehcache 库实现数据库连接池和缓存。</li></ul><h2 id="add-dependencies" tabindex="-1">添加依赖项 <a class="header-anchor" href="#add-dependencies" aria-label="Permalink to &quot;添加依赖项 {id=&quot;add-dependencies&quot;}&quot;">​</a></h2><p>首先，你需要为 Exposed 和 H2 库添加依赖项。打开 <code>gradle.properties</code> 文件并指定库版本：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">exposed_version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.53</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">h2_version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">232</span></span></code></pre></div><p>然后，打开 <code>build.gradle.kts</code> 并添加以下依赖项：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>点击 <code>build.gradle.kts</code> 文件右上角的 <strong>加载 Gradle 更改</strong> 图标以安装新添加的依赖项。</p><h2 id="model" tabindex="-1">更新模型 <a class="header-anchor" href="#model" aria-label="Permalink to &quot;更新模型 {id=&quot;model&quot;}&quot;">​</a></h2><p>Exposed 使用 <code>org.jetbrains.exposed.sql.Table</code> 类作为数据库表。要更新 <code>Article</code> 模型，请打开 <code>models/Article.kt</code> 文件并将现有代码替换为以下内容：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p><code>id</code>、<code>title</code> 和 <code>body</code> 列将存储我们文章的信息。<code>id</code> 列将作为主键。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如果你<a href="https://www.jetbrains.com/help/idea/viewing-reference-information.html#type-info" target="_blank" rel="noreferrer">检查 <code>Articles</code> 对象中属性的类型</a>，你会发现它们具有 <code>Column</code> 类型，并带有必要的类型实参：<code>id</code> 具有 <code>Column&lt;Int&gt;</code> 类型，而 <code>title</code> 和 <code>body</code> 都具有 <code>Column&lt;String&gt;</code> 类型。</p></div><h2 id="connect_db" tabindex="-1">连接到数据库 <a class="header-anchor" href="#connect_db" aria-label="Permalink to &quot;连接到数据库 {id=&quot;connect_db&quot;}&quot;">​</a></h2><p><a href="https://en.wikipedia.org/wiki/Data_access_object" target="_blank" rel="noreferrer">数据访问对象</a> (DAO) 是一种模式，它提供对数据库的接口，而无需暴露特定数据库的细节。我们稍后将定义一个 <code>DAOFacade</code> 接口来抽象我们对数据库的特定请求。</p><p>Exposed 中的每次数据库访问都是通过获取数据库连接来启动的。为此，你需要将 JDBC URL 和驱动程序类名传递给 <code>Database.connect</code> 函数。在 <code>com.example</code> 内部创建 <code>dao</code> 包并添加新的 <code>DatabaseSingleton.kt</code> 文件。然后，插入以下代码：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><blockquote><p>请注意，<code>driverClassName</code> 和 <code>jdbcURL</code> 在此处是硬编码的。Ktor 允许你将此类设置提取到<a href="./server-configuration-file">自定义配置组</a>中。</p></blockquote><h3 id="create_table" tabindex="-1">创建表 <a class="header-anchor" href="#create_table" aria-label="Permalink to &quot;创建表 {id=&quot;create_table&quot;}&quot;">​</a></h3><p>获取连接后，所有 SQL 语句都应放在事务中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> database </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Database.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jdbcURL, driverClassName)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transaction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(database) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Statements here</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在此代码示例中，默认数据库被显式传递给 <code>transaction</code> 函数。如果你只有一个数据库，可以省略它。在这种情况下，Exposed 会自动使用最后连接的数据库进行事务处理。</p><blockquote><p>请注意，<code>Database.connect</code> 函数在你调用事务之前不会建立真实的数据库连接——它只会为未来的连接创建一个描述符。</p></blockquote><p>鉴于 <code>Articles</code> 表已声明，我们可以在 <code>init</code> 函数的底部调用 <code>SchemaUtils.create(Articles)</code>，并将其包装在 <code>transaction</code> 调用中，以指示数据库在表不存在时创建该表：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> database </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Database.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jdbcURL, driverClassName)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transaction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(database) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        SchemaUtils.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Articles)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="queries" tabindex="-1">执行查询 <a class="header-anchor" href="#queries" aria-label="Permalink to &quot;执行查询 {id=&quot;queries&quot;}&quot;">​</a></h3><p>为方便起见，我们在 <code>DatabaseSingleton</code> 对象内部创建一个实用函数 <code>dbQuery</code>，我们将用它来处理所有未来的数据库请求。与其使用事务以阻塞方式访问数据库，不如利用协程并在其自己的协程中启动每个查询：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>最终的 <code>DatabaseSingleton.kt</code> 文件应如下所示：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h3 id="startup" tabindex="-1">在启动时加载数据库配置 <a class="header-anchor" href="#startup" aria-label="Permalink to &quot;在启动时加载数据库配置 {id=&quot;startup&quot;}&quot;">​</a></h3><p>最后，我们需要在应用程序启动时加载创建的配置。打开 <code>Application.kt</code> 并在 <code>Application.module</code> 主体中调用 <code>DatabaseSingleton.init</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h2 id="persistence_logic" tabindex="-1">实现持久化逻辑 <a class="header-anchor" href="#persistence_logic" aria-label="Permalink to &quot;实现持久化逻辑 {id=&quot;persistence_logic&quot;}&quot;">​</a></h2><p>现在让我们创建一个接口来抽象更新文章所需的必要操作。在 <code>dao</code> 包中创建 <code>DAOFacade.kt</code> 文件并填充以下代码：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>我们需要列出所有文章，通过其 ID 查看文章，添加新文章，编辑或删除文章。由于所有这些函数都在底层执行数据库查询，因此它们被定义为挂起函数。</p><p>要实现 <code>DAOFacade</code> 接口，请将光标放在其名称上，点击接口旁边的黄色灯泡图标并选择 <strong>实现接口</strong>。在弹出的对话框中，保留默认设置并点击 <strong>OK</strong>。</p><p>在 <strong>实现成员</strong> 对话框中，选择所有函数并点击 <strong>OK</strong>。</p><p><img src="`+c+'" alt="Implement Members" width="451"></p><p>IntelliJ IDEA 在 <code>dao</code> 包中创建 <code>DAOFacadeImpl.kt</code> 文件。让我们使用 Exposed DSL 实现所有函数。</p><h3 id="get_all" tabindex="-1">获取所有文章 <a class="header-anchor" href="#get_all" aria-label="Permalink to &quot;获取所有文章 {id=&quot;get_all&quot;}&quot;">​</a></h3><p>让我们从一个返回所有条目的函数开始。我们的请求被包装在 <code>dbQuery</code> 调用中。我们调用 <code>Table.selectAll</code> 扩展函数从数据库中获取所有数据。<code>Articles</code> 对象是 <code>Table</code> 的子类，因此我们使用 Exposed DSL 方法来处理它。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p><code>Table.selectAll</code> 返回一个 <code>Query</code> 实例，因此要获取 <code>Article</code> 实例的 list，我们需要手动提取每一行的数据并将其转换为我们的数据类。我们通过使用辅助函数 <code>resultRowToArticle</code> 来实现这一点，该函数从 <code>ResultRow</code> 构建一个 <code>Article</code>。</p><p><code>ResultRow</code> 提供了一种通过使用简洁的 <code>get</code> 操作符获取存储在指定 <code>Column</code> 中的数据的方式，允许我们使用方括号语法，类似于数组或 map。</p><blockquote><p><code>Articles.id</code> 的类型是 <code>Column&lt;Int&gt;</code>，它实现了 <code>Expression</code> 接口。这就是为什么我们可以将任何列作为表达式传递。</p></blockquote><h3 id="get_article" tabindex="-1">获取文章 <a class="header-anchor" href="#get_article" aria-label="Permalink to &quot;获取文章 {id=&quot;get_article&quot;}&quot;">​</a></h3><p>现在让我们实现一个返回一篇文章的函数：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p><code>select</code> 函数将一个扩展 lambda 作为实参。此 lambda 内的隐式接收者类型为 <code>SqlExpressionBuilder</code>。你不需要显式使用此类型，但它定义了大量有用的列操作，你可以使用它们来构建查询。你可以使用比较（<code>eq</code>、<code>less</code>、<code>greater</code>）、算术操作（<code>plus</code>、<code>times</code>）、检查值是否属于或不属于提供的值 list（<code>inList</code>、<code>notInList</code>）、检查值是否为空或非空等等。</p><p><code>select</code> 返回一个 <code>Query</code> 值 list。和以前一样，我们将它们转换为文章。在我们的例子中，它应该是一篇文章，所以我们将其作为结果返回。</p><h3 id="add_article" tabindex="-1">添加新文章 <a class="header-anchor" href="#add_article" aria-label="Permalink to &quot;添加新文章 {id=&quot;add_article&quot;}&quot;">​</a></h3><p>要将新文章插入到表中，请使用 <code>Table.insert</code> 函数，它接受一个 lambda 实参：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>在此 lambda 内部，我们指定哪个值应该被设置到哪个列。<code>it</code> 实参的类型为 <code>InsertStatement</code>，我们可以对它调用 <code>set</code> 操作符，该操作符接受列和值作为实参。</p><h3 id="edit_article" tabindex="-1">编辑文章 <a class="header-anchor" href="#edit_article" aria-label="Permalink to &quot;编辑文章 {id=&quot;edit_article&quot;}&quot;">​</a></h3><p>要更新现有文章，请使用 <code>Table.update</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h3 id="delete_article" tabindex="-1">删除文章 <a class="header-anchor" href="#delete_article" aria-label="Permalink to &quot;删除文章 {id=&quot;delete_article&quot;}&quot;">​</a></h3><p>最后，使用 <code>Table.deleteWhere</code> 从数据库中删除文章：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h3 id="init-dao-facade" tabindex="-1">初始化 DAOFacade <a class="header-anchor" href="#init-dao-facade" aria-label="Permalink to &quot;初始化 DAOFacade {id=&quot;init-dao-facade&quot;}&quot;">​</a></h3><p>让我们创建 <code>DAOFacade</code> 的实例，并在应用程序启动之前添加一个要插入到数据库的示例文章。 在 <code>DAOFacadeImpl.kt</code> 的底部添加以下代码：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h2 id="update_routes" tabindex="-1">更新路由 <a class="header-anchor" href="#update_routes" aria-label="Permalink to &quot;更新路由 {id=&quot;update_routes&quot;}&quot;">​</a></h2><p>现在我们准备好在路由处理程序中使用已实现的数据库操作。 打开 <code>plugins/Routing.kt</code> 文件。 要显示所有文章，请在 <code>get</code> 处理程序中调用 <code>dao.allArticles</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>要发布新文章，请在 <code>post</code> 中调用 <code>dao.addNewArticle</code> 函数：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>要获取文章以供显示和编辑，请分别在 <code>get(&quot;{id}&quot;)</code> 和 <code>get(&quot;{id}/edit&quot;)</code> 中使用 <code>dao.article</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>最后，进入 <code>post(&quot;{id}&quot;)</code> 处理程序并使用 <code>dao.editArticle</code> 更新文章和 <code>dao.deleteArticle</code> 删除文章：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><blockquote><p>你可以在此处找到本教程的最终项目：<a href="https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/tutorial-website-interactive-persistence" target="_blank" rel="noreferrer">tutorial-website-interactive-persistence</a>。</p></blockquote><h2 id="run_app" tabindex="-1">运行应用程序 <a class="header-anchor" href="#run_app" aria-label="Permalink to &quot;运行应用程序 {id=&quot;run_app&quot;}&quot;">​</a></h2><p>让我们看看我们的日志应用程序是否按预期运行。我们可以通过点击 <code>Application.kt</code> 中 <code>fun main(...)</code> 旁边的 <strong>运行</strong> 按钮来运行我们的应用程序：</p><p><img src="'+p+'" alt="Run Server" width="706"></p><p>IntelliJ IDEA 将启动应用程序，几秒钟后，我们应该会看到应用程序正在运行的确认信息：</p><div class="language-Bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[main] INFO  Application - Responding at http://0.0.0.0:8080</span></span></code></pre></div><p>在浏览器中打开 <a href="http://localhost:8080/" target="_blank" rel="noreferrer"><code>http://localhost:8080/</code></a> 并尝试创建、编辑和删除文章。文章将保存到 <code>build/db.mv.db</code> 文件中。在 IntelliJ IDEA 中，你可以在<a href="https://www.jetbrains.com/help/idea/database-tool-window.html" target="_blank" rel="noreferrer">数据库工具窗口</a>中查看此文件的内容。</p><p><img src="'+r+'" alt="Database tool window" width="706"></p>',82))])}const A=h(b,[["render",m]]);export{f as __pageData,A as default};
