import{_ as a,c as i,o as t,ag as n}from"./chunks/framework.Bksy39di.js";const o=JSON.parse('{"title":"追踪","description":"","frontmatter":{},"headers":[],"relativePath":"koog/tracing.md","filePath":"koog/tracing.md","lastUpdated":1755146406000}'),e={name:"koog/tracing.md"};function l(h,s,p,d,k,r){return t(),i("div",null,s[0]||(s[0]=[n(`<h1 id="追踪" tabindex="-1">追踪 <a class="header-anchor" href="#追踪" aria-label="Permalink to &quot;追踪&quot;">​</a></h1><p>本页面包含有关 Tracing 特性的详细信息，该特性为 AI 代理提供了全面的追踪能力。</p><h2 id="特性概览" tabindex="-1">特性概览 <a class="header-anchor" href="#特性概览" aria-label="Permalink to &quot;特性概览&quot;">​</a></h2><p>Tracing 特性是一个强大的监控和调试工具，它捕获有关代理运行的详细信息，包括：</p><ul><li>策略执行</li><li>LLM 调用</li><li>工具调用</li><li>代理图中的节点执行</li></ul><p>此特性通过拦截代理流水线中的关键事件并将其转发给可配置的消息处理器来运行。这些处理器可以将追踪信息输出到各种目标，例如日志文件或文件系统中的其他类型文件，使开发者能够深入了解代理行为并有效排查问题。</p><h3 id="事件流" tabindex="-1">事件流 <a class="header-anchor" href="#事件流" aria-label="Permalink to &quot;事件流&quot;">​</a></h3><ol><li>Tracing 特性拦截代理流水线中的事件。</li><li>事件根据配置的消息过滤器进行过滤。</li><li>过滤后的事件传递给已注册的消息处理器。</li><li>消息处理器格式化事件并将其输出到各自的目标。</li></ol><h2 id="配置与初始化" tabindex="-1">配置与初始化 <a class="header-anchor" href="#配置与初始化" aria-label="Permalink to &quot;配置与初始化&quot;">​</a></h2><h3 id="基本设置" tabindex="-1">基本设置 <a class="header-anchor" href="#基本设置" aria-label="Permalink to &quot;基本设置&quot;">​</a></h3><p>要使用 Tracing 特性，你需要：</p><ol><li>拥有一个或多个消息处理器（你可以使用现有处理器或创建自己的处理器）。</li><li>在你的代理中安装 <code>Tracing</code>。</li><li>配置消息过滤器（可选）。</li><li>将消息处理器添加到该特性中。</li></ol><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义将用作追踪消息目标的日志器/文件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> logger </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KotlinLogging.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> outputPath </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/trace.log&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建代理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> agent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AIAgent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> simpleOllamaAIExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   llmModel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> OllamaModels.Meta.LLAMA_3_2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Tracing) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 配置消息处理器以处理追踪事件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      addMessageProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TraceFeatureMessageLogWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(logger))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      addMessageProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         TraceFeatureMessageFileWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            outputPath,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            { path: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SystemFileSystem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sink</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">buffered</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 可选地过滤消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      messageFilter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 仅追踪 LLM 调用和工具调用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AfterLLMCallEvent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ToolCallEvent</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="消息过滤" tabindex="-1">消息过滤 <a class="header-anchor" href="#消息过滤" aria-label="Permalink to &quot;消息过滤&quot;">​</a></h3><p>你可以处理所有现有事件，或根据特定条件选择其中一些。消息过滤器允许你控制哪些事件被处理。这对于关注代理运行的特定方面很有用：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 仅过滤与 LLM 相关的事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">messageFilter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BeforeLLMCallEvent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AfterLLMCallEvent</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 仅过滤与工具相关的事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">messageFilter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ToolCallEvent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ToolCallResultEvent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ToolValidationErrorEvent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ToolCallFailureEvent</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 仅过滤节点执行事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">messageFilter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AIAgentNodeExecutionStartEvent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AIAgentNodeExecutionEndEvent</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="大量追踪数据" tabindex="-1">大量追踪数据 <a class="header-anchor" href="#大量追踪数据" aria-label="Permalink to &quot;大量追踪数据&quot;">​</a></h3><p>对于具有复杂策略或长时间运行的代理，追踪事件量可能非常大。考虑使用以下方法管理事件量：</p><ul><li>使用特定的消息过滤器来减少事件数量。</li><li>实现带有缓冲或采样的自定义消息处理器。</li><li>对日志文件使用文件轮转，以防止它们变得过大。</li></ul><h3 id="依赖图" tabindex="-1">依赖图 <a class="header-anchor" href="#依赖图" aria-label="Permalink to &quot;依赖图&quot;">​</a></h3><p>Tracing 特性具有以下依赖项：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Tracing</span></span>
<span class="line"><span>├── AIAgentPipeline (用于拦截事件)</span></span>
<span class="line"><span>├── TraceFeatureConfig</span></span>
<span class="line"><span>│   └── FeatureConfig</span></span>
<span class="line"><span>├── Message Processors (消息处理器)</span></span>
<span class="line"><span>│   ├── TraceFeatureMessageLogWriter</span></span>
<span class="line"><span>│   │   └── FeatureMessageLogWriter</span></span>
<span class="line"><span>│   ├── TraceFeatureMessageFileWriter</span></span>
<span class="line"><span>│   │   └── FeatureMessageFileWriter</span></span>
<span class="line"><span>│   └── TraceFeatureMessageRemoteWriter</span></span>
<span class="line"><span>│       └── FeatureMessageRemoteWriter</span></span>
<span class="line"><span>└── Event Types (事件类型) (from ai.koog.agents.core.feature.model)</span></span>
<span class="line"><span>    ├── AIAgentStartedEvent</span></span>
<span class="line"><span>    ├── AIAgentFinishedEvent</span></span>
<span class="line"><span>    ├── AIAgentRunErrorEvent</span></span>
<span class="line"><span>    ├── AIAgentStrategyStartEvent</span></span>
<span class="line"><span>    ├── AIAgentStrategyFinishedEvent</span></span>
<span class="line"><span>    ├── AIAgentNodeExecutionStartEvent</span></span>
<span class="line"><span>    ├── AIAgentNodeExecutionEndEvent</span></span>
<span class="line"><span>    ├── LLMCallStartEvent</span></span>
<span class="line"><span>    ├── LLMCallWithToolsStartEvent</span></span>
<span class="line"><span>    ├── LLMCallEndEvent</span></span>
<span class="line"><span>    ├── LLMCallWithToolsEndEvent</span></span>
<span class="line"><span>    ├── ToolCallEvent</span></span>
<span class="line"><span>    ├── ToolValidationErrorEvent</span></span>
<span class="line"><span>    ├── ToolCallFailureEvent</span></span>
<span class="line"><span>    └── ToolCallResultEvent</span></span></code></pre></div><h2 id="示例与快速入门" tabindex="-1">示例与快速入门 <a class="header-anchor" href="#示例与快速入门" aria-label="Permalink to &quot;示例与快速入门&quot;">​</a></h2><h3 id="基本日志追踪" tabindex="-1">基本日志追踪 <a class="header-anchor" href="#基本日志追踪" aria-label="Permalink to &quot;基本日志追踪&quot;">​</a></h3><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个日志器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> logger </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KotlinLogging.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 创建一个带追踪功能的代理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> agent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AIAgent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> simpleOllamaAIExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          llmModel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> OllamaModels.Meta.LLAMA_3_2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       ) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Tracing) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">             addMessageProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TraceFeatureMessageLogWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(logger))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 运行代理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       agent.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, agent!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="错误处理与边缘情况" tabindex="-1">错误处理与边缘情况 <a class="header-anchor" href="#错误处理与边缘情况" aria-label="Permalink to &quot;错误处理与边缘情况&quot;">​</a></h2><h3 id="没有消息处理器" tabindex="-1">没有消息处理器 <a class="header-anchor" href="#没有消息处理器" aria-label="Permalink to &quot;没有消息处理器&quot;">​</a></h3><p>如果 Tracing 特性没有添加任何消息处理器，将记录一条警告：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Tracing Feature. No feature out stream providers are defined. Trace streaming has no target.</span></span></code></pre></div><p>该特性仍将拦截事件，但它们不会被处理或输出到任何地方。</p><h3 id="资源管理" tabindex="-1">资源管理 <a class="header-anchor" href="#资源管理" aria-label="Permalink to &quot;资源管理&quot;">​</a></h3><p>消息处理器可能会持有需要正确释放的资源（如文件句柄）。使用 <code>use</code> 扩展函数以确保正确清理：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建代理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> agent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AIAgent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> simpleOllamaAIExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    llmModel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> OllamaModels.Meta.LLAMA_3_2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> writer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TraceFeatureMessageFileWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        outputPath,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        { path: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SystemFileSystem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sink</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">buffered</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Tracing) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        addMessageProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(writer)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 运行代理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">agent.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Writer will be automatically closed when the block exits</span></span></code></pre></div><h3 id="追踪特定事件到文件" tabindex="-1">追踪特定事件到文件 <a class="header-anchor" href="#追踪特定事件到文件" aria-label="Permalink to &quot;追踪特定事件到文件&quot;">​</a></h3><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Tracing) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 仅追踪 LLM 调用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    messageFilter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BeforeLLMCallEvent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AfterLLMCallEvent</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    addMessageProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(writer)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="追踪特定事件到远程端点" tabindex="-1">追踪特定事件到远程端点 <a class="header-anchor" href="#追踪特定事件到远程端点" aria-label="Permalink to &quot;追踪特定事件到远程端点&quot;">​</a></h3><p>当你需要通过网络发送事件数据时，可以使用追踪到远程端点。一旦启动，追踪到远程端点会在指定的端口号启动一个轻量级服务器，并通过 Kotlin Server-Sent Events (SSE) 发送事件。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建代理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> agent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AIAgent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> simpleOllamaAIExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    llmModel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> OllamaModels.Meta.LLAMA_3_2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> connectionConfig </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AIAgentFeatureServerConnectionConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(host </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> host, port </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> port)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> writer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TraceFeatureMessageRemoteWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        connectionConfig </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> connectionConfig</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Tracing) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        addMessageProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(writer)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 运行代理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">agent.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Writer will be automatically closed when the block exits</span></span></code></pre></div><p>在客户端，你可以使用 <code>FeatureMessageRemoteClient</code> 来接收事件并将其反序列化。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clientConfig </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AIAgentFeatureClientConnectionConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(host </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> host, port </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> port, protocol </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> URLProtocol.HTTP)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> agentEvents </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mutableListOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DefinedFeatureEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clientJob </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    FeatureMessageRemoteClient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(connectionConfig </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clientConfig, scope </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { client </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> collectEventsJob </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            client.receivedMessages.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">consumeAsFlow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">collect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { event </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // 从服务器收集事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                agentEvents.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DefinedFeatureEvent)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // 在代理结束时停止收集事件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (event </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AIAgentFinishedEvent) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    cancel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        client.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        collectEventsJob.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        client.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">healthCheck</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(clientJob).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">joinAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h2 id="api-文档" tabindex="-1">API 文档 <a class="header-anchor" href="#api-文档" aria-label="Permalink to &quot;API 文档&quot;">​</a></h2><p>Tracing 特性遵循模块化架构，包含以下关键组件：</p><ol><li><a href="https://api.koog.ai/agents/agents-features/agents-features-trace/ai.koog.agents.features.tracing.feature/-tracing/index.html" target="_blank" rel="noreferrer">Tracing</a>：拦截代理流水线中事件的主要特性类。</li><li><a href="https://api.koog.ai/agents/agents-features/agents-features-trace/ai.koog.agents.features.tracing.feature/-trace-feature-config/index.html" target="_blank" rel="noreferrer">TraceFeatureConfig</a>：用于自定义特性行为的配置类。</li><li>消息处理器：处理并输出追踪事件的组件： <ul><li><a href="https://api.koog.ai/agents/agents-features/agents-features-trace/ai.koog.agents.features.tracing.writer/-trace-feature-message-log-writer/index.html" target="_blank" rel="noreferrer">TraceFeatureMessageLogWriter</a>：将追踪事件写入日志器。</li><li><a href="https://api.koog.ai/agents/agents-features/agents-features-trace/ai.koog.agents.features.tracing.writer/-trace-feature-message-file-writer/index.html" target="_blank" rel="noreferrer">TraceFeatureMessageFileWriter</a>：将追踪事件写入文件。</li><li><a href="https://api.koog.ai/agents/agents-features/agents-features-trace/ai.koog.agents.features.tracing.writer/-trace-feature-message-remote-writer/index.html" target="_blank" rel="noreferrer">TraceFeatureMessageRemoteWriter</a>：将追踪事件发送到远程服务器。</li></ul></li></ol><h2 id="常见问题与故障排除" tabindex="-1">常见问题与故障排除 <a class="header-anchor" href="#常见问题与故障排除" aria-label="Permalink to &quot;常见问题与故障排除&quot;">​</a></h2><p>以下部分包含与 Tracing 特性相关的常见问题与解答。</p><h3 id="如何仅追踪代理执行的特定部分" tabindex="-1">如何仅追踪代理执行的特定部分？ <a class="header-anchor" href="#如何仅追踪代理执行的特定部分" aria-label="Permalink to &quot;如何仅追踪代理执行的特定部分？&quot;">​</a></h3><p>使用 <code>messageFilter</code> 属性来过滤事件。例如，要仅追踪节点执行：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Tracing) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 仅追踪 LLM 调用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   messageFilter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BeforeLLMCallEvent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AfterLLMCallEvent</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   addMessageProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(writer)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="我可以使用多个消息处理器吗" tabindex="-1">我可以使用多个消息处理器吗？ <a class="header-anchor" href="#我可以使用多个消息处理器吗" aria-label="Permalink to &quot;我可以使用多个消息处理器吗？&quot;">​</a></h3><p>是的，你可以添加多个消息处理器，以同时追踪到不同的目标：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Tracing) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    addMessageProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TraceFeatureMessageLogWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(logger))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    addMessageProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TraceFeatureMessageFileWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(outputPath, syncOpener))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    addMessageProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TraceFeatureMessageRemoteWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(connectionConfig))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="如何创建自定义消息处理器" tabindex="-1">如何创建自定义消息处理器？ <a class="header-anchor" href="#如何创建自定义消息处理器" aria-label="Permalink to &quot;如何创建自定义消息处理器？&quot;">​</a></h3><p>实现 <code>FeatureMessageProcessor</code> 接口：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CustomTraceProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FeatureMessageProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理器的当前打开状态</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _isOpen </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MutableStateFlow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isOpen: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StateFlow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _isOpen.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asStateFlow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> processMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FeatureMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 自定义处理逻辑</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (message) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AIAgentNodeExecutionStartEvent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // 处理节点启动事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AfterLLMCallEvent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // 处理 LLM 调用结束事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 处理其他事件类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 关闭已建立的连接</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用自定义处理器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Tracing) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    addMessageProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CustomTraceProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>有关消息处理器可处理的现有事件类型的更多信息，请参见 <a href="#predefined-event-types">预定义事件类型</a>。</p><h2 id="预定义事件类型" tabindex="-1">预定义事件类型 <a class="header-anchor" href="#预定义事件类型" aria-label="Permalink to &quot;预定义事件类型&quot;">​</a></h2><p>Koog 提供了可在自定义消息处理器中使用的预定义事件类型。预定义事件可根据其关联的实体分为以下几类：</p><ul><li><a href="#agent-events">代理事件</a></li><li><a href="#strategy-events">策略事件</a></li><li><a href="#node-events">节点事件</a></li><li><a href="#llm-call-events">LLM 调用事件</a></li><li><a href="#tool-call-events">工具调用事件</a></li></ul><h3 id="代理事件" tabindex="-1">代理事件 <a class="header-anchor" href="#代理事件" aria-label="Permalink to &quot;代理事件&quot;">​</a></h3><h4 id="aiagentstartedevent" tabindex="-1">AIAgentStartedEvent <a class="header-anchor" href="#aiagentstartedevent" aria-label="Permalink to &quot;AIAgentStartedEvent&quot;">​</a></h4><p>表示代理运行的开始。包含以下字段：</p><table tabindex="0"><thead><tr><th>名称</th><th>数据类型</th><th>必需</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>strategyName</code></td><td>String</td><td>是</td><td></td><td>代理应遵循的策略名称。</td></tr><tr><td><code>eventId</code></td><td>String</td><td>否</td><td><code>AIAgentStartedEvent</code></td><td>事件的标识符。通常是事件类的 <code>simpleName</code>。</td></tr></tbody></table><h4 id="aiagentfinishedevent" tabindex="-1">AIAgentFinishedEvent <a class="header-anchor" href="#aiagentfinishedevent" aria-label="Permalink to &quot;AIAgentFinishedEvent&quot;">​</a></h4><p>表示代理运行的结束。包含以下字段：</p><table tabindex="0"><thead><tr><th>名称</th><th>数据类型</th><th>必需</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>strategyName</code></td><td>String</td><td>是</td><td></td><td>代理所遵循的策略名称。</td></tr><tr><td><code>result</code></td><td>String</td><td>是</td><td></td><td>代理运行的结果。如果没有结果，可以为 <code>null</code>。</td></tr><tr><td><code>eventId</code></td><td>String</td><td>否</td><td><code>AIAgentFinishedEvent</code></td><td>事件的标识符。通常是事件类的 <code>simpleName</code>。</td></tr></tbody></table><h4 id="aiagentrunerrorevent" tabindex="-1">AIAgentRunErrorEvent <a class="header-anchor" href="#aiagentrunerrorevent" aria-label="Permalink to &quot;AIAgentRunErrorEvent&quot;">​</a></h4><p>表示代理运行期间发生错误。包含以下字段：</p><table tabindex="0"><thead><tr><th>名称</th><th>数据类型</th><th>必需</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>strategyName</code></td><td>String</td><td>是</td><td></td><td>代理所遵循的策略名称。</td></tr><tr><td><code>error</code></td><td>AIAgentError</td><td>是</td><td></td><td>代理运行期间发生的具体错误。有关更多信息，请参见 <a href="#aiagenterror">AIAgentError</a>。</td></tr><tr><td><code>eventId</code></td><td>String</td><td>否</td><td><code>AIAgentRunErrorEvent</code></td><td>事件的标识符。通常是事件类的 <code>simpleName</code>。</td></tr></tbody></table><p><a id="aiagenterror"></a><code>AIAgentError</code> 类提供了关于代理运行期间所发生错误的更多详细信息。包含以下字段：</p><table tabindex="0"><thead><tr><th>名称</th><th>数据类型</th><th>必需</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>message</code></td><td>String</td><td>是</td><td></td><td>提供有关具体错误更多详细信息的消息。</td></tr><tr><td><code>stackTrace</code></td><td>String</td><td>是</td><td></td><td>直到最后执行代码的堆栈记录集合。</td></tr><tr><td><code>cause</code></td><td>String</td><td>否</td><td>null</td><td>错误的起因，如果可用。</td></tr></tbody></table><h3 id="策略事件" tabindex="-1">策略事件 <a class="header-anchor" href="#策略事件" aria-label="Permalink to &quot;策略事件&quot;">​</a></h3><h4 id="aiagentstrategystartevent" tabindex="-1">AIAgentStrategyStartEvent <a class="header-anchor" href="#aiagentstrategystartevent" aria-label="Permalink to &quot;AIAgentStrategyStartEvent&quot;">​</a></h4><p>表示策略运行的开始。包含以下字段：</p><table tabindex="0"><thead><tr><th>名称</th><th>数据类型</th><th>必需</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>strategyName</code></td><td>String</td><td>是</td><td></td><td>策略名称。</td></tr><tr><td><code>eventId</code></td><td>String</td><td>否</td><td><code>AIAgentStrategyStartEvent</code></td><td>事件的标识符。通常是事件类的 <code>simpleName</code>。</td></tr></tbody></table><h4 id="aiagentstrategyfinishedevent" tabindex="-1">AIAgentStrategyFinishedEvent <a class="header-anchor" href="#aiagentstrategyfinishedevent" aria-label="Permalink to &quot;AIAgentStrategyFinishedEvent&quot;">​</a></h4><p>表示策略运行的结束。包含以下字段：</p><table tabindex="0"><thead><tr><th>名称</th><th>数据类型</th><th>必需</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>strategyName</code></td><td>String</td><td>是</td><td></td><td>策略名称。</td></tr><tr><td><code>result</code></td><td>String</td><td>是</td><td></td><td>运行结果。</td></tr><tr><td><code>eventId</code></td><td>String</td><td>否</td><td><code>AIAgentStrategyFinishedEvent</code></td><td>事件的标识符。通常是事件类的 <code>simpleName</code>。</td></tr></tbody></table><h3 id="节点事件" tabindex="-1">节点事件 <a class="header-anchor" href="#节点事件" aria-label="Permalink to &quot;节点事件&quot;">​</a></h3><h4 id="aiagentnodeexecutionstartevent" tabindex="-1">AIAgentNodeExecutionStartEvent <a class="header-anchor" href="#aiagentnodeexecutionstartevent" aria-label="Permalink to &quot;AIAgentNodeExecutionStartEvent&quot;">​</a></h4><p>表示节点运行的开始。包含以下字段：</p><table tabindex="0"><thead><tr><th>名称</th><th>数据类型</th><th>必需</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>nodeName</code></td><td>String</td><td>是</td><td></td><td>已开始运行的节点名称。</td></tr><tr><td><code>input</code></td><td>String</td><td>是</td><td></td><td>节点的输入值。</td></tr><tr><td><code>eventId</code></td><td>String</td><td>否</td><td><code>AIAgentNodeExecutionStartEvent</code></td><td>事件的标识符。通常是事件类的 <code>simpleName</code>。</td></tr></tbody></table><h4 id="aiagentnodeexecutionendevent" tabindex="-1">AIAgentNodeExecutionEndEvent <a class="header-anchor" href="#aiagentnodeexecutionendevent" aria-label="Permalink to &quot;AIAgentNodeExecutionEndEvent&quot;">​</a></h4><p>表示节点运行的结束。包含以下字段：</p><table tabindex="0"><thead><tr><th>名称</th><th>数据类型</th><th>必需</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>nodeName</code></td><td>String</td><td>是</td><td></td><td>已结束运行的节点名称。</td></tr><tr><td><code>input</code></td><td>String</td><td>是</td><td></td><td>节点的输入值。</td></tr><tr><td><code>output</code></td><td>String</td><td>是</td><td></td><td>节点产生的输出值。</td></tr><tr><td><code>eventId</code></td><td>String</td><td>否</td><td><code>AIAgentNodeExecutionEndEvent</code></td><td>事件的标识符。通常是事件类的 <code>simpleName</code>。</td></tr></tbody></table><h3 id="llm-调用事件" tabindex="-1">LLM 调用事件 <a class="header-anchor" href="#llm-调用事件" aria-label="Permalink to &quot;LLM 调用事件&quot;">​</a></h3><h4 id="llmcallstartevent" tabindex="-1">LLMCallStartEvent <a class="header-anchor" href="#llmcallstartevent" aria-label="Permalink to &quot;LLMCallStartEvent&quot;">​</a></h4><p>表示 LLM 调用的开始。包含以下字段：</p><table tabindex="0"><thead><tr><th>名称</th><th>数据类型</th><th>必需</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>prompt</code></td><td>Prompt</td><td>是</td><td></td><td>发送到模型的提示。有关更多信息，请参见 <a href="#prompt">Prompt</a>。</td></tr><tr><td><code>tools</code></td><td>List&lt;String&gt;</td><td>是</td><td></td><td>模型可以调用的工具列表。</td></tr><tr><td><code>eventId</code></td><td>String</td><td>否</td><td><code>LLMCallStartEvent</code></td><td>事件的标识符。通常是事件类的 <code>simpleName</code>。</td></tr></tbody></table><p><a id="prompt"></a><code>Prompt</code> 类表示提示的数据结构，包含消息列表、唯一标识符以及语言模型设置的可选参数。包含以下字段：</p><table tabindex="0"><thead><tr><th>名称</th><th>数据类型</th><th>必需</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>messages</code></td><td>List&lt;Message&gt;</td><td>是</td><td></td><td>提示包含的消息列表。</td></tr><tr><td><code>id</code></td><td>String</td><td>是</td><td></td><td>提示的唯一标识符。</td></tr><tr><td><code>params</code></td><td>LLMParams</td><td>否</td><td>LLMParams()</td><td>控制 LLM 生成内容方式的设置。</td></tr></tbody></table><h4 id="llmcallendevent" tabindex="-1">LLMCallEndEvent <a class="header-anchor" href="#llmcallendevent" aria-label="Permalink to &quot;LLMCallEndEvent&quot;">​</a></h4><p>表示 LLM 调用的结束。包含以下字段：</p><table tabindex="0"><thead><tr><th>名称</th><th>数据类型</th><th>必需</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>responses</code></td><td>List&lt;Message.Response&gt;</td><td>是</td><td></td><td>模型返回的一个或多个响应。</td></tr><tr><td><code>eventId</code></td><td>String</td><td>否</td><td><code>LLMCallEndEvent</code></td><td>事件的标识符。通常是事件类的 <code>simpleName</code>。</td></tr></tbody></table><h3 id="工具调用事件" tabindex="-1">工具调用事件 <a class="header-anchor" href="#工具调用事件" aria-label="Permalink to &quot;工具调用事件&quot;">​</a></h3><h4 id="toolcallevent" tabindex="-1">ToolCallEvent <a class="header-anchor" href="#toolcallevent" aria-label="Permalink to &quot;ToolCallEvent&quot;">​</a></h4><p>表示模型调用工具的事件。包含以下字段：</p><table tabindex="0"><thead><tr><th>名称</th><th>数据类型</th><th>必需</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>toolName</code></td><td>String</td><td>是</td><td></td><td>工具名称。</td></tr><tr><td><code>toolArgs</code></td><td>Tool.Args</td><td>是</td><td></td><td>提供给工具的实参。</td></tr><tr><td><code>eventId</code></td><td>String</td><td>否</td><td><code>ToolCallEvent</code></td><td>事件的标识符。通常是事件类的 <code>simpleName</code>。</td></tr></tbody></table><h4 id="toolvalidationerrorevent" tabindex="-1">ToolValidationErrorEvent <a class="header-anchor" href="#toolvalidationerrorevent" aria-label="Permalink to &quot;ToolValidationErrorEvent&quot;">​</a></h4><p>表示工具调用期间发生验证错误。包含以下字段：</p><table tabindex="0"><thead><tr><th>名称</th><th>数据类型</th><th>必需</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>toolName</code></td><td>String</td><td>是</td><td></td><td>验证失败的工具名称。</td></tr><tr><td><code>toolArgs</code></td><td>Tool.Args</td><td>是</td><td></td><td>提供给工具的实参。</td></tr><tr><td><code>errorMessage</code></td><td>String</td><td>是</td><td></td><td>验证错误消息。</td></tr><tr><td><code>eventId</code></td><td>String</td><td>否</td><td><code>ToolValidationErrorEvent</code></td><td>事件的标识符。通常是事件类的 <code>simpleName</code>。</td></tr></tbody></table><h4 id="toolcallfailureevent" tabindex="-1">ToolCallFailureEvent <a class="header-anchor" href="#toolcallfailureevent" aria-label="Permalink to &quot;ToolCallFailureEvent&quot;">​</a></h4><p>表示调用工具失败。包含以下字段：</p><table tabindex="0"><thead><tr><th>名称</th><th>数据类型</th><th>必需</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>toolName</code></td><td>String</td><td>是</td><td></td><td>工具名称。</td></tr><tr><td><code>toolArgs</code></td><td>Tool.Args</td><td>是</td><td></td><td>提供给工具的实参。</td></tr><tr><td><code>error</code></td><td>AIAgentError</td><td>是</td><td></td><td>尝试调用工具时发生的具体错误。有关更多信息，请参见 <a href="#aiagenterror">AIAgentError</a>。</td></tr><tr><td><code>eventId</code></td><td>String</td><td>否</td><td><code>ToolCallFailureEvent</code></td><td>事件的标识符。通常是事件类的 <code>simpleName</code>。</td></tr></tbody></table><h4 id="toolcallresultevent" tabindex="-1">ToolCallResultEvent <a class="header-anchor" href="#toolcallresultevent" aria-label="Permalink to &quot;ToolCallResultEvent&quot;">​</a></h4><p>表示工具调用成功并返回结果。包含以下字段：</p><table tabindex="0"><thead><tr><th>名称</th><th>数据类型</th><th>必需</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>toolName</code></td><td>String</td><td>是</td><td></td><td>工具名称。</td></tr><tr><td><code>toolArgs</code></td><td>Tool.Args</td><td>是</td><td></td><td>提供给工具的实参。</td></tr><tr><td><code>result</code></td><td>ToolResult</td><td>是</td><td></td><td>工具调用的结果。</td></tr><tr><td><code>eventId</code></td><td>String</td><td>否</td><td><code>ToolCallResultEvent</code></td><td>事件的标识符。通常是事件类的 <code>simpleName</code>。</td></tr></tbody></table>`,106)]))}const g=a(e,[["render",l]]);export{o as __pageData,g as default};
