import{_ as i,c as a,o as t,ag as e}from"./chunks/framework.Bksy39di.js";const c=JSON.parse('{"title":"부호 없는 정수 타입","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/unsigned-integer-types.md","filePath":"ko/kotlin/unsigned-integer-types.md","lastUpdated":1754307826000}'),n={name:"ko/kotlin/unsigned-integer-types.md"};function l(p,s,h,d,k,o){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="부호-없는-정수-타입" tabindex="-1">부호 없는 정수 타입 <a class="header-anchor" href="#부호-없는-정수-타입" aria-label="Permalink to &quot;부호 없는 정수 타입&quot;">​</a></h1><p><a href="/ko/kotlin/numbers#integer-types">정수 타입</a> 외에도 Kotlin은 부호 없는 정수를 위해 다음 타입을 제공합니다.</p><table tabindex="0"><thead><tr><th>타입</th><th>크기 (비트)</th><th>최솟값</th><th>최댓값</th></tr></thead><tbody><tr><td><code>UByte</code></td><td>8</td><td>0</td><td>255</td></tr><tr><td><code>UShort</code></td><td>16</td><td>0</td><td>65,535</td></tr><tr><td><code>UInt</code></td><td>32</td><td>0</td><td>4,294,967,295 (2<sup>32</sup> - 1)</td></tr><tr><td><code>ULong</code></td><td>64</td><td>0</td><td>18,446,744,073,709,551,615 (2<sup>64</sup> - 1)</td></tr></tbody></table><p>부호 없는 타입은 부호 있는 타입의 대부분의 연산을 지원합니다.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>부호 없는 숫자는 동일한 너비의 해당 부호 있는 타입을 포함하는 단일 저장 프로퍼티를 가진 <a href="/ko/kotlin/inline-classes">인라인 클래스</a>로 구현됩니다. 부호 없는 정수 타입과 부호 있는 정수 타입 간에 변환하려는 경우, 모든 함수 호출과 연산이 새로운 타입을 지원하도록 코드를 업데이트해야 합니다.</p></div><h2 id="부호-없는-배열과-범위" tabindex="-1">부호 없는 배열과 범위 <a class="header-anchor" href="#부호-없는-배열과-범위" aria-label="Permalink to &quot;부호 없는 배열과 범위&quot;">​</a></h2><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>부호 없는 배열과 그에 대한 연산은 <a href="/ko/kotlin/components-stability">베타</a> 상태입니다. 언제든지 호환되지 않게 변경될 수 있습니다. 옵트인(Opt-in)이 필요합니다(자세한 내용은 아래 참조).</p></div><p>기본 타입과 마찬가지로 각 부호 없는 타입은 해당 타입의 배열을 나타내는 대응하는 타입을 가집니다.</p><ul><li><code>UByteArray</code>: 부호 없는 바이트 배열.</li><li><code>UShortArray</code>: 부호 없는 쇼트 배열.</li><li><code>UIntArray</code>: 부호 없는 인트 배열.</li><li><code>ULongArray</code>: 부호 없는 롱 배열.</li></ul><p>부호 있는 정수 배열과 마찬가지로, 이들은 박싱 오버헤드 없이 <code>Array</code> 클래스와 유사한 API를 제공합니다.</p><p>부호 없는 배열을 사용하면 이 기능이 아직 안정적이지 않다는 경고를 받게 됩니다. 경고를 제거하려면 <code>@ExperimentalUnsignedTypes</code> 어노테이션으로 옵트인해야 합니다. 클라이언트가 API 사용에 명시적으로 옵트인해야 하는지 여부는 여러분이 결정할 일이지만, 부호 없는 배열은 안정적인 기능이 아니라는 점을 명심하십시오. 따라서 이를 사용하는 API는 언어 변경으로 인해 손상될 수 있습니다. <a href="/ko/kotlin/opt-in-requirements">옵트인 요구 사항에 대해 자세히 알아보기</a>.</p><p><a href="/ko/kotlin/ranges">범위와 진행</a>은 <code>UIntRange</code>, <code>UIntProgression</code>, <code>ULongRange</code>, <code>ULongProgression</code> 클래스에 의해 <code>UInt</code> 및 <code>ULong</code>에 대해 지원됩니다. 부호 없는 정수 타입과 함께 이 클래스들은 안정적입니다.</p><h2 id="부호-없는-정수-리터럴" tabindex="-1">부호 없는 정수 리터럴 <a class="header-anchor" href="#부호-없는-정수-리터럴" aria-label="Permalink to &quot;부호 없는 정수 리터럴&quot;">​</a></h2><p>부호 없는 정수를 더 쉽게 사용하기 위해 정수 리터럴에 특정 부호 없는 타입을 나타내는 접미사를 추가할 수 있습니다(<code>Float</code>의 <code>F</code> 또는 <code>Long</code>의 <code>L</code>과 유사하게).</p><ul><li><p><code>u</code> 및 <code>U</code> 문자는 정확한 타입을 지정하지 않고 부호 없는 리터럴을 나타냅니다. 예상되는 타입이 제공되지 않으면 컴파일러는 리터럴의 크기에 따라 <code>UInt</code> 또는 <code>ULong</code>을 사용합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UByte</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1u</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // UByte, expected type provided</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UShort</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1u</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // UShort, expected type provided</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ULong</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1u</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ULong, expected type provided</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42u</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // UInt: no expected type provided, constant fits in UInt</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0xFFFF_FFFF_FFFFu</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // ULong: no expected type provided, constant doesn&#39;t fit in UInt</span></span></code></pre></div></li><li><p><code>uL</code> 및 <code>UL</code>은 리터럴이 부호 없는 롱(unsigned long)이어야 함을 명시적으로 지정합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1UL</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // ULong, even though no expected type provided and the constant fits into UInt</span></span></code></pre></div></li></ul><h2 id="사용-사례" tabindex="-1">사용 사례 <a class="header-anchor" href="#사용-사례" aria-label="Permalink to &quot;사용 사례&quot;">​</a></h2><p>부호 없는 숫자의 주요 사용 사례는 정수의 전체 비트 범위를 활용하여 양수 값을 나타내는 것입니다. 예를 들어, 32비트 <code>AARRGGBB</code> 형식의 색상과 같이 부호 있는 타입에 맞지 않는 16진수 상수를 나타내는 것입니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> representation: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> yellow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0xFFCC00CCu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>명시적인 <code>toByte()</code> 리터럴 캐스트 없이 부호 없는 숫자를 사용하여 바이트 배열을 초기화할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> byteOrderMarkUtf8 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ubyteArrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0xEFu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0xBBu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0xBFu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>또 다른 사용 사례는 네이티브 API와의 상호 운용성입니다. Kotlin은 서명에 부호 없는 타입을 포함하는 네이티브 선언을 표현할 수 있습니다. 매핑은 부호 없는 정수를 부호 있는 정수로 대체하지 않으며 의미를 변경하지 않고 유지합니다.</p><h3 id="비목표" tabindex="-1">비목표 <a class="header-anchor" href="#비목표" aria-label="Permalink to &quot;비목표&quot;">​</a></h3><p>부호 없는 정수는 양수와 0만 나타낼 수 있지만, 애플리케이션 도메인에서 음수가 아닌 정수를 요구하는 곳에 이를 사용하는 것은 목표가 아닙니다. 예를 들어, 컬렉션 크기 또는 컬렉션 인덱스 값의 타입으로.</p><p>몇 가지 이유가 있습니다.</p><ul><li>부호 있는 정수를 사용하면 의도치 않은 오버플로우를 감지하고 오류 조건을 알리는 데 도움이 될 수 있습니다. 예를 들어, 빈 리스트에 대해 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/last-index.html" target="_blank" rel="noreferrer"><code>List.lastIndex</code></a>가 -1인 경우와 같이.</li><li>부호 없는 정수는 부호 있는 정수의 범위 제한 버전으로 취급될 수 없습니다. 그 이유는 값의 범위가 부호 있는 정수 범위의 부분 집합이 아니기 때문입니다.</li><li>부호 있는 정수도, 부호 없는 정수도 서로의 하위 타입이 아닙니다.</li></ul>`,25)]))}const g=i(n,[["render",l]]);export{c as __pageData,g as default};
