import{_ as l,C as o,c as p,o as r,j as e,G as t,ag as h,a as i,w as c}from"./chunks/framework.Bksy39di.js";const x=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ktor/db-connection-pooling-caching.md","filePath":"ktor/db-connection-pooling-caching.md","lastUpdated":1755457140000}'),u={name:"ktor/db-connection-pooling-caching.md"};function g(k,a,b,m,v,C){const s=o("show-structure"),n=o("tldr"),d=o("link-summary");return r(),p("div",null,[a[2]||(a[2]=e("h1",{id:"连接池与缓存",tabindex:"-1"},[i("连接池与缓存 "),e("a",{class:"header-anchor",href:"#连接池与缓存","aria-label":'Permalink to "连接池与缓存"'},"​")],-1)),t(s,{for:"chapter",depth:"2"}),t(n,null,{default:c(()=>a[0]||(a[0]=[e("p",null,[e("b",null,"代码示例"),i(": "),e("a",{href:"https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/tutorial-website-interactive-persistence-advanced"}," tutorial-website-interactive-persistence-advanced ")],-1),e("p",null,[e("b",null,"使用库"),i(": "),e("a",{href:"https://github.com/brettwooldridge/HikariCP"},"HikariCP"),i(", "),e("a",{href:"https://www.ehcache.org/"},"Ehcache")],-1)])),_:1}),t(d,null,{default:c(()=>a[1]||(a[1]=[i("了解如何实现数据库连接池与缓存。")])),_:1}),a[3]||(a[3]=h(`<p>在<a href="./db-persistence">前一个教程</a>中，我们使用 Exposed 框架为网站添加了持久化功能。 在本教程中，我们将探讨如何分别使用 HikariCP 和 Ehcache 库来实现数据库连接池与缓存。</p><h2 id="add-dependencies" tabindex="-1">添加依赖项 <a class="header-anchor" href="#add-dependencies" aria-label="Permalink to &quot;添加依赖项 {id=&quot;add-dependencies&quot;}&quot;">​</a></h2><p>首先，你需要添加 HikariCP 和 Ehcache 库的依赖项。 打开 <code>gradle.properties</code> 文件并指定库版本：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ehcache_version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">logback_version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span></span></code></pre></div><p>然后，打开 <code>build.gradle.kts</code> 并添加以下依赖项：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>点击 <code>build.gradle.kts</code> 文件右上角的 <strong>Load Gradle Changes</strong> 图标以安装新添加的依赖项。</p><h2 id="connection-pooling" tabindex="-1">连接池 <a class="header-anchor" href="#connection-pooling" aria-label="Permalink to &quot;连接池 {id=&quot;connection-pooling&quot;}&quot;">​</a></h2><p>当 Exposed 在 <code>transaction</code> 的作用域内首次对数据库执行操作时，它会在每个 <code>transaction</code> 调用中启动一个新的 JDBC 连接。 但建立多个 JDBC 连接会消耗大量资源：重用现有连接有助于提升性能。 _连接池_机制解决了这个问题。</p><p>在本节中，我们将使用 HikariCP 框架来管理应用程序中的 JDBC 连接池。</p><h3 id="connection-settings-config" tabindex="-1">将连接设置提取到配置文件中 <a class="header-anchor" href="#connection-settings-config" aria-label="Permalink to &quot;将连接设置提取到配置文件中 {id=&quot;connection-settings-config&quot;}&quot;">​</a></h3><p>在<a href="./db-persistence#connect_db">前一个教程</a>中，我们使用 <code>com/example/dao/DatabaseSingleton.kt</code> 文件中硬编码的 <code>driverClassName</code> 和 <code>jdbcURL</code> 来建立数据库连接：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>让我们将数据库连接设置提取到<a href="./server-configuration-file">自定义配置组</a>中。</p><ol><li><p>打开 <code>src/main/resources/application.conf</code> 文件，并在 <code>ktor</code> 组外部添加 <code>storage</code> 组，如下所示：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div></li><li><p>打开 <code>com/example/dao/DatabaseSingleton.kt</code> 并更新 <code>init</code> 函数，使其从配置文件加载存储设置：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>现在，<code>init</code> 函数接受 <code>ApplicationConfig</code> 并使用 <code>config.property</code> 来加载自定义设置。</p></li><li><p>最后，打开 <code>com/example/Application.kt</code> 并将 <code>environment.config</code> 传递给 <code>DatabaseSingleton.init</code>，以便在应用程序启动时加载连接设置：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div></li></ol><h3 id="enable-connection-pooling" tabindex="-1">启用连接池 <a class="header-anchor" href="#enable-connection-pooling" aria-label="Permalink to &quot;启用连接池 {id=&quot;enable-connection-pooling&quot;}&quot;">​</a></h3><p>要在 Exposed 中启用连接池，你需要将 <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.sql/javax/sql/DataSource.html" target="_blank" rel="noreferrer">DataSource</a> 作为形参传递给 <code>Database.connect</code> 函数。 HikariCP 提供了实现 <code>DataSource</code> 接口的 <code>HikariDataSource</code> 类。</p><ol><li><p>要创建 <code>HikariDataSource</code>，请打开 <code>com/example/dao/DatabaseSingleton.kt</code> 并在 <code>DatabaseSingleton</code> 对象中添加 <code>createHikariDataSource</code> 函数：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>以下是关于数据源设置的一些注意事项：</p><ul><li><code>createHikariDataSource</code> 函数接受驱动程序类名和数据库 URL 作为形参。</li><li><code>maximumPoolSize</code> 属性指定了连接池可以达到的最大大小。</li><li><code>isAutoCommit</code> 和 <code>transactionIsolation</code> 的设置与 Exposed 使用的默认设置同步。</li></ul></li><li><p>要使用 <code>HikariDataSource</code>，将其传递给 <code>Database.connect</code> 函数：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>你现在可以<a href="./db-persistence#run_app">运行应用程序</a>，并确保一切都像以前一样正常工作。</p></li></ol><h2 id="caching" tabindex="-1">缓存 <a class="header-anchor" href="#caching" aria-label="Permalink to &quot;缓存 {id=&quot;caching&quot;}&quot;">​</a></h2><p>你可以为数据库补充一个数据库缓存。 缓存是一种将常用数据存储在临时内存中的技术，可以减少数据库的工作负载以及读取常用数据所需的时间。</p><p>在本教程中，我们将使用 Ehcache 库来组织文件中的缓存。</p><h3 id="cache-file-path" tabindex="-1">将缓存文件路径添加到配置中 <a class="header-anchor" href="#cache-file-path" aria-label="Permalink to &quot;将缓存文件路径添加到配置中 {id=&quot;cache-file-path&quot;}&quot;">​</a></h3><p>打开 <code>src/main/resources/application.conf</code> 文件，并将 <code>ehcacheFilePath</code> 属性添加到 <code>storage</code> 组：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>此属性指定了用于存储缓存数据的文件路径。 我们稍后将使用它来配置一个 <code>DAOFacade</code> 实现，用于处理缓存。</p><h3 id="implement-caching" tabindex="-1">实现缓存 <a class="header-anchor" href="#implement-caching" aria-label="Permalink to &quot;实现缓存 {id=&quot;implement-caching&quot;}&quot;">​</a></h3><p>要实现缓存，我们需要提供另一个 <code>DAOFacade</code> 实现，该实现从缓存中返回值；如果缓存中没有值，则将其委托给数据库接口。</p><ol><li><p>在 <code>com.example.dao</code> 包中创建一个新的 <code>DAOFacadeCacheImpl.kt</code> 文件，并向其中添加以下实现：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>以下是此代码示例的简要概述：</p><ul><li>为了初始化和配置缓存，我们定义了一个 Ehcache <code>CacheManager</code> 实例。我们将 <code>storagePath</code> 作为用于磁盘存储的根目录。</li><li>我们创建了一个缓存，用于按 ID 存储文章条目：<code>articlesCache</code> 将 <code>Int</code> 键映射到 <code>Article</code> 值。</li><li>然后，我们为本地内存和磁盘资源提供大小限制。你可以在 <a href="https://www.ehcache.org/documentation/2.8/configuration/cache-size.html" target="_blank" rel="noreferrer">Ehcache 文档</a>中阅读有关这些形参的更多信息。</li><li>最后，我们通过调用 <code>cacheManager.getCache()</code> 并传入指定的名称、键和值类型来获取创建的缓存。</li></ul></li><li><p>要在缓存中使用，<code>Article</code> 类应是可序列化的并实现 <code>java.io.Serializable</code>。 打开 <code>com/example/models/Article.kt</code> 并按如下方式更新代码：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div></li><li><p>现在我们准备实现 <code>DAOFacade</code> 的成员。 回到 <code>DAOFacadeCacheImpl.kt</code>，添加以下方法：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><ul><li><code>allArticles</code>：我们不尝试缓存所有文章；我们将其委托给主数据库。</li><li><code>article</code>：当我们获取一篇文章时，我们首先检测它是否存在于缓存中，只有当它不存在时，我们才将其委托给主 <code>DAOFacade</code>，并将这篇文章添加到缓存中。</li><li><code>addNewArticle</code>：当我们添加一篇新文章时，我们将其委托给主 <code>DAOFacade</code>，但也会将这篇文章添加到缓存中。</li><li><code>editArticle</code>：编辑现有文章时，我们同时更新缓存和数据库。</li><li><code>deleteArticle</code>：删除时，我们需要同时从缓存和主数据库中删除文章。</li></ul></li></ol><h3 id="init-dao-facade" tabindex="-1">初始化 DAOFacadeCacheImpl <a class="header-anchor" href="#init-dao-facade" aria-label="Permalink to &quot;初始化 DAOFacadeCacheImpl {id=&quot;init-dao-facade&quot;}&quot;">​</a></h3><p>让我们创建一个 <code>DAOFacadeCacheImpl</code> 实例，并在应用程序启动前添加一篇示例文章插入到数据库中：</p><ol><li><p>首先，打开 <code>DAOFacadeImpl.kt</code> 文件并删除文件底部的 <code>dao</code> 变量初始化。</p></li><li><p>然后，打开 <code>com/example/plugins/Routing.kt</code> 并在 <code>configureRouting</code> 代码块内初始化 <code>dao</code> 变量：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>就是这样。 你现在可以<a href="./db-persistence#run_app">运行应用程序</a>，并确保一切都像以前一样正常工作。</p></li></ol><blockquote><p>你可以在此处找到包含连接池和缓存的完整示例：<a href="https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/tutorial-website-interactive-persistence-advanced" target="_blank" rel="noreferrer">tutorial-website-interactive-persistence-advanced</a>。</p></blockquote>`,32))])}const y=l(u,[["render",g]]);export{x as __pageData,y as default};
