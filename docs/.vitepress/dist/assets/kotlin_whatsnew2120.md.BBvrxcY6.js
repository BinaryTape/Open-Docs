import{_ as t,a as l}from"./chunks/wasm-custom-formatters-firefox.C2LVO8ja.js";import{_ as e,C as p,c as h,o as k,ag as i,G as n}from"./chunks/framework.Bksy39di.js";const F=JSON.parse('{"title":"Kotlin 2.1.20 有哪些新特性","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/whatsnew2120.md","filePath":"kotlin/whatsnew2120.md","lastUpdated":1754307826000}'),o={name:"kotlin/whatsnew2120.md"};function r(d,s,c,E,g,u){const a=p("TopicTitle");return k(),h("div",null,[s[0]||(s[0]=i('<h1 id="kotlin-2-1-20-有哪些新特性" tabindex="-1">Kotlin 2.1.20 有哪些新特性 <a class="header-anchor" href="#kotlin-2-1-20-有哪些新特性" aria-label="Permalink to &quot;Kotlin 2.1.20 有哪些新特性&quot;">​</a></h1><p><em><a href="/kotlin/releases#release-details">发布日期：2025 年 3 月 20 日</a></em></p><p>Kotlin 2.1.20 版本现已发布！主要亮点如下：</p><ul><li><strong>K2 编译器更新</strong>：<a href="#kotlin-k2-compiler">新的 kapt 和 Lombok 插件的更新</a></li><li><strong>Kotlin Multiplatform</strong>：<a href="#kotlin-multiplatform-new-dsl-to-replace-gradle-s-application-plugin">用于替代 Gradle Application 插件的新 DSL</a></li><li><strong>Kotlin/Native</strong>：<a href="#kotlin-native">支持 Xcode 16.3 并新增内联优化</a></li><li><strong>Kotlin/Wasm</strong>：<a href="#kotlin-wasm">默认自定义格式化程序、支持 DWARF 以及迁移到 Provider API</a></li><li><strong>Gradle 支持</strong>：<a href="#gradle">兼容 Gradle 的 Isolated Projects 和自定义发布变体</a></li><li><strong>标准库</strong>：<a href="#standard-library">通用原子类型、改进的 UUID 支持以及新的时间追踪功能</a></li><li><strong>Compose 编译器</strong>：<a href="#compose-compiler">放宽了对 <code>@Composable</code> 函数的限制及其他更新</a></li><li><strong>文档</strong>：<a href="#documentation-updates">Kotlin 文档的显著改进</a>。</li></ul><h2 id="ide-支持" tabindex="-1">IDE 支持 <a class="header-anchor" href="#ide-支持" aria-label="Permalink to &quot;IDE 支持&quot;">​</a></h2><p>支持 2.1.20 版本的 Kotlin 插件已捆绑到最新版 IntelliJ IDEA 和 Android Studio 中。 您无需在 IDE 中更新 Kotlin 插件。 您只需在构建脚本中将 Kotlin 版本更改为 2.1.20 即可。</p><p>详情请参见<a href="/kotlin/releases#update-to-a-new-kotlin-version">更新到新版本</a>。</p><h3 id="下载支持-osgi-的项目中-kotlin-构件的源代码" tabindex="-1">下载支持 OSGi 的项目中 Kotlin 构件的源代码 <a class="header-anchor" href="#下载支持-osgi-的项目中-kotlin-构件的源代码" aria-label="Permalink to &quot;下载支持 OSGi 的项目中 Kotlin 构件的源代码&quot;">​</a></h3><p><code>kotlin-osgi-bundle</code> 库的所有依赖项的源代码现在已包含在其分发中。这使得 IntelliJ IDEA 可以下载这些源代码，为 Kotlin 符号提供文档并改善调试体验。</p><h2 id="kotlin-k2-编译器" tabindex="-1">Kotlin K2 编译器 <a class="header-anchor" href="#kotlin-k2-编译器" aria-label="Permalink to &quot;Kotlin K2 编译器&quot;">​</a></h2><p>我们正在继续改进对新的 Kotlin K2 编译器的插件支持。此版本带来了对新的 kapt 和 Lombok 插件的更新。</p>',11)),n(a,{id:"新的默认-kapt-插件",level:"3",title:"新的默认 kapt 插件",labelRef:"beta"}),s[1]||(s[1]=i('<p>从 Kotlin 2.1.20 开始，kapt 编译器插件的 K2 实现默认对所有项目启用。</p><p>JetBrains 团队早在 Kotlin 1.9.20 中就推出了 K2 编译器对 kapt 插件的新实现。 从那时起，我们进一步开发了 K2 kapt 的内部实现，使其行为与 K1 版本相似， 同时显著提高了其性能。</p><p>如果您在使用 K2 编译器配合 kapt 时遇到任何问题， 可以暂时恢复到以前的插件实现。</p><p>为此，请将以下选项添加到您项目的 <code>gradle.properties</code> 文件中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kapt.use.k2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span></span></code></pre></div><p>请向我们的<a href="https://youtrack.jetbrains.com/issue/KT-71439/K2-kapt-feedback" target="_blank" rel="noreferrer">问题追踪器</a>报告任何问题。</p>',6)),n(a,{id:"lombok-编译器插件-支持-superbuilder-和-builder-的更新",level:"3",title:"Lombok 编译器插件：支持 `@SuperBuilder` 和 `@Builder` 的更新",labelRef:"experimental-general"}),s[2]||(s[2]=i('<p><a href="/kotlin/lombok">Kotlin Lombok 编译器插件</a>现在支持 <code>@SuperBuilder</code> 注解，这使得为类层次结构创建构建器变得更容易。此前，在 Kotlin 中使用 Lombok 的开发者在处理继承时必须手动定义构建器。有了 <code>@SuperBuilder</code>，构建器会自动继承超类字段，允许您在构造对象时对其进行初始化。</p><p>此外，本次更新还包括多项改进和错误修复：</p><ul><li><code>@Builder</code> 注解现在可用于构造函数，从而实现更灵活的对象创建。更多详情， 请参见相应的 <a href="https://youtrack.jetbrains.com/issue/KT-71547" target="_blank" rel="noreferrer">YouTrack 问题</a>。</li><li>已解决与 Lombok 在 Kotlin 中的代码生成相关的几个问题，提高了整体兼容性。 更多详情，请参见 <a href="https://github.com/JetBrains/kotlin/releases/tag/v2.1.20" target="_blank" rel="noreferrer">GitHub 变更日志</a>。</li></ul><p>关于 <code>@SuperBuilder</code> 注解的更多信息，请参见官方 <a href="https://projectlombok.org/features/experimental/SuperBuilder" target="_blank" rel="noreferrer">Lombok 文档</a>。</p>',4)),n(a,{id:"kotlin-multiplatform-用于替代-gradle-application-插件的新-dsl",level:"2",title:"Kotlin Multiplatform：用于替代 Gradle Application 插件的新 DSL",labelRef:"experimental-opt-in"}),s[3]||(s[3]=i(`<p>从 Gradle 8.7 开始，<a href="https://docs.gradle.org/current/userguide/application_plugin.html" target="_blank" rel="noreferrer">Application</a> 插件不再与 Kotlin Multiplatform Gradle 插件兼容。Kotlin 2.1.20 引入了一个实验性的 DSL，以实现类似的功能。新的 <code>executable {}</code> 代码块为 JVM 目标平台配置执行任务和 Gradle <a href="https://docs.gradle.org/current/userguide/distribution_plugin.html#distribution_plugin" target="_blank" rel="noreferrer">分发</a>。</p><p>在您的构建脚本中的 <code>executable {}</code> 代码块之前，添加以下 <code>@OptIn</code> 注解：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalKotlinGradlePluginApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalKotlinGradlePluginApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        binaries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Configures a JavaExec task named &quot;runJvm&quot; and a Gradle distribution for the &quot;main&quot; compilation in this target</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            executable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                mainClass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo.MainKt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Configures a JavaExec task named &quot;runJvmAnother&quot; and a Gradle distribution for the &quot;main&quot; compilation</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            executable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(KotlinCompilation.MAIN_COMPILATION_NAME, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;another&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // Set a different class</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                mainClass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo.MainAnotherKt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Configures a JavaExec task named &quot;runJvmTest&quot; and a Gradle distribution for the &quot;test&quot; compilation</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            executable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(KotlinCompilation.TEST_COMPILATION_NAME) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                mainClass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo.MainTestKt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Configures a JavaExec task named &quot;runJvmTestAnother&quot; and a Gradle distribution for the &quot;test&quot; compilation</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            executable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(KotlinCompilation.TEST_COMPILATION_NAME, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;another&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                mainClass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo.MainAnotherTestKt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在此示例中，Gradle 的 <a href="https://docs.gradle.org/current/userguide/distribution_plugin.html#distribution_plugin" target="_blank" rel="noreferrer">Distribution</a> 插件应用于第一个 <code>executable {}</code> 代码块。</p><p>如果您遇到任何问题，请在我们的<a href="https://kotl.in/issue" target="_blank" rel="noreferrer">问题追踪器</a>中报告，或在我们的<a href="https://kotlinlang.slack.com/archives/C19FD9681" target="_blank" rel="noreferrer">公共 Slack 频道</a>中告知我们。</p><h2 id="kotlin-native" tabindex="-1">Kotlin/Native <a class="header-anchor" href="#kotlin-native" aria-label="Permalink to &quot;Kotlin/Native&quot;">​</a></h2><h3 id="支持-xcode-16-3" tabindex="-1">支持 Xcode 16.3 <a class="header-anchor" href="#支持-xcode-16-3" aria-label="Permalink to &quot;支持 Xcode 16.3&quot;">​</a></h3><p>从 Kotlin <strong>2.1.21</strong> 开始，Kotlin/Native 编译器支持 Xcode 16.3——Xcode 的最新稳定版本。 请随意更新您的 Xcode 并继续为 Apple 操作系统处理您的 Kotlin 项目。</p><p>2.1.21 版本还修复了相关的 <a href="https://youtrack.jetbrains.com/issue/KT-75781/" target="_blank" rel="noreferrer">cinterop 问题</a>，该问题导致 Kotlin Multiplatform 项目的编译失败。</p>`,11)),n(a,{id:"新增内联优化",level:"3",title:"新增内联优化",labelRef:"experimental-opt-in"}),s[4]||(s[4]=i('<p>Kotlin 2.1.20 引入了新的内联优化过程，它在实际的代码生成阶段之前。</p><p>Kotlin/Native 编译器中新的内联过程应比标准的 LLVM 内联器表现更好，并能提高生成代码的运行时性能。</p><p>新的内联过程目前处于<a href="/kotlin/components-stability#stability-levels-explained">实验阶段</a>。要试用， 请使用以下编译器选项：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-Xbinary=preCodegenInlineThreshold=40</span></span></code></pre></div><p>我们的实验表明，将阈值设置为 40 个 token（由编译器解析的代码单元）为编译优化提供了一个合理的折衷。根据我们的基准测试，这带来了 9.5% 的总体性能提升。当然，您也可以尝试其他值。</p><p>如果您遇到二进制文件大小增加或编译时间延长的问题，请通过 <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack</a> 报告此类问题。</p><h2 id="kotlin-wasm" tabindex="-1">Kotlin/Wasm <a class="header-anchor" href="#kotlin-wasm" aria-label="Permalink to &quot;Kotlin/Wasm&quot;">​</a></h2><p>此版本改进了 Kotlin/Wasm 的调试和属性使用。现在，自定义格式化程序在开发构建中开箱即用，而 DWARF 调试则有助于代码探查。此外，Provider API 简化了 Kotlin/Wasm 和 Kotlin/JS 中的属性使用。</p><h3 id="自定义格式化程序默认启用" tabindex="-1">自定义格式化程序默认启用 <a class="header-anchor" href="#自定义格式化程序默认启用" aria-label="Permalink to &quot;自定义格式化程序默认启用&quot;">​</a></h3><p>此前，您必须<a href="/kotlin/whatsnew21#improved-debugging-experience-for-kotlin-wasm">手动配置</a>自定义格式化程序，以便在使用 Kotlin/Wasm 代码时改进 Web 浏览器中的调试体验。</p><p>在此版本中，自定义格式化程序默认在开发构建中启用，因此您不需要额外的 Gradle 配置。</p><p>要使用此特性，您只需确保在浏览器的开发者工具中启用自定义格式化程序：</p><ul><li><p>在 Chrome DevTools 中，在 <strong>Settings | Preferences | Console</strong> 中找到自定义格式化程序复选框：</p><p><img src="'+t+'" alt="在 Chrome 中启用自定义格式化程序" width="400"></p></li><li><p>在 Firefox DevTools 中，在 <strong>Settings | Advanced settings</strong> 中找到自定义格式化程序复选框：</p><p><img src="'+l+`" alt="在 Firefox 中启用自定义格式化程序" width="400"></p></li></ul><p>此更改主要影响 Kotlin/Wasm 开发构建。如果您对生产构建有特定要求，则需要相应地调整您的 Gradle 配置。为此，请将以下编译器选项添加到 <code>wasmJs {}</code> 代码块中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    wasmJs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xwasm-debugger-custom-formatters&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="支持-dwarf-以调试-kotlin-wasm-代码" tabindex="-1">支持 DWARF 以调试 Kotlin/Wasm 代码 <a class="header-anchor" href="#支持-dwarf-以调试-kotlin-wasm-代码" aria-label="Permalink to &quot;支持 DWARF 以调试 Kotlin/Wasm 代码&quot;">​</a></h3><p>Kotlin 2.1.20 引入了对 Kotlin/Wasm 中 DWARF（任意记录格式调试）的支持。</p><p>通过此更改，Kotlin/Wasm 编译器能够将 DWARF 数据嵌入到生成的 WebAssembly (Wasm) 二进制文件中。 许多调试器和虚拟机可以读取此数据，以深入了解编译后的代码。</p><p>DWARF 主要用于在独立的 Wasm 虚拟机 (VM) 内调试 Kotlin/Wasm 应用程序。要使用此 特性，Wasm VM 和调试器必须支持 DWARF。</p><p>借助 DWARF 支持，您可以单步调试 Kotlin/Wasm 应用程序、探查变量并获得代码见解。要启用此特性，请使用以下编译器选项：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-Xwasm-generate-dwarf</span></span></code></pre></div><h3 id="迁移到-provider-api-以用于-kotlin-wasm-和-kotlin-js-属性" tabindex="-1">迁移到 Provider API 以用于 Kotlin/Wasm 和 Kotlin/JS 属性 <a class="header-anchor" href="#迁移到-provider-api-以用于-kotlin-wasm-和-kotlin-js-属性" aria-label="Permalink to &quot;迁移到 Provider API 以用于 Kotlin/Wasm 和 Kotlin/JS 属性&quot;">​</a></h3><p>此前，Kotlin/Wasm 和 Kotlin/JS 扩展中的属性是可变的 (<code>var</code>)，并在构建脚本中直接赋值：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">the</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NodeJsExtension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;().version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;2.0.0&quot;</span></span></code></pre></div><p>现在，属性通过 <a href="https://docs.gradle.org/current/userguide/properties_providers.html" target="_blank" rel="noreferrer">Provider API</a> 暴露，您必须使用 <code>.set()</code> 函数来赋值：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">the</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NodeJsEnvSpec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;().version.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Provider API 确保值是惰性计算的，并与任务依赖项正确集成，从而提高构建性能。</p><p>通过此更改，直接属性赋值已被弃用，取而代之的是 <code>*EnvSpec</code> 类，例如 <code>NodeJsEnvSpec</code> 和 <code>YarnRootEnvSpec</code>。</p><p>此外，为了避免混淆，已删除了一些别名任务：</p><table tabindex="0"><thead><tr><th>已弃用任务</th><th>替代项</th></tr></thead><tbody><tr><td><code>wasmJsRun</code></td><td><code>wasmJsBrowserDevelopmentRun</code></td></tr><tr><td><code>wasmJsBrowserRun</code></td><td><code>wasmJsBrowserDevelopmentRun</code></td></tr><tr><td><code>wasmJsNodeRun</code></td><td><code>wasmJsNodeDevelopmentRun</code></td></tr><tr><td><code>wasmJsBrowserWebpack</code></td><td><code>wasmJsBrowserProductionWebpack</code> or <code>wasmJsBrowserDistribution</code></td></tr><tr><td><code>jsRun</code></td><td><code>jsBrowserDevelopmentRun</code></td></tr><tr><td><code>jsBrowserRun</code></td><td><code>jsBrowserDevelopmentRun</code></td></tr><tr><td><code>jsNodeRun</code></td><td><code>jsNodeDevelopmentRun</code></td></tr><tr><td><code>jsBrowserWebpack</code></td><td><code>jsBrowserProductionWebpack</code> or <code>jsBrowserDistribution</code></td></tr></tbody></table><p>如果您只在构建脚本中使用 Kotlin/JS 或 Kotlin/Wasm，则无需执行任何操作，因为 Gradle 会自动处理赋值。</p><p>但是，如果您维护一个基于 Kotlin Gradle 插件的插件，并且您的插件不应用 <code>kotlin-dsl</code>，则必须更新属性赋值以使用 <code>.set()</code> 函数。</p><h2 id="gradle" tabindex="-1">Gradle <a class="header-anchor" href="#gradle" aria-label="Permalink to &quot;Gradle&quot;">​</a></h2><p>Kotlin 2.1.20 完全兼容 Gradle 7.6.3 至 8.11。您也可以使用直到最新 Gradle 版本的 Gradle 版本。但是，请注意，这样做可能会导致弃用警告，并且某些新的 Gradle 特性可能无法工作。</p><p>此版本的 Kotlin 包含 Kotlin Gradle 插件与 Gradle 的 Isolated Projects 的兼容性，以及对自定义 Gradle 发布变体的支持。</p>`,35)),n(a,{id:"kotlin-gradle-插件兼容-gradle-的-isolated-projects",level:"3",title:"Kotlin Gradle 插件兼容 Gradle 的 Isolated Projects",labelRef:"experimental-opt-in"}),s[5]||(s[5]=i('<div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>此特性目前在 Gradle 中处于预 Alpha 状态。目前不支持 JS 和 Wasm 目标平台。 仅在 Gradle 8.10 或更高版本中使用它，并且仅用于求值目的。</p></div><p>自 Kotlin 2.1.0 以来，您已能够在项目中<a href="/kotlin/whatsnew21#preview-gradle-s-isolated-projects-in-kotlin-multiplatform">预览 Gradle 的 Isolated Projects 特性</a>。</p><p>此前，您必须配置 Kotlin Gradle 插件，才能使您的项目与 Isolated Projects 特性兼容，然后才能试用它。在 Kotlin 2.1.20 中，不再需要此额外步骤。</p><p>现在，要启用 Isolated Projects 特性，您只需<a href="https://docs.gradle.org/current/userguide/isolated_projects.html#how_do_i_use_it" target="_blank" rel="noreferrer">设置系统属性</a>。</p><p>Kotlin Gradle 插件支持 Gradle 的 Isolated Projects 特性，适用于多平台项目以及仅包含 JVM 或 Android 目标平台的项目。</p><p>特别是对于多平台项目，如果您在升级后发现 Gradle 构建存在问题，可以通过添加以下内容来选择退出新的 Kotlin Gradle 插件行为：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.kmp.isolated-projects.support=disable</span></span></code></pre></div><p>但是，如果您在多平台项目中使用此 Gradle 属性，则无法使用 Isolated Projects 特性。</p><p>请在 <a href="https://youtrack.jetbrains.com/issue/KT-57279/Support-Gradle-Project-Isolation-Feature-for-Kotlin-Multiplatform" target="_blank" rel="noreferrer">YouTrack</a> 中告诉我们您使用此特性的体验。</p>',9)),n(a,{id:"支持添加自定义-gradle-发布变体",level:"3",title:"支持添加自定义 Gradle 发布变体",labelRef:"experimental-opt-in"}),s[6]||(s[6]=i(`<p>Kotlin 2.1.20 引入了对添加自定义 <a href="https://docs.gradle.org/current/userguide/variant_attributes.html" target="_blank" rel="noreferrer">Gradle 发布变体</a>的支持。 此特性适用于多平台项目和面向 JVM 的项目。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>您无法使用此特性修改现有的 Gradle 变体。</p></div><p>此特性是<a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>。 要选择启用，请使用 <code>@OptIn(ExperimentalKotlinGradlePluginApi::class)</code> 注解。</p><p>要添加自定义 Gradle 发布变体，请调用 <code>adhocSoftwareComponent()</code> 函数，它会返回一个 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/component/AdhocComponentWithVariants.html" target="_blank" rel="noreferrer"><code>AdhocComponentWithVariants</code></a> 实例，您可以在 Kotlin DSL 中配置它：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">plugins</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Only JVM and Multiplatform are supported</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;jvm&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // or</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;multiplatform&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalKotlinGradlePluginApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    publishing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Returns an instance of AdhocSoftwareComponent</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        adhocSoftwareComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Alternatively, you can configure AdhocSoftwareComponent in the DSL block as follows</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        adhocSoftwareComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Add your custom variants here using the AdhocSoftwareComponent API</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>有关变体的更多信息，请参见 Gradle 的<a href="https://docs.gradle.org/current/userguide/publishing_customization.html" target="_blank" rel="noreferrer">自定义发布指南</a>。</p></div><h2 id="标准库" tabindex="-1">标准库 <a class="header-anchor" href="#标准库" aria-label="Permalink to &quot;标准库&quot;">​</a></h2><p>此版本为标准库带来了新的实验性特性：通用原子类型、改进的 UUID 支持以及新的时间追踪功能。</p>`,8)),n(a,{id:"通用原子类型",level:"3",title:"通用原子类型",labelRef:"experimental-opt-in"}),s[7]||(s[7]=i(`<p>在 Kotlin 2.1.20 中，我们将在标准库的 <code>kotlin.concurrent.atomics</code> 包中引入通用原子类型，从而实现用于线程安全操作的共享的、平台无关的代码。这通过消除跨源代码集重复原子相关逻辑的需要，简化了 Kotlin Multiplatform 项目的开发。</p><p><code>kotlin.concurrent.atomics</code> 包及其属性是<a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>。 要选择启用，请使用 <code>@OptIn(ExperimentalAtomicApi::class)</code> 注解或编译器选项 <code>-opt-in=kotlin.ExperimentalAtomicApi</code>。</p><p>以下示例展示了如何使用 <code>AtomicInt</code> 安全地计算跨多个线程处理的项：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 导入必要的库</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.concurrent.atomics.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalAtomicApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 初始化用于处理项的原子计数器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> processedItems </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AtomicInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> totalItems </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(totalItems) { </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;item</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$it</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 将项拆分为块，以便由多个协程处理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chunkSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> itemChunks </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chunked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(chunkSize)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    coroutineScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (chunk </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> itemChunks) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chunk) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Processing </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$item</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> in thread \${Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    processedItems </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 以原子方式递增计数器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 打印处理的项总数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Total processed items: \${processedItems.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">load</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>为了实现 Kotlin 的原子类型与 Java 的 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html" target="_blank" rel="noreferrer"><code>java.util.concurrent.atomic</code></a> 原子类型之间的无缝互操作性，该 API 提供了 <code>.asJavaAtomic()</code> 和 <code>.asKotlinAtomic()</code> 扩展函数。在 JVM 上，Kotlin 原子类型和 Java 原子类型在运行时是相同的类型，因此您可以将 Java 原子类型转换为 Kotlin 原子类型，反之亦然，而无需任何开销。</p><p>以下示例展示了 Kotlin 和 Java 原子类型如何协同工作：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 导入必要的库</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.concurrent.atomics.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> java.util.concurrent.atomic.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalAtomicApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 将 Kotlin AtomicInt 转换为 Java 的 AtomicInteger</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlinAtomic </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AtomicInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> javaAtomic: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AtomicInteger</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlinAtomic.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asJavaAtomic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Java atomic value: \${javaAtomic.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Java atomic value: 42</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 将 Java 的 AtomicInteger 转换回 Kotlin 的 AtomicInt</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlinAgain: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AtomicInt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> javaAtomic.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asKotlinAtomic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Kotlin atomic value: \${kotlinAgain.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">load</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Kotlin atomic value: 42</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,7)),n(a,{id:"uuid-解析、格式化和可比较性方面的更改",level:"3",title:"UUID 解析、格式化和可比较性方面的更改",labelRef:"experimental-opt-in"}),s[8]||(s[8]=i(`<p>JetBrains 团队继续改进对 <a href="/kotlin/whatsnew2020#support-for-uuids-in-the-common-kotlin-standard-library">2.0.20 版本中引入标准库</a>的 UUID 的支持。</p><p>此前，<code>parse()</code> 函数只接受十六进制带连字符格式的 UUID。使用 Kotlin 2.1.20， 您可以将 <code>parse()</code> 用于十六进制带连字符格式和纯十六进制（不带连字符）格式。</p><p>在此版本中，我们还引入了专门用于十六进制带连字符格式操作的函数：</p><ul><li><code>parseHexDash()</code> 从十六进制带连字符格式解析 UUID。</li><li><code>toHexDashString()</code> 将 <code>Uuid</code> 转换为十六进制带连字符格式的 <code>String</code>（与 <code>toString()</code> 的功能相对应）。</li></ul><p>这些函数的工作方式类似于 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.uuid/-uuid/-companion/parse-hex.html" target="_blank" rel="noreferrer"><code>parseHex()</code></a> 和 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.uuid/-uuid/to-hex-string.html" target="_blank" rel="noreferrer"><code>toHexString()</code></a>，它们此前是为十六进制格式引入的。解析和格式化功能的显式命名应该会提高代码清晰度以及您使用 UUID 的整体体验。</p><p>Kotlin 中的 UUID 现在是 <code>Comparable</code> 的。从 Kotlin 2.1.20 开始，您可以直接比较和排序 <code>Uuid</code> 类型的值。这使得 <code>&lt;</code> 和 <code>&gt;</code> 操作符以及仅适用于 <code>Comparable</code> 类型或其集合（例如 <code>sorted()</code>）的标准库扩展得以使用，并且还允许将 UUID 传递给任何需要 <code>Comparable</code> 接口的函数或 API。</p><p>请记住，标准库中的 UUID 支持仍处于<a href="/kotlin/components-stability#stability-levels-explained">实验阶段</a>。 要选择启用，请使用 <code>@OptIn(ExperimentalUuidApi::class)</code> 注解或编译器选项 <code>-opt-in=kotlin.uuid.ExperimentalUuidApi</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.uuid.ExperimentalUuidApi</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.uuid.Uuid</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalUuidApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // parse() 接受纯十六进制格式的 UUID</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uuid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Uuid.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;550e8400e29b41d4a716446655440000&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 将其转换为十六进制带连字符格式</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hexDashFormat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uuid.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toHexDashString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 输出十六进制带连字符格式的 UUID</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hexDashFormat)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 按升序输出 UUID</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            uuid,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Uuid.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;780e8400e29b41d4a716446655440005&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Uuid.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;5ab88400e29b41d4a716446655440076&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sorted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span></code></pre></div>`,8)),n(a,{id:"新增时间追踪功能",level:"3",title:"新增时间追踪功能",labelRef:"experimental-opt-in"}),s[9]||(s[9]=i(`<p>从 Kotlin 2.1.20 开始，标准库提供了表示时间点的能力。此功能此前仅在 <a href="https://kotlinlang.org/api/kotlinx-datetime/" target="_blank" rel="noreferrer"><code>kotlinx-datetime</code></a>（一个官方 Kotlin 库）中提供。</p><p><a href="https://kotlinlang.org/api/kotlinx-datetime/kotlinx-datetime/kotlinx.datetime/-clock/" target="_blank" rel="noreferrer"><code>kotlinx.datetime.Clock</code></a> 接口作为 <code>kotlin.time.Clock</code> 引入到标准库中，<a href="https://kotlinlang.org/api/kotlinx-datetime/kotlinx-datetime/kotlinx.datetime/-instant/" target="_blank" rel="noreferrer"><code>kotlinx.datetime.Instant</code></a> 类作为 <code>kotlin.time.Instant</code> 引入。这些概念与标准库中的 <code>time</code> 包自然契合，因为它们只关注时间点，而更复杂的日历和时区功能仍保留在 <code>kotlinx-datetime</code> 中。</p><p>当您需要精确的时间追踪而不考虑时区或日期时，<code>Instant</code> 和 <code>Clock</code> 会很有用。例如，您可以使用它们记录带时间戳的事件、测量两个时间点之间的持续时间，以及获取系统进程的当前时间点。</p><p>为了提供与其他语言的互操作性，还提供了额外的转换函数：</p><ul><li><code>.toKotlinInstant()</code> 将时间值转换为 <code>kotlin.time.Instant</code> 实例。</li><li><code>.toJavaInstant()</code> 将 <code>kotlin.time.Instant</code> 值转换为 <code>java.time.Instant</code> 值。</li><li><code>Instant.toJSDate()</code> 将 <code>kotlin.time.Instant</code> 值转换为 JS <code>Date</code> 类的一个实例。此转换不精确；JS 使用毫秒精度表示日期，而 Kotlin 允许纳秒分辨率。</li></ul><p>标准库的新时间特性仍处于<a href="/kotlin/components-stability#stability-levels-explained">实验阶段</a>。 要选择启用，请使用 <code>@OptIn(ExperimentalTime::class)</code> 注解：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.time.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalTime::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 获取当前时间点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentInstant </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Clock.System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Current time: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$currentInstant</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 查找两个时间点之间的差异</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pastInstant </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Instant.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2023-01-01T00:00:00Z&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> duration </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentInstant </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pastInstant</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Time elapsed since 2023-01-01: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$duration</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>有关实现的更多信息，请参见此 <a href="https://github.com/Kotlin/KEEP/pull/387/files" target="_blank" rel="noreferrer">KEEP 提案</a>。</p><h2 id="compose-编译器" tabindex="-1">Compose 编译器 <a class="header-anchor" href="#compose-编译器" aria-label="Permalink to &quot;Compose 编译器&quot;">​</a></h2><p>在 2.1.20 中，Compose 编译器放宽了此前版本中引入的对 <code>@Composable</code> 函数的一些限制。 此外，Compose 编译器 Gradle 插件默认设置为包含源代码信息，使所有平台上的行为与 Android 保持一致。</p><h3 id="支持开放-composable-函数中带默认值的形参" tabindex="-1">支持开放 <code>@Composable</code> 函数中带默认值的形参 <a class="header-anchor" href="#支持开放-composable-函数中带默认值的形参" aria-label="Permalink to &quot;支持开放 \`@Composable\` 函数中带默认值的形参&quot;">​</a></h3><p>此前，编译器限制在开放的 <code>@Composable</code> 函数中使用带默认值的形参，原因在于编译器输出不正确，这会导致运行时崩溃。现在，底层问题已解决，与 Kotlin 2.1.20 或更高版本一起使用时，带默认值的形参得到完全支持。</p><p>Compose 编译器在 <a href="https://developer.android.com/jetpack/androidx/releases/compose-compiler#1.5.8" target="_blank" rel="noreferrer">1.5.8 版本</a>之前允许在开放函数中使用带默认值的形参，因此支持取决于项目配置：</p><ul><li>如果开放的可组合函数使用 Kotlin 2.1.20 或更高版本编译，编译器会为带默认值的形参生成正确的包装器。这包括与 1.5.8 之前的二进制文件兼容的包装器，这意味着下游库也将能够使用此开放函数。</li><li>如果开放的可组合函数使用低于 2.1.20 版本的 Kotlin 编译，Compose 将使用兼容模式，这可能会导致运行时崩溃。使用兼容模式时，编译器会发出警告以突出显示潜在问题。</li></ul><h3 id="最终覆盖的函数允许可重启" tabindex="-1">最终覆盖的函数允许可重启 <a class="header-anchor" href="#最终覆盖的函数允许可重启" aria-label="Permalink to &quot;最终覆盖的函数允许可重启&quot;">​</a></h3><p>虚函数（<code>open</code> 和 <code>abstract</code> 的覆盖，包括接口）<a href="/kotlin/whatsnew21#changes-to-open-and-overridden-composable-functions">在 2.1.0 版本中被强制为不可重启</a>。 对于作为 <code>final</code> 类成员或自身为 <code>final</code> 的函数，此限制现在已放宽——它们将照常重启或跳过。</p><p>升级到 Kotlin 2.1.20 后，您可能会在受影响的函数中观察到一些行为变化。要强制使用以前版本的不可重启逻辑，请将 <code>@NonRestartableComposable</code> 注解应用于该函数。</p><h3 id="composablesingletons-从公共-api-中移除" tabindex="-1"><code>ComposableSingletons</code> 从公共 API 中移除 <a class="header-anchor" href="#composablesingletons-从公共-api-中移除" aria-label="Permalink to &quot;\`ComposableSingletons\` 从公共 API 中移除&quot;">​</a></h3><p><code>ComposableSingletons</code> 是 Compose 编译器在优化 <code>@Composable</code> lambda 表达式时创建的一个类。不捕获任何形参的 lambda 表达式会一次性分配并缓存在该类的一个属性中，从而节省运行时分配。 该类以内部可见性生成，仅用于优化编译单元（通常是文件）内的 lambda 表达式。</p><p>然而，此优化也应用于 <code>inline</code> 函数体，这导致单例 lambda 实例泄露到公共 API 中。为了解决此问题，从 2.1.20 开始，<code>@Composable</code> lambda 表达式不再在内联函数内部优化为单例。同时，Compose 编译器将继续为内联函数生成单例类和 lambda 表达式，以支持在先前模型下编译的模块的二进制兼容性。</p><h3 id="源代码信息默认包含" tabindex="-1">源代码信息默认包含 <a class="header-anchor" href="#源代码信息默认包含" aria-label="Permalink to &quot;源代码信息默认包含&quot;">​</a></h3><p>Compose 编译器 Gradle 插件在 Android 上已默认启用<a href="https://kotlinlang.org/api/kotlin-gradle-plugin/compose-compiler-gradle-plugin/org.jetbrains.kotlin.compose.compiler.gradle/-compose-compiler-gradle-plugin-extension/include-source-information.html" target="_blank" rel="noreferrer">包含源代码信息</a>特性。从 Kotlin 2.1.20 开始，此特性将默认在所有平台上启用。</p><p>请记住检查您是否使用 <code>freeCompilerArgs</code> 设置了此选项。此方法与插件一起使用时可能会导致构建失败，因为一个选项被有效地设置了两次。</p><h2 id="重大变更与弃用" tabindex="-1">重大变更与弃用 <a class="header-anchor" href="#重大变更与弃用" aria-label="Permalink to &quot;重大变更与弃用&quot;">​</a></h2><ul><li>为了使 Kotlin Multiplatform 与 Gradle 即将进行的更改保持一致，我们正在逐步淘汰 <code>withJava()</code> 函数。 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-compatibility-guide.html#java-source-sets-created-by-default" target="_blank" rel="noreferrer">Java 源代码集现在默认创建</a>。如果您使用 <a href="https://docs.gradle.org/current/userguide/java_testing.html#sec:java_test_fixtures" target="_blank" rel="noreferrer">Java 测试夹具</a> Gradle 插件， 请直接升级到 <a href="/kotlin/releases#release-details">Kotlin 2.1.21</a> 以避免兼容性问题。</li><li>JetBrains 团队正在继续弃用 <code>kotlin-android-extensions</code> 插件。如果您尝试在项目中使用它，您现在将收到配置错误，并且不会执行任何插件代码。</li><li>旧版 <code>kotlin.incremental.classpath.snapshot.enabled</code> 属性已从 Kotlin Gradle 插件中移除。 该属性曾提供一个回退到 JVM 上内置 ABI 快照的机会。该插件现在使用 其他方法来检测和避免不必要的重新编译，从而使该属性过时。</li></ul><h2 id="文档更新" tabindex="-1">文档更新 <a class="header-anchor" href="#文档更新" aria-label="Permalink to &quot;文档更新&quot;">​</a></h2><p>Kotlin 文档收到了一些显著的更改：</p><h3 id="修订和新页面" tabindex="-1">修订和新页面 <a class="header-anchor" href="#修订和新页面" aria-label="Permalink to &quot;修订和新页面&quot;">​</a></h3><ul><li><a href="/kotlin/roadmap">Kotlin 路线图</a> – 查看 Kotlin 在语言和生态系统演进方面的更新优先级列表。</li><li><a href="/kotlin/gradle-best-practices">Gradle 最佳实践</a>页面 – 了解优化 Gradle 构建和提高性能的基本最佳实践。</li><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-multiplatform-and-jetpack-compose.html" target="_blank" rel="noreferrer">Compose Multiplatform 和 Jetpack Compose</a> – 两个 UI 框架之间关系的概述。</li><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/kotlin-multiplatform-flutter.html" target="_blank" rel="noreferrer">Kotlin Multiplatform 和 Flutter</a> – 查看两个流行的跨平台框架的比较。</li><li><a href="/kotlin/native-c-interop">与 C 的互操作性</a> – 探索 Kotlin 与 C 互操作性的详细信息。</li><li><a href="/kotlin/numbers">数字</a> – 了解用于表示数字的不同 Kotlin 类型。</li></ul><h3 id="新增和更新的教程" tabindex="-1">新增和更新的教程 <a class="header-anchor" href="#新增和更新的教程" aria-label="Permalink to &quot;新增和更新的教程&quot;">​</a></h3><ul><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-publish-libraries.html" target="_blank" rel="noreferrer">将您的库发布到 Maven Central</a> – 了解如何将 KMP 库构件发布到最流行的 Maven 版本库。</li><li><a href="/kotlin/native-dynamic-libraries">Kotlin/Native 作为动态库</a> – 创建一个动态 Kotlin 库。</li><li><a href="/kotlin/apple-framework">Kotlin/Native 作为 Apple framework</a> – 创建您自己的 framework，并在 macOS 和 iOS 上从 Swift/Objective-C 应用程序中使用 Kotlin/Native 代码。</li></ul><h2 id="如何更新到-kotlin-2-1-20" tabindex="-1">如何更新到 Kotlin 2.1.20 <a class="header-anchor" href="#如何更新到-kotlin-2-1-20" aria-label="Permalink to &quot;如何更新到 Kotlin 2.1.20&quot;">​</a></h2><p>从 IntelliJ IDEA 2023.3 和 Android Studio Iguana (2023.2.1) Canary 15 开始，Kotlin 插件作为捆绑插件分发，包含在您的 IDE 中。这意味着您无法再从 JetBrains Marketplace 安装该插件。</p><p>要更新到新的 Kotlin 版本，请在构建脚本中<a href="/kotlin/releases#update-to-a-new-kotlin-version">将 Kotlin 版本更改</a>为 2.1.20。</p>`,34))])}const b=e(o,[["render",r]]);export{F as __pageData,b as default};
