import{_ as k,C as h,c as r,o,ag as t,j as s,G as e,w as n,a}from"./chunks/framework.Bksy39di.js";const C=JSON.parse('{"title":"Kotlin 1.4.30의 새로운 기능","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/whatsnew1430.md","filePath":"ko/kotlin/whatsnew1430.md","lastUpdated":1754307826000}'),d={name:"ko/kotlin/whatsnew1430.md"};function c(g,i,E,y,u,b){const l=h("tab"),p=h("tabs");return o(),r("div",null,[i[4]||(i[4]=t(`<h1 id="kotlin-1-4-30의-새로운-기능" tabindex="-1">Kotlin 1.4.30의 새로운 기능 <a class="header-anchor" href="#kotlin-1-4-30의-새로운-기능" aria-label="Permalink to &quot;Kotlin 1.4.30의 새로운 기능&quot;">​</a></h1><p><em><a href="/ko/kotlin/releases#release-details">출시일: 2021년 2월 3일</a></em></p><p>Kotlin 1.4.30은 새로운 언어 기능의 프리뷰 버전을 제공하고, Kotlin/JVM 컴파일러의 새로운 IR 백엔드를 베타로 승격하며, 다양한 성능 및 기능 개선 사항을 포함합니다.</p><p>새로운 기능에 대한 자세한 내용은 <a href="https://blog.jetbrains.com/kotlin/2021/01/kotlin-1-4-30-released/" target="_blank" rel="noreferrer">이 블로그 게시물</a>에서도 확인할 수 있습니다.</p><h2 id="언어-기능" tabindex="-1">언어 기능 <a class="header-anchor" href="#언어-기능" aria-label="Permalink to &quot;언어 기능&quot;">​</a></h2><p>Kotlin 1.5.0에서는 JVM 레코드 지원, 봉인된 인터페이스(sealed interfaces), 안정적인 인라인 클래스(Stable inline classes) 등 새로운 언어 기능이 제공될 예정입니다. Kotlin 1.4.30에서는 이러한 기능 및 개선 사항을 프리뷰 모드에서 사용해 볼 수 있습니다. 1.5.0 릴리스 전에 저희가 피드백을 반영할 수 있도록 해당 YouTrack 티켓에 의견을 공유해 주시면 감사하겠습니다.</p><ul><li><a href="#jvm-records-support">JVM 레코드 지원</a></li><li><a href="#sealed-interfaces">봉인된 인터페이스</a> 및 <a href="#package-wide-sealed-class-hierarchies">봉인된 클래스 개선 사항</a></li><li><a href="#improved-inline-classes">개선된 인라인 클래스</a></li></ul><p>프리뷰 모드에서 이러한 언어 기능 및 개선 사항을 활성화하려면 특정 컴파일러 옵션을 추가하여 옵트인(opt-in)해야 합니다. 자세한 내용은 아래 섹션을 참조하세요.</p><p>새로운 기능 프리뷰에 대한 자세한 내용은 <a href="https://blog.jetbrains.com/kotlin/2021/01/new-language-features-preview-in-kotlin-1-4-30" target="_blank" rel="noreferrer">이 블로그 게시물</a>에서 확인할 수 있습니다.</p><h3 id="jvm-레코드-지원" tabindex="-1">JVM 레코드 지원 <a class="header-anchor" href="#jvm-레코드-지원" aria-label="Permalink to &quot;JVM 레코드 지원&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>JVM 레코드 기능은 <a href="/ko/kotlin/components-stability">실험적(Experimental)</a>입니다. 이 기능은 언제든지 제거되거나 변경될 수 있습니다. 옵트인(opt-in)이 필요하며(자세한 내용은 아래 참조), 평가 목적으로만 사용해야 합니다. <a href="https://youtrack.jetbrains.com/issue/KT-42430" target="_blank" rel="noreferrer">YouTrack</a>을 통해 피드백을 주시면 감사하겠습니다.</p></div><p><a href="https://openjdk.java.net/projects/jdk/16/" target="_blank" rel="noreferrer">JDK 16 릴리스</a>에는 <a href="https://openjdk.java.net/jeps/395" target="_blank" rel="noreferrer">레코드(record)</a>라는 새로운 Java 클래스 유형을 안정화하려는 계획이 포함되어 있습니다. Kotlin의 모든 이점을 제공하고 Java와의 상호 운용성을 유지하기 위해 Kotlin은 실험적인 레코드 클래스 지원을 도입하고 있습니다.</p><p>Java에서 선언된 레코드 클래스는 Kotlin의 속성을 가진 클래스처럼 사용할 수 있습니다. 추가 단계는 필요하지 않습니다.</p><p>1.4.30부터는 <a href="/ko/kotlin/data-classes">데이터 클래스</a>에 <code>@JvmRecord</code> 어노테이션을 사용하여 Kotlin에서 레코드 클래스를 선언할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmRecord</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>JVM 레코드의 프리뷰 버전을 사용해 보려면 컴파일러 옵션 <code>-Xjvm-enable-preview</code>와 <code>-language-version 1.5</code>를 추가하세요.</p><p>저희는 JVM 레코드 지원 작업을 계속하고 있으며, 이 <a href="https://youtrack.jetbrains.com/issue/KT-42430" target="_blank" rel="noreferrer">YouTrack 티켓</a>을 통해 피드백을 공유해 주시면 감사하겠습니다.</p><p>구현, 제한 사항 및 구문에 대한 자세한 내용은 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/jvm-records.md" target="_blank" rel="noreferrer">KEEP</a>에서 확인할 수 있습니다.</p><h3 id="봉인된-인터페이스" tabindex="-1">봉인된 인터페이스 <a class="header-anchor" href="#봉인된-인터페이스" aria-label="Permalink to &quot;봉인된 인터페이스&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>봉인된 인터페이스는 <a href="/ko/kotlin/components-stability">실험적(Experimental)</a>입니다. 이 기능은 언제든지 제거되거나 변경될 수 있습니다. 옵트인(opt-in)이 필요하며(자세한 내용은 아래 참조), 평가 목적으로만 사용해야 합니다. <a href="https://youtrack.jetbrains.com/issue/KT-42433" target="_blank" rel="noreferrer">YouTrack</a>을 통해 피드백을 주시면 감사하겠습니다.</p></div><p>Kotlin 1.4.30에서는 _봉인된 인터페이스(sealed interfaces)_의 프로토타입을 제공합니다. 이는 봉인된 클래스(sealed classes)를 보완하고 더욱 유연한 제한된 클래스 계층 구조를 구축할 수 있도록 합니다.</p><p>봉인된 인터페이스는 동일한 모듈 외부에서는 구현할 수 없는 &quot;내부&quot; 인터페이스 역할을 할 수 있습니다. 예를 들어, 완전한 <code>when</code> 표현식을 작성할 때 이 사실을 활용할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Polygon</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rectangle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Polygon</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Triangle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Polygon</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// when()은 완전합니다: 모듈 컴파일 후에는 다른 Polygon 구현이 나타날 수 없습니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> draw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(polygon: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Polygon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (polygon) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Rectangle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Triangle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>또 다른 사용 사례: 봉인된 인터페이스를 사용하면 하나 이상의 봉인된 슈퍼클래스(sealed superclasses)로부터 클래스를 상속할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Fillable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Polygon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vertices: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rectangle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vertices: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Fillable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Polygon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*...*/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>봉인된 인터페이스의 프리뷰 버전을 사용해 보려면 컴파일러 옵션 <code>-language-version 1.5</code>를 추가하세요. 이 버전으로 전환하면 인터페이스에 <code>sealed</code> 수식어를 사용할 수 있습니다. 이 <a href="https://youtrack.jetbrains.com/issue/KT-42433" target="_blank" rel="noreferrer">YouTrack 티켓</a>을 통해 피드백을 공유해 주시면 감사하겠습니다.</p><p><a href="/ko/kotlin/sealed-classes">봉인된 인터페이스에 대해 자세히 알아보기</a>.</p><h3 id="패키지-전체에-적용되는-봉인된-클래스-계층-구조" tabindex="-1">패키지 전체에 적용되는 봉인된 클래스 계층 구조 <a class="header-anchor" href="#패키지-전체에-적용되는-봉인된-클래스-계층-구조" aria-label="Permalink to &quot;패키지 전체에 적용되는 봉인된 클래스 계층 구조&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>패키지 전체에 적용되는 봉인된 클래스 계층 구조는 <a href="/ko/kotlin/components-stability">실험적(Experimental)</a>입니다. 이 기능은 언제든지 제거되거나 변경될 수 있습니다. 옵트인(opt-in)이 필요하며(자세한 내용은 아래 참조), 평가 목적으로만 사용해야 합니다. <a href="https://youtrack.jetbrains.com/issue/KT-42433" target="_blank" rel="noreferrer">YouTrack</a>을 통해 피드백을 주시면 감사하겠습니다.</p></div><p>이제 봉인된 클래스는 더욱 유연한 계층 구조를 형성할 수 있습니다. 동일한 컴파일 단위 및 동일한 패키지의 모든 파일에 서브클래스를 가질 수 있습니다. 이전에는 모든 서브클래스가 동일한 파일에 있어야 했습니다.</p><p>직접적인 서브클래스는 최상위 수준이거나 다른 명명된 클래스, 명명된 인터페이스 또는 명명된 객체 안에 중첩될 수 있습니다. 봉인된 클래스의 서브클래스는 적절히 한정된 이름을 가져야 하며, 로컬 객체 또는 익명 객체일 수 없습니다.</p><p>패키지 전체에 적용되는 봉인된 클래스 계층 구조를 사용해 보려면 컴파일러 옵션 <code>-language-version 1.5</code>를 추가하세요. 이 <a href="https://youtrack.jetbrains.com/issue/KT-42433" target="_blank" rel="noreferrer">YouTrack 티켓</a>을 통해 피드백을 공유해 주시면 감사하겠습니다.</p><p><a href="/ko/kotlin/sealed-classes#inheritance">패키지 전체에 적용되는 봉인된 클래스 계층 구조에 대해 자세히 알아보기</a>.</p><h3 id="개선된-인라인-클래스" tabindex="-1">개선된 인라인 클래스 <a class="header-anchor" href="#개선된-인라인-클래스" aria-label="Permalink to &quot;개선된 인라인 클래스&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>인라인 값 클래스는 <a href="/ko/kotlin/components-stability">베타(Beta)</a>입니다. 거의 안정적이지만, 향후 마이그레이션 단계가 필요할 수 있습니다. 변경 사항을 최소화하기 위해 최선을 다할 것입니다. 인라인 클래스 기능에 대한 피드백을 <a href="https://youtrack.jetbrains.com/issue/KT-42434" target="_blank" rel="noreferrer">YouTrack</a>을 통해 주시면 감사하겠습니다.</p></div><p>Kotlin 1.4.30은 <a href="/ko/kotlin/inline-classes">인라인 클래스</a>를 <a href="/ko/kotlin/components-stability">베타</a>로 승격하고 다음과 같은 기능 및 개선 사항을 제공합니다.</p><ul><li><p>인라인 클래스는 <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/doc-files/ValueBased.html" target="_blank" rel="noreferrer">값 기반(value-based)</a>이므로 <code>value</code> 수식어를 사용하여 정의할 수 있습니다. 이제 <code>inline</code>과 <code>value</code> 수식어는 서로 동등합니다. 향후 Kotlin 버전에서는 <code>inline</code> 수식어를 사용 중단(deprecate)할 예정입니다.</p><p>이제부터 Kotlin은 JVM 백엔드의 클래스 선언 전에 <code>@JvmInline</code> 어노테이션을 요구합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JVM 백엔드의 경우</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmInline</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div></li><li><p>인라인 클래스는 <code>init</code> 블록을 가질 수 있습니다. 클래스가 인스턴스화된 직후에 실행될 코드를 추가할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmInline</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Negative</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>Java 코드에서 인라인 클래스를 사용하는 함수 호출: Kotlin 1.4.30 이전에는 맹글링(mangling) 때문에 Java에서 인라인 클래스를 받는 함수를 호출할 수 없었습니다. 이제부터는 수동으로 맹글링을 비활성화할 수 있습니다. Java 코드에서 이러한 함수를 호출하려면 함수 선언 전에 <code>@JvmName</code> 어노테이션을 추가해야 합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;computeUInt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { }</span></span></code></pre></div></li><li><p>이 릴리스에서는 잘못된 동작을 수정하기 위해 함수의 맹글링 스키마를 변경했습니다. 이러한 변경은 ABI 변경으로 이어졌습니다.</p><p>1.4.30부터 Kotlin 컴파일러는 기본적으로 새로운 맹글링 스키마를 사용합니다. 컴파일러가 이전 1.4.0 맹글링 스키마를 사용하고 바이너리 호환성을 유지하도록 강제하려면 <code>-Xuse-14-inline-classes-mangling-scheme</code> 컴파일러 플래그를 사용하세요.</p></li></ul><p>Kotlin 1.4.30은 인라인 클래스를 베타로 승격하며, 향후 릴리스에서 안정적인 기능으로 만들 계획입니다. 이 <a href="https://youtrack.jetbrains.com/issue/KT-42434" target="_blank" rel="noreferrer">YouTrack 티켓</a>을 통해 피드백을 공유해 주시면 감사하겠습니다.</p><p>인라인 클래스의 프리뷰 버전을 사용해 보려면 컴파일러 옵션 <code>-Xinline-classes</code> 또는 <code>-language-version 1.5</code>를 추가하세요.</p><p>맹글링 알고리즘에 대한 자세한 내용은 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/inline-classes.md" target="_blank" rel="noreferrer">KEEP</a>에서 확인할 수 있습니다.</p><p><a href="/ko/kotlin/inline-classes">인라인 클래스에 대해 자세히 알아보기</a>.</p><h2 id="kotlin-jvm" tabindex="-1">Kotlin/JVM <a class="header-anchor" href="#kotlin-jvm" aria-label="Permalink to &quot;Kotlin/JVM&quot;">​</a></h2><h3 id="jvm-ir-컴파일러-백엔드가-베타에-도달" tabindex="-1">JVM IR 컴파일러 백엔드가 베타에 도달 <a class="header-anchor" href="#jvm-ir-컴파일러-백엔드가-베타에-도달" aria-label="Permalink to &quot;JVM IR 컴파일러 백엔드가 베타에 도달&quot;">​</a></h3><p>Kotlin/JVM용 <a href="/ko/kotlin/whatsnew14#unified-backends-and-extensibility">IR 기반 컴파일러 백엔드</a>는 1.4.0에서 <a href="/ko/kotlin/components-stability">알파(Alpha)</a>로 선보인 후 베타에 도달했습니다. 이는 IR 백엔드가 Kotlin/JVM 컴파일러의 기본값이 되기 전 마지막 사전 안정화 단계입니다.</p><p>이제 IR 컴파일러가 생성한 바이너리 사용 제한이 해제됩니다. 이전에는 새 JVM IR 백엔드를 활성화한 경우에만 새 백엔드로 컴파일된 코드를 사용할 수 있었습니다. 1.4.30부터는 이러한 제한이 없으므로 새 백엔드를 사용하여 라이브러리와 같은 타사 구성 요소를 빌드할 수 있습니다. 새 백엔드의 베타 버전을 사용해 보고 <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">이슈 트래커</a>에 피드백을 공유해 주세요.</p><p>새 JVM IR 백엔드를 활성화하려면 프로젝트 구성 파일에 다음 줄을 추가하세요:</p>`,46)),s("ul",null,[s("li",null,[i[2]||(i[2]=s("p",null,"Gradle에서:",-1)),e(p,{group:"build-script"},{default:n(()=>[e(l,{title:"Kotlin","group-key":"kotlin"},{default:n(()=>i[0]||(i[0]=[s("div",{class:"language-kotlin vp-adaptive-theme"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"kotlin"),s("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"tasks."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"withType"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(org.jetbrains.kotlin.gradle.dsl.KotlinJvmCompile::"),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"class"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"  kotlinOptions.useIR "),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),s("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," true")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),e(l,{title:"Groovy","group-key":"groovy"},{default:n(()=>i[1]||(i[1]=[s("div",{class:"language-groovy vp-adaptive-theme"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"groovy"),s("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"tasks"),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"withType("),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"org.jetbrains.kotlin.gradle.dsl.KotlinJvmCompile"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"  kotlinOptions"),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"useIR "),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),s("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," true")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1})]),i[3]||(i[3]=t(`<li><p>Maven에서:</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">configuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;-Xuse-ir&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">configuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li>`,1))]),i[5]||(i[5]=t(`<p>JVM IR 백엔드가 가져오는 변경 사항에 대한 자세한 내용은 <a href="https://blog.jetbrains.com/kotlin/2021/01/the-jvm-backend-is-in-beta-let-s-make-it-stable-together" target="_blank" rel="noreferrer">이 블로그 게시물</a>에서 확인할 수 있습니다.</p><h2 id="kotlin-native" tabindex="-1">Kotlin/Native <a class="header-anchor" href="#kotlin-native" aria-label="Permalink to &quot;Kotlin/Native&quot;">​</a></h2><h3 id="성능-개선" tabindex="-1">성능 개선 <a class="header-anchor" href="#성능-개선" aria-label="Permalink to &quot;성능 개선&quot;">​</a></h3><p>Kotlin/Native는 1.4.30에서 다양한 성능 개선이 이루어져 컴파일 시간이 단축되었습니다. 예를 들어, <a href="https://github.com/kotlin-hands-on/kmm-networking-and-data-storage/tree/final" target="_blank" rel="noreferrer">Kotlin 멀티플랫폼 모바일로 네트워킹 및 데이터 저장</a> 샘플에서 프레임워크를 재빌드하는 데 필요한 시간이 9.5초(1.4.10)에서 4.5초(1.4.30)로 감소했습니다.</p><h3 id="apple-watchos-64비트-시뮬레이터-타겟" tabindex="-1">Apple watchOS 64비트 시뮬레이터 타겟 <a class="header-anchor" href="#apple-watchos-64비트-시뮬레이터-타겟" aria-label="Permalink to &quot;Apple watchOS 64비트 시뮬레이터 타겟&quot;">​</a></h3><p>watchOS 7.0부터 x86 시뮬레이터 타겟은 더 이상 사용되지 않습니다(deprecated). 최신 watchOS 버전과 보조를 맞추기 위해 Kotlin/Native는 64비트 아키텍처에서 시뮬레이터를 실행하기 위한 새로운 타겟 <code>watchosX64</code>를 제공합니다.</p><h3 id="xcode-12-2-라이브러리-지원" tabindex="-1">Xcode 12.2 라이브러리 지원 <a class="header-anchor" href="#xcode-12-2-라이브러리-지원" aria-label="Permalink to &quot;Xcode 12.2 라이브러리 지원&quot;">​</a></h3><p>Xcode 12.2와 함께 제공되는 새로운 라이브러리에 대한 지원이 추가되었습니다. 이제 Kotlin 코드에서 해당 라이브러리를 사용할 수 있습니다.</p><h2 id="kotlin-js" tabindex="-1">Kotlin/JS <a class="header-anchor" href="#kotlin-js" aria-label="Permalink to &quot;Kotlin/JS&quot;">​</a></h2><h3 id="최상위-속성-지연-초기화" tabindex="-1">최상위 속성 지연 초기화 <a class="header-anchor" href="#최상위-속성-지연-초기화" aria-label="Permalink to &quot;최상위 속성 지연 초기화&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>최상위 속성의 지연 초기화는 <a href="/ko/kotlin/components-stability">실험적(Experimental)</a>입니다. 이 기능은 언제든지 제거되거나 변경될 수 있습니다. 옵트인(opt-in)이 필요하며(자세한 내용은 아래 참조), 평가 목적으로만 사용해야 합니다. <a href="https://youtrack.jetbrains.com/issue/KT-44320" target="_blank" rel="noreferrer">YouTrack</a>을 통해 피드백을 주시면 감사하겠습니다.</p></div><p>Kotlin/JS용 <a href="/ko/kotlin/js-ir-compiler">IR 백엔드</a>는 최상위 속성의 지연 초기화 프로토타입 구현을 받고 있습니다. 이는 애플리케이션 시작 시 모든 최상위 속성을 초기화할 필요성을 줄여주고, 애플리케이션 시작 시간을 크게 개선할 것입니다.</p><p>저희는 지연 초기화 작업을 계속할 것이며, 현재 프로토타입을 사용해 보고 이 <a href="https://youtrack.jetbrains.com/issue/KT-44320" target="_blank" rel="noreferrer">YouTrack 티켓</a>이나 공식 <a href="https://kotlinlang.slack.com" target="_blank" rel="noreferrer">Kotlin Slack</a>의 <code>javascript</code> 채널(초대 받기 <a href="https://surveys.jetbrains.com/s3/kotlin-slack-sign-up" target="_blank" rel="noreferrer">여기</a>)에 의견과 결과를 공유해 주시기를 요청합니다.</p><p>지연 초기화를 사용하려면 JS IR 컴파일러로 코드를 컴파일할 때 <code>-Xir-property-lazy-initialization</code> 컴파일러 옵션을 추가하세요.</p><h2 id="gradle-프로젝트-개선-사항" tabindex="-1">Gradle 프로젝트 개선 사항 <a class="header-anchor" href="#gradle-프로젝트-개선-사항" aria-label="Permalink to &quot;Gradle 프로젝트 개선 사항&quot;">​</a></h2><h3 id="gradle-설정-캐시-지원" tabindex="-1">Gradle 설정 캐시 지원 <a class="header-anchor" href="#gradle-설정-캐시-지원" aria-label="Permalink to &quot;Gradle 설정 캐시 지원&quot;">​</a></h3><p>1.4.30부터 Kotlin Gradle 플러그인은 <a href="https://docs.gradle.org/current/userguide/configuration_cache.html" target="_blank" rel="noreferrer">설정 캐시(configuration cache)</a> 기능을 지원합니다. 이 기능은 빌드 프로세스의 속도를 높여줍니다: 명령을 실행하면 Gradle은 설정 단계를 실행하고 태스크 그래프를 계산합니다. Gradle은 결과를 캐시하고 후속 빌드에서 재사용합니다.</p><p>이 기능을 사용하려면 <a href="https://docs.gradle.org/current/userguide/configuration_cache.html#config_cache:usage" target="_blank" rel="noreferrer">Gradle 명령을 사용</a>하거나 <a href="https://docs.gradle.org/current/userguide/configuration_cache.html#config_cache:ide:intellij" target="_blank" rel="noreferrer">IntelliJ 기반 IDE를 설정</a>할 수 있습니다.</p><h2 id="표준-라이브러리" tabindex="-1">표준 라이브러리 <a class="header-anchor" href="#표준-라이브러리" aria-label="Permalink to &quot;표준 라이브러리&quot;">​</a></h2><h3 id="텍스트-대-소문자-변환을-위한-로케일-독립적-locale-agnostic-api" tabindex="-1">텍스트 대/소문자 변환을 위한 로케일 독립적(Locale-agnostic) API <a class="header-anchor" href="#텍스트-대-소문자-변환을-위한-로케일-독립적-locale-agnostic-api" aria-label="Permalink to &quot;텍스트 대/소문자 변환을 위한 로케일 독립적(Locale-agnostic) API&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>로케일 독립적(locale-agnostic) API 기능은 <a href="/ko/kotlin/components-stability">실험적(Experimental)</a>입니다. 이 기능은 언제든지 제거되거나 변경될 수 있습니다. 평가 목적으로만 사용해야 합니다. <a href="https://youtrack.jetbrains.com/issue/KT-42437" target="_blank" rel="noreferrer">YouTrack</a>을 통해 피드백을 주시면 감사하겠습니다.</p></div><p>이번 릴리스에서는 문자열 및 문자의 대소문자를 변경하기 위한 실험적인 로케일 독립적 API를 도입합니다. 현재 <code>toLowerCase()</code>, <code>toUpperCase()</code>, <code>capitalize()</code>, <code>decapitalize()</code> API 함수는 로케일 민감(locale-sensitive)입니다. 이는 다른 플랫폼 로케일 설정이 코드 동작에 영향을 미칠 수 있음을 의미합니다. 예를 들어, 터키어 로케일에서 &quot;kotlin&quot; 문자열을 <code>toUpperCase</code>를 사용하여 변환하면 결과는 &quot;KOTLİN&quot;이지 &quot;KOTLIN&quot;이 아닙니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 현재 API</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Needs to be capitalized&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toUpperCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// NEEDS TO BE CAPITALIZED</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 새로운 API</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Needs to be capitalized&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">uppercase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// NEEDS TO BE CAPITALIZED</span></span></code></pre></div><p>Kotlin 1.4.30은 다음 대안을 제공합니다:</p><ul><li><p><code>String</code> 함수:</p><table tabindex="0"><thead><tr><th><strong>이전 버전</strong></th><th><strong>1.4.30 대안</strong></th></tr></thead><tbody><tr><td><code>String.toUpperCase()</code></td><td><code>String.uppercase()</code></td></tr><tr><td><code>String.toLowerCase()</code></td><td><code>String.lowercase()</code></td></tr><tr><td><code>String.capitalize()</code></td><td><code>String.replaceFirstChar { it.uppercase() }</code></td></tr><tr><td><code>String.decapitalize()</code></td><td><code>String.replaceFirstChar { it.lowercase() }</code></td></tr></tbody></table></li><li><p><code>Char</code> 함수:</p><table tabindex="0"><thead><tr><th><strong>이전 버전</strong></th><th><strong>1.4.30 대안</strong></th></tr></thead><tbody><tr><td><code>Char.toUpperCase()</code></td><td><code>Char.uppercaseChar(): Char</code><br><code>Char.uppercase(): String</code></td></tr><tr><td><code>Char.toLowerCase()</code></td><td><code>Char.lowercaseChar(): Char</code><br><code>Char.lowercase(): String</code></td></tr><tr><td><code>Char.toTitleCase()</code></td><td><code>Char.titlecaseChar(): Char</code><br><code>Char.titlecase(): String</code></td></tr></tbody></table></li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Kotlin/JVM의 경우, 명시적인 <code>Locale</code> 매개변수가 있는 오버로드된 <code>uppercase()</code>, <code>lowercase()</code>, <code>titlecase()</code> 함수도 있습니다.</p></div><p>텍스트 처리 함수의 전체 변경 목록은 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/locale-agnostic-string-conversions.md" target="_blank" rel="noreferrer">KEEP</a>에서 확인할 수 있습니다.</p><h3 id="명확한-char-to-code-및-char-to-digit-변환" tabindex="-1">명확한 Char-to-code 및 Char-to-digit 변환 <a class="header-anchor" href="#명확한-char-to-code-및-char-to-digit-변환" aria-label="Permalink to &quot;명확한 Char-to-code 및 Char-to-digit 변환&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>Char</code> 변환 기능의 명확한 API는 <a href="/ko/kotlin/components-stability">실험적(Experimental)</a>입니다. 이 기능은 언제든지 제거되거나 변경될 수 있습니다. 평가 목적으로만 사용해야 합니다. <a href="https://youtrack.jetbrains.com/issue/KT-44333" target="_blank" rel="noreferrer">YouTrack</a>을 통해 피드백을 주시면 감사하겠습니다.</p></div><p>현재 UTF-16 코드를 다양한 숫자 유형으로 표현하여 반환하는 <code>Char</code>에서 숫자로의 변환 함수는 문자열의 숫자 값을 반환하는 유사한 String-to-Int 변환과 혼동되는 경우가 많습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;4&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4 반환</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;4&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 52 반환</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 그리고 Char &#39;4&#39;에 대해 숫자 값 4를 반환하는 공통 함수는 없었습니다.</span></span></code></pre></div><p>이러한 혼동을 피하기 위해 <code>Char</code> 변환을 명확하게 명명된 다음 두 가지 함수 세트로 분리하기로 결정했습니다:</p><ul><li><p><code>Char</code>의 정수 코드(integer code)를 가져오고 주어진 코드로부터 <code>Char</code>를 구성하는 함수:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(code: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Char</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(code: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UShort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Char</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Char.code: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span></span></code></pre></div></li><li><p><code>Char</code>를 나타내는 숫자의 값으로 변환하는 함수:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">digitToInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radix: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">digitToIntOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radix: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?</span></span></code></pre></div></li><li><p><code>Int</code>에 대한 확장 함수로, 해당 <code>Int</code>가 나타내는 음수가 아닌 단일 숫자를 해당 <code>Char</code> 표현으로 변환합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">digitToChar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radix: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Char</span></span></code></pre></div></li></ul><p>자세한 내용은 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/char-int-conversions.md" target="_blank" rel="noreferrer">KEEP</a>에서 확인할 수 있습니다.</p><h2 id="직렬화-serialization-업데이트" tabindex="-1">직렬화(Serialization) 업데이트 <a class="header-anchor" href="#직렬화-serialization-업데이트" aria-label="Permalink to &quot;직렬화(Serialization) 업데이트&quot;">​</a></h2><p>Kotlin 1.4.30과 함께 <code>kotlinx.serialization</code> <a href="https://github.com/Kotlin/kotlinx.serialization/releases/tag/v1.1.0-RC" target="_blank" rel="noreferrer">1.1.0-RC</a>를 출시하며, 여기에는 몇 가지 새로운 기능이 포함되어 있습니다:</p><ul><li>인라인 클래스 직렬화 지원</li><li>부호 없는 프리미티브 타입 직렬화 지원</li></ul><h3 id="인라인-클래스-직렬화-지원" tabindex="-1">인라인 클래스 직렬화 지원 <a class="header-anchor" href="#인라인-클래스-직렬화-지원" aria-label="Permalink to &quot;인라인 클래스 직렬화 지원&quot;">​</a></h3><p>Kotlin 1.4.30부터 인라인 클래스를 <a href="/ko/kotlin/serialization">직렬화 가능</a>하게 만들 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Serializable</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rgb: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>이 기능은 새로운 1.4.30 IR 컴파일러를 필요로 합니다.</p></div><p>직렬화 프레임워크는 다른 직렬화 가능 클래스에서 사용될 때 직렬화 가능한 인라인 클래스를 박싱(boxing)하지 않습니다.</p><p>자세한 내용은 <code>kotlinx.serialization</code> <a href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/inline-classes.md#serializable-inline-classes" target="_blank" rel="noreferrer">문서</a>에서 알아보세요.</p><h3 id="부호-없는-프리미티브-타입-직렬화-지원" tabindex="-1">부호 없는 프리미티브 타입 직렬화 지원 <a class="header-anchor" href="#부호-없는-프리미티브-타입-직렬화-지원" aria-label="Permalink to &quot;부호 없는 프리미티브 타입 직렬화 지원&quot;">​</a></h3><p>1.4.30부터 <a href="https://github.com/Kotlin/kotlinx.serialization" target="_blank" rel="noreferrer">kotlinx.serialization</a>의 표준 JSON 직렬화기를 부호 없는 프리미티브 타입(<code>UInt</code>, <code>ULong</code>, <code>UByte</code>, <code>UShort</code>)에 사용할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Serializable</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> counted: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UByte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> description: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> counted </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 239</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toUByte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Json.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">encodeToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(counted, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;tries&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>자세한 내용은 <code>kotlinx.serialization</code> <a href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/inline-classes.md#unsigned-types-support-json-only" target="_blank" rel="noreferrer">문서</a>에서 알아보세요.</p>`,47))])}const m=k(d,[["render",c]]);export{C as __pageData,m as default};
