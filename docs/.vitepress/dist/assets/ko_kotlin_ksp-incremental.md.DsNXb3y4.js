import{_ as i,c as a,o as e,ag as l}from"./chunks/framework.Bksy39di.js";const c=JSON.parse('{"title":"증분 처리","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/ksp-incremental.md","filePath":"ko/kotlin/ksp-incremental.md","lastUpdated":1754307826000}'),t={name:"ko/kotlin/ksp-incremental.md"};function n(p,s,h,k,o,d){return e(),a("div",null,s[0]||(s[0]=[l(`<h1 id="증분-처리" tabindex="-1">증분 처리 <a class="header-anchor" href="#증분-처리" aria-label="Permalink to &quot;증분 처리&quot;">​</a></h1><p>증분 처리는 소스 재처리를 가능한 한 피하는 처리 기법입니다. 증분 처리의 주요 목표는 일반적인 변경-컴파일-테스트 주기의 소요 시간을 줄이는 것입니다. 자세한 내용은 위키백과의 <a href="https://en.wikipedia.org/wiki/Incremental_computing" target="_blank" rel="noreferrer">증분 컴퓨팅</a> 문서를 참조하십시오.</p><p>어떤 소스가 변경되었는지 (재처리되어야 하는 소스)를 결정하기 위해 KSP는 프로세서의 도움을 받아 어떤 입력 소스가 어떤 생성된 출력에 해당하는지 식별해야 합니다. 이 번거롭고 오류가 발생하기 쉬운 과정을 돕기 위해 KSP는 프로세서가 코드 구조를 탐색하는 시작점으로 사용하는 최소한의 <em>루트 소스</em> 집합만 요구하도록 설계되었습니다. 다시 말해, <code>KSNode</code>가 다음 중 하나에서 얻어진 경우 프로세서는 해당 <code>KSNode</code>의 소스와 출력을 연결해야 합니다:</p><ul><li><code>Resolver.getAllFiles</code></li><li><code>Resolver.getSymbolsWithAnnotation</code></li><li><code>Resolver.getClassDeclarationByName</code></li><li><code>Resolver.getDeclarationsFromPackage</code></li></ul><p>증분 처리는 현재 기본적으로 활성화되어 있습니다. 비활성화하려면 Gradle 속성 <code>ksp.incremental=false</code>를 설정하십시오. 의존성 및 출력에 따라 변경된 집합을 덤프하는 로그를 활성화하려면 <code>ksp.incremental.log=true</code>를 사용하십시오. 이러한 로그 파일은 <code>build</code> 출력 디렉터리에서 <code>.log</code> 파일 확장자로 찾을 수 있습니다.</p><p>JVM에서는 클래스패스 변경뿐만 아니라 코틀린 및 자바 소스 변경도 기본적으로 추적됩니다. 코틀린 및 자바 소스 변경만 추적하려면 <code>ksp.incremental.intermodule=false</code> Gradle 속성을 설정하여 클래스패스 추적을 비활성화하십시오.</p><h2 id="집계-aggregating-vs-격리-isolating" tabindex="-1">집계 (Aggregating) vs 격리 (Isolating) <a class="header-anchor" href="#집계-aggregating-vs-격리-isolating" aria-label="Permalink to &quot;집계 (Aggregating) vs 격리 (Isolating)&quot;">​</a></h2><p><a href="https://docs.gradle.org/current/userguide/java_plugin.html#sec:incremental_annotation_processing" target="_blank" rel="noreferrer">Gradle 어노테이션 처리</a>의 개념과 유사하게, KSP는 <em>집계 (aggregating)</em> 및 <em>격리 (isolating)</em> 모드를 모두 지원합니다. Gradle 어노테이션 처리와 달리 KSP는 전체 프로세서가 아닌 각 출력을 집계 또는 격리로 분류한다는 점에 유의하십시오.</p><p>집계 출력은 다른 파일에 영향을 주지 않는 파일 제거를 제외하고 잠재적으로 모든 입력 변경에 영향을 받을 수 있습니다. 이는 모든 입력 변경이 모든 집계 출력의 재빌드를 초래하며, 이는 결국 모든 해당 등록된, 새롭고 수정된 소스 파일의 재처리를 의미합니다.</p><p>예를 들어, 특정 어노테이션을 가진 모든 심볼을 수집하는 출력은 집계 출력으로 간주됩니다.</p><p>격리 출력은 지정된 소스에만 의존합니다. 다른 소스에 대한 변경 사항은 격리 출력에 영향을 주지 않습니다. Gradle 어노테이션 처리와 달리 단일 출력에 대해 여러 소스 파일을 정의할 수 있습니다.</p><p>예를 들어, 구현하는 인터페이스에 전용으로 생성된 클래스는 격리로 간주됩니다.</p><p>요약하자면, 출력이 새로운 소스 또는 변경된 소스에 의존할 수 있다면 집계로 간주됩니다. 그렇지 않으면 출력은 격리입니다.</p><p>자바 어노테이션 처리(Java annotation processing)에 익숙한 독자를 위한 요약입니다:</p><ul><li>격리 자바 어노테이션 프로세서에서 모든 출력은 KSP에서 격리입니다.</li><li>집계 자바 어노테이션 프로세서에서 일부 출력은 KSP에서 격리일 수 있고 일부는 집계일 수 있습니다.</li></ul><h3 id="구현-방식" tabindex="-1">구현 방식 <a class="header-anchor" href="#구현-방식" aria-label="Permalink to &quot;구현 방식&quot;">​</a></h3><p>의존성은 어노테이션 대신 입력 및 출력 파일의 연결로 계산됩니다. 이는 다대다 관계입니다.</p><p>입력-출력 연결로 인한 변경 상태 전파 규칙은 다음과 같습니다:</p><ol><li>입력 파일이 변경되면 항상 재처리됩니다.</li><li>입력 파일이 변경되고, 특정 출력과 연결되어 있는 경우, 해당 출력과 연결된 다른 모든 입력 파일도 재처리됩니다. 이는 전이적이며, 즉 새로운 변경된 파일이 없을 때까지 무효화가 반복적으로 발생합니다.</li><li>하나 이상의 집계 출력과 연결된 모든 입력 파일은 재처리됩니다. 다시 말해, 입력 파일이 어떤 집계 출력과도 연결되어 있지 않으면 재처리되지 않습니다 (위 1. 또는 2.에 해당하는 경우는 제외).</li></ol><p>이유는 다음과 같습니다:</p><ol><li>입력이 변경되면 새로운 정보가 도입될 수 있으므로 프로세서는 해당 입력으로 다시 실행되어야 합니다.</li><li>출력은 입력 집합으로 구성됩니다. 프로세서는 출력을 재생성하기 위해 모든 입력이 필요할 수 있습니다.</li><li><code>aggregating=true</code>는 출력이 새로운 정보에 잠재적으로 의존할 수 있음을 의미하며, 이 정보는 새 파일이나 변경된 기존 파일에서 올 수 있습니다.</li><li><code>aggregating=false</code>는 프로세서가 정보가 특정 입력 파일에서만 오고 다른 파일이나 새 파일에서는 절대 오지 않는다고 확신함을 의미합니다.</li></ol><h2 id="예시-1" tabindex="-1">예시 1 <a class="header-anchor" href="#예시-1" aria-label="Permalink to &quot;예시 1&quot;">​</a></h2><p>프로세서가 <code>A.kt</code>의 클래스 <code>A</code>와 <code>B.kt</code>의 클래스 <code>B</code>를 읽은 후 <code>outputForA</code>를 생성합니다. 여기서 <code>A</code>는 <code>B</code>를 확장합니다. 프로세서는 <code>Resolver.getSymbolsWithAnnotation</code>을 통해 <code>A</code>를 얻었고, 그 다음 <code>A</code>로부터 <code>KSClassDeclaration.superTypes</code>를 통해 <code>B</code>를 얻었습니다. <code>B</code>의 포함이 <code>A</code> 때문이므로, <code>outputForA</code>의 <code>dependencies</code>에 <code>B.kt</code>를 지정할 필요가 없습니다. 이 경우에도 <code>B.kt</code>를 지정할 수 있지만, 필수는 아닙니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// A.kt</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Interesting</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// B.kt</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">open</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Example1Processor.kt</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Example1Processor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SymbolProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(resolver: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Resolver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> declA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> resolver.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getSymbolsWithAnnotation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Interesting&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">first</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KSClassDeclaration</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> declB </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> declA.superTypes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">first</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().declaration</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // B.kt는 KSP에 의해 의존성으로 추론될 수 있으므로 필요하지 않습니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dependencies </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(aggregating </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, declA.containingFile</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // outputForA.kt</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> outputName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;outputFor\${declA.simpleName.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asString</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()}&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // outputForA는 A.kt와 B.kt에 의존합니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> output </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> codeGenerator.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createNewFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dependencies, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;com.example&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, outputName, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;kt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        output.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;// </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$declA</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$declB</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toByteArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        output.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="예시-2" tabindex="-1">예시 2 <a class="header-anchor" href="#예시-2" aria-label="Permalink to &quot;예시 2&quot;">​</a></h2><p>프로세서가 <code>sourceA</code>를 읽은 후 <code>outputA</code>를, <code>sourceB</code>를 읽은 후 <code>outputB</code>를 생성한다고 가정해 봅시다.</p><p><code>sourceA</code>가 변경될 때:</p><ul><li><code>outputB</code>가 집계(aggregating)인 경우, <code>sourceA</code>와 <code>sourceB</code> 둘 다 재처리됩니다.</li><li><code>outputB</code>가 격리(isolating)인 경우, <code>sourceA</code>만 재처리됩니다.</li></ul><p><code>sourceC</code>가 추가될 때:</p><ul><li><code>outputB</code>가 집계(aggregating)인 경우, <code>sourceC</code>와 <code>sourceB</code> 둘 다 재처리됩니다.</li><li><code>outputB</code>가 격리(isolating)인 경우, <code>sourceC</code>만 재처리됩니다.</li></ul><p><code>sourceA</code>가 제거되면 아무것도 재처리할 필요가 없습니다.</p><p><code>sourceB</code>가 제거되면 아무것도 재처리할 필요가 없습니다.</p><h2 id="파일의-변경-상태-결정-방식" tabindex="-1">파일의 변경 상태 결정 방식 <a class="header-anchor" href="#파일의-변경-상태-결정-방식" aria-label="Permalink to &quot;파일의 변경 상태 결정 방식&quot;">​</a></h2><p>변경된 (dirty) 파일은 사용자에 의해 직접 _변경_되거나 다른 변경된 파일에 의해 간접적으로 <em>영향을 받은</em> 파일입니다. KSP는 두 단계로 변경 상태를 전파합니다:</p><ul><li>_해결 추적(resolution tracing)_에 의한 전파: 타입 참조를 (암시적으로든 명시적으로든) 해결하는 것이 한 파일에서 다른 파일로 이동하는 유일한 방법입니다. 프로세서에 의해 타입 참조가 해결될 때, 해결 결과에 잠재적으로 영향을 미칠 수 있는 변경 사항을 포함하는 변경되거나 영향을 받은 파일은 해당 참조를 포함하는 파일에 영향을 미칩니다.</li><li>_입력-출력 대응(input-output correspondence)_에 의한 전파: 소스 파일이 변경되거나 영향을 받으면, 해당 파일과 공통된 출력을 가진 다른 모든 소스 파일도 영향을 받습니다.</li></ul><p>둘 다 전이적이며, 두 번째는 동등성 클래스를 형성한다는 점에 유의하십시오.</p><h2 id="버그-보고" tabindex="-1">버그 보고 <a class="header-anchor" href="#버그-보고" aria-label="Permalink to &quot;버그 보고&quot;">​</a></h2><p>버그를 보고하려면, Gradle 속성 <code>ksp.incremental=true</code>와 <code>ksp.incremental.log=true</code>를 설정하고 클린 빌드를 수행하십시오. 이 빌드는 두 개의 로그 파일을 생성합니다:</p><ul><li><code>build/kspCaches/&lt;source set&gt;/logs/kspDirtySet.log</code></li><li><code>build/kspCaches/&lt;source set&gt;/logs/kspSourceToOutputs.log</code></li></ul><p>그런 다음 연속적인 증분 빌드를 실행할 수 있으며, 이는 두 개의 추가 로그 파일을 생성할 것입니다:</p><ul><li><code>build/kspCaches/&lt;source set&gt;/logs/kspDirtySetByDeps.log</code></li><li><code>build/kspCaches/&lt;source set&gt;/logs/kspDirtySetByOutputs.log</code></li></ul><p>이 로그에는 소스 및 출력 파일 이름과 빌드의 타임스탬프가 포함되어 있습니다.</p>`,42)]))}const g=i(t,[["render",n]]);export{c as __pageData,g as default};
