import{_ as t}from"./chunks/get-started-coroutines.DKuC7weC.js";import{_ as r,c as n,o as s,ag as e}from"./chunks/framework.Bksy39di.js";const p=JSON.parse('{"title":"协程","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/coroutines-overview.md","filePath":"kotlin/coroutines-overview.md","lastUpdated":1754307826000}'),g={name:"kotlin/coroutines-overview.md"};function i(a,o,l,c,h,u){return s(),n("div",null,o[0]||(o[0]=[e('<h1 id="协程" tabindex="-1">协程 <a class="header-anchor" href="#协程" aria-label="Permalink to &quot;协程&quot;">​</a></h1><p>应用程序通常需要同时执行多个<strong>任务</strong>，例如响应用户输入、加载数据或更新屏幕。为支持此<strong>功能</strong>，它们依赖于<strong>并发</strong>，这允许操作独立运行而互不阻塞。</p><p>最常见的<strong>并发</strong>运行<strong>任务</strong>的方式是使用<strong>线程</strong>，<strong>线程</strong>是由操作系统管理的独立执行路径。然而，<strong>线程</strong>相对“重”（heavy），创建过多可能导致性能问题。</p><p>为支持高效<strong>并发</strong>，Kotlin 使用基于<strong>协程</strong>的异步编程，它允许你使用<strong>挂起函数</strong>以自然、顺序的风格编写异步代码。<strong>协程</strong>是<strong>线程</strong>的轻量级替代品。它们可以在不阻塞系统资源的情况下<strong>挂起</strong>，并且资源友好，因此更适合细粒度的<strong>并发</strong>。</p><p>大多数<strong>协程****特性</strong>由 <a href="https://github.com/Kotlin/kotlinx.coroutines" target="_blank" rel="noreferrer"><code>kotlinx.coroutines</code></a> 库提供，该库包含用于启动<strong>协程</strong>、处理<strong>并发</strong>、使用异步流等的工具。</p><p>如果你是 Kotlin <strong>协程</strong>的新手，请在深入学习更复杂的<strong>主题</strong>之前，从 <a href="/kotlin/coroutines-basics"><strong>协程</strong>基础知识</a><strong>指南</strong>开始。本<strong>指南</strong>通过简单的示例介绍了<strong>挂起函数</strong>、<strong>协程构建器</strong>和<strong>结构化并发</strong>的关键<strong>概念</strong>：</p><p><a href="/kotlin/coroutines-basics"><img src="'+t+'" width="700" alt="Get started with coroutines" style=""></a></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>关于****协程</strong>在实践中的用法，<strong>请检测</strong> <a href="https://github.com/JetBrains/kotlinconf-app" target="_blank" rel="noreferrer">KotlinConf <strong>应用</strong></a> 的示例<strong>项目</strong>。</p></div><h2 id="协程-概念" tabindex="-1"><strong>协程****概念</strong> <a class="header-anchor" href="#协程-概念" aria-label="Permalink to &quot;**协程****概念**&quot;">​</a></h2><p><code>kotlinx.coroutines</code> 库提供了用于<strong>并发</strong>运行<strong>任务</strong>、<strong>构建****协程</strong>执行以及管理共享状态的核心<strong>构建块</strong>。</p><h3 id="挂起函数与协程构建器" tabindex="-1"><strong>挂起函数</strong>与<strong>协程构建器</strong> <a class="header-anchor" href="#挂起函数与协程构建器" aria-label="Permalink to &quot;**挂起函数**与**协程构建器**&quot;">​</a></h3><p>Kotlin 中的<strong>协程</strong>基于<strong>挂起函数****构建</strong>，它允许代码暂停和恢复而不阻塞<strong>线程</strong>。<code>suspend</code> 关键字标记可以异步执行长时间运行操作的<strong>函数</strong>。</p><p>要启动新的<strong>协程</strong>，请使用<strong>协程构建器</strong>，例如 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html" target="_blank" rel="noreferrer"><code>.launch()</code></a> 和 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html" target="_blank" rel="noreferrer"><code>.async()</code></a>。这些<strong>构建器</strong>是 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/" target="_blank" rel="noreferrer"><code>CoroutineScope</code></a> 上的<strong>扩展函数</strong>，它<strong>定义</strong>了<strong>协程</strong>的生命周期并提供了<strong>协程上下文</strong>。</p><p><strong>关于</strong>这些<strong>构建器</strong>的更多信息，<strong>请参见</strong> <a href="/kotlin/coroutines-basics"><strong>协程</strong>基础知识</a> 和 <a href="/kotlin/coroutines-and-channels">组合<strong>挂起函数</strong></a>。</p><h3 id="协程上下文与行为" tabindex="-1"><strong>协程上下文</strong>与行为 <a class="header-anchor" href="#协程上下文与行为" aria-label="Permalink to &quot;**协程上下文**与行为&quot;">​</a></h3><p>从 <code>CoroutineScope</code> 启动<strong>协程</strong>会创建一个<strong>上下文</strong>，它管理<strong>协程</strong>的执行。<code>.launch()</code> 和 <code>.async()</code> 等<strong>构建器函数</strong>会自动创建一组<strong>元素</strong>，用于<strong>定义****协程</strong>的行为：</p><ul><li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/" target="_blank" rel="noreferrer"><code>Job</code></a> 接口跟踪<strong>协程</strong>的生命周期并启用<strong>结构化并发</strong>。</li><li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/" target="_blank" rel="noreferrer"><code>CoroutineDispatcher</code></a> 控制<strong>协程</strong>的运行位置，例如在后台<strong>线程</strong>或 UI <strong>应用程序</strong>的主<strong>线程</strong>上。</li><li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/" target="_blank" rel="noreferrer"><code>CoroutineExceptionHandler</code></a> 处理未捕获的异常。</li></ul><p>这些<strong>元素</strong>，以及其他可能的<strong>元素</strong>，构成了 <a href="/kotlin/coroutine-context-and-dispatchers"><em><strong>协程上下文</strong></em></a>，该<strong>上下文</strong>默认<strong>继承</strong>自<strong>协程</strong>的父级。此<strong>上下文</strong>形成一个<strong>层次结构</strong>，它实现了<strong>结构化并发</strong>，其中相关的<strong>协程</strong>可以一起 <a href="/kotlin/cancellation-and-timeouts"><strong>取消</strong></a> 或作为一个组 <a href="/kotlin/exception-handling">处理异常</a>。</p><h3 id="异步流与共享可变状态" tabindex="-1">异步流与共享可变状态 <a class="header-anchor" href="#异步流与共享可变状态" aria-label="Permalink to &quot;异步流与共享可变状态&quot;">​</a></h3><p>Kotlin 提供了多种<strong>协程</strong>通信的方式。<strong>关于</strong>如何在<strong>协程</strong>之间共享值，请根据你的需求选择以下选项之一：</p><ul><li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/" target="_blank" rel="noreferrer"><code>Flow</code></a> 仅在<strong>协程</strong>主动收集时才<strong>生产</strong>值。</li><li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/" target="_blank" rel="noreferrer"><code>Channel</code></a> 允许多个<strong>协程</strong>发送和接收值，每个值都只传递给一个<strong>协程</strong>。</li><li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/" target="_blank" rel="noreferrer"><code>SharedFlow</code></a> 持续与所有活动的收集<strong>协程</strong>共享每个值。</li></ul><p>当多个<strong>协程</strong>需要访问或更新相同数据时，它们会 <em>共享可变状态</em>。如果缺乏协调，这可能导致<strong>竞态条件</strong>，其中操作会以不可预测的方式相互干扰。为了安全地管理共享可变状态，请使用 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/#" target="_blank" rel="noreferrer"><code>StateFlow</code></a> 包装共享数据。然后，你可以从一个<strong>协程</strong>更新它，并从其他<strong>协程</strong>收集其最新值。</p><p><strong>关于</strong>更多信息，<strong>请参见</strong> <a href="/kotlin/flow">异步流</a>、<a href="/kotlin/channels"><strong>通道</strong></a> 和 <a href="/kotlin/coroutines-and-channels"><strong>协程</strong>与<strong>通道****教程</strong></a>。</p><h2 id="后续步骤" tabindex="-1">后续步骤 <a class="header-anchor" href="#后续步骤" aria-label="Permalink to &quot;后续步骤&quot;">​</a></h2><ul><li><strong>关于</strong> <strong>协程</strong>、<strong>挂起函数</strong>和<strong>构建器</strong>的基本<strong>原理</strong>，<strong>请参见</strong> <a href="/kotlin/coroutines-basics"><strong>协程</strong>基础知识<strong>指南</strong></a>。</li><li><strong>关于</strong>如何组合<strong>挂起函数</strong>并<strong>构建<strong><strong>协程</strong></strong>流水线</strong>，<strong>请探查</strong> <a href="/kotlin/coroutine-context-and-dispatchers">组合<strong>挂起函数</strong></a>。</li><li><strong>关于</strong>如何使用 IntelliJ IDEA 中的内置工具 <a href="/kotlin/debug-coroutines-with-idea"><strong>调试****协程</strong></a>，<strong>请参见</strong>该<strong>指南</strong>。</li><li><strong>关于</strong>特定于 Flow 的<strong>调试</strong>，<strong>请参见</strong> <a href="/kotlin/debug-flow-with-idea">使用 IntelliJ IDEA <strong>调试</strong> Kotlin Flow</a><strong>教程</strong>。</li><li><strong>关于</strong>基于<strong>协程</strong>的 UI <strong>开发</strong>，<strong>请参阅</strong> <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md" target="_blank" rel="noreferrer"><strong>协程</strong> UI 编程<strong>指南</strong></a>。</li><li><strong>关于</strong>在 Android 中使用<strong>协程</strong>的 <a href="https://developer.android.com/kotlin/coroutines/coroutines-best-practices" target="_blank" rel="noreferrer"><strong>最佳实践</strong></a>，<strong>请审阅</strong>。</li><li><strong>请检测</strong> <a href="https://kotlinlang.org/api/kotlinx.coroutines/" target="_blank" rel="noreferrer"><code>kotlinx.coroutines</code> <strong>API 参考</strong></a>。</li></ul>',25)]))}const f=r(g,[["render",i]]);export{p as __pageData,f as default};
