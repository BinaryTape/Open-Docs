import{_ as s,c as i,o as e,ag as t}from"./chunks/framework.Bksy39di.js";const c=JSON.parse('{"title":"多輪處理","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/ksp-multi-round.md","filePath":"zh-Hant/kotlin/ksp-multi-round.md","lastUpdated":1754307826000}'),l={name:"zh-Hant/kotlin/ksp-multi-round.md"};function n(h,a,r,o,p,d){return e(),i("div",null,a[0]||(a[0]=[t(`<h1 id="多輪處理" tabindex="-1">多輪處理 <a class="header-anchor" href="#多輪處理" aria-label="Permalink to &quot;多輪處理&quot;">​</a></h1><p>KSP 支援 <em>多輪處理</em>，或透過多個回合處理檔案。這表示後續的回合會使用先前回合的輸出作為額外的輸入。</p><h2 id="對處理器的變更" tabindex="-1">對處理器的變更 <a class="header-anchor" href="#對處理器的變更" aria-label="Permalink to &quot;對處理器的變更&quot;">​</a></h2><p>若要使用多輪處理，<code>SymbolProcessor.process()</code> 函式需要傳回一個延遲符號清單 (<code>List&lt;KSAnnotated&gt;</code>) 針對無效符號。使用 <code>KSAnnotated.validate()</code> 來篩選要延遲到下一個回合的無效符號。</p><p>以下範例程式碼展示了如何透過驗證檢查來延遲無效符號：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(resolver: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Resolver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSAnnotated</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> symbols </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> resolver.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getSymbolsWithAnnotation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;com.example.annotation.Builder&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> symbols.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">validate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    symbols</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KSClassDeclaration </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">validate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BuilderVisitor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), Unit) }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="多輪行為" tabindex="-1">多輪行為 <a class="header-anchor" href="#多輪行為" aria-label="Permalink to &quot;多輪行為&quot;">​</a></h2><h3 id="將符號延遲到下一個回合" tabindex="-1">將符號延遲到下一個回合 <a class="header-anchor" href="#將符號延遲到下一個回合" aria-label="Permalink to &quot;將符號延遲到下一個回合&quot;">​</a></h3><p>處理器可以將特定符號的處理延遲到下一個回合。當符號被延遲時，處理器會等待其他處理器提供額外資訊。它可以根據需要繼續延遲符號任意多個回合。一旦其他處理器提供了所需資訊，處理器就可以處理該延遲符號。處理器應僅延遲缺少必要資訊的無效符號。因此，處理器<strong>不應</strong>延遲來自 Classpath 的符號，KSP 也會篩選掉任何非來自原始碼的延遲符號。</p><p>例如，一個為帶註解類別建立 Builder 的處理器，可能會要求其建構函式的所有參數型別都是有效的（已解析為具體型別）。在第一個回合中，其中一個參數型別無法解析。然後在第二個回合中，由於第一個回合中產生的檔案，它變得可解析。</p><h3 id="驗證符號" tabindex="-1">驗證符號 <a class="header-anchor" href="#驗證符號" aria-label="Permalink to &quot;驗證符號&quot;">​</a></h3><p>判斷符號是否應延遲的一個便捷方法是透過驗證。處理器應知道哪些資訊對於正確處理符號是必要的。請注意，驗證通常需要解析，這可能很耗費資源，因此我們建議僅檢查所需內容。延續之前的範例，對於 Builder 處理器來說，理想的驗證只會檢查帶註解符號的建構函式的所有已解析參數型別是否包含 <code>isError == false</code>。</p><p>KSP 提供了一個預設的驗證工具。更多資訊請參閱 <a href="#advanced">進階</a> 部分。</p><h3 id="終止條件" tabindex="-1">終止條件 <a class="header-anchor" href="#終止條件" aria-label="Permalink to &quot;終止條件&quot;">​</a></h3><p>當一個完整回合的處理沒有產生任何新檔案時，多輪處理就會終止。如果在滿足終止條件時仍存在未處理的延遲符號，KSP 會為每個包含未處理延遲符號的處理器記錄一個錯誤訊息。</p><h3 id="每個回合中可存取的檔案" tabindex="-1">每個回合中可存取的檔案 <a class="header-anchor" href="#每個回合中可存取的檔案" aria-label="Permalink to &quot;每個回合中可存取的檔案&quot;">​</a></h3><p>新產生的檔案和現有檔案都可以透過 <code>Resolver</code> 存取。KSP 提供了兩個用於存取檔案的 API：<code>Resolver.getAllFiles()</code> 和 <code>Resolver.getNewFiles()</code>。<code>getAllFiles()</code> 傳回現有檔案和新產生檔案的組合清單，而 <code>getNewFiles()</code> 僅傳回新產生的檔案。</p><h3 id="對-getsymbolsannotatedwith-的變更" tabindex="-1">對 getSymbolsAnnotatedWith() 的變更 <a class="header-anchor" href="#對-getsymbolsannotatedwith-的變更" aria-label="Permalink to &quot;對 getSymbolsAnnotatedWith() 的變更&quot;">​</a></h3><p>為了避免不必要的符號重複處理，<code>getSymbolsAnnotatedWith()</code> 僅傳回在新產生檔案中找到的符號，以及來自上一回合延遲符號的符號。</p><h3 id="處理器實例化" tabindex="-1">處理器實例化 <a class="header-anchor" href="#處理器實例化" aria-label="Permalink to &quot;處理器實例化&quot;">​</a></h3><p>處理器實例只建立一次，這表示您可以將資訊儲存在處理器物件中，供後續回合使用。</p><h3 id="跨回合資訊一致性" tabindex="-1">跨回合資訊一致性 <a class="header-anchor" href="#跨回合資訊一致性" aria-label="Permalink to &quot;跨回合資訊一致性&quot;">​</a></h3><p>所有 KSP 符號都不能在多個回合中重複使用，因為解析結果可能會根據先前回合中產生的內容而改變。然而，由於 KSP 不允許修改現有程式碼，某些資訊，例如符號名稱的字串值，仍然應該是可重複使用的。總之，處理器可以儲存來自先前回合的資訊，但需要記住這些資訊在未來回合中可能無效。</p><h3 id="錯誤與例外處理" tabindex="-1">錯誤與例外處理 <a class="header-anchor" href="#錯誤與例外處理" aria-label="Permalink to &quot;錯誤與例外處理&quot;">​</a></h3><p>當發生錯誤（由處理器呼叫 <code>KSPLogger.error()</code> 定義）或例外時，處理會在目前回合完成後停止。所有處理器都將呼叫 <code>onError()</code> 方法，且<strong>不會</strong>呼叫 <code>finish()</code> 方法。</p><p>請注意，即使發生錯誤，其他處理器也會在該回合中正常繼續處理。這表示錯誤處理發生在該回合處理完成之後。</p><p>發生例外時，KSP 將嘗試區分來自 KSP 的例外和來自處理器的例外。例外將導致處理立即終止，並在 <code>KSPLogger</code> 中記錄為錯誤。來自 KSP 的例外應報告給 KSP 開發人員以供進一步調查。在發生例外或錯誤的回合結束時，所有處理器都將調用 <code>onError()</code> 函式來執行自己的錯誤處理。</p><p>KSP 提供了 <code>onError()</code> 的預設無操作實作，作為 <code>SymbolProcessor</code> 介面的一部分。您可以覆寫此方法來提供自己的錯誤處理邏輯。</p><h2 id="進階" tabindex="-1">進階 <a class="header-anchor" href="#進階" aria-label="Permalink to &quot;進階&quot;">​</a></h2><h3 id="驗證的預設行為" tabindex="-1">驗證的預設行為 <a class="header-anchor" href="#驗證的預設行為" aria-label="Permalink to &quot;驗證的預設行為&quot;">​</a></h3><p>KSP 提供的預設驗證邏輯會驗證正在驗證的符號之封閉範圍內所有直接可達的符號。預設驗證會檢查封閉範圍內的參考是否可解析為具體型別，但不會遞迴深入參考型別來執行驗證。</p><h3 id="撰寫您自己的驗證邏輯" tabindex="-1">撰寫您自己的驗證邏輯 <a class="header-anchor" href="#撰寫您自己的驗證邏輯" aria-label="Permalink to &quot;撰寫您自己的驗證邏輯&quot;">​</a></h3><p>預設的驗證行為可能不適用於所有情況。您可以參考 <code>KSValidateVisitor</code> 並撰寫您自己的驗證邏輯，透過提供自訂的 <code>predicate</code> Lambda，<code>KSValidateVisitor</code> 會使用它來篩選出需要檢查的符號。</p>`,33)]))}const E=s(l,[["render",n]]);export{c as __pageData,E as default};
