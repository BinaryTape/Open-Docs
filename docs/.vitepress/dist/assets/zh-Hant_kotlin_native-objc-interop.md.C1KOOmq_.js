import{_ as o,C as h,c as d,o as k,ag as t,G as e,j as i,w as n,a}from"./chunks/framework.Bksy39di.js";const F=JSON.parse('{"title":"與 Swift/Objective-C 的互通性","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/native-objc-interop.md","filePath":"zh-Hant/kotlin/native-objc-interop.md","lastUpdated":1754307826000}'),r={name:"zh-Hant/kotlin/native-objc-interop.md"};function c(E,s,g,y,b,u){const l=h("tab"),p=h("tabs");return k(),d("div",null,[s[2]||(s[2]=t(`<h1 id="與-swift-objective-c-的互通性" tabindex="-1">與 Swift/Objective-C 的互通性 <a class="header-anchor" href="#與-swift-objective-c-的互通性" aria-label="Permalink to &quot;與 Swift/Objective-C 的互通性&quot;">​</a></h1><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Objective-C 函式庫的匯入功能處於 <a href="/zh-Hant/kotlin/native-c-interop-stability">Beta</a> 階段。 所有由 <code>cinterop</code> 工具從 Objective-C 函式庫產生的 Kotlin 宣告 都應該具有 <code>@ExperimentalForeignApi</code> 註解。 隨 Kotlin/Native 提供的原生平台函式庫（如 Foundation、UIKit 和 POSIX） 僅針對部分 API 需要選擇啟用。</p></div><p>Kotlin/Native 透過 Objective-C 提供與 Swift 的間接互通性。本文檔涵蓋了如何在 Swift/Objective-C 程式碼中使用 Kotlin 宣告，以及如何在 Kotlin 程式碼中使用 Objective-C 宣告。</p><p>您可能會發現有用的其他資源：</p><ul><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia" target="_blank" rel="noreferrer">Kotlin-Swift 互通百科</a>，一個關於如何在 Swift 程式碼中使用 Kotlin 宣告的範例集合。</li><li><a href="/zh-Hant/kotlin/native-arc-integration">與 Swift/Objective-C ARC 整合</a> 章節，涵蓋 Kotlin 追蹤式 GC 與 Objective-C ARC 之間整合的細節。</li></ul><h2 id="將-swift-objective-c-函式庫匯入-kotlin" tabindex="-1">將 Swift/Objective-C 函式庫匯入 Kotlin <a class="header-anchor" href="#將-swift-objective-c-函式庫匯入-kotlin" aria-label="Permalink to &quot;將 Swift/Objective-C 函式庫匯入 Kotlin&quot;">​</a></h2><p>Objective-C 框架和函式庫可在 Kotlin 程式碼中使用，前提是它們已正確匯入建置（系統框架預設會匯入）。 更多細節請參閱：</p><ul><li><a href="/zh-Hant/kotlin/native-definition-file">建立並配置函式庫定義檔</a></li><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-configure-compilations.html#configure-interop-with-native-languages" target="_blank" rel="noreferrer">配置原生函式庫的編譯</a></li></ul><p>如果 Swift 函式庫的 API 使用 <code>@objc</code> 匯出到 Objective-C，則可以在 Kotlin 程式碼中使用。 純粹的 Swift 模組尚不支援。</p><h2 id="在-swift-objective-c-中使用-kotlin" tabindex="-1">在 Swift/Objective-C 中使用 Kotlin <a class="header-anchor" href="#在-swift-objective-c-中使用-kotlin" aria-label="Permalink to &quot;在 Swift/Objective-C 中使用 Kotlin&quot;">​</a></h2><p>Kotlin 模組如果編譯為框架，則可以在 Swift/Objective-C 程式碼中使用：</p><ul><li>請參閱 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-build-native-binaries.html#declare-binaries" target="_blank" rel="noreferrer">建置最終原生二進位檔</a>，了解如何宣告二進位檔。</li><li>查看 <a href="https://github.com/Kotlin/kmm-basic-sample" target="_blank" rel="noreferrer">Kotlin Multiplatform 範例專案</a> 以獲取範例。</li></ul><h3 id="從-objective-c-和-swift-隱藏-kotlin-宣告" tabindex="-1">從 Objective-C 和 Swift 隱藏 Kotlin 宣告 <a class="header-anchor" href="#從-objective-c-和-swift-隱藏-kotlin-宣告" aria-label="Permalink to &quot;從 Objective-C 和 Swift 隱藏 Kotlin 宣告&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>@HiddenFromObjC</code> 註解為 <a href="/zh-Hant/kotlin/components-stability#stability-levels-explained">實驗性</a> 功能，且需要<a href="/zh-Hant/kotlin/opt-in-requirements">選擇啟用</a>。</p></div><p>為了讓您的 Kotlin 程式碼更符合 Swift/Objective-C 習慣，請使用 <code>@HiddenFromObjC</code> 註解來隱藏 Objective-C 和 Swift 中的 Kotlin 宣告。它會停用函數或屬性匯出到 Objective-C。</p><p>或者，您可以使用 <code>internal</code> 修飾符標記 Kotlin 宣告，以限制它們在編譯模組中的可見性。如果您希望從 Objective-C 和 Swift 隱藏 Kotlin 宣告，同時讓它對其他 Kotlin 模組可見，請使用 <code>@HiddenFromObjC</code>。</p><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/HiddenFromObjC.md" target="_blank" rel="noreferrer">請參閱 Kotlin-Swift 互通百科中的範例</a>。</p><h3 id="在-swift-中使用精簡-refining-功能" tabindex="-1">在 Swift 中使用精簡 (Refining) 功能 <a class="header-anchor" href="#在-swift-中使用精簡-refining-功能" aria-label="Permalink to &quot;在 Swift 中使用精簡 (Refining) 功能&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>@ShouldRefineInSwift</code> 註解為 <a href="/zh-Hant/kotlin/components-stability#stability-levels-explained">實驗性</a> 功能，且需要<a href="/zh-Hant/kotlin/opt-in-requirements">選擇啟用</a>。</p></div><p><code>@ShouldRefineInSwift</code> 有助於將 Kotlin 宣告替換為使用 Swift 編寫的包裝器。該註解將函數或屬性在產生的 Objective-C API 中標記為 <code>swift_private</code>。這些宣告會加上 <code>__</code> 前綴，使其在 Swift 中不可見。</p><p>您仍然可以在 Swift 程式碼中使用這些宣告來建立 Swift 友好的 API，但它們不會在 Xcode 自動完成中建議。</p><ul><li>有關在 Swift 中精簡 Objective-C 宣告的更多資訊，請參閱 <a href="https://developer.apple.com/documentation/swift/improving-objective-c-api-declarations-for-swift" target="_blank" rel="noreferrer">官方 Apple 文件</a>。</li><li>有關如何使用 <code>@ShouldRefineInSwift</code> 註解的範例，請參閱 <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/ShouldRefineInSwift.md" target="_blank" rel="noreferrer">Kotlin-Swift 互通百科</a>。</li></ul><h3 id="更改宣告名稱" tabindex="-1">更改宣告名稱 <a class="header-anchor" href="#更改宣告名稱" aria-label="Permalink to &quot;更改宣告名稱&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>@ObjCName</code> 註解為 <a href="/zh-Hant/kotlin/components-stability#stability-levels-explained">實驗性</a> 功能，且需要<a href="/zh-Hant/kotlin/opt-in-requirements">選擇啟用</a>。</p></div><p>為避免重新命名 Kotlin 宣告，請使用 <code>@ObjCName</code> 註解。它指示 Kotlin 編譯器為被註解的類別、介面或其他 Kotlin 實體使用自訂的 Objective-C 和 Swift 名稱：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@ObjCName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(swiftName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;MySwiftArray&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyKotlinArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @ObjCName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@ObjCName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;of&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) element: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TODO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Usage with the ObjCName annotations</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MySwiftArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(of: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;element&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/ObjCName.md" target="_blank" rel="noreferrer">請參閱 Kotlin-Swift 互通百科中的另一個範例</a>。</p><h3 id="使用-kdoc-註解提供文件" tabindex="-1">使用 KDoc 註解提供文件 <a class="header-anchor" href="#使用-kdoc-註解提供文件" aria-label="Permalink to &quot;使用 KDoc 註解提供文件&quot;">​</a></h3><p>文件對於理解任何 API 至關重要。為共享的 Kotlin API 提供文件可讓您與其使用者就使用方式、注意事項等進行溝通。</p><p>預設情況下，<a href="/zh-Hant/kotlin/kotlin-doc">KDocs</a> 註解在產生 Objective-C 標頭時不會翻譯成對應的註解。例如，以下帶有 KDoc 的 Kotlin 程式碼：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Prints the sum of the arguments.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Properly handles the case when the sum doesn&#39;t fit in 32-bit integer.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLong</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b)</span></span></code></pre></div><p>將產生不含任何註解的 Objective-C 宣告：</p><div class="language-objc vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">objc</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)printSumA:(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)a b:(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)b </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">swift_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;printSum(a:b:)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)));</span></span></code></pre></div><p>若要啟用 KDoc 註解的匯出，請將以下編譯器選項新增到您的 <code>build.gradle(.kts)</code> 中：</p>`,34)),e(p,{group:"build-script"},{default:n(()=>[e(l,{title:"Kotlin","group-key":"kotlin"},{default:n(()=>s[0]||(s[0]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    targets."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"withType"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"org"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"jetbrains"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"gradle"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"plugin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"mpp"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"KotlinNativeTarget"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"> {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        compilations."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"get"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"main"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},").compilerOptions.options.freeCompilerArgs."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"add"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"-Xexport-kdoc"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),e(l,{title:"Groovy","group-key":"groovy"},{default:n(()=>s[1]||(s[1]=[i("div",{class:"language-groovy vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"groovy"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"kotlin {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    targets"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"withType("),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTarget"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        compilations"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"get("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"main"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"compilerOptions"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"options"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"freeCompilerArgs"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"add("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"-Xexport-kdoc"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),s[3]||(s[3]=t(`<p>之後，Objective-C 標頭將包含對應的註解：</p><div class="language-objc vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">objc</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Prints the sum of the arguments.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Properly handles the case when the sum doesn&#39;t fit in 32-bit integer.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)printSumA:(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)a b:(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)b </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">swift_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;printSum(a:b:)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)));</span></span></code></pre></div><p>您將能夠在自動完成中看到類別和方法的註解，例如在 Xcode 中。如果您前往函數定義（在 <code>.h</code> 檔案中），您將看到關於 <code>@param</code>、<code>@return</code> 等的註解。</p><p>已知限制：</p><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>將 KDoc 註解匯出到產生的 Objective-C 標頭的功能為 <a href="/zh-Hant/kotlin/components-stability">實驗性</a> 功能。 它可能隨時被捨棄或更改。 需要選擇啟用（詳情請參閱下方），且您應僅將其用於評估目的。 我們將非常感謝您在 <a href="https://youtrack.jetbrains.com/issue/KT-38600" target="_blank" rel="noreferrer">YouTrack</a> 上提供回饋。</p></div><ul><li>依賴項文件不會匯出，除非它本身也使用 <code>-Xexport-kdoc</code> 進行編譯。此功能是實驗性的，因此使用此選項編譯的函式庫可能與其他編譯器版本不相容。</li><li>KDoc 註解主要按原樣匯出。許多 KDoc 功能，例如 <code>@property</code>，尚不支援。</li></ul><h2 id="映射" tabindex="-1">映射 <a class="header-anchor" href="#映射" aria-label="Permalink to &quot;映射&quot;">​</a></h2><p>下表顯示了 Kotlin 概念如何映射到 Swift/Objective-C，反之亦然。</p><p>「-&gt;」和「&lt;-」表示映射僅單向進行。</p><table tabindex="0"><thead><tr><th>Kotlin</th><th>Swift</th><th>Objective-C</th><th>備註</th></tr></thead><tbody><tr><td><code>class</code></td><td><code>class</code></td><td><code>@interface</code></td><td><a href="#classes">備註</a></td></tr><tr><td><code>interface</code></td><td><code>protocol</code></td><td><code>@protocol</code></td><td></td></tr><tr><td><code>constructor</code>/<code>create</code></td><td>Initializer</td><td>Initializer</td><td><a href="#initializers">備註</a></td></tr><tr><td>Property</td><td>Property</td><td>Property</td><td><a href="#top-level-functions-and-properties">備註 1</a>, <a href="#setters">備註 2</a></td></tr><tr><td>Method</td><td>Method</td><td>Method</td><td><a href="#top-level-functions-and-properties">備註 1</a>, <a href="#method-names-translation">備註 2</a></td></tr><tr><td><code>enum class</code></td><td><code>class</code></td><td><code>@interface</code></td><td><a href="#enums">備註</a></td></tr><tr><td><code>suspend</code> -&gt;</td><td><code>completionHandler:</code>/ <code>async</code></td><td><code>completionHandler:</code></td><td><a href="#errors-and-exceptions">備註 1</a>, <a href="#suspending-functions">備註 2</a></td></tr><tr><td><code>@Throws fun</code></td><td><code>throws</code></td><td><code>error:(NSError**)error</code></td><td><a href="#errors-and-exceptions">備註</a></td></tr><tr><td>Extension</td><td>Extension</td><td>Category member</td><td><a href="#extensions-and-category-members">備註</a></td></tr><tr><td><code>companion</code> member &lt;-</td><td>Class method or property</td><td>Class method or property</td><td></td></tr><tr><td><code>null</code></td><td><code>nil</code></td><td><code>nil</code></td><td></td></tr><tr><td><code>Singleton</code></td><td><code>shared</code> or <code>companion</code> property</td><td><code>shared</code> or <code>companion</code> property</td><td><a href="#kotlin-singletons">備註</a></td></tr><tr><td>Primitive type</td><td>Primitive type / <code>NSNumber</code></td><td></td><td><a href="#primitive-types">備註</a></td></tr><tr><td><code>Unit</code> return type</td><td><code>Void</code></td><td><code>void</code></td><td></td></tr><tr><td><code>String</code></td><td><code>String</code></td><td><code>NSString</code></td><td><a href="#strings">備註</a></td></tr><tr><td><code>String</code></td><td><code>NSMutableString</code></td><td><code>NSMutableString</code></td><td><a href="#nsmutablestring">備註</a></td></tr><tr><td><code>List</code></td><td><code>Array</code></td><td><code>NSArray</code></td><td></td></tr><tr><td><code>MutableList</code></td><td><code>NSMutableArray</code></td><td><code>NSMutableArray</code></td><td></td></tr><tr><td><code>Set</code></td><td><code>Set</code></td><td><code>NSSet</code></td><td></td></tr><tr><td><code>MutableSet</code></td><td><code>NSMutableSet</code></td><td><code>NSMutableSet</code></td><td><a href="#collections">備註</a></td></tr><tr><td><code>Map</code></td><td><code>Dictionary</code></td><td><code>NSDictionary</code></td><td></td></tr><tr><td><code>MutableMap</code></td><td><code>NSMutableDictionary</code></td><td><code>NSMutableDictionary</code></td><td><a href="#collections">備註</a></td></tr><tr><td>Function type</td><td>Function type</td><td>Block pointer type</td><td><a href="#function-types">備註</a></td></tr><tr><td>Inline classes</td><td>Unsupported</td><td>Unsupported</td><td><a href="#unsupported">備註</a></td></tr></tbody></table><h3 id="類別-classes" tabindex="-1">類別 (Classes) <a class="header-anchor" href="#類別-classes" aria-label="Permalink to &quot;類別 (Classes)&quot;">​</a></h3><h4 id="名稱翻譯" tabindex="-1">名稱翻譯 <a class="header-anchor" href="#名稱翻譯" aria-label="Permalink to &quot;名稱翻譯&quot;">​</a></h4><p>Objective-C 類別會以其原始名稱匯入 Kotlin。 協定會以 <code>Protocol</code> 名稱後綴作為介面匯入，例如，<code>@protocol Foo</code> -&gt; <code>interface FooProtocol</code>。 這些類別和介面會放置在 <a href="#importing-swift-objective-c-libraries-to-kotlin">建置配置中指定</a> 的套件中（預配置系統框架為 <code>platform.*</code> 套件）。</p><p>Kotlin 類別和介面的名稱在匯入 Objective-C 時會加上前綴。 該前綴源自框架名稱。</p><p>Objective-C 不支援框架中的套件。如果 Kotlin 編譯器在同一個框架中發現具有相同名稱但不同套件的 Kotlin 類別，它會重新命名它們。此演算法尚不穩定，可能會在 Kotlin 版本之間更改。為解決此問題，您可以重新命名框架中衝突的 Kotlin 類別。</p><h4 id="強連結" tabindex="-1">強連結 <a class="header-anchor" href="#強連結" aria-label="Permalink to &quot;強連結&quot;">​</a></h4><p>每當您在 Kotlin 原始碼中使用 Objective-C 類別時，它都會被標記為強連結符號。產生的建置產物會將相關符號提及為強外部參照。</p><p>這意味著應用程式在啟動期間會嘗試動態連結符號，如果它們不可用，應用程式就會崩潰。 即使從未使用過這些符號，崩潰也會發生。這些符號可能在特定裝置或作業系統版本上不可用。</p><p>為了解決此問題並避免「符號未找到」錯誤，請使用 Swift 或 Objective-C 包裝器來檢查類別是否實際可用。<a href="https://github.com/JetBrains/compose-multiplatform-core/pull/1278/files" target="_blank" rel="noreferrer">請參閱 Compose Multiplatform 框架中此解決方案的實作方式</a>。</p><h3 id="初始化器-initializers" tabindex="-1">初始化器 (Initializers) <a class="header-anchor" href="#初始化器-initializers" aria-label="Permalink to &quot;初始化器 (Initializers)&quot;">​</a></h3><p>Swift/Objective-C 初始化器會作為建構子或名為 <code>create</code> 的工廠方法匯入 Kotlin。 後者發生在 Objective-C 類別或 Swift 擴展中宣告的初始化器，因為 Kotlin 沒有擴展建構子的概念。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在將 Swift 初始化器匯入 Kotlin 之前，請不要忘記使用 <code>@objc</code> 註解它們。</p></div><p>Kotlin 建構子會作為初始化器匯入 Swift/Objective-C。</p><h3 id="設定器-setters" tabindex="-1">設定器 (Setters) <a class="header-anchor" href="#設定器-setters" aria-label="Permalink to &quot;設定器 (Setters)&quot;">​</a></h3><p>可寫入的 Objective-C 屬性如果覆寫了父類別的唯讀屬性，則會以屬性 <code>foo</code> 的 <code>setFoo()</code> 方法來表示。對於實作為可變的協定唯讀屬性也是如此。</p><h3 id="頂層函數和屬性" tabindex="-1">頂層函數和屬性 <a class="header-anchor" href="#頂層函數和屬性" aria-label="Permalink to &quot;頂層函數和屬性&quot;">​</a></h3><p>頂層 Kotlin 函數和屬性可作為特殊類別的成員存取。 每個 Kotlin 檔案都會被翻譯成這樣的類別，例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// MyLibraryUtils.kt</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> my.library</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span></code></pre></div><p>然後您可以像這樣從 Swift 呼叫 <code>foo()</code> 函數：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyLibraryUtilsKt.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>請參閱 Kotlin-Swift 互通百科中存取頂層 Kotlin 宣告的範例集合：</p><ul><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/Top-level%20functions.md" target="_blank" rel="noreferrer">頂層函數</a></li><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/functionsandproperties/Top-level%20val%20properties.md" target="_blank" rel="noreferrer">頂層唯讀屬性</a></li><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/functionsandproperties/Top-level%20mutable%20var%20properties.md" target="_blank" rel="noreferrer">頂層可變屬性</a></li></ul><h3 id="方法名稱翻譯" tabindex="-1">方法名稱翻譯 <a class="header-anchor" href="#方法名稱翻譯" aria-label="Permalink to &quot;方法名稱翻譯&quot;">​</a></h3><p>一般而言，Swift 引數標籤和 Objective-C 選擇器片段會映射到 Kotlin 參數名稱。這兩個概念具有不同的語意，因此有時 Swift/Objective-C 方法可能會因 Kotlin 簽章衝突而匯入。 在這種情況下，衝突的方法可以使用命名引數從 Kotlin 呼叫，例如：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[player moveTo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LEFT byMeters</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[player moveTo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UP byInches</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>在 Kotlin 中，它是：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">player.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">moveTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(LEFT, byMeters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">player.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">moveTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UP, byInches </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>以下是 <code>kotlin.Any</code> 函數如何映射到 Swift/Objective-C 的方式：</p><table tabindex="0"><thead><tr><th>Kotlin</th><th>Swift</th><th>Objective-C</th></tr></thead><tbody><tr><td><code>equals()</code></td><td><code>isEquals(_:)</code></td><td><code>isEquals:</code></td></tr><tr><td><code>hashCode()</code></td><td><code>hash</code></td><td><code>hash</code></td></tr><tr><td><code>toString()</code></td><td><code>description</code></td><td><code>description</code></td></tr></tbody></table><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Data%20classes.md" target="_blank" rel="noreferrer">請參閱 Kotlin-Swift 互通百科中資料類別的範例</a>。</p><p>您可以在 Swift 或 Objective-C 中指定一個更慣用的名稱，而不是使用 <a href="#change-declaration-names"><code>@ObjCName</code> 註解</a> 重新命名 Kotlin 宣告。</p><h3 id="錯誤與例外-errors-and-exceptions" tabindex="-1">錯誤與例外 (Errors and exceptions) <a class="header-anchor" href="#錯誤與例外-errors-and-exceptions" aria-label="Permalink to &quot;錯誤與例外 (Errors and exceptions)&quot;">​</a></h3><p>所有 Kotlin 例外都是未檢查的，這意味著錯誤是在執行時捕捉的。然而，Swift 只有已檢查錯誤，這些錯誤是在編譯時處理的。因此，如果 Swift 或 Objective-C 程式碼呼叫一個會拋出例外的 Kotlin 方法，該 Kotlin 方法應該使用 <code>@Throws</code> 註解標記，並指定一個「預期」例外類別的列表。</p><p>當編譯到 Swift/Objective-C 框架時，具有或繼承 <code>@Throws</code> 註解的非 <code>suspend</code> 函數在 Objective-C 中表示為產生 <code>NSError*</code> 的方法，在 Swift 中表示為 <code>throws</code> 方法。 <code>suspend</code> 函數的表示總是具有完成處理器中的 <code>NSError*</code>/<code>Error</code> 參數。</p><p>當從 Swift/Objective-C 程式碼呼叫的 Kotlin 函數拋出一個例外，該例外是 <code>@Throws</code> 指定的類別之一或其子類別的實例時，該例外會作為 <code>NSError</code> 傳播。 到達 Swift/Objective-C 的其他 Kotlin 例外被視為未處理，並導致程式終止。</p><p>沒有 <code>@Throws</code> 的 <code>suspend</code> 函數只傳播 <code>CancellationException</code>（作為 <code>NSError</code>）。 沒有 <code>@Throws</code> 的非 <code>suspend</code> 函數根本不傳播 Kotlin 例外。</p><p>請注意，相反的翻譯尚未實作：Swift/Objective-C 拋出錯誤的方法不會作為拋出例外的 Kotlin 方法匯入。</p><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/Exceptions.md" target="_blank" rel="noreferrer">請參閱 Kotlin-Swift 互通百科中的範例</a>。</p><h3 id="列舉-enums" tabindex="-1">列舉 (Enums) <a class="header-anchor" href="#列舉-enums" aria-label="Permalink to &quot;列舉 (Enums)&quot;">​</a></h3><p>Kotlin 列舉會匯入 Objective-C 為 <code>@interface</code>，匯入 Swift 為 <code>class</code>。 這些資料結構具有對應每個列舉值的屬性。考慮以下 Kotlin 程式碼：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Colors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RED, GREEN, BLUE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>您可以從 Swift 存取此列舉類別的屬性，如下所示：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Swift</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Colors.red</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Colors.green</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Colors.blue</span></span></code></pre></div><p>要在 Swift 的 <code>switch</code> 陳述式中使用 Kotlin 列舉的變數，請提供一個 <code>default</code> 陳述式以防止編譯錯誤：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> color {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .red</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;It&#39;s red&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .green</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;It&#39;s green&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .blue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;It&#39;s blue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    default:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fatalError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;No such color&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Enum%20classes.md" target="_blank" rel="noreferrer">請參閱 Kotlin-Swift 互通百科中的另一個範例</a>。</p><h3 id="暫停函數-suspending-functions" tabindex="-1">暫停函數 (Suspending functions) <a class="header-anchor" href="#暫停函數-suspending-functions" aria-label="Permalink to &quot;暫停函數 (Suspending functions)&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>從 Swift 程式碼呼叫 <code>suspend</code> 函數作為 <code>async</code> 功能的支援為 <a href="/zh-Hant/kotlin/components-stability">實驗性</a> 功能。 它可能隨時被捨棄或更改。 僅將其用於評估目的。我們將非常感謝您在 <a href="https://youtrack.jetbrains.com/issue/KT-47610" target="_blank" rel="noreferrer">YouTrack</a> 上提供回饋。</p></div><p>Kotlin 的<a href="/zh-Hant/kotlin/coroutines-basics">暫停函數</a> (<code>suspend</code>) 在產生的 Objective-C 標頭中以帶有回呼的函數形式呈現，或以 Swift/Objective-C 術語中的<a href="https://developer.apple.com/documentation/swift/calling_objective-c_apis_asynchronously" target="_blank" rel="noreferrer">完成處理器</a>形式呈現。</p><p>從 Swift 5.5 開始，Kotlin 的 <code>suspend</code> 函數也可以作為 <code>async</code> 函數從 Swift 呼叫，而無需使用完成處理器。目前，此功能仍高度實驗性，並具有某些限制。請參閱 <a href="https://youtrack.jetbrains.com/issue/KT-47610" target="_blank" rel="noreferrer">此 YouTrack 問題</a> 以獲取詳細資訊。</p><ul><li>了解更多關於 Swift 文件中的 <a href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html" target="_blank" rel="noreferrer"><code>async</code>/<code>await</code> 機制</a>。</li><li>請參閱 <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/coroutines/Suspend%20functions.md" target="_blank" rel="noreferrer">Kotlin-Swift 互通百科</a> 中的範例和有關實作相同功能的第三方函式庫的建議。</li></ul><h3 id="擴展與類別成員-extensions-and-category-members" tabindex="-1">擴展與類別成員 (Extensions and category members) <a class="header-anchor" href="#擴展與類別成員-extensions-and-category-members" aria-label="Permalink to &quot;擴展與類別成員 (Extensions and category members)&quot;">​</a></h3><p>Objective-C 類別和 Swift 擴展的成員通常會作為擴展匯入 Kotlin。這就是為什麼這些宣告在 Kotlin 中無法覆寫，以及擴展初始化器無法作為 Kotlin 建構子使用的原因。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>目前有兩個例外。從 Kotlin 1.8.20 開始，在與 NSView 類別（來自 AppKit 框架）或 UIView 類別（來自 UIKit 框架）相同的標頭中宣告的類別成員會作為這些類別的成員匯入。這意味著您可以覆寫從 NSView 或 UIView 子類別化的方法。</p></div><p>Kotlin 對「常規」Kotlin 類別的擴展會分別匯入 Swift 和 Objective-C 作為擴展和類別成員。Kotlin 對其他類型的擴展則視為 <a href="#top-level-functions-and-properties">頂層宣告</a>，並帶有額外的接收者參數。這些類型包括：</p><ul><li>Kotlin <code>String</code> 類型</li><li>Kotlin 集合類型和子類型</li><li>Kotlin <code>interface</code> 類型</li><li>Kotlin 基本型別</li><li>Kotlin <code>inline</code> 類別</li><li>Kotlin <code>Any</code> 類型</li><li>Kotlin 函數類型和子類型</li><li>Objective-C 類別和協定</li></ul><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/tree/main/docs/extensions" target="_blank" rel="noreferrer">請參閱 Kotlin-Swift 互通百科中的範例集合</a>。</p><h3 id="kotlin-單例-kotlin-singletons" tabindex="-1">Kotlin 單例 (Kotlin singletons) <a class="header-anchor" href="#kotlin-單例-kotlin-singletons" aria-label="Permalink to &quot;Kotlin 單例 (Kotlin singletons)&quot;">​</a></h3><p>Kotlin 單例（使用 <code>object</code> 宣告建立，包括 <code>companion object</code>）會匯入 Swift/Objective-C 為具有單一實例的類別。</p><p>該實例可透過 <code>shared</code> 和 <code>companion</code> 屬性取得。</p><p>對於以下 Kotlin 程式碼：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">object</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Some value&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    companion</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Some value&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>存取這些物件的方式如下：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyObject.shared</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyObject.shared.x</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyClass.companion</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyClass.Companion.shared</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>透過 <code>[MySingleton mySingleton]</code> 在 Objective-C 中和 <code>MySingleton()</code> 在 Swift 中存取物件已被棄用。</p></div><p>請參閱 Kotlin-Swift 互通百科中的更多範例：</p><ul><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Objects.md" target="_blank" rel="noreferrer">如何使用 <code>shared</code> 存取 Kotlin 物件</a></li><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Companion%20objects.md" target="_blank" rel="noreferrer">如何從 Swift 存取 Kotlin 伴隨物件的成員</a>。</li></ul><h3 id="基本型別-primitive-types" tabindex="-1">基本型別 (Primitive types) <a class="header-anchor" href="#基本型別-primitive-types" aria-label="Permalink to &quot;基本型別 (Primitive types)&quot;">​</a></h3><p>Kotlin 基本型別的裝箱會映射到特殊的 Swift/Objective-C 類別。例如，<code>kotlin.Int</code> 裝箱在 Swift 中表示為 <code>KotlinInt</code> 類別實例（或在 Objective-C 中表示為 <code>\${prefix}Int</code> 實例，其中 <code>prefix</code> 是框架的名稱前綴）。 這些類別源自 <code>NSNumber</code>，因此實例是支援所有相應操作的適當 <code>NSNumber</code>。</p><p>當 <code>NSNumber</code> 用作 Swift/Objective-C 參數類型或回傳值時，它不會自動翻譯為 Kotlin 基本型別。原因是 <code>NSNumber</code> 類型未提供足夠關於包裝的基本值類型資訊，例如，靜態上不知道 <code>NSNumber</code> 是 <code>Byte</code>、<code>Boolean</code> 還是 <code>Double</code>。因此，Kotlin 基本值應<a href="#casting-between-mapped-types">手動轉換為和從 <code>NSNumber</code> 轉換</a>。</p><h3 id="字串-strings" tabindex="-1">字串 (Strings) <a class="header-anchor" href="#字串-strings" aria-label="Permalink to &quot;字串 (Strings)&quot;">​</a></h3><p>當 Kotlin <code>String</code> 傳遞給 Swift 時，它首先會匯出為 Objective-C 物件，然後 Swift 編譯器會再次複製它以進行 Swift 轉換。這會導致額外的執行時間開銷。</p><p>為避免這種情況，請直接將 Kotlin 字串作為 Objective-C <code>NSString</code> 存取。 <a href="#see-the-conversion-example">請參閱轉換範例</a>。</p><h4 id="nsmutablestring" tabindex="-1">NSMutableString <a class="header-anchor" href="#nsmutablestring" aria-label="Permalink to &quot;NSMutableString&quot;">​</a></h4><p><code>NSMutableString</code> Objective-C 類別在 Kotlin 中不可用。 <code>NSMutableString</code> 的所有實例在傳遞給 Kotlin 時都會被複製。</p><h3 id="集合-collections" tabindex="-1">集合 (Collections) <a class="header-anchor" href="#集合-collections" aria-label="Permalink to &quot;集合 (Collections)&quot;">​</a></h3><h4 id="kotlin-objective-c-swift" tabindex="-1">Kotlin -&gt; Objective-C -&gt; Swift <a class="header-anchor" href="#kotlin-objective-c-swift" aria-label="Permalink to &quot;Kotlin -&gt; Objective-C -&gt; Swift&quot;">​</a></h4><p>當 Kotlin 集合傳遞給 Swift 時，它首先會轉換為 Objective-C 等效項，然後 Swift 編譯器會複製整個集合並將其轉換為 <a href="#mappings">映射表</a> 中描述的 Swift 原生集合。</p><p>最後的這種轉換會導致效能成本。為防止這種情況，當在 Swift 中使用 Kotlin 集合時，請明確將它們轉換為其 Objective-C 對應項：<code>NSDictionary</code>、<code>NSArray</code> 或 <code>NSSet</code>。</p>`,89)),s[4]||(s[4]=i("h5",{"initial-collapse-state":"collapsed",collapsible:"true",id:"請參閱轉換範例",tabindex:"-1"},[a("請參閱轉換範例 "),i("a",{class:"header-anchor",href:"#請參閱轉換範例","aria-label":'Permalink to "請參閱轉換範例 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[5]||(s[5]=t(`<p>例如，以下 Kotlin 宣告：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> map: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>在 Swift 中可能看起來像這樣：</p><div class="language-Swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map[key]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ??</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre></div><p>在這裡，<code>map</code> 會隱式轉換為 Swift 的 <code>Dictionary</code>，其字串值會映射到 Swift 的 <code>String</code>。 這會導致效能成本。</p><p>為避免轉換，請明確將 <code>map</code> 轉換為 Objective-C 的 <code>NSDictionary</code>，並將值作為 <code>NSString</code> 存取：</p><div class="language-Swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsMap: NSDictionary </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> map </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NSDictionary</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nsMap[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NSString)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">??</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre></div><p>這可確保 Swift 編譯器不會執行額外的轉換步驟。</p><h4 id="swift-objective-c-kotlin" tabindex="-1">Swift -&gt; Objective-C -&gt; Kotlin <a class="header-anchor" href="#swift-objective-c-kotlin" aria-label="Permalink to &quot;Swift -&gt; Objective-C -&gt; Kotlin&quot;">​</a></h4><p>Swift/Objective-C 集合會映射到 Kotlin，如 <a href="#mappings">映射表</a> 中所述，但 <code>NSMutableSet</code> 和 <code>NSMutableDictionary</code> 除外。</p><p><code>NSMutableSet</code> 不會轉換為 Kotlin 的 <code>MutableSet</code>。要將物件傳遞給 Kotlin <code>MutableSet</code>，請明確建立此類 Kotlin 集合。為此，例如，在 Kotlin 中使用 <code>mutableSetOf()</code> 函數，或在 Swift 中使用 <code>KotlinMutableSet</code> 類別，在 Objective-C 中使用 <code>\${prefix}MutableSet</code>（<code>prefix</code> 是框架名稱前綴）。 <code>MutableMap</code> 也是如此。</p><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/Collections.md" target="_blank" rel="noreferrer">請參閱 Kotlin-Swift 互通百科中的範例</a>。</p><h3 id="函數型別-function-types" tabindex="-1">函數型別 (Function types) <a class="header-anchor" href="#函數型別-function-types" aria-label="Permalink to &quot;函數型別 (Function types)&quot;">​</a></h3><p>Kotlin 函數型別物件（例如，Lambda 運算式）在 Swift 中會轉換為函數，在 Objective-C 中會轉換為區塊。 <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/functionsandproperties/Functions%20returning%20function%20type.md" target="_blank" rel="noreferrer">請參閱 Kotlin-Swift 互通百科中帶有 Lambda 的 Kotlin 函數範例</a>。</p><p>然而，在翻譯函數和函數型別時，參數和回傳值的類型映射方式存在差異。在後者情況下，基本型別會映射到其裝箱表示。Kotlin <code>Unit</code> 回傳值在 Swift/Objective-C 中表示為對應的 <code>Unit</code> 單例。此單例的值可以像任何其他 Kotlin <code>object</code> 一樣檢索。請參閱上方<a href="#mappings">表格</a>中的單例。</p><p>考慮以下 Kotlin 函數：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span></code></pre></div><p>它在 Swift 中表示如下：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (KotlinInt) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KotlinUnit)</span></span></code></pre></div><p>您可以像這樣呼叫它：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Int32)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> KotlinUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="泛型-generics" tabindex="-1">泛型 (Generics) <a class="header-anchor" href="#泛型-generics" aria-label="Permalink to &quot;泛型 (Generics)&quot;">​</a></h3><p>Objective-C 支援在類別中定義的「輕量級泛型」，功能集相對有限。Swift 可以匯入在類別上定義的泛型，以協助向編譯器提供額外的類型資訊。</p><p>Objective-C 和 Swift 的泛型功能支援與 Kotlin 不同，因此翻譯不可避免地會遺失一些資訊，但支援的功能仍保留有意義的資訊。</p><p>有關如何在 Swift 中使用 Kotlin 泛型的具體範例，請參閱 <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/ShouldRefineInSwift.md" target="_blank" rel="noreferrer">Kotlin-Swift 互通百科</a>。</p><h4 id="限制" tabindex="-1">限制 <a class="header-anchor" href="#限制" aria-label="Permalink to &quot;限制&quot;">​</a></h4><p>Objective-C 泛型不支援 Kotlin 或 Swift 的所有功能，因此翻譯中會遺失一些資訊。</p><p>泛型只能在類別上定義，不能在介面（Objective-C 和 Swift 中的協定）或函數上定義。</p><h4 id="可為空性-nullability" tabindex="-1">可為空性 (Nullability) <a class="header-anchor" href="#可為空性-nullability" aria-label="Permalink to &quot;可為空性 (Nullability)&quot;">​</a></h4><p>Kotlin 和 Swift 都將可為空性定義為類型規範的一部分，而 Objective-C 則在類型的方法和屬性上定義可為空性。因此，以下 Kotlin 程式碼：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在 Swift 中看起來像這樣：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fun </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">myVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>為了支援潛在的可為空類型，Objective-C 標頭需要將 <code>myVal</code> 定義為可為空回傳值。</p><p>為緩解此問題，當定義您的泛型類別時，如果泛型類型「絕不」應為空，請提供一個不可為空類型約束：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>這將強制 Objective-C 標頭將 <code>myVal</code> 標記為不可為空。</p><h4 id="變異性-variance" tabindex="-1">變異性 (Variance) <a class="header-anchor" href="#變異性-variance" aria-label="Permalink to &quot;變異性 (Variance)&quot;">​</a></h4><p>Objective-C 允許泛型宣告為共變或逆變。Swift 不支援變異性。來自 Objective-C 的泛型類別可以根據需要強制轉換。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BaseData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GenVarOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">out</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arg: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> variOut </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GenVarOut</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SomeData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: sd)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> variOutAny : GenVarOut&lt;BaseData&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> variOut </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GenVarOut</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BaseData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><h4 id="約束-constraints" tabindex="-1">約束 (Constraints) <a class="header-anchor" href="#約束-constraints" aria-label="Permalink to &quot;約束 (Constraints)&quot;">​</a></h4><p>在 Kotlin 中，您可以為泛型類型提供上限。Objective-C 也支援此功能，但在更複雜的情況下不適用，且目前 Kotlin - Objective-C 互通不支援。這裡的例外是，不可為空的上限會使 Objective-C 方法/屬性不可為空。</p><h4 id="停用" tabindex="-1">停用 <a class="header-anchor" href="#停用" aria-label="Permalink to &quot;停用&quot;">​</a></h4><p>要在沒有泛型的情況下編寫框架標頭，請在您的建置檔案中新增以下編譯器選項：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">binaries.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">framework</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    freeCompilerArgs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;-Xno-objc-generics&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="前向宣告-forward-declarations" tabindex="-1">前向宣告 (Forward declarations) <a class="header-anchor" href="#前向宣告-forward-declarations" aria-label="Permalink to &quot;前向宣告 (Forward declarations)&quot;">​</a></h3><p>若要匯入前向宣告，請使用 <code>objcnames.classes</code> 和 <code>objcnames.protocols</code> 套件。例如， 若要匯入在 Objective-C 函式庫中以 <code>library.package</code> 宣告的 <code>objcprotocolName</code> 前向宣告， 請使用特殊的前向宣告套件：<code>import objcnames.protocols.objcprotocolName</code>。</p><p>考慮兩個 objcinterop 函式庫：一個使用 <code>objcnames.protocols.ForwardDeclaredProtocolProtocol</code>， 另一個在另一個套件中具有實際實作：</p><div class="language-ObjC vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ObjC</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// First objcinterop library</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;Foundation/Foundation.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@protocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredProtocol;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NSString</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> consumeProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;ForwardDeclaredProtocol&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NSString</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> stringWithUTF8String:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Protocol&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-ObjC vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ObjC</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Second objcinterop library</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Header:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;Foundation/Foundation.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@protocol</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ForwardDeclaredProtocol</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@end</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Implementation:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ForwardDeclaredProtocolImpl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NSObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;ForwardDeclaredProtocol&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;ForwardDeclaredProtocol&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">produceProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ForwardDeclaredProtocolImpl </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>若要在兩個函式庫之間傳輸物件，請在您的 Kotlin 程式碼中使用明確的 <code>as</code> 轉換：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin code:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    consumeProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">produceProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> objcnames.protocols.ForwardDeclaredProtocolProtocol)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>您只能從對應的真實類別轉換為 <code>objcnames.protocols.ForwardDeclaredProtocolProtocol</code>。 否則，您將收到錯誤。</p></div><h2 id="映射類型之間的轉換-casting-between-mapped-types" tabindex="-1">映射類型之間的轉換 (Casting between mapped types) <a class="header-anchor" href="#映射類型之間的轉換-casting-between-mapped-types" aria-label="Permalink to &quot;映射類型之間的轉換 (Casting between mapped types)&quot;">​</a></h2><p>編寫 Kotlin 程式碼時，可能需要將物件從 Kotlin 類型轉換為等效的 Swift/Objective-C 類型（反之亦然）。在這種情況下，可以使用普通的 Kotlin 轉換，例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NSArray</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsString </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsNumber </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NSNumber</span></span></code></pre></div><h2 id="子類別化-subclassing" tabindex="-1">子類別化 (Subclassing) <a class="header-anchor" href="#子類別化-subclassing" aria-label="Permalink to &quot;子類別化 (Subclassing)&quot;">​</a></h2><h3 id="從-swift-objective-c-子類別化-kotlin-類別和介面" tabindex="-1">從 Swift/Objective-C 子類別化 Kotlin 類別和介面 <a class="header-anchor" href="#從-swift-objective-c-子類別化-kotlin-類別和介面" aria-label="Permalink to &quot;從 Swift/Objective-C 子類別化 Kotlin 類別和介面&quot;">​</a></h3><p>Kotlin 類別和介面可以被 Swift/Objective-C 類別和協定子類別化。</p><h3 id="從-kotlin-子類別化-swift-objective-c-類別和協定" tabindex="-1">從 Kotlin 子類別化 Swift/Objective-C 類別和協定 <a class="header-anchor" href="#從-kotlin-子類別化-swift-objective-c-類別和協定" aria-label="Permalink to &quot;從 Kotlin 子類別化 Swift/Objective-C 類別和協定&quot;">​</a></h3><p>Swift/Objective-C 類別和協定可以使用 Kotlin <code>final</code> 類別進行子類別化。非 <code>final</code> 的 Kotlin 類別繼承 Swift/Objective-C 類型目前尚不支援，因此不可能宣告繼承 Swift/Objective-C 類型的複雜類別階層。</p><p>一般方法可以使用 <code>override</code> Kotlin 關鍵字進行覆寫。在這種情況下，覆寫方法必須具有與被覆寫方法相同的參數名稱。</p><p>有時需要覆寫初始化器，例如在子類別化 <code>UIViewController</code> 時。作為 Kotlin 建構子匯入的初始化器可以使用 <code>@OverrideInit</code> 註解標記的 Kotlin 建構子進行覆寫：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ViewController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UIViewController </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @OverrideInit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">coder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: NSCoder) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coder)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>覆寫建構子必須具有與被覆寫建構子相同的參數名稱和類型。</p><p>要覆寫具有衝突 Kotlin 簽章的不同方法，您可以將 <code>@ObjCSignatureOverride</code> 註解新增到類別。 如果從 Objective-C 類別繼承了幾個具有相同引數類型但不同引數名稱的函數，該註解會指示 Kotlin 編譯器忽略衝突的重載。</p><p>預設情況下，Kotlin/Native 編譯器不允許呼叫非指定 Objective-C 初始化器作為 <code>super()</code> 建構子。如果指定初始化器在 Objective-C 函式庫中未正確標記，此行為可能會不方便。若要停用這些編譯器檢查，請在函式庫的 <a href="/zh-Hant/kotlin/native-definition-file"><code>.def</code> 檔案</a> 中新增 <code>disableDesignatedInitializerChecks = true</code>。</p><h2 id="c-功能" tabindex="-1">C 功能 <a class="header-anchor" href="#c-功能" aria-label="Permalink to &quot;C 功能&quot;">​</a></h2><p>有關函式庫使用一些純粹的 C 功能（例如不安全指標、結構等）的範例情況，請參閱 <a href="/zh-Hant/kotlin/native-c-interop">與 C 的互通性</a>。</p><h2 id="不支援的功能-unsupported" tabindex="-1">不支援的功能 (Unsupported) <a class="header-anchor" href="#不支援的功能-unsupported" aria-label="Permalink to &quot;不支援的功能 (Unsupported)&quot;">​</a></h2><p>Kotlin 程式語言的一些功能尚未映射到 Objective-C 或 Swift 的相應功能。 目前，以下功能在產生的框架標頭中未正確公開：</p><ul><li>行內類別 (Inline classes)（引數映射為底層基本型別或 <code>id</code>）</li><li>實作標準 Kotlin 集合介面（<code>List</code>、<code>Map</code>、<code>Set</code>）及其他特殊類別的自訂類別</li><li>Objective-C 類別的 Kotlin 子類別</li></ul>`,73))])}const v=o(r,[["render",c]]);export{F as __pageData,v as default};
