import{_ as t}from"./chunks/lifecycle-states.Kfhu0FKr.js";import{_ as d,c as o,o as a,ag as i}from"./chunks/framework.Bksy39di.js";const m=JSON.parse('{"title":"生命周期","description":"","frontmatter":{},"headers":[],"relativePath":"kmp/compose-lifecycle.md","filePath":"kmp/compose-lifecycle.md","lastUpdated":1755516278000}'),c={name:"kmp/compose-lifecycle.md"};function s(r,e,l,n,p,h){return a(),o("div",null,e[0]||(e[0]=[i(`<h1 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h1><p>Compose Multiplatform 中的组件生命周期沿用了 Jetpack Compose <a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noreferrer">生命周期</a>的概念。 生命周期感知的组件能够响应其他组件的生命周期状态变化，帮助你产出组织更良好、通常更轻量级且更易于维护的代码。</p><p>Compose Multiplatform 提供了一个公共的 <code>LifecycleOwner</code> 实现，它将 Jetpack Compose 的原始功能扩展到其他平台，并帮助在公共代码中观察生命周期状态。</p><p>要使用多平台 <code>Lifecycle</code> 实现，请将以下依赖项添加到你的 <code>commonMain</code> 源代码集：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sourceSets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        commonMain.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // ...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            implementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org.jetbrains.androidx.lifecycle:lifecycle-runtime-compose:2.9.2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>你可以在我们的<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/whats-new-compose.html" target="_blank" rel="noreferrer">新增功能</a>中追踪多平台 Lifecycle 实现的变更，或在 <a href="./https://github.com/JetBrains/compose-multiplatform/blob/master/CHANGELOG">Compose Multiplatform 变更日志</a>中关注特定的抢先体验预览版本。</p></div><h2 id="状态与事件" tabindex="-1">状态与事件 <a class="header-anchor" href="#状态与事件" aria-label="Permalink to &quot;状态与事件&quot;">​</a></h2><p>生命周期状态和事件的流转（与 <a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noreferrer">Jetpack 生命周期</a>相同）：</p><p><img src="`+t+'" alt="生命周期图" width="700"></p><h2 id="生命周期实现" tabindex="-1">生命周期实现 <a class="header-anchor" href="#生命周期实现" aria-label="Permalink to &quot;生命周期实现&quot;">​</a></h2><p>Composables 通常不需要独有的生命周期：一个公共的 <code>LifecycleOwner</code> 为所有相互连接的实体提供一个生命周期。默认情况下，所有由 Compose Multiplatform 创建的 Composables 共享同一生命周期——它们可以订阅其事件、引用生命周期状态等等。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>LifecycleOwner</code> 对象作为 <a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/CompositionLocal" target="_blank" rel="noreferrer">CompositionLocal</a> 提供。 如果你想为特定的可组合项子树单独管理生命周期，你可以<a href="https://developer.android.com/topic/libraries/architecture/lifecycle#implementing-lco" target="_blank" rel="noreferrer">创建自己的</a> <code>LifecycleOwner</code> 实现。</p></div><p>在使用多平台生命周期中的协程时，请记住 <code>Lifecycle.coroutineScope</code> 值绑定到 <code>Dispatchers.Main.immediate</code> 值，该值在桌面目标平台中可能默认不可用。 要使生命周期中的协程和流在 Compose Multiplatform 中正常工作，请将 <code>kotlinx-coroutines-swing</code> 依赖项添加到你的项目。 关于 <code>Dispatchers.Main</code> 的详情，请参见<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html" target="_blank" rel="noreferrer">文档</a>。</p><ul><li>关于导航组件中生命周期如何工作，请了解<a href="./compose-navigation-routing">导航与路由</a>。</li><li>关于多平台 ViewModel 实现的更多信息，请参见<a href="./compose-viewmodel">公共 ViewModel</a> 页面。</li></ul><h2 id="将-android-生命周期映射到其他平台" tabindex="-1">将 Android 生命周期映射到其他平台 <a class="header-anchor" href="#将-android-生命周期映射到其他平台" aria-label="Permalink to &quot;将 Android 生命周期映射到其他平台&quot;">​</a></h2><h3 id="ios" tabindex="-1">iOS <a class="header-anchor" href="#ios" aria-label="Permalink to &quot;iOS&quot;">​</a></h3><table tabindex="0"><thead><tr><th>原生事件和通知</th><th>生命周期事件</th><th>生命周期状态变更</th></tr></thead><tbody><tr><td><code>viewDidDisappear</code></td><td><code>ON_STOP</code></td><td><code>STARTED</code> → <code>CREATED</code></td></tr><tr><td><code>viewWillAppear</code></td><td><code>ON_START</code></td><td><code>CREATED</code> → <code>STARTED</code></td></tr><tr><td><code>willResignActive</code></td><td><code>ON_PAUSE</code></td><td><code>RESUMED</code> → <code>STARTED</code></td></tr><tr><td><code>didBecomeActive</code></td><td><code>ON_RESUME</code></td><td><code>STARTED</code> → <code>RESUMED</code></td></tr><tr><td><code>didEnterBackground</code></td><td><code>ON_STOP</code></td><td><code>STARTED</code> → <code>CREATED</code></td></tr><tr><td><code>willEnterForeground</code></td><td><code>ON_START</code></td><td><code>CREATED</code> → <code>STARTED</code></td></tr><tr><td><code>viewControllerDidLeaveWindowHierarchy</code></td><td><code>ON_DESTROY</code></td><td><code>CREATED</code> → <code>DESTROYED</code></td></tr></tbody></table><h3 id="web" tabindex="-1">Web <a class="header-anchor" href="#web" aria-label="Permalink to &quot;Web&quot;">​</a></h3><p>由于 Wasm 目标平台的限制，生命周期：</p><ul><li>跳过 <code>CREATED</code> 状态，因为应用程序始终附加到页面。</li><li>永远不会达到 <code>DESTROYED</code> 状态，因为网页通常只有当用户关闭标签页时才会被终止。</li></ul><table tabindex="0"><thead><tr><th>原生事件</th><th>生命周期事件</th><th>生命周期状态变更</th></tr></thead><tbody><tr><td><code>blur</code></td><td><code>ON_PAUSE</code></td><td><code>RESUMED</code> → <code>STARTED</code></td></tr><tr><td><code>focus</code></td><td><code>ON_RESUME</code></td><td><code>STARTED</code> → <code>RESUMED</code></td></tr></tbody></table><h3 id="桌面" tabindex="-1">桌面 <a class="header-anchor" href="#桌面" aria-label="Permalink to &quot;桌面&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Swing 监听器回调</th><th>生命周期事件</th><th>生命周期状态变更</th></tr></thead><tbody><tr><td><code>windowIconified</code></td><td><code>ON_STOP</code></td><td><code>STARTED</code> → <code>CREATED</code></td></tr><tr><td><code>windowDeiconified</code></td><td><code>ON_START</code></td><td><code>CREATED</code> → <code>STARTED</code></td></tr><tr><td><code>windowLostFocus</code></td><td><code>ON_PAUSE</code></td><td><code>RESUMED</code> → <code>STARTED</code></td></tr><tr><td><code>windowGainedFocus</code></td><td><code>ON_RESUME</code></td><td><code>STARTED</code> → <code>RESUMED</code></td></tr><tr><td><code>dispose</code></td><td><code>ON_DESTROY</code></td><td><code>CREATED</code> → <code>DESTROYED</code></td></tr></tbody></table>',23)]))}const u=d(c,[["render",s]]);export{m as __pageData,u as default};
