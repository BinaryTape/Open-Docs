import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.Bksy39di.js";const c=JSON.parse('{"title":"相等性","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/equality.md","filePath":"zh-Hant/kotlin/equality.md","lastUpdated":1754307826000}'),e={name:"zh-Hant/kotlin/equality.md"};function t(h,s,p,k,d,o){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="相等性" tabindex="-1">相等性 <a class="header-anchor" href="#相等性" aria-label="Permalink to &quot;相等性&quot;">​</a></h1><p>在 Kotlin 中，有兩種相等性：</p><ul><li><em>結構相等性</em> (<code>==</code>) - 檢查 <code>equals()</code> 函數</li><li><em>參照相等性</em> (<code>===</code>) - 檢查兩個參照是否指向同一個物件</li></ul><h2 id="結構相等性" tabindex="-1">結構相等性 <a class="header-anchor" href="#結構相等性" aria-label="Permalink to &quot;結構相等性&quot;">​</a></h2><p>結構相等性驗證兩個物件是否具有相同的內容或結構。結構相等性由 <code>==</code> 運算及其反向運算 <code>!=</code> 檢查。 依照慣例，像 <code>a == b</code> 這樣的表達式會轉換為：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a?.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b) ?: (b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>如果 <code>a</code> 非 <code>null</code>，它會呼叫 <code>equals(Any?)</code> 函數。否則（即 <code>a</code> 是 <code>null</code>），它會檢查 <code>b</code> 是否參照上等同於 <code>null</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;hello&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;hello&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // true</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // false</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>請注意，當明確地與 <code>null</code> 比較時，無需最佳化您的程式碼： <code>a == null</code> 會自動轉換為 <code>a === null</code>。</p><p>在 Kotlin 中，<code>equals()</code> 函數由所有類別從 <code>Any</code> 類別繼承而來。預設情況下，<code>equals()</code> 函數 實作了<a href="#referential-equality">參照相等性</a>。然而，Kotlin 中的類別可以覆寫 <code>equals()</code> 函數以提供自訂的相等性邏輯，並透過這種方式實作結構相等性。</p><p>值類別 (value classes) 和資料類別 (data classes) 是兩種特定的 Kotlin 型別，它們會自動覆寫 <code>equals()</code> 函數。 這就是為什麼它們預設實作結構相等性的原因。</p><p>然而，在資料類別的情況下，如果 <code>equals()</code> 函數在父類別中被標記為 <code>final</code>，則其行為保持不變。</p><p>相比之下，非資料類別（那些未使用 <code>data</code> 修飾符宣告的類別）預設不覆寫 <code>equals()</code> 函數。相反，非資料類別實作從 <code>Any</code> 類別繼承而來的參照相等性行為。 要實作結構相等性，非資料類別需要自訂的相等性邏輯來覆寫 <code>equals()</code> 函數。</p><p>若要提供自訂的 <code>equals</code> 檢查實作，請覆寫 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/equals.html" target="_blank" rel="noreferrer"><code>equals(other: Any?): Boolean</code></a> 函數：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(other: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> other) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (other </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Point) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 比較屬性以判斷結構相等性</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> other.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> other.y</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>覆寫 <code>equals()</code> 函數時，您也應該覆寫 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/hash-code.html" target="_blank" rel="noreferrer"><code>hashCode()</code> 函數</a>， 以保持相等性與雜湊之間的一致性，並確保這些函數的正確行為。</p></div><p>具有相同名稱及其他簽章的函數（例如 <code>equals(other: Foo)</code>）不會影響使用 <code>==</code> 和 <code>!=</code> 運算符的相等性檢查。</p><p>結構相等性與 <code>Comparable&lt;...&gt;</code> 介面定義的比較無關，因此只有自訂的 <code>equals(Any?)</code> 實作可能會影響該運算符的行為。</p><h2 id="參照相等性" tabindex="-1">參照相等性 <a class="header-anchor" href="#參照相等性" aria-label="Permalink to &quot;參照相等性&quot;">​</a></h2><p>參照相等性驗證兩個物件的記憶體位址，以判斷它們是否為同一個實例。</p><p>參照相等性由 <code>===</code> 運算及其反向運算 <code>!==</code> 檢查。當且僅當 <code>a</code> 和 <code>b</code> 指向同一個物件時，<code>a === b</code> 評估為 <code>true</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;world&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;world&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // true</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // false</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // true</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>對於在執行時由基本型別表示的值 （例如 <code>Int</code>），<code>===</code> 相等性檢查等同於 <code>==</code> 檢查。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>參照相等性在 Kotlin/JS 中實作方式不同。有關相等性的更多資訊，請參閱 <a href="/zh-Hant/kotlin/js-interop#equality">Kotlin/JS</a> 文件。</p></div><h2 id="浮點數相等性" tabindex="-1">浮點數相等性 <a class="header-anchor" href="#浮點數相等性" aria-label="Permalink to &quot;浮點數相等性&quot;">​</a></h2><p>當相等性檢查的運算元靜態地已知為 <code>Float</code> 或 <code>Double</code>（可為 <code>null</code> 或不可為 <code>null</code>）時，檢查遵循 <a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noreferrer">IEEE 754 浮點數算術標準</a>。</p><p>對於未靜態鍵入為浮點數的運算元，其行為有所不同。在這些情況下， 實作結構相等性。因此，對於未靜態鍵入為浮點數的運算元的檢查，與 IEEE 標準有所不同。在此情境中：</p><ul><li><code>NaN</code> 等於它自身</li><li><code>NaN</code> 大於任何其他元素（包括 <code>POSITIVE_INFINITY</code>）</li><li><code>-0.0</code> 不等於 <code>0.0</code></li></ul><p>有關更多資訊，請參閱<a href="/zh-Hant/kotlin/numbers#floating-point-numbers-comparison">浮點數比較</a>。</p><h2 id="陣列相等性" tabindex="-1">陣列相等性 <a class="header-anchor" href="#陣列相等性" aria-label="Permalink to &quot;陣列相等性&quot;">​</a></h2><p>要比較兩個陣列是否具有相同元素且順序相同，請使用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/content-equals.html" target="_blank" rel="noreferrer"><code>contentEquals()</code></a>。</p><p>有關更多資訊，請參閱<a href="/zh-Hant/kotlin/arrays#compare-arrays">比較陣列</a>。</p>`,32)]))}const E=i(e,[["render",t]]);export{c as __pageData,E as default};
