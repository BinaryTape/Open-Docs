import{_ as t,c as e,o as r,ag as n}from"./chunks/framework.Bksy39di.js";const u=JSON.parse('{"title":"Kotlin 1.9 호환성 가이드","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/compatibility-guide-19.md","filePath":"ko/kotlin/compatibility-guide-19.md","lastUpdated":1754307826000}'),l={name:"ko/kotlin/compatibility-guide-19.md"};function a(s,o,i,g,c,p){return r(),e("div",null,o[0]||(o[0]=[n('<h1 id="kotlin-1-9-호환성-가이드" tabindex="-1">Kotlin 1.9 호환성 가이드 <a class="header-anchor" href="#kotlin-1-9-호환성-가이드" aria-label="Permalink to &quot;Kotlin 1.9 호환성 가이드&quot;">​</a></h1><p>_<a href="/ko/kotlin/kotlin-evolution-principles">언어 현대성 유지</a>_와 _<a href="/ko/kotlin/kotlin-evolution-principles">편안한 업데이트</a>_는 코틀린 언어 디자인의 근본 원칙 중 일부입니다. 전자는 언어 발전을 저해하는 구성 요소는 제거되어야 한다고 말하고, 후자는 코드 마이그레이션이 가능한 한 원활하게 이루어질 수 있도록 이러한 제거가 사전에 잘 전달되어야 한다고 말합니다.</p><p>대부분의 언어 변경 사항은 업데이트 변경 로그나 컴파일러 경고와 같은 다른 채널을 통해 이미 발표되었지만, 이 문서는 Kotlin 1.8에서 Kotlin 1.9로 마이그레이션하기 위한 완벽한 참조를 제공하며 모든 내용을 요약합니다.</p><h2 id="기본-용어" tabindex="-1">기본 용어 <a class="header-anchor" href="#기본-용어" aria-label="Permalink to &quot;기본 용어&quot;">​</a></h2><p>이 문서에서는 여러 종류의 호환성을 소개합니다:</p><ul><li><em>소스</em>: 소스 비호환 변경은 (오류나 경고 없이) 잘 컴파일되던 코드가 더 이상 컴파일되지 않도록 합니다.</li><li><em>바이너리</em>: 두 바이너리 아티팩트는 서로 교환해도 로딩 또는 링크 오류가 발생하지 않으면 바이너리 호환된다고 합니다.</li><li><em>동작</em>: 동일한 프로그램이 변경 사항을 적용하기 전과 후에 다른 동작을 보인다면 해당 변경은 동작 비호환이라고 합니다.</li></ul><p>이러한 정의는 순수 Kotlin에만 해당된다는 점을 기억하십시오. 다른 언어(예: Java) 관점에서의 Kotlin 코드 호환성은 이 문서의 범위에 포함되지 않습니다.</p><h2 id="언어" tabindex="-1">언어 <a class="header-anchor" href="#언어" aria-label="Permalink to &quot;언어&quot;">​</a></h2><h3 id="언어-버전-1-3-제거" tabindex="-1">언어 버전 1.3 제거 <a class="header-anchor" href="#언어-버전-1-3-제거" aria-label="Permalink to &quot;언어 버전 1.3 제거&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-61111/Remove-language-version-1.3" target="_blank" rel="noreferrer">KT-61111</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.9는 언어 버전 1.9를 도입하고 언어 버전 1.3 지원을 제거합니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.6.0: 경고 보고</li><li>1.9.0: 경고를 오류로 상향 조정</li></ul></blockquote><h3 id="슈퍼-인터페이스-타입이-함수-리터럴일-때-슈퍼-생성자-호출-금지" tabindex="-1">슈퍼 인터페이스 타입이 함수 리터럴일 때 슈퍼 생성자 호출 금지 <a class="header-anchor" href="#슈퍼-인터페이스-타입이-함수-리터럴일-때-슈퍼-생성자-호출-금지" aria-label="Permalink to &quot;슈퍼 인터페이스 타입이 함수 리터럴일 때 슈퍼 생성자 호출 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-46344" target="_blank" rel="noreferrer">KT-46344</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: 인터페이스가 함수 리터럴 타입을 상속하는 경우, Kotlin 1.9는 해당 생성자가 존재하지 않으므로 슈퍼 생성자 호출을 금지합니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.7.0: 경고 보고 (또는 프로그레시브 모드에서는 오류)</li><li>1.9.0: 경고를 오류로 상향 조정</li></ul></blockquote><h3 id="어노테이션-파라미터-타입의-순환-금지" tabindex="-1">어노테이션 파라미터 타입의 순환 금지 <a class="header-anchor" href="#어노테이션-파라미터-타입의-순환-금지" aria-label="Permalink to &quot;어노테이션 파라미터 타입의 순환 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-47932" target="_blank" rel="noreferrer">KT-47932</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.9는 어노테이션 타입이 직접 또는 간접적으로 자신 파라미터 타입 중 하나로 사용되는 것을 금지합니다. 이는 순환 생성을 방지합니다. 하지만 어노테이션 타입의 <code>Array</code> 또는 <code>vararg</code>인 파라미터 타입은 허용됩니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.7.0: 어노테이션 파라미터 타입의 순환에 대해 경고 보고 (또는 프로그레시브 모드에서는 오류)</li><li>1.9.0: 경고를 오류로 상향 조정하며, <code>-XXLanguage:-ProhibitCyclesInAnnotations</code>를 사용하여 일시적으로 1.9 이전 동작으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="파라미터가-없는-함수-타입에-extensionfunctiontype-어노테이션-사용-금지" tabindex="-1">파라미터가 없는 함수 타입에 @ExtensionFunctionType 어노테이션 사용 금지 <a class="header-anchor" href="#파라미터가-없는-함수-타입에-extensionfunctiontype-어노테이션-사용-금지" aria-label="Permalink to &quot;파라미터가 없는 함수 타입에 @ExtensionFunctionType 어노테이션 사용 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-43527" target="_blank" rel="noreferrer">KT-43527</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.9는 파라미터가 없는 함수 타입 또는 함수 타입이 아닌 타입에 <code>@ExtensionFunctionType</code> 어노테이션을 사용하는 것을 금지합니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.7.0: 함수 타입이 아닌 타입의 어노테이션에 대해 경고 보고, 함수 타입인 타입의 어노테이션에 대해 오류 보고</li><li>1.9.0: 함수 타입에 대한 경고를 오류로 상향 조정</li></ul></blockquote><h3 id="할당-시-java-필드-타입-불일치-금지" tabindex="-1">할당 시 Java 필드 타입 불일치 금지 <a class="header-anchor" href="#할당-시-java-필드-타입-불일치-금지" aria-label="Permalink to &quot;할당 시 Java 필드 타입 불일치 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48994" target="_blank" rel="noreferrer">KT-48994</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.9는 Java 필드에 할당된 값의 타입이 Java 필드의 프로젝션된 타입과 일치하지 않는 경우 컴파일러 오류를 보고합니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.6.0: 프로젝션된 Java 필드 타입이 할당된 값 타입과 일치하지 않을 때 경고 보고 (또는 프로그레시브 모드에서는 오류)</li><li>1.9.0: 경고를 오류로 상향 조정하며, <code>-XXLanguage:-RefineTypeCheckingOnAssignmentsToJavaFields</code>를 사용하여 일시적으로 1.9 이전 동작으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="플랫폼-타입-널-가능성-단언-예외에-소스-코드-발췌-없음" tabindex="-1">플랫폼 타입 널 가능성 단언 예외에 소스 코드 발췌 없음 <a class="header-anchor" href="#플랫폼-타입-널-가능성-단언-예외에-소스-코드-발췌-없음" aria-label="Permalink to &quot;플랫폼 타입 널 가능성 단언 예외에 소스 코드 발췌 없음&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-57570" target="_blank" rel="noreferrer">KT-57570</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: Kotlin 1.9에서는 표현식 널 검사로 인해 발생하는 예외 메시지에 소스 코드 발췌가 포함되지 않습니다. 대신, 메서드 또는 필드의 이름이 표시됩니다. 표현식이 메서드나 필드가 아닌 경우, 메시지에 추가 정보가 제공되지 않습니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>&lt; 1.9.0: 표현식 널 검사로 인해 발생하는 예외 메시지에 소스 코드 발췌 포함</li><li>1.9.0: 표현식 널 검사로 인해 발생하는 예외 메시지에 메서드 또는 필드 이름만 포함되며, <code>-XXLanguage:-NoSourceCodeInNotNullAssertionExceptions</code>를 사용하여 일시적으로 1.9 이전 동작으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="슈퍼-호출을-추상-슈퍼클래스-멤버에-위임하는-것-금지" tabindex="-1">슈퍼 호출을 추상 슈퍼클래스 멤버에 위임하는 것 금지 <a class="header-anchor" href="#슈퍼-호출을-추상-슈퍼클래스-멤버에-위임하는-것-금지" aria-label="Permalink to &quot;슈퍼 호출을 추상 슈퍼클래스 멤버에 위임하는 것 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-45508" target="_blank" rel="noreferrer">KT-45508</a>, <a href="https://youtrack.jetbrains.com/issue/KT-49017" target="_blank" rel="noreferrer">KT-49017</a>, <a href="https://youtrack.jetbrains.com/issue/KT-38078" target="_blank" rel="noreferrer">KT-38078</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin은 명시적이거나 암시적인 슈퍼 호출이 슈퍼 인터페이스에 기본 구현이 있더라도 슈퍼클래스의 <em>추상</em> 멤버에 위임될 때 컴파일 오류를 보고합니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.5.20: 모든 추상 멤버를 오버라이드하지 않는 비추상 클래스가 사용될 때 경고 도입</li><li>1.7.0: 슈퍼 호출이 실제로 슈퍼클래스의 추상 멤버에 접근하는 경우 경고 보고</li><li>1.7.0: <code>-Xjvm-default=all</code> 또는 <code>-Xjvm-default=all-compatibility</code> 호환성 모드가 활성화된 경우 모든 해당 사례에 대해 오류 보고; 프로그레시브 모드에서 오류 보고</li><li>1.8.0: 슈퍼클래스의 오버라이드되지 않은 추상 메서드를 가진 구체 클래스를 선언하는 경우, 그리고 <code>Any</code> 메서드의 슈퍼 호출이 슈퍼클래스에서 추상으로 오버라이드된 경우 오류 보고</li><li>1.9.0: 슈퍼클래스의 추상 메서드에 대한 명시적 슈퍼 호출을 포함하여 모든 해당 사례에 대해 오류 보고</li></ul></blockquote><h3 id="주어가-있는-when-문에서-혼란스러운-문법-사용-중단" tabindex="-1">주어가 있는 when 문에서 혼란스러운 문법 사용 중단 <a class="header-anchor" href="#주어가-있는-when-문에서-혼란스러운-문법-사용-중단" aria-label="Permalink to &quot;주어가 있는 when 문에서 혼란스러운 문법 사용 중단&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48385" target="_blank" rel="noreferrer">KT-48385</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.6은 <code>when</code> 조건 표현식에서 여러 혼란스러운 문법 구성을 사용 중단했습니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.6.20: 해당 표현식에 대한 사용 중단 경고 도입</li><li>1.8.0: 이 경고를 오류로 상향 조정하며, <code>-XXLanguage:-ProhibitConfusingSyntaxInWhenBranches</code>를 사용하여 일시적으로 1.8 이전 동작으로 되돌릴 수 있습니다.</li><li>&gt;= 2.1: 일부 사용 중단된 구성을 새로운 언어 기능으로 재사용</li></ul></blockquote><h3 id="다른-숫자-타입-간의-암시적-강제-변환-방지" tabindex="-1">다른 숫자 타입 간의 암시적 강제 변환 방지 <a class="header-anchor" href="#다른-숫자-타입-간의-암시적-강제-변환-방지" aria-label="Permalink to &quot;다른 숫자 타입 간의 암시적 강제 변환 방지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48645" target="_blank" rel="noreferrer">KT-48645</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 동작</p><p><strong>요약</strong>: Kotlin은 의미론적으로 해당 타입으로의 다운캐스트만 필요한 경우, 숫자 값을 자동으로 기본 숫자 타입으로 변환하는 것을 피할 것입니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>&lt; 1.5.30: 모든 해당 사례에서 이전 동작</li><li>1.5.30: 생성된 프로퍼티 위임 접근자에서 다운캐스트 동작 수정하며, <code>-Xuse-old-backend</code>를 사용하여 일시적으로 1.5.30 수정 이전 동작으로 되돌릴 수 있습니다.</li><li>&gt;= 2.0: 다른 해당 사례에서 다운캐스트 동작 수정</li></ul></blockquote><h3 id="제네릭-타입-별칭-사용에서-상한-위반-금지-별칭-타입의-타입-인자의-제네릭-타입-인자에-사용된-타입-파라미터" tabindex="-1">제네릭 타입 별칭 사용에서 상한 위반 금지 (별칭 타입의 타입 인자의 제네릭 타입 인자에 사용된 타입 파라미터) <a class="header-anchor" href="#제네릭-타입-별칭-사용에서-상한-위반-금지-별칭-타입의-타입-인자의-제네릭-타입-인자에-사용된-타입-파라미터" aria-label="Permalink to &quot;제네릭 타입 별칭 사용에서 상한 위반 금지 (별칭 타입의 타입 인자의 제네릭 타입 인자에 사용된 타입 파라미터)&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-54066" target="_blank" rel="noreferrer">KT-54066</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin은 타입 별칭 타입 파라미터가 별칭 타입의 타입 인자의 제네릭 타입 인자로 사용되는 경우(예: <code>typealias Alias&lt;T&gt; = Base&lt;List&lt;T&gt;&gt;</code>), 별칭 타입의 해당 타입 파라미터의 상한 제약을 위반하는 타입 별칭 사용을 금지할 것입니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.8.0: 제네릭 타입 별칭 사용이 별칭 타입의 해당 타입 파라미터의 상한 제약을 위반하는 타입 인자를 가질 때 경고 보고</li><li>2.0.0: 경고를 오류로 상향 조정</li></ul></blockquote><h3 id="공용-시그니처에서-지역-타입을-근사화할-때-널-가능성-유지" tabindex="-1">공용 시그니처에서 지역 타입을 근사화할 때 널 가능성 유지 <a class="header-anchor" href="#공용-시그니처에서-지역-타입을-근사화할-때-널-가능성-유지" aria-label="Permalink to &quot;공용 시그니처에서 지역 타입을 근사화할 때 널 가능성 유지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-53982" target="_blank" rel="noreferrer">KT-53982</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스, 바이너리</p><p><strong>요약</strong>: 명시적으로 지정된 반환 타입 없이 표현식 본문 함수에서 지역 또는 익명 타입이 반환될 때, Kotlin 컴파일러는 해당 타입의 알려진 슈퍼타입을 사용하여 반환 타입을 추론(또는 근사화)합니다. 이 과정에서 컴파일러는 실제로는 널 값을 반환할 수 있는 경우에도 널이 아닌 타입을 추론할 수 있습니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.8.0: 유연한 슈퍼타입으로 유연한 타입 근사화</li><li>1.8.0: 선언이 널이 가능해야 하는 널이 아닌 타입으로 추론될 때 경고를 보고하여 사용자에게 타입을 명시적으로 지정하도록 유도</li><li>2.0.0: 널 가능 슈퍼타입으로 널 가능 타입 근사화하며, <code>-XXLanguage:-KeepNullabilityWhenApproximatingLocalType</code>를 사용하여 일시적으로 2.0 이전 동작으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="오버라이드를-통한-사용-중단-전파-방지" tabindex="-1">오버라이드를 통한 사용 중단 전파 방지 <a class="header-anchor" href="#오버라이드를-통한-사용-중단-전파-방지" aria-label="Permalink to &quot;오버라이드를 통한 사용 중단 전파 방지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-47902" target="_blank" rel="noreferrer">KT-47902</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.9는 슈퍼클래스의 사용 중단된 멤버에서 서브클래스의 오버라이딩 멤버로 사용 중단을 더 이상 전파하지 않을 것입니다. 이는 슈퍼클래스의 멤버를 사용 중단하면서도 서브클래스에서는 사용 중단되지 않은 상태로 유지하는 명시적인 메커니즘을 제공합니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.6.20: 향후 동작 변경에 대한 메시지와 함께 이 경고를 억제하거나 사용 중단된 멤버의 오버라이드에 <code>@Deprecated</code> 어노테이션을 명시적으로 작성하도록 유도하는 경고 보고</li><li>1.9.0: 오버라이드된 멤버로 사용 중단 상태 전파 중단. 이 변경 사항은 프로그레시브 모드에서도 즉시 적용됩니다.</li></ul></blockquote><h3 id="어노테이션-클래스에서-파라미터-선언-외의-어떤-곳에서도-컬렉션-리터럴-사용-금지" tabindex="-1">어노테이션 클래스에서 파라미터 선언 외의 어떤 곳에서도 컬렉션 리터럴 사용 금지 <a class="header-anchor" href="#어노테이션-클래스에서-파라미터-선언-외의-어떤-곳에서도-컬렉션-리터럴-사용-금지" aria-label="Permalink to &quot;어노테이션 클래스에서 파라미터 선언 외의 어떤 곳에서도 컬렉션 리터럴 사용 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.com/issue/KT-39041" target="_blank" rel="noreferrer">KT-39041</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin은 제한된 방식으로 컬렉션 리터럴 사용을 허용합니다. 즉, 어노테이션 클래스의 파라미터에 배열을 전달하거나 이 파라미터의 기본값을 지정하는 데 사용합니다. 그러나 그 외에도 Kotlin은 어노테이션 클래스 내부의 다른 곳, 예를 들어 중첩된 객체에서도 컬렉션 리터럴 사용을 허용했습니다. Kotlin 1.9는 어노테이션 클래스에서 파라미터의 기본값 외의 어떤 곳에서도 컬렉션 리터럴 사용을 금지할 것입니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.7.0: 어노테이션 클래스의 중첩된 객체 내 배열 리터럴에 대해 경고 보고 (또는 프로그레시브 모드에서는 오류)</li><li>1.9.0: 경고를 오류로 상향 조정</li></ul></blockquote><h3 id="기본값-표현식에서-파라미터의-전방-참조-금지" tabindex="-1">기본값 표현식에서 파라미터의 전방 참조 금지 <a class="header-anchor" href="#기본값-표현식에서-파라미터의-전방-참조-금지" aria-label="Permalink to &quot;기본값 표현식에서 파라미터의 전방 참조 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.com/issue/KT-25694" target="_blank" rel="noreferrer">KT-25694</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.9는 다른 파라미터의 기본값 표현식에서 파라미터의 전방 참조를 금지할 것입니다. 이는 파라미터가 기본값 표현식에서 접근될 때, 이미 함수에 전달되었거나 자체 기본값 표현식으로 초기화된 값을 가지고 있음을 보장합니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.7.0: 기본값을 가진 파라미터가 그보다 앞에 오는 다른 파라미터의 기본값에서 참조될 때 경고 보고 (또는 프로그레시브 모드에서는 오류)</li><li>1.9.0: 경고를 오류로 상향 조정하며, <code>-XXLanguage:-ProhibitIllegalValueParameterUsageInDefaultArguments</code>를 사용하여 일시적으로 1.9 이전 동작으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="인라인-함수형-파라미터에-대한-확장-호출-금지" tabindex="-1">인라인 함수형 파라미터에 대한 확장 호출 금지 <a class="header-anchor" href="#인라인-함수형-파라미터에-대한-확장-호출-금지" aria-label="Permalink to &quot;인라인 함수형 파라미터에 대한 확장 호출 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-52502" target="_blank" rel="noreferrer">KT-52502</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin은 인라인 함수형 파라미터를 다른 인라인 함수에 리시버로 전달하는 것을 허용했지만, 그러한 코드를 컴파일할 때 항상 컴파일러 예외가 발생했습니다. Kotlin 1.9는 이를 금지하여 컴파일러 충돌 대신 오류를 보고할 것입니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.7.20: 인라인 함수형 파라미터에 대한 인라인 확장 호출에 대해 경고 보고 (또는 프로그레시브 모드에서는 오류)</li><li>1.9.0: 경고를 오류로 상향 조정</li></ul></blockquote><h3 id="익명-함수-인자를-가진-suspend라는-이름의-중위-함수-호출-금지" tabindex="-1">익명 함수 인자를 가진 <code>suspend</code>라는 이름의 중위 함수 호출 금지 <a class="header-anchor" href="#익명-함수-인자를-가진-suspend라는-이름의-중위-함수-호출-금지" aria-label="Permalink to &quot;익명 함수 인자를 가진 `suspend`라는 이름의 중위 함수 호출 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-49264" target="_blank" rel="noreferrer">KT-49264</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.9는 익명 함수 리터럴로 전달된 함수형 타입의 단일 인자를 가진 <code>suspend</code>라는 이름의 중위 함수를 더 이상 호출하는 것을 허용하지 않을 것입니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.7.20: 익명 함수 리터럴을 사용한 <code>suspend</code> 중위 호출에 대해 경고 보고</li><li>1.9.0: 경고를 오류로 상향 조정하며, <code>-XXLanguage:-ModifierNonBuiltinSuspendFunError</code>를 사용하여 일시적으로 1.9 이전 동작으로 되돌릴 수 있습니다.</li><li>TODO: 파서가 <code>suspend fun</code> 토큰 시퀀스를 해석하는 방식 변경</li></ul></blockquote><h3 id="이너-클래스에서-캡처된-타입-파라미터를-해당-분산에-반하여-사용하는-것-금지" tabindex="-1">이너 클래스에서 캡처된 타입 파라미터를 해당 분산에 반하여 사용하는 것 금지 <a class="header-anchor" href="#이너-클래스에서-캡처된-타입-파라미터를-해당-분산에-반하여-사용하는-것-금지" aria-label="Permalink to &quot;이너 클래스에서 캡처된 타입 파라미터를 해당 분산에 반하여 사용하는 것 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-50947" target="_blank" rel="noreferrer">KT-50947</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.9는 외부 클래스의 <code>in</code> 또는 <code>out</code> 분산을 가진 타입 파라미터를 해당 타입 파라미터의 선언된 분산을 위반하는 위치에서 해당 클래스의 이너 클래스에서 사용하는 것을 금지할 것입니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.7.0: 외부 클래스의 타입 파라미터 사용 위치가 해당 파라미터의 분산 규칙을 위반할 때 경고 보고 (또는 프로그레시브 모드에서는 오류)</li><li>1.9.0: 경고를 오류로 상향 조정하며, <code>-XXLanguage:-ReportTypeVarianceConflictOnQualifierArguments</code>를 사용하여 일시적으로 1.9 이전 동작으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="복합-할당-연산자에서-명시적-반환-타입이-없는-함수의-재귀-호출-금지" tabindex="-1">복합 할당 연산자에서 명시적 반환 타입이 없는 함수의 재귀 호출 금지 <a class="header-anchor" href="#복합-할당-연산자에서-명시적-반환-타입이-없는-함수의-재귀-호출-금지" aria-label="Permalink to &quot;복합 할당 연산자에서 명시적 반환 타입이 없는 함수의 재귀 호출 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48546" target="_blank" rel="noreferrer">KT-48546</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.9는 명시적으로 지정된 반환 타입이 없는 함수를 해당 함수 본문 내의 복합 할당 연산자 인자에서 재귀적으로 호출하는 것을 금지할 것입니다. 이는 현재 해당 함수 본문 내의 다른 표현식에서와 동일하게 적용됩니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.7.0: 명시적으로 지정된 반환 타입이 없는 함수가 해당 함수 본문의 복합 할당 연산자 인자에서 재귀적으로 호출될 때 경고 보고 (또는 프로그레시브 모드에서는 오류)</li><li>1.9.0: 경고를 오류로 상향 조정</li></ul></blockquote><h3 id="notnull-t가-예상되고-널-가능-바운드를-가진-kotlin-제네릭-파라미터가-주어진-경우-건전하지-않은-호출-금지" tabindex="-1">@NotNull T가 예상되고 널 가능 바운드를 가진 Kotlin 제네릭 파라미터가 주어진 경우 건전하지 않은 호출 금지 <a class="header-anchor" href="#notnull-t가-예상되고-널-가능-바운드를-가진-kotlin-제네릭-파라미터가-주어진-경우-건전하지-않은-호출-금지" aria-label="Permalink to &quot;@NotNull T가 예상되고 널 가능 바운드를 가진 Kotlin 제네릭 파라미터가 주어진 경우 건전하지 않은 호출 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-36770" target="_blank" rel="noreferrer">KT-36770</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.9는 잠재적으로 널 가능한 제네릭 타입의 값이 Java 메서드의 <code>@NotNull</code> 어노테이션이 달린 파라미터에 전달되는 메서드 호출을 금지할 것입니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.5.20: 널이 아닌 타입이 예상되는 곳에 제약 없는 제네릭 타입 파라미터가 전달될 때 경고 보고</li><li>1.9.0: 위 경고 대신 타입 불일치 오류를 보고하며, <code>-XXLanguage:-ProhibitUsingNullableTypeParameterAgainstNotNullAnnotated</code>를 사용하여 일시적으로 1.8 이전 동작으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="열거형의-엔트리-초기화자에서-열거형-클래스의-동반-객체-멤버-접근-금지" tabindex="-1">열거형의 엔트리 초기화자에서 열거형 클래스의 동반 객체 멤버 접근 금지 <a class="header-anchor" href="#열거형의-엔트리-초기화자에서-열거형-클래스의-동반-객체-멤버-접근-금지" aria-label="Permalink to &quot;열거형의 엔트리 초기화자에서 열거형 클래스의 동반 객체 멤버 접근 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-49110" target="_blank" rel="noreferrer">KT-49110</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.9는 열거형 엔트리 초기화자에서 열거형의 동반 객체에 대한 모든 종류의 접근을 금지할 것입니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.6.20: 그러한 동반 멤버 접근에 대해 경고 보고 (또는 프로그레시브 모드에서는 오류)</li><li>1.9.0: 경고를 오류로 상향 조정하며, <code>-XXLanguage:-ProhibitAccessToEnumCompanionMembersInEnumConstructorCall</code>를 사용하여 일시적으로 1.8 이전 동작으로 되돌릴 수 있습니다.</li></ul></blockquote><h3 id="enum-declaringclass-합성-프로퍼티-사용-중단-및-제거" tabindex="-1">Enum.declaringClass 합성 프로퍼티 사용 중단 및 제거 <a class="header-anchor" href="#enum-declaringclass-합성-프로퍼티-사용-중단-및-제거" aria-label="Permalink to &quot;Enum.declaringClass 합성 프로퍼티 사용 중단 및 제거&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-49653" target="_blank" rel="noreferrer">KT-49653</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin은 기본 Java 클래스 <code>java.lang.Enum</code>의 <code>getDeclaringClass()</code> 메서드에서 생성된 <code>Enum</code> 값에 대해 합성 프로퍼티 <code>declaringClass</code>를 사용하는 것을 허용했지만, 이 메서드는 Kotlin <code>Enum</code> 타입에서는 사용할 수 없습니다. Kotlin 1.9는 이 프로퍼티 사용을 금지하고, 대신 확장 프로퍼티 <code>declaringJavaClass</code>로 마이그레이션할 것을 제안합니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.7.0: <code>declaringClass</code> 프로퍼티 사용에 대해 경고 보고 (또는 프로그레시브 모드에서는 오류), <code>declaringJavaClass</code> 확장으로 마이그레이션 제안</li><li>1.9.0: 경고를 오류로 상향 조정하며, <code>-XXLanguage:-ProhibitEnumDeclaringClass</code>를 사용하여 일시적으로 1.9 이전 동작으로 되돌릴 수 있습니다.</li><li>2.0.0: <code>declaringClass</code> 합성 프로퍼티 제거</li></ul></blockquote><h3 id="컴파일러-옵션-xjvm-default의-enable-및-compatibility-모드-사용-중단" tabindex="-1">컴파일러 옵션 <code>-Xjvm-default</code>의 <code>enable</code> 및 <code>compatibility</code> 모드 사용 중단 <a class="header-anchor" href="#컴파일러-옵션-xjvm-default의-enable-및-compatibility-모드-사용-중단" aria-label="Permalink to &quot;컴파일러 옵션 `-Xjvm-default`의 `enable` 및 `compatibility` 모드 사용 중단&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-46329" target="_blank" rel="noreferrer">KT-46329</a>, <a href="https://youtrack.jetbrains.com/issue/KT-54746" target="_blank" rel="noreferrer">KT-54746</a></p><p><strong>구성 요소</strong>: Kotlin/JVM</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.9는 <code>-Xjvm-default</code> 컴파일러 옵션의 <code>enable</code> 및 <code>compatibility</code> 모드 사용을 금지합니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.6.20: <code>-Xjvm-default</code> 컴파일러 옵션의 <code>enable</code> 및 <code>compatibility</code> 모드에 대한 경고 도입</li><li>1.9.0: 이 경고를 오류로 상향 조정</li></ul></blockquote><h3 id="빌더-추론-컨텍스트에서-타입-변수를-상한으로-암시적으로-추론하는-것-금지" tabindex="-1">빌더 추론 컨텍스트에서 타입 변수를 상한으로 암시적으로 추론하는 것 금지 <a class="header-anchor" href="#빌더-추론-컨텍스트에서-타입-변수를-상한으로-암시적으로-추론하는-것-금지" aria-label="Permalink to &quot;빌더 추론 컨텍스트에서 타입 변수를 상한으로 암시적으로 추론하는 것 금지&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-47986" target="_blank" rel="noreferrer">KT-47986</a></p><p><strong>구성 요소</strong>: 코어 언어</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 2.0은 빌더 추론 람다 함수의 범위에서 사용 사이트 타입 정보가 없을 때, 타입 변수를 해당 타입 파라미터의 상한으로 추론하는 것을 금지할 것입니다. 이는 현재 다른 컨텍스트에서와 동일한 방식입니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.7.20: 사용 사이트 타입 정보가 없을 때 타입 파라미터가 선언된 상한으로 추론될 때 경고 보고 (또는 프로그레시브 모드에서는 오류)</li><li>2.0.0: 경고를 오류로 상향 조정</li></ul></blockquote><h2 id="표준-라이브러리" tabindex="-1">표준 라이브러리 <a class="header-anchor" href="#표준-라이브러리" aria-label="Permalink to &quot;표준 라이브러리&quot;">​</a></h2><h3 id="range-progression이-collection을-구현하기-시작할-때-잠재적인-오버로드-결정-변경에-대해-경고" tabindex="-1">Range/Progression이 Collection을 구현하기 시작할 때 잠재적인 오버로드 결정 변경에 대해 경고 <a class="header-anchor" href="#range-progression이-collection을-구현하기-시작할-때-잠재적인-오버로드-결정-변경에-대해-경고" aria-label="Permalink to &quot;Range/Progression이 Collection을 구현하기 시작할 때 잠재적인 오버로드 결정 변경에 대해 경고&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-49276" target="_blank" rel="noreferrer">KT-49276</a></p><p><strong>구성 요소</strong>: 코어 언어 / kotlin-stdlib</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Kotlin 1.9에서는 표준 Progression과 그로부터 상속된 구체적인 Range에 <code>Collection</code> 인터페이스를 구현할 계획입니다. 이는 어떤 메서드에 두 가지 오버로드(하나는 요소, 다른 하나는 컬렉션을 허용)가 있을 때 오버로드 결정에서 다른 오버로드가 선택될 수 있도록 할 수 있습니다. Kotlin은 Range 또는 Progression 인자로 그러한 오버로드된 메서드가 호출될 때 경고 또는 오류를 보고하여 이 상황을 가시화할 것입니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.6.20: 표준 Progression 또는 해당 Range 상속자를 인자로 사용하여 오버로드된 메서드가 호출될 때, 이 Progression/Range가 <code>Collection</code> 인터페이스를 구현하면 향후 이 호출에서 다른 오버로드가 선택될 수 있음을 경고 보고</li><li>1.8.0: 이 경고를 오류로 상향 조정</li><li>2.1.0: 오류 보고 중단, Progression에 <code>Collection</code> 인터페이스 구현하여 해당 사례에서 오버로드 결정 결과 변경</li></ul></blockquote><h3 id="kotlin-dom-및-kotlin-browser-패키지의-선언을-kotlinx-로-마이그레이션" tabindex="-1">kotlin.dom 및 kotlin.browser 패키지의 선언을 kotlinx.*로 마이그레이션 <a class="header-anchor" href="#kotlin-dom-및-kotlin-browser-패키지의-선언을-kotlinx-로-마이그레이션" aria-label="Permalink to &quot;kotlin.dom 및 kotlin.browser 패키지의 선언을 kotlinx.*로 마이그레이션&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-39330" target="_blank" rel="noreferrer">KT-39330</a></p><p><strong>구성 요소</strong>: kotlin-stdlib (JS)</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: <code>kotlin.dom</code> 및 <code>kotlin.browser</code> 패키지의 선언은 stdlib에서 추출하기 위한 준비로 해당 <code>kotlinx.*</code> 패키지로 이동됩니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.4.0: <code>kotlinx.dom</code> 및 <code>kotlinx.browser</code> 패키지에 대체 API 도입</li><li>1.4.0: <code>kotlin.dom</code> 및 <code>kotlin.browser</code> 패키지의 API를 사용 중단하고 위 새로운 API를 대체제로 제안</li><li>1.6.0: 사용 중단 수준을 오류로 상향 조정</li><li>1.8.20: JS-IR 타겟용 stdlib에서 사용 중단된 함수 제거</li><li>&gt;= 2.0: kotlinx.* 패키지의 API를 별도 라이브러리로 이동</li></ul></blockquote><h3 id="일부-js-전용-api-사용-중단" tabindex="-1">일부 JS 전용 API 사용 중단 <a class="header-anchor" href="#일부-js-전용-api-사용-중단" aria-label="Permalink to &quot;일부 JS 전용 API 사용 중단&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48587" target="_blank" rel="noreferrer">KT-48587</a></p><p><strong>구성 요소</strong>: kotlin-stdlib (JS)</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: stdlib의 여러 JS 전용 함수가 제거를 위해 사용 중단됩니다. 여기에는 <code>String.concat(String)</code>, <code>String.match(regex: String)</code>, <code>String.matches(regex: String)</code> 및 비교 함수를 인자로 받는 배열의 <code>sort</code> 함수(예: <code>Array&lt;out T&gt;.sort(comparison: (a: T, b: T) -&gt; Int)</code>)가 포함됩니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.6.0: 해당 함수를 경고와 함께 사용 중단</li><li>1.9.0: 사용 중단 수준을 오류로 상향 조정</li><li>&gt;=2.0: 퍼블릭 API에서 사용 중단된 함수 제거</li></ul></blockquote><h2 id="도구" tabindex="-1">도구 <a class="header-anchor" href="#도구" aria-label="Permalink to &quot;도구&quot;">​</a></h2><h3 id="gradle-설정에서-enableendorsedlibs-플래그-제거" tabindex="-1">Gradle 설정에서 enableEndorsedLibs 플래그 제거 <a class="header-anchor" href="#gradle-설정에서-enableendorsedlibs-플래그-제거" aria-label="Permalink to &quot;Gradle 설정에서 enableEndorsedLibs 플래그 제거&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-54098" target="_blank" rel="noreferrer">KT-54098</a></p><p><strong>구성 요소</strong>: Gradle</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: <code>enableEndorsedLibs</code> 플래그는 더 이상 Gradle 설정에서 지원되지 않습니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>&lt; 1.9.0: <code>enableEndorsedLibs</code> 플래그가 Gradle 설정에서 지원됨</li><li>1.9.0: <code>enableEndorsedLibs</code> 플래그는 Gradle 설정에서 <strong>지원되지 않음</strong></li></ul></blockquote><h3 id="gradle-컨벤션-제거" tabindex="-1">Gradle 컨벤션 제거 <a class="header-anchor" href="#gradle-컨벤션-제거" aria-label="Permalink to &quot;Gradle 컨벤션 제거&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-52976" target="_blank" rel="noreferrer">KT-52976</a></p><p><strong>구성 요소</strong>: Gradle</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: Gradle 컨벤션은 Gradle 7.1에서 사용 중단되었으며 Gradle 8에서 제거되었습니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.7.20: Gradle 컨벤션 사용 중단</li><li>1.9.0: Gradle 컨벤션 제거</li></ul></blockquote><h3 id="kotlincompile-태스크의-classpath-프로퍼티-제거" tabindex="-1">KotlinCompile 태스크의 classpath 프로퍼티 제거 <a class="header-anchor" href="#kotlincompile-태스크의-classpath-프로퍼티-제거" aria-label="Permalink to &quot;KotlinCompile 태스크의 classpath 프로퍼티 제거&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-53748" target="_blank" rel="noreferrer">KT-53748</a></p><p><strong>구성 요소</strong>: Gradle</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: <code>KotlinCompile</code> 태스크의 <code>classpath</code> 프로퍼티가 제거됩니다.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.7.0: <code>classpath</code> 프로퍼티 사용 중단</li><li>1.8.0: 사용 중단 수준을 오류로 상향 조정</li><li>1.9.0: 퍼블릭 API에서 사용 중단된 함수 제거</li></ul></blockquote><h3 id="kotlin-internal-single-build-metrics-file-프로퍼티-사용-중단" tabindex="-1">kotlin.internal.single.build.metrics.file 프로퍼티 사용 중단 <a class="header-anchor" href="#kotlin-internal-single-build-metrics-file-프로퍼티-사용-중단" aria-label="Permalink to &quot;kotlin.internal.single.build.metrics.file 프로퍼티 사용 중단&quot;">​</a></h3><blockquote><p><strong>이슈</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-53357" target="_blank" rel="noreferrer">KT-53357</a></p><p><strong>구성 요소</strong>: Gradle</p><p><strong>비호환 변경 유형</strong>: 소스</p><p><strong>요약</strong>: 빌드 보고서용 단일 파일을 정의하는 데 사용되는 <code>kotlin.internal.single.build.metrics.file</code> 프로퍼티를 사용 중단합니다. 대신 <code>kotlin.build.report.output=single_file</code>과 함께 <code>kotlin.build.report.single_file</code> 프로퍼티를 사용하십시오.</p><p><strong>사용 중단 주기</strong>:</p><ul><li>1.8.0: 사용 중단 수준을 경고로 상향 조정</li><li>&gt;= 1.9: 프로퍼티 삭제</li></ul></blockquote>',70)]))}const h=t(l,[["render",a]]);export{u as __pageData,h as default};
