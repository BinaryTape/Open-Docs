import{_ as g}from"./chunks/icon-1-done.ZX9lW-aj.js";import{_ as o}from"./chunks/icon-2-done.DCMUaFG5.js";import{_ as y}from"./chunks/icon-3.BwKvTetO.js";import{_ as F}from"./chunks/icon-4-todo.GaeEmerm.js";import{_ as c,a as u,b as C,c as B}from"./chunks/retrieve-message-by-its-id.Bu3w1K2P.js";import{_ as m,C as k,c as A,o as b,j as s,G as n,ag as p,a,w as l}from"./chunks/framework.Bksy39di.js";const j=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/jvm-spring-boot-add-db-support.md","filePath":"kotlin/jvm-spring-boot-add-db-support.md","lastUpdated":1754307826000}'),D={name:"kotlin/jvm-spring-boot-add-db-support.md"};function v(q,i,f,S,M,T){const r=k("web-summary"),d=k("tldr"),h=k("code-block"),t=k("def"),e=k("deflist"),E=k("list");return b(),A("div",null,[i[31]||(i[31]=s("h1",{id:"为-spring-boot-项目添加数据库支持",tabindex:"-1"},[a("为 Spring Boot 项目添加数据库支持 "),s("a",{class:"header-anchor",href:"#为-spring-boot-项目添加数据库支持","aria-label":'Permalink to "为 Spring Boot 项目添加数据库支持"'},"​")],-1)),n(r,null,{default:l(()=>i[0]||(i[0]=[a("为使用 Kotlin 编写的 Spring Boot 项目添加数据库支持，并使用 JDBC 模板。")])),_:1}),n(d,null,{default:l(()=>i[1]||(i[1]=[s("p",null,[a("这是《"),s("strong",null,"Spring Boot 和 Kotlin 入门"),a("》教程的第三部分。在继续之前，请确保您已完成以下步骤：")],-1),s("br",null,null,-1),s("p",null,[s("img",{src:g,width:"20",alt:"First step"}),a(),s("a",{href:"/kotlin/jvm-create-project-with-spring-boot"},"使用 Kotlin 创建 Spring Boot 项目"),s("br"),s("img",{src:o,width:"20",alt:"Second step"}),a(),s("a",{href:"/kotlin/jvm-spring-boot-add-data-class"},"向 Spring Boot 项目添加数据类"),s("br"),s("img",{src:y,width:"20",alt:"Third step"}),a(),s("strong",null,"为 Spring Boot 项目添加数据库支持"),s("br"),s("img",{src:F,width:"20",alt:"Fourth step"}),a(" 使用 Spring Data CrudRepository 进行数据库访问")],-1)])),_:1}),i[32]||(i[32]=p("",5)),n(e,{collapsible:"true"},{default:l(()=>[n(t,{title:"构造函数实参与依赖项注入 – (private val db: JdbcTemplate)"},{default:l(()=>[i[3]||(i[3]=s("p",null,[a("Kotlin 中的类有一个主构造函数。它还可以有一个或多个 "),s("a",{href:"/kotlin/classes#secondary-constructors"},"次构造函数"),a("。 "),s("em",null,"主构造函数"),a(" 是类头的一部分，它位于类名和可选的类型形参之后。在我们的例子中，构造函数是 "),s("code",null,"(val db: JdbcTemplate)"),a("。")],-1)),i[4]||(i[4]=s("p",null,[s("code",null,"val db: JdbcTemplate"),a(" 是构造函数的实参：")],-1)),n(h,{lang:"kotlin"},{default:l(()=>i[2]||(i[2]=[a(" @Service class MessageService(private val db: JdbcTemplate) ")])),_:1})]),_:1}),n(t,{title:"尾随 lambda 表达式与 SAM 转换"},{default:l(()=>[i[8]||(i[8]=s("p",null,[s("code",null,"findMessages()"),a(" 函数调用 "),s("code",null,"JdbcTemplate"),a(" 类的 "),s("code",null,"query()"),a(" 函数。"),s("code",null,"query()"),a(" 函数接受两个实参：一个作为 String 实例的 SQL 查询，以及一个将每行映射为一个对象的回调：")],-1)),n(h,{lang:"sql"},{default:l(()=>i[5]||(i[5]=[a(' db.query("...", RowMapper { ... } ) ')])),_:1}),i[9]||(i[9]=s("br",null,null,-1)),i[10]||(i[10]=s("p",null,[s("code",null,"RowMapper"),a(" 接口只声明了一个方法，因此可以通过省略接口名称，用 lambda 表达式实现它。Kotlin 编译器知道 lambda 表达式需要转换成的接口，因为您将其用作函数调用的形参。这在 Kotlin 中被称为 "),s("a",{href:"/kotlin/java-interop#sam-conversions"},"SAM 转换"),a("：")],-1)),n(h,{lang:"sql"},{default:l(()=>i[6]||(i[6]=[a(' db.query("...", { ... } ) ')])),_:1}),i[11]||(i[11]=s("br",null,null,-1)),i[12]||(i[12]=s("p",null,[a("SAM 转换后，query 函数最终得到两个实参：第一个位置的 String 和最后一个位置的 lambda 表达式。根据 Kotlin 约定，如果函数的最后一个形参是函数，则作为相应实参传递的 lambda 表达式可以放在圆括号之外。这种语法也被称为 "),s("a",{href:"/kotlin/lambdas#passing-trailing-lambdas"},"尾随 lambda 表达式"),a("：")],-1)),n(h,{lang:"sql"},{default:l(()=>i[7]||(i[7]=[a(' db.query("...") { ... } ')])),_:1})]),_:1}),n(t,{title:"未使用的 lambda 实参的下划线"},{default:l(()=>[i[14]||(i[14]=s("p",null,[a("对于带有多个形参的 lambda 表达式，您可以使用下划线 "),s("code",null,"_"),a(" 字符来替换您未使用的形参名称。")],-1)),i[15]||(i[15]=s("p",null,"因此，query 函数调用的最终语法如下所示：",-1)),n(h,{lang:"kotlin"},{default:l(()=>i[13]||(i[13]=[a(' db.query("select * from messages") { response, _ -> Message(response.getString("id"), response.getString("text")) } ')])),_:1})]),_:1})]),_:1}),i[33]||(i[33]=p("",3)),n(e,{collapsible:"true"},{default:l(()=>[n(t,{title:"@PostMapping 注解"},{default:l(()=>i[16]||(i[16]=[s("p",null,[a("负责处理 HTTP POST 请求的方法需要使用 "),s("code",null,"@PostMapping"),a(" 注解进行标注。为了能够将作为 HTTP 主体内容发送的 JSON 转换为对象，您需要为方法实参使用 "),s("code",null,"@RequestBody"),a(" 注解。多亏了应用程序类路径中包含 Jackson 库，转换会自动发生。")],-1)])),_:1}),n(t,{title:"ResponseEntity"},{default:l(()=>i[17]||(i[17]=[s("p",null,[s("code",null,"ResponseEntity"),a(" 代表整个 HTTP 响应：状态码、头信息和主体。")],-1),s("p",null,[a(" 使用 "),s("code",null,"created()"),a(" 方法，您可以配置响应状态码 (201) 并设置 location 头，指示所创建资源的上下文路径。")],-1)])),_:1})]),_:1}),i[34]||(i[34]=p("",6)),n(e,{collapsible:"true"},{default:l(()=>[n(t,{title:"Elvis 操作符 – ?:"},{default:l(()=>i[18]||(i[18]=[s("p",null,[a("代码 "),s("code",null,"message.id ?: UUID.randomUUID().toString()"),a(" 使用了 "),s("a",{href:"/kotlin/null-safety#elvis-operator"},[a("Elvis 操作符（非空即取简写） "),s("code",null,"?:")]),a("。如果 "),s("code",null,"?:"),a(" 左侧的表达式不为 "),s("code",null,"null"),a("，Elvis 操作符会返回它；否则，它会返回右侧的表达式。请注意，右侧的表达式仅在左侧为 "),s("code",null,"null"),a(" 时才会被求值。")],-1)])),_:1})]),_:1}),i[35]||(i[35]=p("",7)),i[36]||(i[36]=s("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"执行请求的另一种方式",tabindex:"-1"},[a("执行请求的另一种方式 "),s("a",{class:"header-anchor",href:"#执行请求的另一种方式","aria-label":'Permalink to "执行请求的另一种方式 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),i[37]||(i[37]=p("",4)),s("ol",null,[s("li",null,[i[23]||(i[23]=p("",2)),n(e,{collapsible:"true"},{default:l(()=>[n(t,{title:"vararg 实参在形参列表中的位置"},{default:l(()=>[i[20]||(i[20]=s("p",null,[s("code",null,"query()"),a(" 函数接受三个实参：")],-1)),n(E,null,{default:l(()=>i[19]||(i[19]=[s("li",null,"需要一个形参才能运行的 SQL 查询字符串",-1),s("li",null,[s("code",null,"id"),a("，一个 String 类型的形参")],-1),s("li",null,[s("code",null,"RowMapper"),a(" 实例，通过 lambda 表达式实现")],-1)])),_:1}),i[21]||(i[21]=s("p",null,[s("code",null,"query()"),a(" 函数的第二个形参被声明为 "),s("em",null,"可变实参"),a(" ("),s("code",null,"vararg"),a(")。在 Kotlin 中，可变实参形参的位置不要求是形参列表中的最后一个。")],-1))]),_:1}),n(t,{title:"singleOrNull() 函数"},{default:l(()=>i[22]||(i[22]=[s("p",null,[s("a",{href:"https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.collections/single-or-null.html"},[s("code",null,"singleOrNull()")]),a(" 函数返回单个元素，如果数组为空或有多个具有相同值的元素，则返回 "),s("code",null,"null"),a("。")],-1)])),_:1})]),_:1}),i[24]||(i[24]=s("div",{class:"danger custom-block"},[s("p",{class:"custom-block-title"},"WARNING"),s("p",null,[a("用于通过其 id 获取消息的 "),s("code",null,".query()"),a(" 函数是一个 "),s("a",{href:"/kotlin/extensions#extension-functions"},"Kotlin 扩展函数"),a("， 由 Spring Framework 提供。它需要额外导入 "),s("code",null,"import org.springframework.jdbc.core.query"),a("，如上面代码所示。")])],-1))]),s("li",null,[i[30]||(i[30]=p("",2)),n(e,{collapsible:"true"},{default:l(()=>[n(t,{title:"从上下文路径中检索值"},{default:l(()=>i[25]||(i[25]=[s("p",null,[a("消息 "),s("code",null,"id"),a(" 由 Spring Framework 从上下文路径中检索，因为您使用 "),s("code",null,'@GetMapping("/{id}")'),a(" 注解了新函数。通过使用 "),s("code",null,"@PathVariable"),a(" 注解函数实参，您告诉框架将检索到的值用作函数实参。新函数调用 "),s("code",null,"MessageService"),a("，以通过其 id 检索单个消息。")],-1)])),_:1}),n(t,{title:"带可空接收者的扩展函数"},{default:l(()=>[i[27]||(i[27]=s("p",null,[a("扩展可以被定义为带可空接收者类型。如果接收者为 "),s("code",null,"null"),a("，那么 "),s("code",null,"this"),a(" 也为 "),s("code",null,"null"),a("。因此，在定义带可空接收者类型的扩展时，建议在函数体内部执行 "),s("code",null,"this == null"),a(" 检测。")],-1)),i[28]||(i[28]=s("p",null,[a("您也可以使用空安全调用操作符 ("),s("code",null,"?."),a(") 来执行空检测，如上面的 "),s("code",null,"toResponseEntity()"),a(" 函数所示：")],-1)),n(h,{lang:"kotlin"},{default:l(()=>i[26]||(i[26]=[a(" this?.let { ResponseEntity.ok(it) } ")])),_:1})]),_:1}),n(t,{title:"ResponseEntity"},{default:l(()=>i[29]||(i[29]=[s("p",null,[s("code",null,"ResponseEntity"),a(" 代表 HTTP 响应，包括状态码、头信息和主体。它是一个通用封装器，允许您将自定义 HTTP 响应发送回客户端，并对内容有更多控制权。")],-1)])),_:1})]),_:1})])]),i[38]||(i[38]=p("",11))])}const V=m(D,[["render",v]]);export{j as __pageData,V as default};
