import{_ as k,C as e,c as d,o,ag as h,j as s,G as t,a as i,w as n}from"./chunks/framework.Bksy39di.js";const b=JSON.parse('{"title":"从 Kotlin 调用 Java","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/java-interop.md","filePath":"kotlin/java-interop.md","lastUpdated":1754307826000}'),r={name:"kotlin/java-interop.md"};function E(c,a,g,y,u,F){const l=e("tab"),p=e("tabs");return o(),d("div",null,[a[2]||(a[2]=h(`<h1 id="从-kotlin-调用-java" tabindex="-1">从 Kotlin 调用 Java <a class="header-anchor" href="#从-kotlin-调用-java" aria-label="Permalink to &quot;从 Kotlin 调用 Java&quot;">​</a></h1><p>Kotlin 的设计考虑了 Java 互操作性。现有的 Java 代码可以很自然地从 Kotlin 中调用，Kotlin 代码也可以相当流畅地从 Java 中使用。本节将详细介绍从 Kotlin 调用 Java 代码的一些细节。</p><p>几乎所有的 Java 代码都可以毫无问题地使用：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> java.util.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> demo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(source: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // &#39;for&#39; 循环适用于 Java 集合：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 操作符约定也同样适用：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">source.size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        list[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source[i] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调用 get 和 set</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="getters-和-setters" tabindex="-1">Getters 和 setters <a class="header-anchor" href="#getters-和-setters" aria-label="Permalink to &quot;Getters 和 setters&quot;">​</a></h2><p>遵循 Java getter 和 setter 约定的方法（无实参且名称以 <code>get</code> 开头的方法，以及单个实参且名称以 <code>set</code> 开头的方法）在 Kotlin 中表示为属性。此类属性也称为 <em>合成属性</em>。<code>Boolean</code> 访问器方法（其中 getter 的名称以 <code>is</code> 开头，setter 的名称以 <code>set</code> 开头）表示为与 getter 方法同名的属性。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> java.util.Calendar</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> calendarDemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> calendar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Calendar.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (calendar.firstDayOfWeek </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Calendar.SUNDAY) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调用 getFirstDayOfWeek()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        calendar.firstDayOfWeek </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Calendar.MONDAY </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调用 setFirstDayOfWeek()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">calendar.isLenient) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调用 isLenient()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        calendar.isLenient </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 调用 setLenient()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>上述 <code>calendar.firstDayOfWeek</code> 是合成属性的一个示例。</p><p>请注意，如果 Java 类只包含一个 setter，则它在 Kotlin 中不会显示为属性，因为 Kotlin 不支持仅有 setter 的属性。</p><h2 id="java-合成属性引用" tabindex="-1">Java 合成属性引用 <a class="header-anchor" href="#java-合成属性引用" aria-label="Permalink to &quot;Java 合成属性引用&quot;">​</a></h2><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>此特性是 <a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>。它可能随时被删除或更改。我们建议您仅将其用于求值目的。</p></div><p>从 Kotlin 1.8.20 开始，你可以创建对 Java 合成属性的引用。考虑以下 Java 代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String name;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getAge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Kotlin 一直允许你编写 <code>person.age</code>，其中 <code>age</code> 是一个合成属性。现在，你还可以创建对 <code>Person::age</code> 和 <code>person::age</code> 的引用。<code>name</code> 也适用同样的情况。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> persons </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Jack&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Sofie&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Peter&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    persons</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 调用对 Java 合成属性的引用：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sortedBy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Person::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 通过 Kotlin 属性语法调用 Java getter：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person.name) }</span></span></code></pre></div>`,15)),a[3]||(a[3]=s("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"如何启用-java-合成属性引用",tabindex:"-1"},[i("如何启用 Java 合成属性引用 "),s("a",{class:"header-anchor",href:"#如何启用-java-合成属性引用","aria-label":'Permalink to "如何启用 Java 合成属性引用 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),a[4]||(a[4]=s("p",null,[i("要启用此特性，请设置 "),s("code",null,"-language-version 2.1"),i(" 编译器选项。在 Gradle 项目中，你可以通过将以下内容添加到 "),s("code",null,"build.gradle(.kts)"),i(" 中来完成：")],-1)),t(p,{group:"build-script"},{default:n(()=>[t(l,{title:"Kotlin","group-key":"kotlin"},{default:n(()=>a[0]||(a[0]=[s("div",{class:"language-kotlin vp-adaptive-theme"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"kotlin"),s("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"tasks")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    ."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"withType"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"org"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"jetbrains"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"gradle"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"tasks"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"KotlinCompilationTask"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<*>>()")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    ."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"configureEach"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        compilerOptions")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            .languageVersion")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            ."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"set"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"                org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_2_1")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            )")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")])])])],-1)])),_:1}),t(l,{title:"Groovy","group-key":"groovy"},{default:n(()=>a[1]||(a[1]=[s("div",{class:"language-groovy vp-adaptive-theme"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"groovy"),s("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"tasks")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    .withType("),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"org.jetbrains.kotlin.gradle.tasks.KotlinCompilationTask."),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"class)")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    .configureEach {")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        compilerOptions"),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"languageVersion")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"            ="),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}}," org.jetbrains.kotlin.gradle.dsl.KotlinVersion."),s("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"KOTLIN_2_1")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),a[5]||(a[5]=h(`<div class="note custom-block"><p class="custom-block-title">NOTE</p><p>在 Kotlin 1.9.0 之前，要启用此特性，你需要设置 <code>-language-version 1.9</code> 编译器选项。</p></div><h2 id="返回-void-的方法" tabindex="-1">返回 void 的方法 <a class="header-anchor" href="#返回-void-的方法" aria-label="Permalink to &quot;返回 void 的方法&quot;">​</a></h2><p>如果 Java 方法返回 <code>void</code>，则从 Kotlin 调用时它将返回 <code>Unit</code>。如果有人使用了该返回值，Kotlin 编译器将在调用处为其赋值，因为该值本身是预先已知的（即 <code>Unit</code>）。</p><h2 id="转义-kotlin-关键字的-java-标识符" tabindex="-1">转义 Kotlin 关键字的 Java 标识符 <a class="header-anchor" href="#转义-kotlin-关键字的-java-标识符" aria-label="Permalink to &quot;转义 Kotlin 关键字的 Java 标识符&quot;">​</a></h2><p>一些 Kotlin 关键字在 Java 中是有效的标识符：<code>in</code>、<code>object</code>、<code>is</code> 等。如果 Java 库使用 Kotlin 关键字作为方法名，你仍然可以使用反引号（\`）字符将其转义来调用该方法：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">\`is\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bar)</span></span></code></pre></div><h2 id="空安全和平台类型" tabindex="-1">空安全和平台类型 <a class="header-anchor" href="#空安全和平台类型" aria-label="Permalink to &quot;空安全和平台类型&quot;">​</a></h2><p>Java 中的任何引用都可能是 <code>null</code>，这使得 Kotlin 严格的空安全要求对于来自 Java 的对象来说不切实际。Java 声明的类型在 Kotlin 中以特定方式处理，并称为 <em>平台类型</em>。对于此类类型，空检测会放宽，因此它们的安全性保证与 Java 中相同（详见<a href="#mapped-types">下文</a>）。</p><p>考虑以下示例：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 非空的（构造函数结果）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Item&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list.size </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 非空的（原生 int）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 推断为平台类型（普通 Java 对象）</span></span></code></pre></div><p>当你调用平台类型变量上的方法时，Kotlin 不会在编译期发出空性错误，但调用可能会在运行时失败，因为出现空指针异常或 Kotlin 为防止空值传播而生成的断言：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">item.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">substring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 允许，如果 item == null 则抛出异常</span></span></code></pre></div><p>平台类型是<em>不可表示的</em>，这意味着你无法在语言中显式地写下它们。当平台值被赋值给 Kotlin 变量时，你可以依赖类型推断（变量将具有推断的平台类型，如上例中的 <code>item</code>），或者你可以选择你期望的类型（允许可空和非空类型）：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nullable: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 允许，始终有效</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> notNull: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 允许，可能在运行时失败</span></span></code></pre></div><p>如果你选择非空类型，编译器将在赋值时发出断言。这可以防止 Kotlin 的非空变量持有空值。当你将平台值传递给期望非空值的 Kotlin 函数以及其他情况下，也会发出断言。总的来说，编译器会尽力防止空值在程序中传播太远，尽管有时由于泛型，这不可能完全消除。</p><h3 id="平台类型的表示法" tabindex="-1">平台类型的表示法 <a class="header-anchor" href="#平台类型的表示法" aria-label="Permalink to &quot;平台类型的表示法&quot;">​</a></h3><p>如上所述，平台类型无法在程序中显式提及，因此语言中没有它们的语法。尽管如此，编译器和 IDE 有时需要显示它们（例如，在错误消息或参数信息中），因此存在一种助记符表示法：</p><ul><li><code>T!</code> 表示 &quot;<code>T</code> 或 <code>T?</code>&quot;，</li><li><code>(Mutable)Collection&lt;T&gt;!</code> 表示 &quot;Java 集合的 <code>T</code> 可能可变也可能不可变，可能可空也可能不可空&quot;，</li><li><code>Array&lt;(out) T&gt;!</code> 表示 &quot;Java 数组的 <code>T</code>（或 <code>T</code> 的子类型），可空或不可空&quot;</li></ul><h3 id="可空性注解" tabindex="-1">可空性注解 <a class="header-anchor" href="#可空性注解" aria-label="Permalink to &quot;可空性注解&quot;">​</a></h3><p>带有可空性注解的 Java 类型不会表示为平台类型，而是表示为实际可空或非空的 Kotlin 类型。编译器支持多种可空性注解，包括：</p><ul><li><a href="https://www.jetbrains.com/idea/help/nullable-and-notnull-annotations.html" target="_blank" rel="noreferrer">JetBrains</a> (<code>@Nullable</code> 和 <code>@NotNull</code> 来自 <code>org.jetbrains.annotations</code> 包)</li><li><a href="https://jspecify.dev/" target="_blank" rel="noreferrer">JSpecify</a> (<code>org.jspecify.annotations</code>)</li><li>Android (<code>com.android.annotations</code> 和 <code>android.support.annotations</code>)</li><li>JSR-305 (<code>javax.annotation</code>，详见下文)</li><li>FindBugs (<code>edu.umd.cs.findbugs.annotations</code>)</li><li>Eclipse (<code>org.eclipse.jdt.annotation</code>)</li><li>Lombok (<code>lombok.NonNull</code>)</li><li>RxJava 3 (<code>io.reactivex.rxjava3.annotations</code>)</li></ul><p>你可以根据来自特定类型的可空性注解信息，指定编译器是否报告可空性不匹配。使用编译器选项 <code>-Xnullability-annotations=@&lt;package-name&gt;:&lt;report-level&gt;</code>。在参数中，指定完全限定的可空性注解包名和以下报告级别之一：</p><ul><li><code>ignore</code> 忽略可空性不匹配</li><li><code>warn</code> 报告警告</li><li><code>strict</code> 报告错误。</li></ul><p>有关支持的可空性注解的完整列表，请参见 <a href="https://github.com/JetBrains/kotlin/blob/master/core/compiler.common.jvm/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt" target="_blank" rel="noreferrer">Kotlin 编译器源代码</a>。</p><h3 id="注解类型实参和类型形参" tabindex="-1">注解类型实参和类型形参 <a class="header-anchor" href="#注解类型实参和类型形参" aria-label="Permalink to &quot;注解类型实参和类型形参&quot;">​</a></h3><p>你还可以注解泛型类型的类型实参和类型形参，以便为它们提供可空性信息。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>本节中的所有示例都使用 <code>org.jetbrains.annotations</code> 包中的 JetBrains 可空性注解。</p></div><h4 id="类型实参" tabindex="-1">类型实参 <a class="header-anchor" href="#类型实参" aria-label="Permalink to &quot;类型实参&quot;">​</a></h4><p>考虑 Java 声明上的这些注解：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Set</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Collection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elements) { ... }</span></span></code></pre></div><p>它们在 Kotlin 中会产生以下签名：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mutable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Collection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) : (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mutable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span></code></pre></div><p>当类型实参缺少 <code>@NotNull</code> 注解时，你将获得平台类型：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mutable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Collection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">!&gt;) : (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mutable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">!&gt; { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span></code></pre></div><p>Kotlin 还会考虑基类和接口的类型实参上的可空性注解。例如，有两个 Java 类，其签名如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Derived</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nullable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p>在 Kotlin 代码中，将 <code>Derived</code> 实例传递到假定 <code>Base&lt;String&gt;</code> 的地方会产生警告。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> takeBaseOfNotNullStrings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    takeBaseOfNotNullStrings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Derived</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// warning: nullability mismatch</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>Derived</code> 的上界设置为 <code>Base&lt;String?&gt;</code>，这与 <code>Base&lt;String&gt;</code> 不同。</p><p>了解更多关于 <a href="#java-generics-in-kotlin">Kotlin 中的 Java 泛型</a>。</p><h4 id="类型形参" tabindex="-1">类型形参 <a class="header-anchor" href="#类型形参" aria-label="Permalink to &quot;类型形参&quot;">​</a></h4><p>默认情况下，Kotlin 和 Java 中普通类型形参的可空性是未定义的。在 Java 中，你可以使用可空性注解来指定它。让我们注解 <code>Base</code> 类的类型形参：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p>当从 <code>Base</code> 继承时，Kotlin 期望一个非空的类型实参或类型形参。因此，以下 Kotlin 代码会产生警告：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Derived</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// warning: K has undefined nullability</span></span></code></pre></div><p>你可以通过指定上界 <code>K : Any</code> 来修复它。</p><p>Kotlin 还支持 Java 类型形参的边界上的可空性注解。让我们为 <code>Base</code> 添加边界：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BaseWithBound</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p>Kotlin 将其翻译如下：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BaseWithBound</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p>因此，将可空类型作为类型实参或类型形参传递会产生警告。</p><p>注解类型实参和类型形参适用于 Java 8 或更高版本。此特性要求可空性注解支持 <code>TYPE_USE</code> 目标（<code>org.jetbrains.annotations</code> 在版本 15 及更高版本中支持此功能）。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>如果可空性注解支持除 <code>TYPE_USE</code> 目标外还适用于类型的其他目标，则 <code>TYPE_USE</code> 具有优先权。例如，如果 <code>@Nullable</code> 同时具有 <code>TYPE_USE</code> 和 <code>METHOD</code> 目标，则 Java 方法签名 <code>@Nullable String[] f()</code> 在 Kotlin 中变为 <code>fun f(): Array&lt;String?&gt;!</code>。</p></div><h3 id="jsr-305-支持" tabindex="-1">JSR-305 支持 <a class="header-anchor" href="#jsr-305-支持" aria-label="Permalink to &quot;JSR-305 支持&quot;">​</a></h3><p><a href="https://jcp.org/en/jsr/detail?id=305" target="_blank" rel="noreferrer">JSR-305</a> 中定义的 <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/Nonnull.html" target="_blank" rel="noreferrer"><code>@Nonnull</code></a> 注解支持用于表示 Java 类型的可空性。</p><p>如果 <code>@Nonnull(when = ...)</code> 的值为 <code>When.ALWAYS</code>，则被注解的类型被视为非空的；<code>When.MAYBE</code> 和 <code>When.NEVER</code> 表示可空类型；<code>When.UNKNOWN</code> 则强制类型为<a href="#null-safety-and-platform-types">平台类型</a>。</p><p>库可以针对 JSR-305 注解进行编译，但无需将注解构件（例如 <code>jsr305.jar</code>）作为库使用者的编译依赖项。Kotlin 编译器可以在不依赖类路径中注解的情况下从库中读取 JSR-305 注解。</p><p><a href="https://github.com/Kotlin/KEEP/blob/master/proposals/jsr-305-custom-nullability-qualifiers.md" target="_blank" rel="noreferrer">自定义可空性限定符 (KEEP-79)</a> 也受支持（见下文）。</p><h4 id="类型限定符别名" tabindex="-1">类型限定符别名 <a class="header-anchor" href="#类型限定符别名" aria-label="Permalink to &quot;类型限定符别名&quot;">​</a></h4><p>如果注解类型同时被 <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/meta/TypeQualifierNickname.html" target="_blank" rel="noreferrer"><code>@TypeQualifierNickname</code></a> 和 JSR-305 <code>@Nonnull</code>（或其另一个别名，例如 <code>@CheckForNull</code>）注解，则该注解类型本身用于检索精确的可空性，并具有与该可空性注解相同的含义：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierNickname</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">when</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> When.ALWAYS)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Retention</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RetentionPolicy.RUNTIME)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> MyNonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierNickname</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CheckForNull</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 另一个类型限定符别名的别名</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Retention</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RetentionPolicy.RUNTIME)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> MyNullable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">MyNullable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">MyNonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在 Kotlin 中（严格模式）：\`fun foo(x: String): String?\`</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(List&lt;@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">MyNonnull</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在 Kotlin 中（严格模式）：\`fun bar(x: List&lt;String&gt;!): String!\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="类型限定符默认值" tabindex="-1">类型限定符默认值 <a class="header-anchor" href="#类型限定符默认值" aria-label="Permalink to &quot;类型限定符默认值&quot;">​</a></h4><p><a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/meta/TypeQualifierDefault.html" target="_blank" rel="noreferrer"><code>@TypeQualifierDefault</code></a> 允许引入注解，当应用时，这些注解定义了被注解元素作用域内的默认可空性。</p><p>此类注解类型本身应该同时被 <code>@Nonnull</code>（或其别名）和 <code>@TypeQualifierDefault(...)</code> 注解，并带有一个或多个 <code>ElementType</code> 值：</p><ul><li><code>ElementType.METHOD</code> 用于方法的返回类型</li><li><code>ElementType.PARAMETER</code> 用于值形参</li><li><code>ElementType.FIELD</code> 用于字段</li><li><code>ElementType.TYPE_USE</code> 用于任何类型，包括类型实参、类型形参的上界和通配符类型</li></ul><p>当类型本身没有被可空性注解时，将使用默认可空性，默认值由最内层封闭元素确定，该元素被带有一个类型限定符默认注解，并且其 <code>ElementType</code> 与类型用法匹配。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ElementType.METHOD, ElementType.PARAMETER})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NonNullApi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">when</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> When.MAYBE)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE_USE})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NullableApi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NullableApi</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fun foo(x: String?): String?</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNullApi</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 覆盖接口的默认值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nullable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fun bar(x: String, y: String?): String</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 由于 \`@NullableApi\` 具有 \`TYPE_USE\` 元素类型，List&lt;String&gt; 类型实参被视为可空：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">baz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fun baz(List&lt;String?&gt;?): String?</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // \`x\` 形参的类型仍然是平台类型，因为存在显式标记为 UNKNOWN 的可空性注解：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">qux</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">when</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> When.UNKNOWN) String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fun baz(x: String!): String?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>此示例中的类型仅在严格模式启用时才生效；否则，平台类型保持不变。请参阅 <a href="#undermigration-annotation"><code>@UnderMigration</code> 注解</a> 和 <a href="#compiler-configuration">编译器配置</a> 部分。</p></div><p>也支持包级别默认可空性：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// FILE: test/package-info.java</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NonNullApi</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 默认将包 &#39;test&#39; 中的所有类型声明为非空的</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test;</span></span></code></pre></div><h4 id="undermigration-注解" tabindex="-1">@UnderMigration 注解 <a class="header-anchor" href="#undermigration-注解" aria-label="Permalink to &quot;@UnderMigration 注解&quot;">​</a></h4><p><code>@UnderMigration</code> 注解（在单独的构件 <code>kotlin-annotations-jvm</code> 中提供）可供库维护者用于定义可空性类型限定符的迁移状态。</p><p><code>@UnderMigration(status = ...)</code> 中的 status 值指定了编译器如何处理 Kotlin 中被注解类型的不当用法（例如，将 <code>@MyNullable</code> 注解类型的值用作非空）：</p><ul><li><code>MigrationStatus.STRICT</code> 使注解像任何普通的可空性注解一样工作，即报告不当用法的错误，并影响 Kotlin 中被注解声明中的类型</li><li><code>MigrationStatus.WARN</code>：不当用法作为编译警告而不是错误报告，但被注解声明中的类型仍为平台类型</li><li><code>MigrationStatus.IGNORE</code> 使编译器完全忽略可空性注解</li></ul><p>库维护者可以将 <code>@UnderMigration</code> 状态添加到类型限定符别名和类型限定符默认值中：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">when</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> When.ALWAYS)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ElementType.METHOD, ElementType.PARAMETER})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UnderMigration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">status</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MigrationStatus.WARN)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NonNullApi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 类中的类型是非空的，但仅报告警告</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 因为 \`@NonNullApi\` 被注解为 \`@UnderMigration(status = MigrationStatus.WARN)\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NonNullApi</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>可空性注解的迁移状态不会被其类型限定符别名继承，但会应用于其在默认类型限定符中的用法。</p></div><p>如果默认类型限定符使用类型限定符别名，并且它们都处于 <code>@UnderMigration</code> 状态，则使用默认类型限定符的状态。</p><h4 id="编译器配置" tabindex="-1">编译器配置 <a class="header-anchor" href="#编译器配置" aria-label="Permalink to &quot;编译器配置&quot;">​</a></h4><p>JSR-305 检测可以通过添加 <code>-Xjsr305</code> 编译器标志并带以下选项（及其组合）进行配置：</p><ul><li><p><code>-Xjsr305={strict|warn|ignore}</code> 用于设置非 <code>@UnderMigration</code> 注解的行为。自定义可空性限定符，特别是 <code>@TypeQualifierDefault</code>，已广泛应用于许多知名库中，用户在更新到包含 JSR-305 支持的 Kotlin 版本时可能需要平稳迁移。自 Kotlin 1.1.60 起，此标志仅影响非 <code>@UnderMigration</code> 注解。</p></li><li><p><code>-Xjsr305=under-migration:{strict|warn|ignore}</code> 用于覆盖 <code>@UnderMigration</code> 注解的行为。用户可能对库的迁移状态有不同的看法：他们可能希望在官方迁移状态为 <code>WARN</code> 时出现错误，反之，他们可能希望将某些错误的报告推迟到完成迁移之后。</p></li><li><p><code>-Xjsr305=@&lt;fq.name&gt;:{strict|warn|ignore}</code> 用于覆盖单个注解的行为，其中 <code>&lt;fq.name&gt;</code> 是注解的完全限定类名。可以为不同的注解出现多次。这对于管理特定库的迁移状态很有用。</p></li></ul><p><code>strict</code>、<code>warn</code> 和 <code>ignore</code> 值具有与 <code>MigrationStatus</code> 相同的含义，并且只有 <code>strict</code> 模式会影响 Kotlin 中被注解声明中的类型。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>注意：内置的 JSR-305 注解 <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/Nonnull.html" target="_blank" rel="noreferrer"><code>@Nonnull</code></a>、<a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/3.0.1/javax/annotation/Nullable.html" target="_blank" rel="noreferrer"><code>@Nullable</code></a> 和 <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/CheckForNull.html" target="_blank" rel="noreferrer"><code>@CheckForNull</code></a> 始终启用，并影响 Kotlin 中被注解声明的类型，无论 <code>-Xjsr305</code> 标志的编译器配置如何。</p></div><p>例如，将 <code>-Xjsr305=ignore -Xjsr305=under-migration:ignore -Xjsr305=@org.library.MyNullable:warn</code> 添加到编译器实参中，会使编译器对 <code>@org.library.MyNullable</code> 注解类型的不当用法生成警告，并忽略所有其他 JSR-305 注解。</p><p>默认行为与 <code>-Xjsr305=warn</code> 相同。<code>strict</code> 值应被视为实验性的（将来可能会添加更多检测）。</p><h2 id="映射类型" tabindex="-1">映射类型 <a class="header-anchor" href="#映射类型" aria-label="Permalink to &quot;映射类型&quot;">​</a></h2><p>Kotlin 对某些 Java 类型进行了特殊处理。这些类型不会“原样”从 Java 加载，而是<em>映射</em>到相应的 Kotlin 类型。此映射仅在编译期有意义，运行时表示保持不变。Java 的原生类型映射到相应的 Kotlin 类型（请记住<a href="#null-safety-and-platform-types">平台类型</a>）：</p><table tabindex="0"><thead><tr><th><strong>Java 类型</strong></th><th><strong>Kotlin 类型</strong></th></tr></thead><tbody><tr><td><code>byte</code></td><td><code>kotlin.Byte</code></td></tr><tr><td><code>short</code></td><td><code>kotlin.Short</code></td></tr><tr><td><code>int</code></td><td><code>kotlin.Int</code></td></tr><tr><td><code>long</code></td><td><code>kotlin.Long</code></td></tr><tr><td><code>char</code></td><td><code>kotlin.Char</code></td></tr><tr><td><code>float</code></td><td><code>kotlin.Float</code></td></tr><tr><td><code>double</code></td><td><code>kotlin.Double</code></td></tr><tr><td><code>boolean</code></td><td><code>kotlin.Boolean</code></td></tr></tbody></table><p>一些非原生内置类也被映射：</p><table tabindex="0"><thead><tr><th><strong>Java 类型</strong></th><th><strong>Kotlin 类型</strong></th></tr></thead><tbody><tr><td><code>java.lang.Object</code></td><td><code>kotlin.Any!</code></td></tr><tr><td><code>java.lang.Cloneable</code></td><td><code>kotlin.Cloneable!</code></td></tr><tr><td><code>java.lang.Comparable</code></td><td><code>kotlin.Comparable!</code></td></tr><tr><td><code>java.lang.Enum</code></td><td><code>kotlin.Enum!</code></td></tr><tr><td><code>java.lang.annotation.Annotation</code></td><td><code>kotlin.Annotation!</code></td></tr><tr><td><code>java.lang.CharSequence</code></td><td><code>kotlin.CharSequence!</code></td></tr><tr><td><code>java.lang.String</code></td><td><code>kotlin.String!</code></td></tr><tr><td><code>java.lang.Number</code></td><td><code>kotlin.Number!</code></td></tr><tr><td><code>java.lang.Throwable</code></td><td><code>kotlin.Throwable!</code></td></tr></tbody></table><p>Java 的包装原生类型映射到可空的 Kotlin 类型：</p><table tabindex="0"><thead><tr><th><strong>Java 类型</strong></th><th><strong>Kotlin 类型</strong></th></tr></thead><tbody><tr><td><code>java.lang.Byte</code></td><td><code>kotlin.Byte?</code></td></tr><tr><td><code>java.lang.Short</code></td><td><code>kotlin.Short?</code></td></tr><tr><td><code>java.lang.Integer</code></td><td><code>kotlin.Int?</code></td></tr><tr><td><code>java.lang.Long</code></td><td><code>kotlin.Long?</code></td></tr><tr><td><code>java.lang.Character</code></td><td><code>kotlin.Char?</code></td></tr><tr><td><code>java.lang.Float</code></td><td><code>kotlin.Float?</code></td></tr><tr><td><code>java.lang.Double</code></td><td><code>kotlin.Double?</code></td></tr><tr><td><code>java.lang.Boolean</code></td><td><code>kotlin.Boolean?</code></td></tr></tbody></table><p>请注意，用作类型形参的包装原生类型会映射到平台类型：例如，<code>List&lt;java.lang.Integer&gt;</code> 在 Kotlin 中变为 <code>List&lt;Int!&gt;</code>。</p><p>集合类型在 Kotlin 中可以是只读的或可变的，因此 Java 的集合映射如下（此表中的所有 Kotlin 类型都位于 <code>kotlin.collections</code> 包中）：</p><table tabindex="0"><thead><tr><th><strong>Java 类型</strong></th><th><strong>Kotlin 只读类型</strong></th><th><strong>Kotlin 可变类型</strong></th><th><strong>加载的平台类型</strong></th></tr></thead><tbody><tr><td><code>Iterator&lt;T&gt;</code></td><td><code>Iterator&lt;T&gt;</code></td><td><code>MutableIterator&lt;T&gt;</code></td><td><code>(Mutable)Iterator&lt;T&gt;!</code></td></tr><tr><td><code>Iterable&lt;T&gt;</code></td><td><code>Iterable&lt;T&gt;</code></td><td><code>MutableIterable&lt;T&gt;</code></td><td><code>(Mutable)Iterable&lt;T&gt;!</code></td></tr><tr><td><code>Collection&lt;T&gt;</code></td><td><code>Collection&lt;T&gt;</code></td><td><code>MutableCollection&lt;T&gt;</code></td><td><code>(Mutable)Collection&lt;T&gt;!</code></td></tr><tr><td><code>Set&lt;T&gt;</code></td><td><code>Set&lt;T&gt;</code></td><td><code>MutableSet&lt;T&gt;</code></td><td><code>(Mutable)Set&lt;T&gt;!</code></td></tr><tr><td><code>List&lt;T&gt;</code></td><td><code>List&lt;T&gt;</code></td><td><code>MutableList&lt;T&gt;</code></td><td><code>(Mutable)List&lt;T&gt;!</code></td></tr><tr><td><code>ListIterator&lt;T&gt;</code></td><td><code>ListIterator&lt;T&gt;</code></td><td><code>MutableListIterator&lt;T&gt;</code></td><td><code>(Mutable)ListIterator&lt;T&gt;!</code></td></tr><tr><td><code>Map&lt;K, V&gt;</code></td><td><code>Map&lt;K, V&gt;</code></td><td><code>MutableMap&lt;K, V&gt;</code></td><td><code>(Mutable)Map&lt;K, V&gt;!</code></td></tr><tr><td><code>Map.Entry&lt;K, V&gt;</code></td><td><code>Map.Entry&lt;K, V&gt;</code></td><td><code>MutableMap.MutableEntry&lt;K,V&gt;</code></td><td><code>(Mutable)Map.(Mutable)Entry&lt;K, V&gt;!</code></td></tr></tbody></table><p>Java 的数组映射如下文<a href="#java-arrays">所述</a>：</p><table tabindex="0"><thead><tr><th><strong>Java 类型</strong></th><th><strong>Kotlin 类型</strong></th></tr></thead><tbody><tr><td><code>int[]</code></td><td><code>kotlin.IntArray!</code></td></tr><tr><td><code>String[]</code></td><td><code>kotlin.Array&lt;(out) String!&gt;!</code></td></tr></tbody></table><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>这些 Java 类型的静态成员无法直接访问 Kotlin 类型的<a href="/kotlin/object-declarations#companion-objects">伴生对象</a>。要调用它们，请使用 Java 类型的完全限定名称，例如 <code>java.lang.Integer.toHexString(foo)</code>。</p></div><h2 id="kotlin-中的-java-泛型" tabindex="-1">Kotlin 中的 Java 泛型 <a class="header-anchor" href="#kotlin-中的-java-泛型" aria-label="Permalink to &quot;Kotlin 中的 Java 泛型&quot;">​</a></h2><p>Kotlin 的泛型与 Java 的略有不同（请参见<a href="/kotlin/generics">泛型</a>）。将 Java 类型导入到 Kotlin 时，会进行以下转换：</p><ul><li><p>Java 的通配符转换为类型投影：</p><ul><li><code>Foo&lt;? extends Bar&gt;</code> 变为 <code>Foo&lt;out Bar!&gt;!</code></li><li><code>Foo&lt;? super Bar&gt;</code> 变为 <code>Foo&lt;in Bar!&gt;!</code></li></ul></li><li><p>Java 的原始类型转换为星投影：</p><ul><li><code>List</code> 变为 <code>List&lt;*&gt;!</code>，即 <code>List&lt;out Any?&gt;!</code></li></ul></li></ul><p>与 Java 类似，Kotlin 的泛型在运行时不会保留：对象不携带关于传递给其构造函数的实际类型实参的信息。例如，<code>ArrayList&lt;Integer&gt;()</code> 与 <code>ArrayList&lt;Character&gt;()</code> 是无法区分的。这使得执行考虑泛型的 <code>is</code> 检测成为不可能。Kotlin 只允许对星投影泛型类型进行 <code>is</code> 检测：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误：无法检测它是否真的是 List&lt;Int&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 但是</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;*&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK：不保证列表内容</span></span></code></pre></div><h2 id="java-数组" tabindex="-1">Java 数组 <a class="header-anchor" href="#java-数组" aria-label="Permalink to &quot;Java 数组&quot;">​</a></h2><p>Kotlin 中的数组是不变型的，这与 Java 不同。这意味着 Kotlin 不允许你将 <code>Array&lt;String&gt;</code> 赋值给 <code>Array&lt;Any&gt;</code>，这可以防止可能的运行时失败。将子类数组作为超类数组传递给 Kotlin 方法也是禁止的，但对于 Java 方法，通过 <code>Array&lt;(out) String&gt;!</code> 形式的<a href="#null-safety-and-platform-types">平台类型</a>是允许的。</p><p>Java 平台上的原生数据类型数组被使用以避免装箱/拆箱操作的开销。由于 Kotlin 隐藏了这些实现细节，因此需要一种变通方法来与 Java 代码进行接口。每种原生数组类型都有专门的类（<code>IntArray</code>、<code>DoubleArray</code>、<code>CharArray</code> 等）来处理这种情况。它们与 <code>Array</code> 类无关，并被编译为 Java 的原生数组以实现最佳性能。</p><p>假设有一个 Java 方法接受一个 int 数组作为索引：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JavaArrayExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeIndices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">indices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // code here...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>要在 Kotlin 中传递原生值数组，你可以这样做：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> javaObj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JavaArrayExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> intArrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">javaObj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeIndices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将 int[] 传递给方法</span></span></code></pre></div><p>编译为 JVM 字节码时，编译器会优化数组访问，因此不会引入任何开销：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">array[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 没有实际生成对 get() 和 set() 的调用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 没有创建迭代器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>即使你使用索引导航，它也不会引入任何开销：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.indices) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 没有创建迭代器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    array[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>最后，<code>in</code> 检测也没有开销：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.indices) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等同于 (i &gt;= 0 &amp;&amp; i &lt; array.size)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array[i])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="java-可变参数" tabindex="-1">Java 可变参数 <a class="header-anchor" href="#java-可变参数" aria-label="Permalink to &quot;Java 可变参数&quot;">​</a></h2><p>Java 类有时会使用带有可变数量实参（varargs）的索引方法声明：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JavaArrayExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeIndicesVarArg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">... </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">indices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // code here...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这种情况下，你需要使用展开操作符 <code>*</code> 来传递 <code>IntArray</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> javaObj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JavaArrayExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> intArrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">javaObj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeIndicesVarArg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">array)</span></span></code></pre></div><h2 id="操作符" tabindex="-1">操作符 <a class="header-anchor" href="#操作符" aria-label="Permalink to &quot;操作符&quot;">​</a></h2><p>由于 Java 无法标记哪些方法适合使用操作符语法，Kotlin 允许将任何具有正确名称和签名的 Java 方法用作操作符重载和其他约定（如 <code>invoke()</code> 等）。不允许使用中缀调用语法调用 Java 方法。</p><h2 id="受检异常" tabindex="-1">受检异常 <a class="header-anchor" href="#受检异常" aria-label="Permalink to &quot;受检异常&quot;">​</a></h2><p>在 Kotlin 中，所有<a href="/kotlin/exceptions">异常都是非受检的</a>，这意味着编译器不会强制你捕获任何异常。因此，当你调用声明了受检异常的 Java 方法时，Kotlin 不会强制你做任何事情：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(list: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;*&gt;, to: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Appendable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        to.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Java 在此处会要求我们捕获 IOException</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="object-方法" tabindex="-1">Object 方法 <a class="header-anchor" href="#object-方法" aria-label="Permalink to &quot;Object 方法&quot;">​</a></h2><p>当 Java 类型导入到 Kotlin 时，所有 <code>java.lang.Object</code> 类型的引用都转换为 <code>Any</code>。由于 <code>Any</code> 不是平台特有的，它只声明 <code>toString()</code>、<code>hashCode()</code> 和 <code>equals()</code> 作为其成员，因此为了使 <code>java.lang.Object</code> 的其他成员可用，Kotlin 使用了<a href="/kotlin/extensions">扩展函数</a>。</p><h3 id="wait-notify" tabindex="-1">wait()/notify() <a class="header-anchor" href="#wait-notify" aria-label="Permalink to &quot;wait()/notify()&quot;">​</a></h3><p><code>wait()</code> 和 <code>notify()</code> 方法在 <code>Any</code> 类型的引用上不可用。通常不建议使用它们，而推荐使用 <code>java.util.concurrent</code>。如果你确实需要调用这些方法，可以强制转换为 <code>java.lang.Object</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.lang.Object).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h3 id="getclass" tabindex="-1">getClass() <a class="header-anchor" href="#getclass" aria-label="Permalink to &quot;getClass()&quot;">​</a></h3><p>要检索对象的 Java 类，请在<a href="/kotlin/reflection#class-references">类引用</a>上使用 <code>java</code> 扩展属性：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fooClass </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.java</span></span></code></pre></div><p>上面的代码使用了<a href="/kotlin/reflection#bound-class-references">绑定类引用</a>。你也可以使用 <code>javaClass</code> 扩展属性：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fooClass </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo.javaClass</span></span></code></pre></div><h3 id="clone" tabindex="-1">clone() <a class="header-anchor" href="#clone" aria-label="Permalink to &quot;clone()&quot;">​</a></h3><p>要覆盖 <code>clone()</code>，你的类需要扩展 <code>kotlin.Cloneable</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Cloneable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> clone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>不要忘记<a href="https://www.oracle.com/technetwork/java/effectivejava-136174.html" target="_blank" rel="noreferrer">《Effective Java，第 3 版》</a>中的第 13 条：<em>明智地覆盖 clone</em>。</p><h3 id="finalize" tabindex="-1">finalize() <a class="header-anchor" href="#finalize" aria-label="Permalink to &quot;finalize()&quot;">​</a></h3><p>要覆盖 <code>finalize()</code>，你只需声明它，而无需使用 <code>override</code> 关键字：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    protected</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> finalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 终结逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>根据 Java 的规则，<code>finalize()</code> 不得为 <code>private</code>。</p><h2 id="继承-java-类" tabindex="-1">继承 Java 类 <a class="header-anchor" href="#继承-java-类" aria-label="Permalink to &quot;继承 Java 类&quot;">​</a></h2><p>一个 Kotlin 类最多只能有一个 Java 类作为超类型（以及任意数量的 Java 接口）。</p><h2 id="访问静态成员" tabindex="-1">访问静态成员 <a class="header-anchor" href="#访问静态成员" aria-label="Permalink to &quot;访问静态成员&quot;">​</a></h2><p>Java 类的静态成员构成了这些类的“伴生对象”。你不能将此类“伴生对象”作为值传递，但可以显式访问其成员，例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Character.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isLetter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a)) { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span></code></pre></div><p>要访问<a href="#mapped-types">映射</a>到 Kotlin 类型的 Java 类型的静态成员，请使用 Java 类型的完全限定名称：<code>java.lang.Integer.bitCount(foo)</code>。</p><h2 id="java-反射" tabindex="-1">Java 反射 <a class="header-anchor" href="#java-反射" aria-label="Permalink to &quot;Java 反射&quot;">​</a></h2><p>Java 反射适用于 Kotlin 类，反之亦然。如上所述，你可以使用 <code>instance::class.java</code>、<code>ClassName::class.java</code> 或 <code>instance.javaClass</code> 进入 Java 反射，通过 <code>java.lang.Class</code>。不要将 <code>ClassName.javaClass</code> 用于此目的，因为它引用的是 <code>ClassName</code> 的伴生对象类，这与 <code>ClassName.Companion::class.java</code> 相同，而非 <code>ClassName::class.java</code>。</p><p>对于每种原生类型，都有两个不同的 Java 类，Kotlin 提供了获取两者的方法。例如，<code>Int::class.java</code> 将返回表示原生类型本身的类实例，这对应于 Java 中的 <code>Integer.TYPE</code>。要获取相应包装器类型的类，请使用 <code>Int::class.javaObjectType</code>，这等效于 Java 的 <code>Integer.class</code>。</p><p>其他支持的场景包括获取 Kotlin 属性的 Java getter/setter 方法或幕后字段，Java 字段的 <code>KProperty</code>，Java 方法或构造函数的 <code>KFunction</code>，反之亦然。</p><h2 id="sam-转换" tabindex="-1">SAM 转换 <a class="header-anchor" href="#sam-转换" aria-label="Permalink to &quot;SAM 转换&quot;">​</a></h2><p>Kotlin 支持 Java 和 <a href="/kotlin/fun-interfaces">Kotlin 接口</a>的 SAM 转换。对 Java 的此支持意味着 Kotlin 函数字面值可以自动转换为具有单个非默认方法的 Java 接口的实现，只要接口方法的形参类型与 Kotlin 函数的形参类型匹配。</p><p>你可以使用此功能创建 SAM 接口的实例：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> runnable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This runs in a runnable&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span></code></pre></div><p>……并在方法调用中使用：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ThreadPoolExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Java 签名：void execute(Runnable command)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">executor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This runs in a thread pool&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span></code></pre></div><p>如果 Java 类有多个接受函数式接口的方法，你可以通过使用将 lambda 转换为特定 SAM 类型的适配器函数来选择你需要调用的方法。这些适配器函数也会在需要时由编译器生成：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">executor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This runs in a thread pool&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) })</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>SAM 转换仅适用于接口，不适用于抽象类，即使这些抽象类也只有一个抽象方法。</p></div><h2 id="在-kotlin-中使用-jni" tabindex="-1">在 Kotlin 中使用 JNI <a class="header-anchor" href="#在-kotlin-中使用-jni" aria-label="Permalink to &quot;在 Kotlin 中使用 JNI&quot;">​</a></h2><p>要声明一个在原生 (C 或 C++) 代码中实现的函数，你需要用 <code>external</code> 修饰符标记它：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Double</span></span></code></pre></div><p>其余过程与 Java 中的完全相同。</p><p>你还可以将属性的 getter 和 setter 标记为 <code>external</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myProperty: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> get</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> set</span></span></code></pre></div><p>在幕后，这将创建两个函数 <code>getMyProperty</code> 和 <code>setMyProperty</code>，两者都被标记为 <code>external</code>。</p><h2 id="在-kotlin-中使用-lombok-生成的声明" tabindex="-1">在 Kotlin 中使用 Lombok 生成的声明 <a class="header-anchor" href="#在-kotlin-中使用-lombok-生成的声明" aria-label="Permalink to &quot;在 Kotlin 中使用 Lombok 生成的声明&quot;">​</a></h2><p>你可以在 Kotlin 代码中使用 Java 的 Lombok 生成的声明。如果你需要在同一个混合 Java/Kotlin 模块中生成和使用这些声明，你可以在 <a href="/kotlin/lombok">Lombok 编译器插件页面</a>上了解如何操作。如果你从另一个模块调用此类声明，则无需使用此插件来编译该模块。</p>`,173))])}const A=k(r,[["render",E]]);export{b as __pageData,A as default};
