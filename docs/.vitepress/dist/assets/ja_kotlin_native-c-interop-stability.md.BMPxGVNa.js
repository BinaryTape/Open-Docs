import{_ as n,C as a,c as o,o as s,G as e,ag as r}from"./chunks/framework.Bksy39di.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ja/kotlin/native-c-interop-stability.md","filePath":"ja/kotlin/native-c-interop-stability.md","lastUpdated":1754307826000}'),p={name:"ja/kotlin/native-c-interop-stability.md"};function h(c,i,d,k,b,m){const t=a("TopicTitle"),l=a("primary-label");return s(),o("div",null,[e(t,{labelRef:"beta",title:"CおよびObjective-Cライブラリのインポートの安定性"}),e(l,{ref:"beta"},null,512),i[0]||(i[0]=r(`<p>Kotlin/Nativeは、<a href="/ja/kotlin/native-c-interop">C</a>および<a href="/ja/kotlin/native-objc-interop">Objective-C</a>ライブラリのインポート機能を提供します。 これらのライブラリのサポートは、現在<a href="/ja/kotlin/components-stability#kotlin-native">ベータ版</a>です。</p><p>ベータ版である主な理由の1つは、CおよびObjective-Cライブラリを使用すると、さまざまなバージョンのKotlin、依存関係、およびXcodeとのコードの互換性に影響を与える可能性があることです。このガイドでは、実際に頻繁に発生する互換性の問題、一部の場合にのみ発生する問題、および仮想的な潜在的な問題も示します。</p><p>このガイドでは、CおよびObjective-Cライブラリ、または簡潔にするため_ネイティブライブラリ_は、次のように分けられます:</p><ul><li><a href="#platform-libraries">プラットフォームライブラリ</a> (各プラットフォーム上の「システム」ネイティブライブラリにアクセスするためにKotlinがデフォルトで提供するもの)</li><li><a href="#third-party-libraries">サードパーティライブラリ</a> (Kotlinの使用に追加設定が必要なその他のすべてのネイティブライブラリ)</li></ul><p>これら2種類のネイティブライブラリは、互換性の詳細が異なります。</p><h2 id="プラットフォームライブラリ" tabindex="-1">プラットフォームライブラリ <a class="header-anchor" href="#プラットフォームライブラリ" aria-label="Permalink to &quot;プラットフォームライブラリ&quot;">​</a></h2><p><a href="/ja/kotlin/native-platform-libs"><em>プラットフォームライブラリ</em></a>はKotlin/Nativeコンパイラに同梱されています。 そのため、プロジェクトで異なるバージョンのKotlinを使用すると、異なるバージョンのプラットフォームライブラリが使用されることになります。 Appleターゲット (iOSなど) の場合、プラットフォームライブラリは、特定のコンパイラバージョンでサポートされているXcodeのバージョンに基づいて生成されます。</p><p>Xcode SDKに同梱されているネイティブライブラリAPIは、Xcodeのバージョンごとに変更されます。 そのような変更がネイティブ言語内でソースおよびバイナリ互換であっても、相互運用性の実装によりKotlinでは破壊的となる可能性があります。</p><p>その結果、プロジェクトでKotlinバージョンを更新すると、プラットフォームライブラリで破壊的変更が発生する可能性があります。 これは2つのケースで問題となる可能性があります:</p><ul><li><p>プラットフォームライブラリにソースの破壊的変更があり、プロジェクトのソースコードのコンパイルに影響を与える場合。通常、修正は簡単です。</p></li><li><p>プラットフォームライブラリにバイナリの破壊的変更があり、一部の依存関係に影響を与える場合。通常、簡単な回避策はなく、ライブラリ開発者がその側でこれを修正するまで待つ必要があります (たとえば、Kotlinバージョンを更新することによって)。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>そのようなバイナリの非互換性は、リンケージ警告やランタイム例外として現れます。 コンパイル時にそれらを検出したい場合は、<a href="/ja/kotlin/whatsnew19#library-linkage-in-kotlin-native"><code>-Xpartial-linkage-loglevel=ERROR</code></a>コンパイラオプションを使用して警告をエラーに昇格させてください。</p></div></li></ul><p>JetBrainsチームがプラットフォームライブラリを生成するために使用するXcodeバージョンを更新する際、プラットフォームライブラリにおける破壊的変更を回避するために合理的な努力をしています。破壊的変更が発生する可能性がある場合は常に、チームは影響分析を実施し、特定の変更を無視するか (影響を受けるAPIが一般的に使用されていないため)、またはアドホックな修正を適用することを決定します。</p><p>プラットフォームライブラリにおける破壊的変更のもう1つの潜在的な理由は、ネイティブAPIをKotlinに変換するアルゴリズムの変更です。JetBrainsチームは、そのような場合でも破壊的変更を避けるために合理的な努力をしています。</p><h3 id="プラットフォームライブラリからの新しいobjective-cクラスの使用" tabindex="-1">プラットフォームライブラリからの新しいObjective-Cクラスの使用 <a class="header-anchor" href="#プラットフォームライブラリからの新しいobjective-cクラスの使用" aria-label="Permalink to &quot;プラットフォームライブラリからの新しいObjective-Cクラスの使用&quot;">​</a></h3><p>Kotlinコンパイラは、デプロイターゲットで利用できないObjective-Cクラスの使用を妨げません。</p><p>たとえば、デプロイターゲットがiOS 17.0で、iOS 18.0でのみ登場したクラスを使用する場合、コンパイラは警告せず、アプリケーションはiOS 17.0を搭載したデバイスで起動中にクラッシュする可能性があります。 さらに、そのようなクラッシュは、実行がそれらの使用箇所に到達しない場合でも発生するため、バージョンチェックでそれらを保護するだけでは不十分です。</p><p>詳細については、<a href="/ja/kotlin/native-objc-interop#strong-linking">ストロングリンキング</a>を参照してください。</p><h2 id="サードパーティライブラリ" tabindex="-1">サードパーティライブラリ <a class="header-anchor" href="#サードパーティライブラリ" aria-label="Permalink to &quot;サードパーティライブラリ&quot;">​</a></h2><p>システムプラットフォームライブラリとは別に、Kotlin/Nativeはサードパーティのネイティブライブラリのインポートを許可します。 たとえば、<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-overview.html" target="_blank" rel="noreferrer">CocoaPodsの統合</a>を使用するか、<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-dsl-reference.html#cinterops" target="_blank" rel="noreferrer">cinteropsの設定</a>を行うことができます。</p><h3 id="xcodeのバージョンが不一致のライブラリのインポート" tabindex="-1">Xcodeのバージョンが不一致のライブラリのインポート <a class="header-anchor" href="#xcodeのバージョンが不一致のライブラリのインポート" aria-label="Permalink to &quot;Xcodeのバージョンが不一致のライブラリのインポート&quot;">​</a></h3><p>サードパーティのネイティブライブラリをインポートすると、さまざまなXcodeバージョンとの互換性の問題につながる可能性があります。</p><p>ネイティブライブラリを処理する際、コンパイラは通常、ローカルにインストールされているXcodeのヘッダーファイルを使用します。これは、ほとんどすべてのネイティブライブラリのヘッダーが、Xcodeから提供される「標準」ヘッダー (たとえば、<code>stdint.h</code>) をインポートするためです。</p><p>そのため、XcodeのバージョンはKotlinへのネイティブライブラリのインポートに影響を与えます。これは、サードパーティのネイティブライブラリを使用する場合、<a href="/ja/kotlin/whatsnew21#ability-to-publish-kotlin-libraries-from-any-host">Mac以外のホストからのAppleターゲットのクロスコンパイル</a>が依然として不可能な理由の1つでもあります。</p><p>すべてのKotlinバージョンは、単一のXcodeバージョンと最も互換性があります。これが推奨バージョンであり、対応するKotlinバージョンに対して最も多くテストされています。特定のXcodeバージョンとの互換性は、<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-compatibility-guide.html#version-compatibility" target="_blank" rel="noreferrer">互換性テーブル</a>で確認してください。</p><p>新しいまたは古いXcodeバージョンを使用することはしばしば可能ですが、問題を引き起こす可能性があります。通常、サードパーティのネイティブライブラリのインポートに影響します。</p><h4 id="推奨よりも新しいxcodeバージョン" tabindex="-1">推奨よりも新しいXcodeバージョン <a class="header-anchor" href="#推奨よりも新しいxcodeバージョン" aria-label="Permalink to &quot;推奨よりも新しいXcodeバージョン&quot;">​</a></h4><p>推奨よりも新しいXcodeバージョンを使用すると、いくつかのKotlin機能を破壊する可能性があります。これによって最も影響を受けるのはサードパーティのネイティブライブラリのインポートです。サポートされていないXcodeバージョンでは、まったく動作しないことがよくあります。</p><h4 id="推奨よりも古いxcodeバージョン" tabindex="-1">推奨よりも古いXcodeバージョン <a class="header-anchor" href="#推奨よりも古いxcodeバージョン" aria-label="Permalink to &quot;推奨よりも古いXcodeバージョン&quot;">​</a></h4><p>通常、Kotlinは古いXcodeバージョンとうまく動作します。時折問題が発生する可能性があり、それらはほとんどの場合、次の結果をもたらします:</p><ul><li><a href="https://youtrack.jetbrains.com/issue/KT-71694" target="_blank" rel="noreferrer">KT-71694</a>のように、存在しない型を参照するKotlin API。</li><li>システムライブラリの型がネイティブライブラリのKotlin APIに含まれる。 この場合、プロジェクトは正常にコンパイルされますが、システムネイティブ型がネイティブライブラリパッケージに追加されます。 たとえば、IDEのオートコンプリートでこの型が予期せず表示されることがあります。</li></ul><p>Kotlinライブラリが古いXcodeバージョンで正常にコンパイルされる場合、<a href="#using-native-types-in-library-api">KotlinライブラリAPIでサードパーティライブラリの型を使用しない限り</a>、公開しても安全です。</p><h3 id="推移的なサードパーティネイティブ依存関係の使用" tabindex="-1">推移的なサードパーティネイティブ依存関係の使用 <a class="header-anchor" href="#推移的なサードパーティネイティブ依存関係の使用" aria-label="Permalink to &quot;推移的なサードパーティネイティブ依存関係の使用&quot;">​</a></h3><p>プロジェクト内のKotlinライブラリが実装の一部としてサードパーティのネイティブライブラリをインポートする場合、プロジェクトもそのネイティブライブラリにアクセスできます。 これは、Kotlin/Nativeが<code>api</code>と<code>implementation</code>の依存関係タイプを区別しないためであり、そのためネイティブライブラリは常に<code>api</code>依存関係となります。</p><p>そのような推移的なネイティブ依存関係を使用すると、より多くの互換性の問題が発生しやすくなります。 たとえば、Kotlinライブラリ開発者による変更により、ネイティブライブラリのKotlin表現が非互換になる可能性があり、Kotlinライブラリを更新する際に互換性の問題につながります。</p><p>したがって、推移的な依存関係に頼るのではなく、同じネイティブライブラリとの相互運用性を直接設定してください。 そのためには、互換性の問題を防止するために<a href="#use-custom-package-name">カスタムパッケージ名を使用する</a>のと同様に、ネイティブライブラリに別のパッケージ名を使用してください。</p><h3 id="ライブラリapiでのネイティブ型の使用" tabindex="-1">ライブラリAPIでのネイティブ型の使用 <a class="header-anchor" href="#ライブラリapiでのネイティブ型の使用" aria-label="Permalink to &quot;ライブラリAPIでのネイティブ型の使用&quot;">​</a></h3><p>Kotlinライブラリを公開する場合、ライブラリAPIでのネイティブ型に注意してください。そのような使用箇所は、互換性やその他の問題を修正するために将来的に破壊されることが予想されており、これはライブラリユーザーに影響を与えます。</p><p>ライブラリAPIでネイティブ型を使用することが必要な場合があります。これは、ライブラリの目的に必要であるためです。たとえば、Kotlinライブラリが基本的にネイティブライブラリへの拡張機能を提供する場合などです。 それがあなたのケースでない場合は、ライブラリAPIでのネイティブ型の使用を避けるか、制限してください。</p><p>この推奨事項は、ライブラリAPIでのネイティブ型の使用にのみ適用され、アプリケーションコードとは関係ありません。 また、ライブラリの実装には適用されません。たとえば:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 特に注意してください！ネイティブ型がライブラリAPIで使用されています:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createUIView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UIView</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleThirdPartyNativeType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ThirdPartyNativeType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 通常通り注意してください。ネイティブ型はライブラリAPIで使用されていません:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">internal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createUIViewController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UIViewController</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NSDate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h3 id="サードパーティライブラリを使用するライブラリの公開" tabindex="-1">サードパーティライブラリを使用するライブラリの公開 <a class="header-anchor" href="#サードパーティライブラリを使用するライブラリの公開" aria-label="Permalink to &quot;サードパーティライブラリを使用するライブラリの公開&quot;">​</a></h3><p>サードパーティのネイティブライブラリを使用するKotlinライブラリを公開する場合、互換性の問題を回避するためにできることがいくつかあります。</p><h4 id="カスタムパッケージ名の使用" tabindex="-1">カスタムパッケージ名の使用 <a class="header-anchor" href="#カスタムパッケージ名の使用" aria-label="Permalink to &quot;カスタムパッケージ名の使用&quot;">​</a></h4><p>サードパーティのネイティブライブラリにカスタムパッケージ名を使用すると、互換性の問題を防止するのに役立つ場合があります。</p><p>ネイティブライブラリがKotlinにインポートされると、Kotlinパッケージ名が付与されます。一意でない場合、ライブラリユーザーは衝突を経験する可能性があります。たとえば、ネイティブライブラリがユーザーのプロジェクトの他の場所や他の依存関係で同じパッケージ名でインポートされている場合、それら2つの使用箇所は衝突します。</p><p>そのような場合、コンパイルは<code>Linking globals named &#39;...&#39;: symbol multiply defined!</code>エラーで失敗する可能性があります。 しかし、他Rのエラーが発生したり、コンパイルが成功することさえあります。</p><p>サードパーティのネイティブライブラリにカスタム名を使用するには:</p><ul><li>CocoaPods統合を介してネイティブライブラリをインポートする場合、Gradleビルドスクリプトの<code>pod {}</code>ブロックで<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-dsl-reference.html#pod-function" target="_blank" rel="noreferrer"><code>packageName</code></a>プロパティを使用してください。</li><li><code>cinterops</code>設定でネイティブライブラリをインポートする場合、設定ブロックで<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-dsl-reference.html#cinterops" target="_blank" rel="noreferrer"><code>packageName</code></a>プロパティを使用してください。</li></ul><h4 id="古いkotlinバージョンとの互換性を確認する" tabindex="-1">古いKotlinバージョンとの互換性を確認する <a class="header-anchor" href="#古いkotlinバージョンとの互換性を確認する" aria-label="Permalink to &quot;古いKotlinバージョンとの互換性を確認する&quot;">​</a></h4><p>Kotlinライブラリを公開する場合、サードパーティのネイティブライブラリの使用は、他のKotlinバージョンとのライブラリの互換性に影響を与える可能性があります。具体的には:</p><ul><li><p>Kotlin Multiplatformライブラリは前方互換性 (古いコンパイラが新しいコンパイラでコンパイルされたライブラリを使用できること) を保証しません。</p><p>実際には、一部のケースでは動作しますが、ネイティブライブラリを使用すると、前方互換性がさらに制限される可能性があります。</p></li><li><p>Kotlin Multiplatformライブラリは後方互換性 (新しいコンパイラが古いバージョンで生成されたライブラリを使用できること) を提供します。</p><p>Kotlinライブラリでネイティブライブラリを使用しても、通常、その後方互換性に影響を与えるべきではありません。 しかし、互換性に影響を与えるより多くのコンパイラバグの可能性を開きます。</p></li></ul><h4 id="静的ライブラリの埋め込みを避ける" tabindex="-1">静的ライブラリの埋め込みを避ける <a class="header-anchor" href="#静的ライブラリの埋め込みを避ける" aria-label="Permalink to &quot;静的ライブラリの埋め込みを避ける&quot;">​</a></h4><p>ネイティブライブラリをインポートする際、<code>-staticLibrary</code>コンパイラオプションまたは<code>.def</code>ファイルの<code>staticLibraries</code>プロパティを使用して、関連する<a href="/ja/kotlin/native-definition-file#include-a-static-library">静的ライブラリ</a> (<code>.a</code>ファイル) を含めることが可能です。 その場合、ライブラリユーザーはネイティブ依存関係とリンカオプションを処理する必要がありません。</p><p>しかし、含まれている静的ライブラリの使用法をいかなる方法でも設定することは不可能です。つまり、除外することも、置き換える (置換する) こともできません。 そのため、ユーザーは同じ静的ライブラリを含む他のKotlinライブラリとの潜在的な衝突を解決したり、そのバージョンを調整したりすることはできません。</p><h2 id="ネイティブライブラリサポートの進化" tabindex="-1">ネイティブライブラリサポートの進化 <a class="header-anchor" href="#ネイティブライブラリサポートの進化" aria-label="Permalink to &quot;ネイティブライブラリサポートの進化&quot;">​</a></h2><p>現在、KotlinプロジェクトでCおよびObjective-Cを使用すると、互換性の問題につながる可能性があります。その一部はこのガイドに記載されています。 それらを修正するためには、将来的にいくつかの破壊的変更が必要になる可能性があります。これは、それ自体が互換性の問題の一因となります。</p>`,55))])}const g=n(p,[["render",h]]);export{f as __pageData,g as default};
