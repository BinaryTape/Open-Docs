import{_ as a}from"./chunks/ksp-class-diagram.ClaR6pZl.js";import{_ as n,c as t,o as l,j as e,ag as p,a as s}from"./chunks/framework.Bksy39di.js";const f=JSON.parse('{"title":"KSPにおけるKotlinコードのモデル化","description":"","frontmatter":{},"headers":[],"relativePath":"ja/kotlin/ksp-additional-details.md","filePath":"ja/kotlin/ksp-additional-details.md","lastUpdated":1754307826000}'),o={name:"ja/kotlin/ksp-additional-details.md"};function r(c,i,d,k,h,g){return l(),t("div",null,i[0]||(i[0]=[e("h1",{id:"kspにおけるkotlinコードのモデル化",tabindex:"-1"},[s("KSPにおけるKotlinコードのモデル化 "),e("a",{class:"header-anchor",href:"#kspにおけるkotlinコードのモデル化","aria-label":'Permalink to "KSPにおけるKotlinコードのモデル化"'},"​")],-1),e("p",null,[s("API定義は、"),e("a",{href:"https://github.com/google/ksp/tree/main/api/src/main/kotlin/com/google/devtools/ksp",target:"_blank",rel:"noreferrer"},"KSP GitHubリポジトリ"),s("で確認できます。 この図は、KSPでKotlinがどのように"),e("a",{href:"https://github.com/google/ksp/tree/main/api/src/main/kotlin/com/google/devtools/ksp/symbol/",target:"_blank",rel:"noreferrer"},"モデル化"),s("されるかの概要を示しています。")],-1),e("p",null,[e("img",{src:a,alt:"クラス図",thumbnail:"true",width:"800","thumbnail-same-file":"true"})],-1),p(`<div class="note custom-block"><p class="custom-block-title">NOTE</p><p><a href="https://kotlinlang.org/docs/images/ksp-class-diagram.svg" target="_blank" rel="noreferrer">フルサイズの図を参照</a>。</p></div><h2 id="型と解決" tabindex="-1">型と解決 <a class="header-anchor" href="#型と解決" aria-label="Permalink to &quot;型と解決&quot;">​</a></h2><p>解決処理は、基盤となるAPI実装において最もコストがかかります。そのため、型参照はプロセッサによって明示的に解決されるように設計されています（いくつかの例外を除いて）。<code>KSFunctionDeclaration.returnType</code> や <code>KSAnnotation.annotationType</code> のような <em>型</em> が参照される場合、それは常に <code>KSTypeReference</code> であり、アノテーションと修飾子を持つ <code>KSReferenceElement</code> です。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> KSFunctionDeclaration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> returnType: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSTypeReference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> KSTypeReference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSAnnotated</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSModifierListOwner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> type: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSReferenceElement</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>KSTypeReference</code> は <code>KSType</code> に解決することができ、これはKotlinの型システムにおける型を参照します。</p><p><code>KSTypeReference</code> は <code>KSReferenceElement</code> を持ち、これはKotlinのプログラム構造、つまり参照がどのように記述されているかをモデル化します。これは、Kotlinの文法における <a href="https://kotlinlang.org/docs/reference/grammar.html#type" target="_blank" rel="noreferrer"><code>type</code></a> 要素に対応します。</p><p><code>KSReferenceElement</code> は <code>KSClassifierReference</code> または <code>KSCallableReference</code> となり得ます。これらは、解決の必要なしに多くの有用な情報を含んでいます。例えば、<code>KSClassifierReference</code> には <code>referencedName</code> があり、<code>KSCallableReference</code> には <code>receiverType</code>、<code>functionArguments</code>、<code>returnType</code> があります。</p><p><code>KSTypeReference</code> によって参照される元の宣言が必要な場合、通常は <code>KSType</code> に解決し、<code>KSType.declaration</code> を介してアクセスすることで見つけることができます。型が言及されている場所からそのクラスが定義されている場所へ移動するのは次のようになります。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ksType: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSType</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ksTypeReference.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ksDeclaration: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSDeclaration</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ksType.declaration</span></span></code></pre></div><p>型の解決はコストが高く、したがって明示的な形式を持っています。解決から得られる情報の一部は、<code>KSReferenceElement</code> ですでに利用可能です。例えば、<code>KSClassifierReference.referencedName</code> を使用すると、不要な多くの要素をフィルタリングできます。<code>KSDeclaration</code> または <code>KSType</code> から特定の情報が必要な場合にのみ、型を解決すべきです。</p><p>関数型を指す <code>KSTypeReference</code> は、その情報のほとんどをその要素内に持っています。 <code>Function0</code>、<code>Function1</code> などのファミリーに解決できますが、これらの解決は <code>KSCallableReference</code> よりも多くの情報をもたらしません。関数型参照を解決するユースケースの1つは、関数のプロトタイプ（prototype）の同一性を扱うことです。</p>`,11)]))}const m=n(o,[["render",r]]);export{f as __pageData,m as default};
