import{_ as l}from"./chunks/gradle-console-rich-output.BeIOO7Zd.js";import{_ as p,C as n,c as h,o as k,ag as i,G as a,j as o}from"./chunks/framework.Bksy39di.js";const F=JSON.parse('{"title":"Kotlin 2.2.0의 새로운 기능","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/whatsnew22.md","filePath":"ko/kotlin/whatsnew22.md","lastUpdated":1755514048000}'),r={name:"ko/kotlin/whatsnew22.md"};function d(c,s,g,E,y,u){const t=n("YouTubeVideo"),e=n("TopicTitle");return k(),h("div",null,[s[0]||(s[0]=i('<h1 id="kotlin-2-2-0의-새로운-기능" tabindex="-1">Kotlin 2.2.0의 새로운 기능 <a class="header-anchor" href="#kotlin-2-2-0의-새로운-기능" aria-label="Permalink to &quot;Kotlin 2.2.0의 새로운 기능&quot;">​</a></h1><p><em><a href="/ko/kotlin/releases#release-details">출시일: 2025년 6월 23일</a></em></p><p>Kotlin 2.2.0이 출시되었습니다! 주요 내용은 다음과 같습니다:</p><ul><li><strong>언어</strong>: <a href="#preview-of-context-parameters">컨텍스트 파라미터</a>를 포함한 새로운 프리뷰 언어 기능이 추가되었습니다. 가드 조건, 비지역 <code>break</code> 및 <code>continue</code>, 멀티-달러 보간법 등 여러 <a href="#stable-features-guard-conditions-non-local-break-and-continue-and-multi-dollar-interpolation">이전 실험 기능이 이제 Stable</a>로 전환되었습니다.</li><li><strong>Kotlin 컴파일러</strong>: <a href="#kotlin-compiler-unified-management-of-compiler-warnings">컴파일러 경고의 통합 관리</a> 기능이 추가되었습니다.</li><li><strong>Kotlin/JVM</strong>: <a href="#changes-to-default-method-generation-for-interface-functions">인터페이스 함수의 기본 메서드 생성 변경</a>이 있습니다.</li><li><strong>Kotlin/Native</strong>: <a href="#kotlin-native">LLVM 19 및 메모리 소비 추적 및 조정</a>을 위한 새로운 기능이 추가되었습니다.</li><li><strong>Kotlin/Wasm</strong>: <a href="#build-infrastructure-for-wasm-target-separated-from-javascript-target">Wasm 타겟 분리</a> 및 <a href="#per-project-binaryen-configuration">프로젝트별 Binaryen 구성</a> 기능이 추가되었습니다.</li><li><strong>Kotlin/JS</strong>: <a href="#fix-for-copy-in-jsplainobject-interfaces"><code>@JsPlainObject</code> 인터페이스에 생성된 <code>copy()</code> 메서드 수정</a>이 있습니다.</li><li><strong>Gradle</strong>: <a href="#binary-compatibility-validation-included-in-kotlin-gradle-plugin">Kotlin Gradle 플러그인에 바이너리 호환성 검증</a>이 포함되었습니다.</li><li><strong>표준 라이브러리</strong>: <a href="#stable-base64-encoding-and-decoding">Stable Base64 및 HexFormat API</a>가 추가되었습니다.</li><li><strong>문서</strong>: 저희 <a href="https://surveys.jetbrains.com/s3/Kotlin-Docs-2025" target="_blank" rel="noreferrer">문서 설문조사가 진행 중</a>이며, <a href="#documentation-updates">Kotlin 문서에 상당한 개선</a>이 있었습니다.</li></ul><p>Kotlin 언어 발전 팀이 새로운 기능에 대해 논의하고 질문에 답변하는 다음 비디오도 시청할 수 있습니다:</p>',5)),a(t,{src:"https://www.youtube.com/watch?v=jne3923lWtw",title:"What's new in Kotlin 2.2.0"}),s[1]||(s[1]=i('<h2 id="ide-지원" tabindex="-1">IDE 지원 <a class="header-anchor" href="#ide-지원" aria-label="Permalink to &quot;IDE 지원&quot;">​</a></h2><p>2.2.0을 지원하는 Kotlin 플러그인은 최신 버전의 IntelliJ IDEA 및 Android Studio에 번들로 제공됩니다. IDE에서 Kotlin 플러그인을 업데이트할 필요가 없습니다. 빌드 스크립트에서 Kotlin 버전을 2.2.0으로 <a href="/ko/kotlin/configure-build-for-eap#adjust-the-kotlin-version">변경</a>하기만 하면 됩니다.</p><p>자세한 내용은 <a href="/ko/kotlin/releases#update-to-a-new-kotlin-version">새 릴리스로 업데이트</a>를 참조하세요.</p><h2 id="언어" tabindex="-1">언어 <a class="header-anchor" href="#언어" aria-label="Permalink to &quot;언어&quot;">​</a></h2><p>이번 릴리스는 가드 조건, 비지역 <code>break</code> 및 <code>continue</code>, 멀티-달러 보간법을 <a href="/ko/kotlin/components-stability#stability-levels-explained">Stable</a>로 <a href="#stable-features-guard-conditions-non-local-break-and-continue-and-multi-dollar-interpolation">승격</a>시킵니다. 또한 <a href="#preview-of-context-parameters">컨텍스트 파라미터</a> 및 <a href="#preview-of-context-sensitive-resolution">컨텍스트-민감형 분석</a>과 같은 몇 가지 기능이 프리뷰로 도입되었습니다.</p>',5)),a(e,{id:"컨텍스트-파라미터-프리뷰",level:"3",title:"컨텍스트 파라미터 프리뷰",labelRef:"experimental-general"}),s[2]||(s[2]=i(`<p>컨텍스트 파라미터는 함수 및 프로퍼티가 주변 컨텍스트에서 암시적으로 사용 가능한 의존성을 선언할 수 있도록 합니다.</p><p>컨텍스트 파라미터를 사용하면 서비스나 의존성처럼 공유되고 함수 호출 세트 전반에서 거의 변경되지 않는 값을 수동으로 전달할 필요가 없습니다.</p><p>컨텍스트 파라미터는 컨텍스트 리시버(context receivers)라는 이전 실험 기능을 대체합니다. 컨텍스트 리시버에서 컨텍스트 파라미터로 마이그레이션하려면, <a href="https://blog.jetbrains.com/kotlin/2025/04/update-on-context-parameters/" target="_blank" rel="noreferrer">블로그 게시물</a>에 설명된 대로 IntelliJ IDEA의 지원 기능을 사용할 수 있습니다.</p><p>주요 차이점은 컨텍스트 파라미터가 함수 본문에서 리시버로 도입되지 않는다는 것입니다. 결과적으로, 컨텍스트가 암시적으로 사용 가능했던 컨텍스트 리시버와 달리, 컨텍스트 파라미터의 멤버에 접근하려면 해당 이름을 사용해야 합니다.</p><p>Kotlin의 컨텍스트 파라미터는 의존성 주입 간소화, DSL 설계 개선 및 스코프 작업(scoped operations)을 통해 의존성 관리에 상당한 개선을 가져옵니다. 자세한 내용은 이 기능의 <a href="https://github.com/Kotlin/KEEP/blob/context-parameters/proposals/context-parameters.md" target="_blank" rel="noreferrer">KEEP</a>을 참조하세요.</p><h4 id="컨텍스트-파라미터를-선언하는-방법" tabindex="-1">컨텍스트 파라미터를 선언하는 방법 <a class="header-anchor" href="#컨텍스트-파라미터를-선언하는-방법" aria-label="Permalink to &quot;컨텍스트 파라미터를 선언하는 방법&quot;">​</a></h4><p><code>context</code> 키워드 뒤에 <code>name: Type</code> 형식의 파라미터 목록을 사용하여 프로퍼티 및 함수에 대한 컨텍스트 파라미터를 선언할 수 있습니다. <code>UserService</code> 인터페이스에 대한 의존성을 사용하는 예시는 다음과 같습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// UserService는 컨텍스트에서 필요한 의존성을 정의합니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> findUserById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 컨텍스트 파라미터를 사용하여 함수를 선언합니다.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UserService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outputMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 컨텍스트에서 log를 사용합니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    users.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Log: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$message</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 컨텍스트 파라미터를 사용하여 프로퍼티를 선언합니다.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UserService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> firstUser: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 컨텍스트에서 findUserById를 사용합니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">findUserById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><code>_</code>를 컨텍스트 파라미터 이름으로 사용할 수 있습니다. 이 경우, 파라미터 값은 분석에 사용 가능하지만 블록 내에서 이름으로 접근할 수는 없습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;_&quot;를 컨텍스트 파라미터 이름으로 사용합니다.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UserService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> logWelcome</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // UserService에서 적절한 로그 함수를 찾습니다.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    outputMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Welcome!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="컨텍스트-파라미터를-활성화하는-방법" tabindex="-1">컨텍스트 파라미터를 활성화하는 방법 <a class="header-anchor" href="#컨텍스트-파라미터를-활성화하는-방법" aria-label="Permalink to &quot;컨텍스트 파라미터를 활성화하는 방법&quot;">​</a></h4><p>프로젝트에서 컨텍스트 파라미터를 활성화하려면 명령줄에서 다음 컴파일러 옵션을 사용하세요:</p><div class="language-Bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-Xcontext-parameters</span></span></code></pre></div><p>또는 Gradle 빌드 파일의 <code>compilerOptions {}</code> 블록에 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xcontext-parameters&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>-Xcontext-receivers</code>와 <code>-Xcontext-parameters</code> 컴파일러 옵션을 동시에 지정하면 오류가 발생합니다.</p></div><h4 id="피드백-남기기" tabindex="-1">피드백 남기기 <a class="header-anchor" href="#피드백-남기기" aria-label="Permalink to &quot;피드백 남기기&quot;">​</a></h4><p>이 기능은 향후 Kotlin 릴리스에서 안정화되고 개선될 예정입니다. 이슈 트래커인 <a href="https://youtrack.jetbrains.com/issue/KT-10468/Context-Parameters-expanding-extension-receivers-to-work-with-scopes" target="_blank" rel="noreferrer">YouTrack</a>에 피드백을 주시면 감사하겠습니다.</p>`,18)),a(e,{id:"컨텍스트-민감형-분석-프리뷰",level:"3",title:"컨텍스트-민감형 분석 프리뷰",labelRef:"experimental-general"}),s[3]||(s[3]=i(`<p>Kotlin 2.2.0은 컨텍스트-민감형 분석(context-sensitive resolution) 구현을 프리뷰로 도입합니다.</p><p>이전에는 타입이 컨텍스트에서 추론될 수 있었더라도 enum 엔트리 또는 sealed 클래스 멤버의 전체 이름을 작성해야 했습니다. 예를 들어:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Problem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    CONNECTION, AUTHENTICATION, DATABASE, UNKNOWN</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(problem: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Problem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (problem) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Problem.CONNECTION </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;connection&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Problem.AUTHENTICATION </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;authentication&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Problem.DATABASE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;database&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Problem.UNKNOWN </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;unknown&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이제 컨텍스트-민감형 분석을 사용하면 예상 타입이 알려진 컨텍스트에서 타입 이름을 생략할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Problem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    CONNECTION, AUTHENTICATION, DATABASE, UNKNOWN</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 알려진 문제 타입에 따라 enum 엔트리를 분석합니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(problem: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Problem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (problem) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    CONNECTION </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;connection&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    AUTHENTICATION </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;authentication&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    DATABASE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;database&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    UNKNOWN </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;unknown&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>컴파일러는 이 컨텍스트 타입 정보를 사용하여 올바른 멤버를 분석합니다. 이 정보에는 다음이 포함됩니다:</p><ul><li><code>when</code> 표현식의 subject</li><li>명시적 반환 타입</li><li>선언된 변수 타입</li><li>타입 검사 (<code>is</code>) 및 캐스트 (<code>as</code>)</li><li>sealed 클래스 계층 구조의 알려진 타입</li><li>파라미터의 선언된 타입</li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>컨텍스트-민감형 분석은 함수, 파라미터가 있는 프로퍼티, 또는 리시버가 있는 확장 프로퍼티에는 적용되지 않습니다.</p></div><p>프로젝트에서 컨텍스트-민감형 분석을 사용해 보려면 명령줄에서 다음 컴파일러 옵션을 사용하세요:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-Xcontext-sensitive-resolution</span></span></code></pre></div><p>또는 Gradle 빌드 파일의 <code>compilerOptions {}</code> 블록에 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xcontext-sensitive-resolution&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>향후 Kotlin 릴리스에서 이 기능을 안정화하고 개선할 계획이며, 이슈 트래커인 <a href="https://youtrack.jetbrains.com/issue/KT-16768/Context-sensitive-resolution" target="_blank" rel="noreferrer">YouTrack</a>에 피드백을 주시면 감사하겠습니다.</p>`,13)),a(e,{id:"어노테이션-사용-위치-타겟-use-site-targets-을-위한-기능-프리뷰",level:"3",title:"어노테이션 사용-위치 타겟(use-site targets)을 위한 기능 프리뷰",labelRef:"experimental-general"}),s[4]||(s[4]=o("p",null,"Kotlin 2.2.0은 어노테이션 사용-위치 타겟 작업을 더 편리하게 만드는 몇 가지 기능을 도입합니다.",-1)),a(e,{id:"프로퍼티를-위한-all-메타-타겟",level:"4",title:"프로퍼티를 위한 `@all` 메타-타겟",labelRef:"experimental-general"}),s[5]||(s[5]=i(`<p>Kotlin을 사용하면 선언의 특정 부분, 즉 <a href="/ko/kotlin/annotations#annotation-use-site-targets">사용-위치 타겟(use-site targets)</a>에 어노테이션을 붙일 수 있습니다. 그러나 각 타겟에 개별적으로 어노테이션을 다는 것은 복잡하고 오류가 발생하기 쉬웠습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> username: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @param</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Email</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      // </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">생성자</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 파라미터</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Email</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      // </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">백킹</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 필드</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Email</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        // </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">게터</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 메서드</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @property</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Email</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   // </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Kotlin</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 프로퍼티</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 참조</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> email: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Email</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Email</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @property</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Email</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> secondaryEmail: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이를 간소화하기 위해 Kotlin은 프로퍼티를 위한 새로운 <code>@all</code> 메타-타겟을 도입합니다. 이 기능은 컴파일러에게 어노테이션을 프로퍼티의 모든 관련 부분에 적용하도록 지시합니다. <code>@all</code>을 사용하면 어노테이션을 다음 대상에 적용하려고 시도합니다:</p><ul><li><p><strong><code>param</code></strong>: 주 생성자에 선언된 경우 생성자 파라미터.</p></li><li><p><strong><code>property</code></strong>: Kotlin 프로퍼티 자체.</p></li><li><p><strong><code>field</code></strong>: 백킹 필드가 존재하는 경우.</p></li><li><p><strong><code>get</code></strong>: 게터 메서드.</p></li><li><p><strong><code>set_param</code></strong>: 프로퍼티가 <code>var</code>로 정의된 경우 세터 메서드의 파라미터.</p></li><li><p><strong><code>RECORD_COMPONENT</code></strong>: 클래스가 <code>@JvmRecord</code>인 경우, 어노테이션은 <a href="#improved-support-for-annotating-jvm-records">자바 레코드 컴포넌트</a>에 적용됩니다. 이 동작은 자바가 레코드 컴포넌트의 어노테이션을 처리하는 방식과 유사합니다.</p></li></ul><p>컴파일러는 주어진 프로퍼티의 타겟에만 어노테이션을 적용합니다.</p><p>아래 예시에서, <code>@Email</code> 어노테이션은 각 프로퍼티의 모든 관련 타겟에 적용됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> username: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // @Email을 param, property, field,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // get, set_param (var인 경우)에 적용</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Email</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> val</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> email</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // @Email을 property, field, getter에 적용</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // (생성자에 없으므로 param에는 적용 안함)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Email</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> val</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> secondaryEmail</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? = </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>@all</code> 메타-타겟은 주 생성자 내부와 외부 모두에서 모든 프로퍼티와 함께 사용할 수 있습니다. 그러나 <code>@all</code> 메타-타겟을 <a href="https://kotlinlang.org/spec/syntax-and-grammar.html#grammar-rule-annotation" target="_blank" rel="noreferrer">여러 어노테이션</a>과 함께 사용할 수는 없습니다.</p><p>이 새로운 기능은 구문을 간소화하고, 일관성을 보장하며, 자바 레코드와의 상호 운용성을 개선합니다.</p><p>프로젝트에서 <code>@all</code> 메타-타겟을 활성화하려면 명령줄에서 다음 컴파일러 옵션을 사용하세요:</p><div class="language-Bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-Xannotation-target-all</span></span></code></pre></div><p>또는 Gradle 빌드 파일의 <code>compilerOptions {}</code> 블록에 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xannotation-target-all&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 기능은 프리뷰 상태입니다. <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack</a>의 이슈 트래커에 문제점을 보고해 주세요. <code>@all</code> 메타-타겟에 대한 자세한 내용은 이 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/annotation-target-in-properties.md" target="_blank" rel="noreferrer">KEEP</a> 제안을 읽어보세요.</p>`,14)),a(e,{id:"사용-위치-어노테이션-타겟을-위한-새로운-기본-규칙",level:"4",title:"사용-위치 어노테이션 타겟을 위한 새로운 기본 규칙",labelRef:"experimental-general"}),s[6]||(s[6]=i(`<p>Kotlin 2.2.0은 파라미터, 필드 및 프로퍼티로 어노테이션을 전파하기 위한 새로운 기본 규칙을 도입합니다. 이전에는 어노테이션이 기본적으로 <code>param</code>, <code>property</code>, 또는 <code>field</code> 중 하나에만 적용되었지만, 이제 기본값은 어노테이션에 기대되는 바와 더 일치합니다.</p><p>여러 적용 가능한 타겟이 있는 경우, 하나 이상이 다음과 같이 선택됩니다:</p><ul><li>생성자 파라미터 타겟(<code>param</code>)이 적용 가능하면 사용됩니다.</li><li>프로퍼티 타겟(<code>property</code>)이 적용 가능하면 사용됩니다.</li><li><code>property</code>가 적용 가능하지 않은 동안 필드 타겟(<code>field</code>)이 적용 가능하면 <code>field</code>가 사용됩니다.</li></ul><p>여러 타겟이 있고 <code>param</code>, <code>property</code>, 또는 <code>field</code> 중 어느 것도 적용 가능하지 않으면 어노테이션은 오류를 발생시킵니다.</p><p>이 기능을 활성화하려면 Gradle 빌드 파일의 <code>compilerOptions {}</code> 블록에 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xannotation-default-target=param-property&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>또는 컴파일러에 대한 명령줄 인수를 사용하세요:</p><div class="language-Bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">-Xannotation-default-target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">param-property</span></span></code></pre></div><p>이전 동작을 사용하고 싶다면 다음을 할 수 있습니다:</p><ul><li><p>특정 경우에 <code>param:Annotation</code> 대신 <code>@Annotation</code>을 사용하여 필요한 타겟을 명시적으로 정의합니다.</p></li><li><p>전체 프로젝트의 경우, Gradle 빌드 파일에서 이 플래그를 사용합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xannotation-default-target=first-only&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><p>이 기능은 프리뷰 상태입니다. <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack</a>의 이슈 트래커에 문제점을 보고해 주세요. 어노테이션 사용-위치 타겟을 위한 새로운 기본 규칙에 대한 자세한 내용은 이 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/annotation-target-in-properties.md" target="_blank" rel="noreferrer">KEEP</a> 제안을 읽어보세요.</p>`,11)),a(e,{id:"중첩된-타입-별칭-nested-type-aliases-지원",level:"3",title:"중첩된 타입 별칭(nested type aliases) 지원",labelRef:"beta"}),s[7]||(s[7]=i(`<p>이전에는 Kotlin 파일의 최상위 레벨에서만 <a href="/ko/kotlin/type-aliases">타입 별칭(type aliases)</a>을 선언할 수 있었습니다. 이는 내부 또는 도메인별 타입 별칭조차도 사용되는 클래스 외부에서 존재해야 한다는 것을 의미했습니다.</p><p>2.2.0부터는 외부 클래스에서 타입 파라미터를 캡처하지 않는 한, 다른 선언 내부에 타입 별칭을 정의할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Dijkstra</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    typealias</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VisitedNodes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Set</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> step</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(visited: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">VisitedNodes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>중첩된 타입 별칭에는 타입 파라미터를 언급할 수 없는 것과 같은 몇 가지 추가 제약 조건이 있습니다. 전체 규칙 집합은 <a href="/ko/kotlin/type-aliases#nested-type-aliases">문서</a>를 참조하세요.</p><p>중첩된 타입 별칭은 캡슐화를 개선하고, 패키지 레벨의 혼란을 줄이며, 내부 구현을 단순화하여 더 깔끔하고 유지보수 가능한 코드를 가능하게 합니다.</p><h4 id="중첩된-타입-별칭을-활성화하는-방법" tabindex="-1">중첩된 타입 별칭을 활성화하는 방법 <a class="header-anchor" href="#중첩된-타입-별칭을-활성화하는-방법" aria-label="Permalink to &quot;중첩된 타입 별칭을 활성화하는 방법&quot;">​</a></h4><p>프로젝트에서 중첩된 타입 별칭을 활성화하려면 명령줄에서 다음 컴파일러 옵션을 사용하세요:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-Xnested-type-aliases</span></span></code></pre></div><p>또는 Gradle 빌드 파일의 <code>compilerOptions {}</code> 블록에 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xnested-type-aliases&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="피드백-공유" tabindex="-1">피드백 공유 <a class="header-anchor" href="#피드백-공유" aria-label="Permalink to &quot;피드백 공유&quot;">​</a></h4><p>중첩된 타입 별칭은 현재 <a href="/ko/kotlin/components-stability#stability-levels-explained">베타</a> 상태입니다. <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack</a>의 이슈 트래커에 문제점을 보고해 주세요. 이 기능에 대한 자세한 내용은 이 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/nested-typealias.md" target="_blank" rel="noreferrer">KEEP</a> 제안을 읽어보세요.</p><h3 id="stable-기능-가드-조건-비지역-break-및-continue-멀티-달러-보간법" tabindex="-1">Stable 기능: 가드 조건, 비지역 <code>break</code> 및 <code>continue</code>, 멀티-달러 보간법 <a class="header-anchor" href="#stable-기능-가드-조건-비지역-break-및-continue-멀티-달러-보간법" aria-label="Permalink to &quot;Stable 기능: 가드 조건, 비지역 \`break\` 및 \`continue\`, 멀티-달러 보간법&quot;">​</a></h3><p>Kotlin 2.1.0에서는 여러 새로운 언어 기능이 프리뷰로 도입되었습니다. 이번 릴리스에서 다음 언어 기능이 <a href="/ko/kotlin/components-stability#stability-levels-explained">Stable</a>로 전환되었음을 발표하게 되어 기쁩니다:</p><ul><li><a href="/ko/kotlin/whatsnew21#guard-conditions-in-when-with-a-subject">Subject가 있는 <code>when</code>의 가드 조건</a></li><li><a href="/ko/kotlin/whatsnew21#non-local-break-and-continue">비지역 <code>break</code> 및 <code>continue</code></a></li><li><a href="/ko/kotlin/whatsnew21#multi-dollar-string-interpolation">멀티-달러 보간법: 문자열 리터럴에서 <code>$</code> 처리 개선</a></li></ul><p><a href="/ko/kotlin/kotlin-language-features-and-proposals">Kotlin 언어 설계 기능 및 제안의 전체 목록</a>을 참조하세요.</p>`,16)),a(e,{id:"kotlin-컴파일러-컴파일러-경고의-통합-관리",level:"2",title:"Kotlin 컴파일러: 컴파일러 경고의 통합 관리",labelRef:"experimental-general"}),s[8]||(s[8]=i(`<p>Kotlin 2.2.0은 새로운 컴파일러 옵션인 <code>-Xwarning-level</code>을 도입합니다. 이 옵션은 Kotlin 프로젝트에서 컴파일러 경고를 통합적으로 관리할 수 있는 방법을 제공하도록 설계되었습니다.</p><p>이전에는 <code>-nowarn</code>으로 모든 경고를 비활성화하거나, <code>-Werror</code>로 모든 경고를 컴파일 오류로 전환하거나, <code>-Wextra</code>로 추가 컴파일러 검사를 활성화하는 것과 같은 일반적인 모듈 전체 규칙만 적용할 수 있었습니다. 특정 경고에 대해 조정할 수 있는 유일한 옵션은 <code>-Xsuppress-warning</code> 옵션이었습니다.</p><p>새로운 솔루션을 사용하면 일반 규칙을 재정의하고 특정 진단 메시지를 일관된 방식으로 제외할 수 있습니다.</p><h3 id="적용-방법" tabindex="-1">적용 방법 <a class="header-anchor" href="#적용-방법" aria-label="Permalink to &quot;적용 방법&quot;">​</a></h3><p>새로운 컴파일러 옵션은 다음 구문을 가집니다:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">-Xwarning-level</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">DIAGNOSTIC_NAME:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">warning</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disabled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ul><li><code>error</code>: 지정된 경고를 오류로 격상시킵니다.</li><li><code>warning</code>: 경고를 발생시키며 기본적으로 활성화됩니다.</li><li><code>disabled</code>: 지정된 경고를 모듈 전체에서 완전히 억제합니다.</li></ul><p>새로운 컴파일러 옵션으로는 _경고_의 심각도 수준만 구성할 수 있다는 점을 명심하세요.</p><h3 id="사용-사례" tabindex="-1">사용 사례 <a class="header-anchor" href="#사용-사례" aria-label="Permalink to &quot;사용 사례&quot;">​</a></h3><p>새로운 솔루션을 사용하면 일반 규칙과 특정 규칙을 결합하여 프로젝트에서 경고 보고를 더 세밀하게 조정할 수 있습니다. 사용 사례를 선택하세요:</p><h4 id="경고-억제" tabindex="-1">경고 억제 <a class="header-anchor" href="#경고-억제" aria-label="Permalink to &quot;경고 억제&quot;">​</a></h4><table tabindex="0"><thead><tr><th style="text-align:left;">명령</th><th style="text-align:left;">설명</th></tr></thead><tbody><tr><td style="text-align:left;"><a href="/ko/kotlin/compiler-reference#nowarn"><code>-nowarn</code></a></td><td style="text-align:left;">컴파일 중 모든 경고를 억제합니다.</td></tr><tr><td style="text-align:left;"><code>-Xwarning-level=DIAGNOSTIC_NAME:disabled</code></td><td style="text-align:left;">지정된 경고만 억제합니다.</td></tr><tr><td style="text-align:left;"><code>-nowarn -Xwarning-level=DIAGNOSTIC_NAME:warning</code></td><td style="text-align:left;">지정된 경고를 제외한 모든 경고를 억제합니다.</td></tr></tbody></table><h4 id="경고를-오류로-격상" tabindex="-1">경고를 오류로 격상 <a class="header-anchor" href="#경고를-오류로-격상" aria-label="Permalink to &quot;경고를 오류로 격상&quot;">​</a></h4><table tabindex="0"><thead><tr><th style="text-align:left;">명령</th><th style="text-align:left;">설명</th></tr></thead><tbody><tr><td style="text-align:left;"><a href="/ko/kotlin/compiler-reference#werror"><code>-Werror</code></a></td><td style="text-align:left;">모든 경고를 컴파일 오류로 격상시킵니다.</td></tr><tr><td style="text-align:left;"><code>-Xwarning-level=DIAGNOSTIC_NAME:error</code></td><td style="text-align:left;">지정된 경고만 오류로 격상시킵니다.</td></tr><tr><td style="text-align:left;"><code>-Werror -Xwarning-level=DIAGNOSTIC_NAME:warning</code></td><td style="text-align:left;">지정된 경고를 제외한 모든 경고를 오류로 격상시킵니다.</td></tr></tbody></table><h4 id="추가-컴파일러-경고-활성화" tabindex="-1">추가 컴파일러 경고 활성화 <a class="header-anchor" href="#추가-컴파일러-경고-활성화" aria-label="Permalink to &quot;추가 컴파일러 경고 활성화&quot;">​</a></h4><table tabindex="0"><thead><tr><th style="text-align:left;">명령</th><th style="text-align:left;">설명</th></tr></thead><tbody><tr><td style="text-align:left;"><a href="/ko/kotlin/compiler-reference#wextra"><code>-Wextra</code></a></td><td style="text-align:left;">true인 경우 경고를 발생하는 모든 추가 선언, 표현식 및 타입 컴파일러 검사를 활성화합니다.</td></tr><tr><td style="text-align:left;"><code>-Xwarning-level=DIAGNOSTIC_NAME:warning</code></td><td style="text-align:left;">지정된 추가 컴파일러 검사만 활성화합니다.</td></tr><tr><td style="text-align:left;"><code>-Wextra -Xwarning-level=DIAGNOSTIC_NAME:disabled</code></td><td style="text-align:left;">지정된 검사를 제외한 모든 추가 검사를 활성화합니다.</td></tr></tbody></table><h4 id="경고-목록" tabindex="-1">경고 목록 <a class="header-anchor" href="#경고-목록" aria-label="Permalink to &quot;경고 목록&quot;">​</a></h4><p>일반 규칙에서 제외하고 싶은 경고가 많다면 <a href="/ko/kotlin/compiler-reference#argfile"><code>@argfile</code></a>을 통해 별도의 파일에 목록을 작성할 수 있습니다.</p><h3 id="피드백-남기기-1" tabindex="-1">피드백 남기기 <a class="header-anchor" href="#피드백-남기기-1" aria-label="Permalink to &quot;피드백 남기기&quot;">​</a></h3><p>새로운 컴파일러 옵션은 아직 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적(Experimental)</a>입니다. <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack</a>의 이슈 트래커에 문제점을 보고해 주세요.</p><h2 id="kotlin-jvm" tabindex="-1">Kotlin/JVM <a class="header-anchor" href="#kotlin-jvm" aria-label="Permalink to &quot;Kotlin/JVM&quot;">​</a></h2><p>Kotlin 2.2.0은 JVM에 많은 업데이트를 제공합니다. 이제 컴파일러는 Java 24 바이트코드를 지원하며, 인터페이스 함수의 기본 메서드 생성에 변경 사항을 도입합니다. 이 릴리스는 또한 Kotlin 메타데이터에서 어노테이션 작업의 복잡성을 줄이고, 인라인 값 클래스와의 Java 상호 운용성을 개선하며, JVM 레코드에 어노테이션을 달기 위한 더 나은 지원을 포함합니다.</p><h3 id="인터페이스-함수의-기본-메서드-생성-변경" tabindex="-1">인터페이스 함수의 기본 메서드 생성 변경 <a class="header-anchor" href="#인터페이스-함수의-기본-메서드-생성-변경" aria-label="Permalink to &quot;인터페이스 함수의 기본 메서드 생성 변경&quot;">​</a></h3><p>Kotlin 2.2.0부터, 인터페이스에 선언된 함수는 달리 구성되지 않는 한 JVM 기본 메서드로 컴파일됩니다. 이 변경은 구현이 있는 Kotlin 인터페이스 함수가 바이트코드로 컴파일되는 방식에 영향을 미칩니다.</p><p>이 동작은 더 이상 사용되지 않는 <code>-Xjvm-default</code> 옵션을 대체하는 새로운 Stable 컴파일러 옵션 <code>-jvm-default</code>에 의해 제어됩니다.</p><p><code>-jvm-default</code> 옵션의 동작은 다음 값을 사용하여 제어할 수 있습니다:</p><ul><li><code>enable</code> (기본값): 인터페이스에 기본 구현을 생성하고 서브클래스 및 <code>DefaultImpls</code> 클래스에 브리지 함수를 포함합니다. 이 모드는 이전 Kotlin 버전과의 바이너리 호환성을 유지하는 데 사용됩니다.</li><li><code>no-compatibility</code>: 인터페이스에 기본 구현만 생성합니다. 이 모드는 호환성 브리지 및 <code>DefaultImpls</code> 클래스를 건너뛰므로 새 코드에 적합합니다.</li><li><code>disable</code>: 인터페이스의 기본 구현을 비활성화합니다. 브리지 함수 및 <code>DefaultImpls</code> 클래스만 생성되며, 이는 Kotlin 2.2.0 이전의 동작과 일치합니다.</li></ul><p><code>-jvm-default</code> 컴파일러 옵션을 구성하려면 Gradle Kotlin DSL에서 <code>jvmDefault</code> 프로퍼티를 설정하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        jvmDefault </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> JvmDefaultMode.NO_COMPATIBILITY</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,29)),a(e,{id:"kotlin-메타데이터에서-어노테이션-읽기-및-쓰기-지원",level:"3",title:"Kotlin 메타데이터에서 어노테이션 읽기 및 쓰기 지원",labelRef:"experimental-general"}),s[9]||(s[9]=i(`<p>이전에는 컴파일된 JVM 클래스 파일에서 리플렉션이나 바이트코드 분석을 사용하여 어노테이션을 읽고 시그니처를 기반으로 메타데이터 엔트리와 수동으로 일치시켜야 했습니다. 이 과정은 특히 오버로드된 함수에 대해 오류가 발생하기 쉬웠습니다.</p><p>이제 Kotlin 2.2.0에서는 <a href="/ko/kotlin/metadata-jvm"></a>가 Kotlin 메타데이터에 저장된 어노테이션 읽기 지원을 도입합니다.</p><p>컴파일된 파일의 메타데이터에서 어노테이션을 사용할 수 있게 하려면 다음 컴파일러 옵션을 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Xannotations</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-in-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">metadata</span></span></code></pre></div><p>또는 Gradle 빌드 파일의 <code>compilerOptions {}</code> 블록에 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xannotations-in-metadata&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 옵션이 활성화되면 Kotlin 컴파일러는 JVM 바이트코드와 함께 어노테이션을 메타데이터에 작성하여 <code>kotlin-metadata-jvm</code> 라이브러리에서 접근할 수 있게 합니다.</p><p>라이브러리는 어노테이션에 접근하기 위한 다음 API를 제공합니다:</p><ul><li><code>KmClass.annotations</code></li><li><code>KmFunction.annotations</code></li><li><code>KmProperty.annotations</code></li><li><code>KmConstructor.annotations</code></li><li><code>KmPropertyAccessorAttributes.annotations</code></li><li><code>KmValueParameter.annotations</code></li><li><code>KmFunction.extensionReceiverAnnotations</code></li><li><code>KmProperty.extensionReceiverAnnotations</code></li><li><code>KmProperty.backingFieldAnnotations</code></li><li><code>KmProperty.delegateFieldAnnotations</code></li><li><code>KmEnumEntry.annotations</code></li></ul><p>이 API는 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적(Experimental)</a>입니다. 옵트인하려면 <code>@OptIn(ExperimentalAnnotationsInMetadata::class)</code> 어노테이션을 사용하세요.</p><p>Kotlin 메타데이터에서 어노테이션을 읽는 예시는 다음과 같습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@file</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ExperimentalAnnotationsInMetadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.metadata.ExperimentalAnnotationsInMetadata</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.metadata.jvm.KotlinClassMetadata</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">annotation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Message class&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Message</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> metadata </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Message::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.java.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getAnnotation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Metadata::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.java)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kmClass </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (KotlinClassMetadata.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readStrict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(metadata) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KotlinClassMetadata.Class).kmClass</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kmClass.annotations)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // [@Label(value = StringValue(&quot;Message class&quot;))]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>프로젝트에서 <code>kotlin-metadata-jvm</code> 라이브러리를 사용하는 경우, 어노테이션을 지원하도록 코드를 테스트하고 업데이트하는 것을 권장합니다. 그렇지 않으면, 향후 Kotlin 버전에서 메타데이터의 어노테이션이 <a href="https://youtrack.jetbrains.com/issue/KT-75736" target="_blank" rel="noreferrer">기본적으로 활성화</a>되면 프로젝트에서 유효하지 않거나 불완전한 메타데이터가 생성될 수 있습니다. 문제가 발생하면 <a href="https://youtrack.jetbrains.com/issue/KT-31857" target="_blank" rel="noreferrer">이슈 트래커</a>에 보고해 주세요.</p></div>`,13)),a(e,{id:"인라인-값-클래스를-사용한-java-상호-운용성-개선",level:"3",title:"인라인 값 클래스를 사용한 Java 상호 운용성 개선",labelRef:"experimental-general"}),s[10]||(s[10]=i(`<p>Kotlin 2.2.0은 새로운 실험적 어노테이션인 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.jvm/-jvm-expose-boxed/" target="_blank" rel="noreferrer"><code>@JvmExposeBoxed</code></a>를 도입합니다. 이 어노테이션은 <a href="/ko/kotlin/inline-classes">인라인 값 클래스</a>를 Java에서 사용하기 쉽게 만듭니다.</p><p>기본적으로 Kotlin은 인라인 값 클래스를 **언박스된 표현(unboxed representations)**을 사용하도록 컴파일합니다. 이는 성능이 좋지만 Java에서는 사용하기 어렵거나 심지어 불가능한 경우가 많습니다. 예를 들어:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmInline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PositiveInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(number </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 경우, 클래스가 언박스되어 있기 때문에 Java에서 호출할 수 있는 생성자가 없습니다. 또한 Java가 <code>init</code> 블록을 트리거하여 <code>number</code>가 양수인지 확인할 방법도 없습니다.</p><p>클래스에 <code>@JvmExposeBoxed</code> 어노테이션을 달면 Kotlin은 Java에서 직접 호출할 수 있는 public 생성자를 생성하여 <code>init</code> 블록도 실행되도록 보장합니다.</p><p><code>@JvmExposeBoxed</code> 어노테이션은 클래스, 생성자 또는 함수 레벨에 적용하여 Java에 노출되는 대상을 세밀하게 제어할 수 있습니다.</p><p>예를 들어, 다음 코드에서 확장 함수 <code>.timesTwoBoxed()</code>는 Java에서 접근할 수 <strong>없습니다</strong>:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmInline</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">timesTwoBoxed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyInt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><code>MyInt</code> 클래스의 인스턴스를 생성하고 Java 코드에서 <code>.timesTwoBoxed()</code> 함수를 호출할 수 있게 하려면 클래스와 함수 모두에 <code>@JvmExposeBoxed</code> 어노테이션을 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmExposeBoxed</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmInline</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmExposeBoxed</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">timesTwoBoxed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyInt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>이러한 어노테이션을 사용하면 Kotlin 컴파일러는 <code>MyInt</code> 클래스에 대한 Java-접근 가능한 생성자를 생성합니다. 또한 값 클래스의 박스된 형식을 사용하는 확장 함수에 대한 오버로드도 생성합니다. 결과적으로 다음 Java 코드가 성공적으로 실행됩니다:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyInt input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyInt output </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ExampleKt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">timesTwoBoxed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input);</span></span></code></pre></div><p>노출하려는 인라인 값 클래스의 모든 부분에 어노테이션을 달고 싶지 않다면, 모듈 전체에 어노테이션을 효과적으로 적용할 수 있습니다. 모듈에 이 동작을 적용하려면 <code>-Xjvm-expose-boxed</code> 옵션으로 컴파일하세요. 이 옵션으로 컴파일하면 모듈의 모든 선언에 <code>@JvmExposeBoxed</code> 어노테이션이 있는 것과 동일한 효과를 줍니다.</p><p>이 새로운 어노테이션은 Kotlin이 내부적으로 값 클래스를 컴파일하거나 사용하는 방식을 변경하지 않으며, 기존의 모든 컴파일된 코드는 유효합니다. 단순히 Java 상호 운용성을 개선하기 위한 새로운 기능을 추가할 뿐입니다. 값 클래스를 사용하는 Kotlin 코드의 성능에는 영향을 미치지 않습니다.</p><p><code>@JvmExposeBoxed</code> 어노테이션은 멤버 함수의 박스된 변형을 노출하고 박스된 반환 타입을 받으려는 라이브러리 작성자에게 유용합니다. 이는 인라인 값 클래스(효율적이지만 Kotlin 전용)와 데이터 클래스(Java 호환되지만 항상 박스됨) 중 하나를 선택해야 하는 필요성을 없애줍니다.</p><p><code>@JvmExposedBoxed</code> 어노테이션이 작동하는 방식과 해결하는 문제에 대한 자세한 설명은 이 <a href="https://github.com/Kotlin/KEEP/blob/jvm-expose-boxed/proposals/jvm-expose-boxed.md" target="_blank" rel="noreferrer">KEEP</a> 제안을 참조하세요.</p><h3 id="jvm-레코드-어노테이션-지원-개선" tabindex="-1">JVM 레코드 어노테이션 지원 개선 <a class="header-anchor" href="#jvm-레코드-어노테이션-지원-개선" aria-label="Permalink to &quot;JVM 레코드 어노테이션 지원 개선&quot;">​</a></h3><p>Kotlin은 Kotlin 1.5.0부터 <a href="/ko/kotlin/jvm-records">JVM 레코드</a>를 지원했습니다. 이제 Kotlin 2.2.0은 레코드 컴포넌트의 어노테이션 처리, 특히 Java의 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/annotation/ElementType.html#RECORD_COMPONENT" target="_blank" rel="noreferrer"><code>RECORD_COMPONENT</code></a> 타겟과 관련하여 개선되었습니다.</p><p>첫째, <code>RECORD_COMPONENT</code>를 어노테이션 타겟으로 사용하려면 Kotlin (<code>@Target</code>) 및 Java에 대한 어노테이션을 수동으로 추가해야 합니다. 이는 Kotlin의 <code>@Target</code> 어노테이션이 <code>RECORD_COMPONENT</code>를 지원하지 않기 때문입니다. 예를 들어:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(AnnotationTarget.CLASS, AnnotationTarget.PROPERTY)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@java.lang.annotation.Target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ElementType.CLASS, ElementType.RECORD_COMPONENT)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">annotation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> exampleClass</span></span></code></pre></div><p>두 목록을 수동으로 유지하는 것은 오류가 발생하기 쉬울 수 있으므로, Kotlin 2.2.0은 Kotlin과 Java 타겟이 일치하지 않을 경우 컴파일러 경고를 도입합니다. 예를 들어, Java 타겟 목록에서 <code>ElementType.CLASS</code>를 생략하면 컴파일러는 다음과 같이 보고합니다:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Incompatible annotation targets: Java target &#39;CLASS&#39; missing, corresponding to Kotlin targets &#39;CLASS&#39;.</span></span></code></pre></div><p>둘째, 레코드에서 어노테이션을 전파하는 방식에서 Kotlin의 동작은 Java와 다릅니다. Java에서는 레코드 컴포넌트의 어노테이션이 백킹 필드, 게터 및 생성자 파라미터에 자동으로 적용됩니다. Kotlin은 기본적으로 이를 수행하지 않지만, 이제 <a href="#all-meta-target-for-properties"><code>@all:</code> 사용-위치 타겟</a>을 사용하여 이 동작을 재현할 수 있습니다.</p><p>예를 들어:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmRecord</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Positive</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> val</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><code>@JvmRecord</code>와 <code>@all:</code>을 함께 사용하면 Kotlin은 이제 다음을 수행합니다:</p><ul><li>어노테이션을 프로퍼티, 백킹 필드, 생성자 파라미터 및 게터에 전파합니다.</li><li>어노테이션이 Java의 <code>RECORD_COMPONENT</code>를 지원하는 경우 레코드 컴포넌트에도 어노테이션을 적용합니다.</li></ul><h2 id="kotlin-native" tabindex="-1">Kotlin/Native <a class="header-anchor" href="#kotlin-native" aria-label="Permalink to &quot;Kotlin/Native&quot;">​</a></h2><p>2.2.0부터 Kotlin/Native는 LLVM 19를 사용합니다. 이 릴리스는 또한 메모리 소비를 추적하고 조정하도록 설계된 여러 실험 기능을 제공합니다.</p>`,29)),a(e,{id:"객체별-메모리-할당",level:"3",title:"객체별 메모리 할당",labelRef:"experimental-opt-in"}),s[11]||(s[11]=i('<p>Kotlin/Native의 <a href="https://github.com/JetBrains/kotlin/blob/master/kotlin-native/runtime/src/alloc/custom/README.md" target="_blank" rel="noreferrer">메모리 할당자</a>는 이제 객체별로 메모리를 예약할 수 있습니다. 경우에 따라 엄격한 메모리 제한을 충족하거나 애플리케이션 시작 시 메모리 소비를 줄이는 데 도움이 될 수 있습니다.</p><p>이 새로운 기능은 기본 메모리 할당자 대신 시스템 메모리 할당자를 활성화했던 <code>-Xallocator=std</code> 컴파일러 옵션을 대체하도록 설계되었습니다. 이제 메모리 할당자를 전환하지 않고도 버퍼링(할당 페이징)을 비활성화할 수 있습니다.</p><p>이 기능은 현재 <a href="/ko/kotlincomponents-stability.3d#stability-levels-explained">실험적(Experimental)</a>입니다. 활성화하려면 <code>gradle.properties</code> 파일에 다음 옵션을 설정하세요:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.pagedAllocator=false</span></span></code></pre></div><p><a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack</a>의 이슈 트래커에 문제점을 보고해 주세요.</p>',5)),a(e,{id:"런타임에-latin-1-인코딩된-문자열-지원",level:"3",title:"런타임에 Latin-1 인코딩된 문자열 지원",labelRef:"experimental-opt-in"}),s[12]||(s[12]=i(`<p>Kotlin은 이제 <a href="https://openjdk.org/jeps/254" target="_blank" rel="noreferrer">JVM</a>과 유사하게 Latin-1 인코딩된 문자열을 지원합니다. 이는 애플리케이션의 바이너리 크기를 줄이고 메모리 소비를 조정하는 데 도움이 될 것입니다.</p><p>기본적으로 Kotlin의 문자열은 UTF-16 인코딩을 사용하여 저장되며, 각 문자는 두 바이트로 표현됩니다. 경우에 따라 이는 문자열이 바이너리에서 소스 코드보다 두 배의 공간을 차지하게 만들고, 간단한 ASCII 파일에서 데이터를 읽는 것은 파일을 디스크에 저장하는 것보다 두 배 많은 메모리를 차지할 수 있습니다.</p><p>반대로, <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" target="_blank" rel="noreferrer">Latin-1 (ISO 8859-1)</a> 인코딩은 처음 256개의 유니코드 문자를 각각 1바이트로 표현합니다. Latin-1 지원을 활성화하면 모든 문자가 해당 범위 내에 있는 한 문자열은 Latin-1 인코딩으로 저장됩니다. 그렇지 않으면 기본 UTF-16 인코딩이 사용됩니다.</p><h4 id="latin-1-지원을-활성화하는-방법" tabindex="-1">Latin-1 지원을 활성화하는 방법 <a class="header-anchor" href="#latin-1-지원을-활성화하는-방법" aria-label="Permalink to &quot;Latin-1 지원을 활성화하는 방법&quot;">​</a></h4><p>이 기능은 현재 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적(Experimental)</a>입니다. 활성화하려면 <code>gradle.properties</code> 파일에 다음 옵션을 설정하세요:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.latin1Strings=true</span></span></code></pre></div><h4 id="알려진-문제" tabindex="-1">알려진 문제 <a class="header-anchor" href="#알려진-문제" aria-label="Permalink to &quot;알려진 문제&quot;">​</a></h4><p>이 기능이 실험적인 동안, cinterop 확장 함수 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/pin.html" target="_blank" rel="noreferrer"><code>String.pin</code></a>, <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/use-pinned.html" target="_blank" rel="noreferrer"><code>String.usePinned</code></a>, 및 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/ref-to.html" target="_blank" rel="noreferrer"><code>String.refTo</code></a>는 효율성이 떨어집니다. 각 호출 시 자동 문자열 변환이 UTF-16으로 트리거될 수 있습니다.</p><p>이 기능을 구현해 주신 Google 동료들과 특히 <a href="https://github.com/pyos" target="_blank" rel="noreferrer">Sonya Valchuk</a>님께 Kotlin 팀은 깊이 감사드립니다.</p><p>Kotlin의 메모리 소비에 대한 자세한 내용은 <a href="/ko/kotlin/native-memory-manager#memory-consumption">문서</a>를 참조하세요.</p><h3 id="apple-플랫폼에서의-메모리-소비-추적-개선" tabindex="-1">Apple 플랫폼에서의 메모리 소비 추적 개선 <a class="header-anchor" href="#apple-플랫폼에서의-메모리-소비-추적-개선" aria-label="Permalink to &quot;Apple 플랫폼에서의 메모리 소비 추적 개선&quot;">​</a></h3><p>Kotlin 2.2.0부터 Kotlin 코드에 의해 할당된 메모리에 태그가 지정됩니다. 이는 Apple 플랫폼에서 메모리 문제를 디버깅하는 데 도움이 될 수 있습니다.</p><p>애플리케이션의 높은 메모리 사용량을 조사할 때, 이제 Kotlin 코드가 예약한 메모리 양을 식별할 수 있습니다. Kotlin의 점유분은 식별자로 태그가 지정되며 Xcode Instruments의 VM Tracker와 같은 도구를 통해 추적할 수 있습니다.</p><p>이 기능은 기본적으로 활성화되어 있지만, 다음 모든 조건이 충족될 때 Kotlin/Native 기본 메모리 할당자에서만 사용할 수 있습니다:</p><ul><li><p><strong>태깅 활성화</strong>. 메모리는 유효한 식별자로 태그되어야 합니다. Apple은 240에서 255 사이의 숫자를 권장하며, 기본값은 246입니다.</p><p><code>kotlin.native.binary.mmapTag=0</code> Gradle 프로퍼티를 설정하면 태깅이 비활성화됩니다.</p></li><li><p><strong>mmap을 사용한 할당</strong>. 할당자는 <code>mmap</code> 시스템 호출을 사용하여 파일을 메모리에 매핑해야 합니다.</p><p><code>kotlin.native.binary.disableMmap=true</code> Gradle 프로퍼티를 설정하면 기본 할당자가 <code>mmap</code> 대신 <code>malloc</code>을 사용합니다.</p></li><li><p><strong>페이징 활성화</strong>. 할당 페이징(버퍼링)이 활성화되어야 합니다.</p><p><a href="#per-object-memory-allocation"><code>kotlin.native.binary.pagedAllocator=false</code></a> Gradle 프로퍼티를 설정하면 메모리가 객체별로 예약됩니다.</p></li></ul><p>Kotlin의 메모리 소비에 대한 자세한 내용은 <a href="/ko/kotlin/native-memory-manager#memory-consumption">문서</a>를 참조하세요.</p><h3 id="llvm-16에서-19로-업데이트" tabindex="-1">LLVM 16에서 19로 업데이트 <a class="header-anchor" href="#llvm-16에서-19로-업데이트" aria-label="Permalink to &quot;LLVM 16에서 19로 업데이트&quot;">​</a></h3><p>Kotlin 2.2.0에서 LLVM이 버전 16에서 19로 업데이트되었습니다. 새로운 버전에는 성능 개선, 버그 수정 및 보안 업데이트가 포함되어 있습니다.</p><p>이 업데이트는 코드에 영향을 미치지 않아야 하지만, 문제가 발생하면 <a href="http://kotl.in/issue" target="_blank" rel="noreferrer">이슈 트래커</a>에 보고해 주세요.</p><h3 id="windows-7-타겟-deprecated" tabindex="-1">Windows 7 타겟 Deprecated <a class="header-anchor" href="#windows-7-타겟-deprecated" aria-label="Permalink to &quot;Windows 7 타겟 Deprecated&quot;">​</a></h3><p>Kotlin 2.2.0부터 지원되는 최소 Windows 버전이 Windows 7에서 Windows 10으로 상향되었습니다. Microsoft가 2025년 1월에 Windows 7 지원을 종료했으므로, 이 레거시 타겟도 더 이상 사용하지 않기로 결정했습니다.</p><p>자세한 내용은 <a href="/ko/kotlin/native-target-support"></a>를 참조하세요.</p><h2 id="kotlin-wasm" tabindex="-1">Kotlin/Wasm <a class="header-anchor" href="#kotlin-wasm" aria-label="Permalink to &quot;Kotlin/Wasm&quot;">​</a></h2><p>이번 릴리스에서는 <a href="#build-infrastructure-for-wasm-target-separated-from-javascript-target">Wasm 타겟의 빌드 인프라가 JavaScript 타겟과 분리</a>되었습니다. 또한 이제 <a href="#per-project-binaryen-configuration">프로젝트 또는 모듈별로 Binaryen 도구를 구성</a>할 수 있습니다.</p><h3 id="wasm-타겟의-빌드-인프라가-javascript-타겟과-분리됨" tabindex="-1">Wasm 타겟의 빌드 인프라가 JavaScript 타겟과 분리됨 <a class="header-anchor" href="#wasm-타겟의-빌드-인프라가-javascript-타겟과-분리됨" aria-label="Permalink to &quot;Wasm 타겟의 빌드 인프라가 JavaScript 타겟과 분리됨&quot;">​</a></h3><p>이전에는 <code>wasmJs</code> 타겟이 <code>js</code> 타겟과 동일한 인프라를 공유했습니다. 결과적으로, 두 타겟 모두 동일한 디렉토리(<code>build/js</code>)에 호스팅되었고 동일한 NPM 태스크 및 구성을 사용했습니다.</p><p>이제 <code>wasmJs</code> 타겟은 <code>js</code> 타겟과 별개의 자체 인프라를 가집니다. 이를 통해 Wasm 태스크와 타입이 JavaScript 태스크와 분리되어 독립적인 구성이 가능해졌습니다.</p><p>또한 Wasm 관련 프로젝트 파일 및 NPM 종속성은 이제 별도의 <code>build/wasm</code> 디렉토리에 저장됩니다.</p><p>Wasm을 위한 새로운 NPM 관련 태스크가 도입되었으며, 기존 JavaScript 태스크는 이제 JavaScript 전용으로 사용됩니다:</p><table tabindex="0"><thead><tr><th style="text-align:left;"><strong>Wasm 태스크</strong></th><th style="text-align:left;"><strong>JavaScript 태스크</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><code>kotlinWasmNpmInstall</code></td><td style="text-align:left;"><code>kotlinNpmInstall</code></td></tr><tr><td style="text-align:left;"><code>wasmRootPackageJson</code></td><td style="text-align:left;"><code>rootPackageJson</code></td></tr></tbody></table><p>마찬가지로, 새로운 Wasm 전용 선언이 추가되었습니다:</p><table tabindex="0"><thead><tr><th style="text-align:left;"><strong>Wasm 선언</strong></th><th style="text-align:left;"><strong>JavaScript 선언</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><code>WasmNodeJsRootPlugin</code></td><td style="text-align:left;"><code>NodeJsRootPlugin</code></td></tr><tr><td style="text-align:left;"><code>WasmNodeJsPlugin</code></td><td style="text-align:left;"><code>NodeJsPlugin</code></td></tr><tr><td style="text-align:left;"><code>WasmYarnPlugin</code></td><td style="text-align:left;"><code>YarnPlugin</code></td></tr><tr><td style="text-align:left;"><code>WasmNodeJsRootExtension</code></td><td style="text-align:left;"><code>NodeJsRootExtension</code></td></tr><tr><td style="text-align:left;"><code>WasmNodeJsEnvSpec</code></td><td style="text-align:left;"><code>NodeJsEnvSpec</code></td></tr><tr><td style="text-align:left;"><code>WasmYarnRootEnvSpec</code></td><td style="text-align:left;"><code>YarnRootEnvSpec</code></td></tr></tbody></table><p>이제 JavaScript 타겟과 독립적으로 Wasm 타겟으로 작업할 수 있어 구성 프로세스가 단순해집니다.</p><p>이 변경은 기본적으로 활성화되어 있으며 추가 설정이 필요하지 않습니다.</p><h3 id="프로젝트별-binaryen-구성" tabindex="-1">프로젝트별 Binaryen 구성 <a class="header-anchor" href="#프로젝트별-binaryen-구성" aria-label="Permalink to &quot;프로젝트별 Binaryen 구성&quot;">​</a></h3><p>Kotlin/Wasm에서 <a href="/ko/kotlin/whatsnew20#optimized-production-builds-by-default-using-binaryen">프로덕션 빌드를 최적화하는 데</a> 사용되는 Binaryen 도구는 이전에는 루트 프로젝트에서 한 번만 구성되었습니다.</p><p>이제 프로젝트 또는 모듈별로 Binaryen 도구를 구성할 수 있습니다. 이 변경은 Gradle의 모범 사례와 일치하며 <a href="https://docs.gradle.org/current/userguide/isolated_projects.html" target="_blank" rel="noreferrer">프로젝트 격리</a>와 같은 기능을 더 잘 지원하여 복잡한 빌드에서 빌드 성능과 안정성을 향상시킵니다.</p><p>또한 필요에 따라 다른 모듈에 다른 버전의 Binaryen을 구성할 수 있습니다.</p><p>이 기능은 기본적으로 활성화되어 있습니다. 그러나 Binaryen에 대한 사용자 지정 구성이 있는 경우, 이제 루트 프로젝트에서만 적용하는 대신 프로젝트별로 적용해야 합니다.</p><h2 id="kotlin-js" tabindex="-1">Kotlin/JS <a class="header-anchor" href="#kotlin-js" aria-label="Permalink to &quot;Kotlin/JS&quot;">​</a></h2><p>이번 릴리스에서는 <a href="#fix-for-copy-in-jsplainobject-interfaces"><code>@JsPlainObject</code> 인터페이스의 <code>copy()</code> 함수</a>, <a href="#support-for-type-aliases-in-files-with-jsmodule-annotation"><code>@JsModule</code> 어노테이션이 있는 파일의 타입 별칭</a>, 및 기타 Kotlin/JS 기능이 개선되었습니다.</p><h3 id="jsplainobject-인터페이스의-copy-수정" tabindex="-1"><code>@JsPlainObject</code> 인터페이스의 <code>copy()</code> 수정 <a class="header-anchor" href="#jsplainobject-인터페이스의-copy-수정" aria-label="Permalink to &quot;\`@JsPlainObject\` 인터페이스의 \`copy()\` 수정&quot;">​</a></h3><p>Kotlin/JS에는 <code>js-plain-objects</code>라는 실험적 플러그인이 있으며, 이는 <code>@JsPlainObject</code> 어노테이션이 달린 인터페이스에 <code>copy()</code> 함수를 도입했습니다. <code>copy()</code> 함수를 사용하여 객체를 조작할 수 있습니다.</p><p>그러나 <code>copy()</code>의 초기 구현은 상속과 호환되지 않았으며, 이는 <code>@JsPlainObject</code> 인터페이스가 다른 인터페이스를 확장할 때 문제를 일으켰습니다.</p><p>플레인 객체에 대한 제한을 피하기 위해 <code>copy()</code> 함수가 객체 자체에서 컴패니언 객체로 이동되었습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JsPlainObject</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;SomeUser&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 21</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 이 구문은 더 이상 유효하지 않습니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> copy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">copy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 35</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 이것이 올바른 구문입니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> copy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> User.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">copy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user, age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 35</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 변경은 상속 계층 구조의 충돌을 해결하고 모호성을 제거합니다. Kotlin 2.2.0부터 기본적으로 활성화됩니다.</p><h3 id="jsmodule-어노테이션이-있는-파일의-타입-별칭-지원" tabindex="-1"><code>@JsModule</code> 어노테이션이 있는 파일의 타입 별칭 지원 <a class="header-anchor" href="#jsmodule-어노테이션이-있는-파일의-타입-별칭-지원" aria-label="Permalink to &quot;\`@JsModule\` 어노테이션이 있는 파일의 타입 별칭 지원&quot;">​</a></h3><p>이전에는 JavaScript 모듈에서 선언을 임포트하기 위해 <code>@JsModule</code> 어노테이션이 달린 파일은 외부 선언으로만 제한되었습니다. 이는 그러한 파일에서 <code>typealias</code>를 선언할 수 없다는 것을 의미했습니다.</p><p>Kotlin 2.2.0부터는 <code>@JsModule</code>로 표시된 파일 내에 타입 별칭을 선언할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@file</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JsModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">somepackage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&quot;)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> somepackage</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typealias</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeClass</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Any</span></span></code></pre></div><p>이 변경은 Kotlin/JS 상호 운용성 제한의 한 측면을 줄여주며, 향후 릴리스에서 더 많은 개선이 계획되어 있습니다.</p><p><code>@JsModule</code>이 있는 파일의 타입 별칭 지원은 기본적으로 활성화됩니다.</p><h3 id="멀티플랫폼-expect-선언에서-jsexport-지원" tabindex="-1">멀티플랫폼 <code>expect</code> 선언에서 <code>@JsExport</code> 지원 <a class="header-anchor" href="#멀티플랫폼-expect-선언에서-jsexport-지원" aria-label="Permalink to &quot;멀티플랫폼 \`expect\` 선언에서 \`@JsExport\` 지원&quot;">​</a></h3><p>Kotlin 멀티플랫폼 프로젝트에서 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-expect-actual.html" target="_blank" rel="noreferrer"><code>expect/actual</code> 메커니즘</a>으로 작업할 때, 공통 코드의 <code>expect</code> 선언에 <code>@JsExport</code> 어노테이션을 사용할 수 없었습니다.</p><p>이번 릴리스부터 <code>@JsExport</code>를 <code>expect</code> 선언에 직접 적용할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// commonMain</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 이전에는 오류가 발생했지만, 이제 올바르게 작동합니다.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JsExport</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">expect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WindowManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JsExport</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> acceptWindowManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(manager: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WindowManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// jsMain</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JsExport</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">actual </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WindowManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>JavaScript 소스 세트의 해당 <code>actual</code> 구현에도 <code>@JsExport</code> 어노테이션을 달아야 하며, export 가능한 타입만 사용해야 합니다.</p><p>이 수정으로 <code>commonMain</code>에 정의된 공유 코드가 JavaScript로 올바르게 export될 수 있습니다. 이제 수동적인 해결 방법 없이도 멀티플랫폼 코드를 JavaScript 사용자에게 노출할 수 있습니다.</p><p>이 변경은 기본적으로 활성화됩니다.</p><h3 id="promise-unit-타입과-jsexport-사용-가능" tabindex="-1"><code>Promise&lt;Unit&gt;</code> 타입과 <code>@JsExport</code> 사용 가능 <a class="header-anchor" href="#promise-unit-타입과-jsexport-사용-가능" aria-label="Permalink to &quot;\`Promise&lt;Unit&gt;\` 타입과 \`@JsExport\` 사용 가능&quot;">​</a></h3><p>이전에는 <code>@JsExport</code> 어노테이션을 사용하여 <code>Promise&lt;Unit&gt;</code> 타입을 반환하는 함수를 export하려고 하면 Kotlin 컴파일러가 오류를 생성했습니다.</p><p><code>Promise&lt;Int&gt;</code>와 같은 반환 타입은 올바르게 작동했지만, <code>Promise&lt;Unit&gt;</code>은 TypeScript에서 <code>Promise&lt;void&gt;</code>로 올바르게 매핑되었음에도 불구하고 &quot;non-exportable type&quot; 경고를 트리거했습니다.</p><p>이러한 제한이 제거되었습니다. 이제 다음 코드는 오류 없이 컴파일됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 이전에는 올바르게 작동했습니다.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JsExport</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fooInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GlobalScope.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@promise </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 이전에는 오류가 발생했지만, 이제 올바르게 작동합니다.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JsExport</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fooUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GlobalScope.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 변경은 Kotlin/JS 상호 운용 모델의 불필요한 제한을 제거합니다. 이 수정은 기본적으로 활성화됩니다.</p><h2 id="gradle" tabindex="-1">Gradle <a class="header-anchor" href="#gradle" aria-label="Permalink to &quot;Gradle&quot;">​</a></h2><p>Kotlin 2.2.0은 Gradle 7.6.3부터 8.14까지 완벽하게 호환됩니다. 최신 Gradle 릴리스 버전까지도 사용할 수 있습니다. 그러나 그렇게 할 경우 경고가 발생할 수 있으며, 일부 새로운 Gradle 기능이 작동하지 않을 수 있음을 유의하세요.</p><p>이번 릴리스에서 Kotlin Gradle 플러그인(KGP)은 진단 기능에 대한 몇 가지 개선 사항을 포함합니다. 또한 라이브러리 작업을 용이하게 하는 <a href="#binary-compatibility-validation-included-in-kotlin-gradle-plugin">바이너리 호환성 검증</a>의 실험적 통합을 도입합니다.</p>`,69)),a(e,{id:"kotlin-gradle-플러그인에-바이너리-호환성-검증-포함",level:"3",title:"Kotlin Gradle 플러그인에 바이너리 호환성 검증 포함",labelRef:"experimental-general"}),s[13]||(s[13]=i(`<p>라이브러리 버전 간의 바이너리 호환성을 쉽게 확인할 수 있도록, <a href="https://github.com/Kotlin/binary-compatibility-validator" target="_blank" rel="noreferrer">바이너리 호환성 검증 도구</a>의 기능을 Kotlin Gradle 플러그인(KGP)으로 옮기는 실험을 진행 중입니다. 장난감 프로젝트에서 시도해 볼 수 있지만, 아직 프로덕션 환경에서 사용하는 것을 권장하지 않습니다.</p><p>원래의 <a href="https://github.com/Kotlin/binary-compatibility-validator" target="_blank" rel="noreferrer">바이너리 호환성 검증 도구</a>는 이 실험 단계 동안 계속 유지보수됩니다.</p><p>Kotlin 라이브러리는 JVM 클래스 파일 또는 <code>klib</code> 두 가지 바이너리 형식 중 하나를 사용할 수 있습니다. 이 형식들은 호환되지 않기 때문에 KGP는 각각 별도로 작업합니다.</p><p>바이너리 호환성 검증 기능을 활성화하려면 <code>build.gradle.kts</code> 파일의 <code>kotlin{}</code> 블록에 다음을 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(org.jetbrains.kotlin.gradle.dsl.abi.ExperimentalAbiValidation::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    abiValidation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 이전 Gradle 버전과의 호환성을 보장하기 위해 set() 함수를 사용합니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        enabled.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>바이너리 호환성을 확인하려는 여러 모듈이 프로젝트에 있는 경우, 각 모듈에서 기능을 별도로 구성하세요. 각 모듈은 자체 사용자 지정 구성을 가질 수 있습니다.</p><p>활성화되면 <code>checkLegacyAbi</code> Gradle 태스크를 실행하여 바이너리 호환성 문제를 확인하세요. IntelliJ IDEA 또는 프로젝트 디렉토리의 명령줄에서 태스크를 실행할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gradlew checkLegacyAbi</span></span></code></pre></div><p>이 태스크는 현재 코드에서 ABI(Application Binary Interface) 덤프를 UTF-8 텍스트 파일로 생성합니다. 그런 다음 태스크는 새 덤프를 이전 릴리스의 덤프와 비교합니다. 차이점이 발견되면 오류로 보고합니다. 오류를 검토한 후 변경 사항이 허용된다고 결정하면 <code>updateLegacyAbi</code> Gradle 태스크를 실행하여 참조 ABI 덤프를 업데이트할 수 있습니다.</p><h4 id="클래스-필터링" tabindex="-1">클래스 필터링 <a class="header-anchor" href="#클래스-필터링" aria-label="Permalink to &quot;클래스 필터링&quot;">​</a></h4><p>이 기능은 ABI 덤프에서 클래스를 필터링할 수 있도록 합니다. 이름 또는 부분 이름, 또는 해당 클래스를 표시하는 어노테이션(또는 어노테이션 이름의 일부)으로 클래스를 명시적으로 포함하거나 제외할 수 있습니다.</p><p>예를 들어, 이 샘플은 <code>com.company</code> 패키지의 모든 클래스를 제외합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(org.jetbrains.kotlin.gradle.dsl.abi.ExperimentalAbiValidation::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    abiValidation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        filters.excluded.byNames.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;com.company.**&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>바이너리 호환성 검증 도구 구성에 대한 자세한 내용은 <a href="https://kotlinlang.org/api/kotlin-gradle-plugin/kotlin-gradle-plugin-api/org.jetbrains.kotlin.gradle.dsl.abi/" target="_blank" rel="noreferrer">KGP API 참조</a>를 참조하세요.</p><h4 id="멀티플랫폼-제한-사항" tabindex="-1">멀티플랫폼 제한 사항 <a class="header-anchor" href="#멀티플랫폼-제한-사항" aria-label="Permalink to &quot;멀티플랫폼 제한 사항&quot;">​</a></h4><p>멀티플랫폼 프로젝트에서 호스트가 모든 타겟에 대한 교차 컴파일을 지원하지 않는 경우, KGP는 다른 타겟의 ABI 덤프를 확인하여 지원되지 않는 타겟의 ABI 변경 사항을 추론하려고 시도합니다. 이 접근 방식은 나중에 모든 타겟을 컴파일 <strong>할 수 있는</strong> 호스트로 전환할 때 잘못된 유효성 검사 실패를 방지하는 데 도움이 됩니다.</p><p>KGP가 지원되지 않는 타겟에 대한 ABI 변경 사항을 추론하지 않도록 이 기본 동작을 변경하려면 <code>build.gradle.kts</code> 파일에 다음을 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(org.jetbrains.kotlin.gradle.dsl.abi.ExperimentalAbiValidation::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    abiValidation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        klib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            keepUnsupportedTargets </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>그러나 프로젝트에 지원되지 않는 타겟이 있는 경우, <code>checkLegacyAbi</code> 태스크는 ABI 덤프를 생성할 수 없으므로 실패합니다. 이 동작은 다른 타겟에서 추론된 ABI 변경으로 인해 호환되지 않는 변경을 놓치는 것보다 검사가 실패하는 것이 더 중요한 경우 바람직할 수 있습니다.</p><h3 id="kotlin-gradle-플러그인-콘솔의-풍부한-출력-지원" tabindex="-1">Kotlin Gradle 플러그인 콘솔의 풍부한 출력 지원 <a class="header-anchor" href="#kotlin-gradle-플러그인-콘솔의-풍부한-출력-지원" aria-label="Permalink to &quot;Kotlin Gradle 플러그인 콘솔의 풍부한 출력 지원&quot;">​</a></h3><p>Kotlin 2.2.0에서는 Gradle 빌드 프로세스 중 콘솔에서 색상 및 기타 풍부한 출력을 지원하여 보고된 진단 메시지를 더 쉽게 읽고 이해할 수 있도록 합니다.</p><p>풍부한 출력은 Linux 및 macOS에서 지원되는 터미널 에뮬레이터에서 사용할 수 있으며, Windows 지원을 추가하는 작업을 진행 중입니다.</p><p><img src="`+l+'" alt="Gradle 콘솔" width="600"></p><p>이 기능은 기본적으로 활성화되어 있지만, 재정의하려면 <code>gradle.properties</code> 파일에 다음 Gradle 프로퍼티를 추가하세요:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>org.gradle.console=plain</span></span></code></pre></div><p>이 프로퍼티 및 옵션에 대한 자세한 내용은 Gradle 문서의 <a href="https://docs.gradle.org/current/userguide/command_line_interface.html#sec:command_line_customizing_log_format" target="_blank" rel="noreferrer">로그 형식 사용자 지정</a>을 참조하세요.</p><h3 id="kgp-진단-기능-내-problems-api-통합" tabindex="-1">KGP 진단 기능 내 Problems API 통합 <a class="header-anchor" href="#kgp-진단-기능-내-problems-api-통합" aria-label="Permalink to &quot;KGP 진단 기능 내 Problems API 통합&quot;">​</a></h3><p>이전에는 Kotlin Gradle Plugin(KGP)이 경고 및 오류와 같은 진단 메시지를 콘솔 또는 로그에 일반 텍스트 출력으로만 보고할 수 있었습니다.</p><p>2.2.0부터 KGP는 추가 보고 메커니즘을 도입합니다: 이제 <a href="https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.problems/index.html" target="_blank" rel="noreferrer">Gradle의 Problems API</a>를 사용합니다. 이는 빌드 프로세스 중에 풍부하고 구조화된 문제 정보를 보고하는 표준화된 방법입니다.</p><p>KGP 진단 메시지는 이제 Gradle CLI 및 IntelliJ IDEA와 같은 다양한 인터페이스에서 더 쉽게 읽고 일관되게 표시됩니다.</p><p>이 통합은 Gradle 8.6 이상부터 기본적으로 활성화됩니다. API는 여전히 발전 중이므로, 최신 개선 사항을 활용하려면 가장 최신 Gradle 버전을 사용하세요.</p><h3 id="warning-mode와의-kgp-호환성" tabindex="-1"><code>--warning-mode</code>와의 KGP 호환성 <a class="header-anchor" href="#warning-mode와의-kgp-호환성" aria-label="Permalink to &quot;`--warning-mode`와의 KGP 호환성&quot;">​</a></h3><p>Kotlin Gradle Plugin(KGP) 진단 메시지는 고정된 심각도 수준을 사용하여 문제를 보고했습니다. 즉, Gradle의 <a href="https://docs.gradle.org/current/userguide/command_line_interface.html#sec:command_line_warnings" target="_blank" rel="noreferrer"><code>--warning-mode</code> 명령줄 옵션</a>은 KGP가 오류를 표시하는 방식에 영향을 미치지 않았습니다.</p><p>이제 KGP 진단 메시지는 <code>--warning-mode</code> 옵션과 호환되어 더 많은 유연성을 제공합니다. 예를 들어, 모든 경고를 오류로 변환하거나 경고를 완전히 비활성화할 수 있습니다.</p><p>이 변경으로 KGP 진단 메시지는 선택된 경고 모드에 따라 출력을 조정합니다:</p><ul><li><code>--warning-mode=fail</code>로 설정하면 <code>Severity.Warning</code> 진단 메시지가 이제 <code>Severity.Error</code>로 격상됩니다.</li><li><code>--warning-mode=none</code>로 설정하면 <code>Severity.Warning</code> 진단 메시지가 로그에 기록되지 않습니다.</li></ul><p>이 동작은 2.2.0부터 기본적으로 활성화됩니다.</p><p><code>--warning-mode</code> 옵션을 무시하려면 <code>gradle.properties</code> 파일에 다음 Gradle 프로퍼티를 설정하세요:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.internal.diagnostics.ignoreWarningMode=true</span></span></code></pre></div>',39)),a(e,{id:"새로운-실험적-빌드-도구-api-bta",level:"2",title:"새로운 실험적 빌드 도구 API (BTA)",labelRef:"experimental-general"}),s[14]||(s[14]=i(`<p>Kotlin은 Gradle, Maven, Amper 등 다양한 빌드 시스템과 함께 사용할 수 있습니다. 그러나 Kotlin을 각 시스템에 통합하여 증분 컴파일, Kotlin 컴파일러 플러그인, 데몬, Kotlin 멀티플랫폼과의 호환성 등 모든 기능을 지원하려면 상당한 노력이 필요합니다.</p><p>이 프로세스를 단순화하기 위해 Kotlin 2.2.0은 새로운 실험적 빌드 도구 API (BTA)를 도입합니다. BTA는 빌드 시스템과 Kotlin 컴파일러 생태계 사이의 추상화 계층 역할을 하는 범용 API입니다. 이 접근 방식을 통해 각 빌드 시스템은 단일 BTA 진입점만 지원하면 됩니다.</p><p>현재 BTA는 Kotlin/JVM만 지원합니다. JetBrains의 Kotlin 팀은 이미 Kotlin Gradle 플러그인(KGP)과 <code>kotlin-maven-plugin</code>에서 이를 사용하고 있습니다. 이 플러그인을 통해 BTA를 사용해 볼 수 있지만, API 자체는 아직 자체 빌드 도구 통합에 사용할 준비가 되지 않았습니다. BTA 제안에 대해 궁금하거나 피드백을 공유하고 싶다면, <a href="https://github.com/Kotlin/KEEP/issues/421" target="_blank" rel="noreferrer">KEEP</a> 제안을 참조하세요.</p><p>BTA를 사용해 보려면:</p><ul><li>KGP의 경우, <code>gradle.properties</code> 파일에 다음 프로퍼티를 추가하세요:</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kotlin.compiler.runViaBuildToolsApi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span></code></pre></div><ul><li>Maven의 경우, 아무것도 할 필요가 없습니다. 기본적으로 활성화되어 있습니다.</li></ul><p>BTA는 현재 Maven 플러그인에 직접적인 이점은 없지만, <a href="https://youtrack.jetbrains.com/issue/KT-77587/Maven-Introduce-Kotlin-daemon-support-and-make-it-enabled-by-default" target="_blank" rel="noreferrer">Kotlin 데몬 지원</a> 및 <a href="https://youtrack.jetbrains.com/issue/KT-77086/Stabilize-incremental-compilation-in-Maven" target="_blank" rel="noreferrer">증분 컴파일 안정화</a>와 같은 새로운 기능을 더 빠르게 제공하기 위한 견고한 기반을 마련합니다.</p><p>KGP의 경우 BTA를 사용하면 이미 다음과 같은 이점이 있습니다:</p><ul><li><a href="#improved-in-process-compiler-execution-strategy">개선된 &quot;in process&quot; 컴파일러 실행 전략</a></li><li><a href="#flexibility-to-configure-different-compiler-versions-from-kotlin">Kotlin에서 다른 컴파일러 버전을 구성할 수 있는 유연성</a></li></ul><h3 id="개선된-in-process-컴파일러-실행-전략" tabindex="-1">개선된 &quot;in process&quot; 컴파일러 실행 전략 <a class="header-anchor" href="#개선된-in-process-컴파일러-실행-전략" aria-label="Permalink to &quot;개선된 &quot;in process&quot; 컴파일러 실행 전략&quot;">​</a></h3><p>KGP는 세 가지 <a href="/ko/kotlin/gradle-compilation-and-caches#defining-kotlin-compiler-execution-strategy">Kotlin 컴파일러 실행 전략</a>을 지원합니다. 이전에는 Gradle 데몬 프로세스 내에서 컴파일러를 실행하는 &quot;in process&quot; 전략이 증분 컴파일을 지원하지 않았습니다.</p><p>이제 BTA를 사용하면 &quot;in-process&quot; 전략이 증분 컴파일을 <strong>지원</strong>합니다. 이를 사용하려면 <code>gradle.properties</code> 파일에 다음 프로퍼티를 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kotlin.compiler.execution.strategy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=in-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">process</span></span></code></pre></div><h3 id="kotlin에서-다른-컴파일러-버전을-구성할-수-있는-유연성" tabindex="-1">Kotlin에서 다른 컴파일러 버전을 구성할 수 있는 유연성 <a class="header-anchor" href="#kotlin에서-다른-컴파일러-버전을-구성할-수-있는-유연성" aria-label="Permalink to &quot;Kotlin에서 다른 컴파일러 버전을 구성할 수 있는 유연성&quot;">​</a></h3><p>때로는 빌드 스크립트 deprecation을 계속 처리하면서 새로운 언어 기능을 시도하기 위해, KGP는 이전 버전을 유지한 채 코드에서 더 새로운 Kotlin 컴파일러 버전을 사용하고 싶을 수 있습니다. 또는 KGP 버전을 업데이트하되 이전 Kotlin 컴파일러 버전을 유지하고 싶을 수도 있습니다.</p><p>BTA는 이를 가능하게 합니다. <code>build.gradle.kts</code> 파일에서 다음과 같이 구성할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> org.jetbrains.kotlin.buildtools.api.ExperimentalBuildToolsApi</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> org.jetbrains.kotlin.gradle.ExperimentalKotlinGradlePluginApi</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">plugins</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;jvm&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) version </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2.2.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">group </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;org.jetbrains.example&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;1.0-SNAPSHOT&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">repositories</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    mavenCentral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvmToolchain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalBuildToolsApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ExperimentalKotlinGradlePluginApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    compilerVersion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2.1.21&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2.2.0과 다른 버전</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>BTA는 KGP와 Kotlin 컴파일러 버전을 이전 세 가지 주요 버전 및 다음 하나의 주요 버전과 함께 구성하는 것을 지원합니다. 따라서 KGP 2.2.0에서는 Kotlin 컴파일러 버전 2.1.x, 2.0.x 및 1.9.25가 지원됩니다. KGP 2.2.0은 또한 향후 Kotlin 컴파일러 버전 2.2.x 및 2.3.x와 호환됩니다.</p><p>그러나 다른 컴파일러 버전을 컴파일러 플러그인과 함께 사용하면 Kotlin 컴파일러 예외가 발생할 수 있다는 점을 명심하세요. Kotlin 팀은 향후 릴리스에서 이러한 종류의 문제를 해결할 계획입니다.</p><p>이 플러그인으로 BTA를 사용해 보고 <a href="https://youtrack.jetbrains.com/issue/KT-56574" target="_blank" rel="noreferrer">KGP</a> 및 <a href="https://youtrack.jetbrains.com/issue/KT-73012" target="_blank" rel="noreferrer">Maven 플러그인</a> 전용 YouTrack 티켓에 피드백을 보내주세요.</p><h2 id="kotlin-표준-라이브러리" tabindex="-1">Kotlin 표준 라이브러리 <a class="header-anchor" href="#kotlin-표준-라이브러리" aria-label="Permalink to &quot;Kotlin 표준 라이브러리&quot;">​</a></h2><p>Kotlin 2.2.0에서 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.io.encoding/-base64/" target="_blank" rel="noreferrer"><code>Base64</code> API</a>와 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.text/-hex-format/" target="_blank" rel="noreferrer"><code>HexFormat</code> API</a>는 이제 <a href="/ko/kotlin/components-stability#stability-levels-explained">Stable</a>입니다.</p><h3 id="stable-base64-인코딩-및-디코딩" tabindex="-1">Stable Base64 인코딩 및 디코딩 <a class="header-anchor" href="#stable-base64-인코딩-및-디코딩" aria-label="Permalink to &quot;Stable Base64 인코딩 및 디코딩&quot;">​</a></h3><p>Kotlin 1.8.20은 <a href="/ko/kotlin/whatsnew1820#support-for-base64-encoding">Base64 인코딩 및 디코딩에 대한 실험적 지원</a>을 도입했습니다. Kotlin 2.2.0에서 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.io.encoding/-base64/" target="_blank" rel="noreferrer">Base64 API</a>는 이제 <a href="/ko/kotlin/components-stability#stability-levels-explained">Stable</a>이며, 이번 릴리스에 추가된 새로운 <code>Base64.Pem</code>을 포함하여 네 가지 인코딩 방식을 제공합니다:</p><ul><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.io.encoding/-base64/-default/" target="_blank" rel="noreferrer"><code>Base64.Default</code></a>는 표준 <a href="https://www.rfc-editor.org/rfc/rfc4648#section-4" target="_blank" rel="noreferrer">Base64 인코딩 방식</a>을 사용합니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>Base64.Default</code>는 <code>Base64</code> 클래스의 컴패니언 객체입니다. 결과적으로 <code>Base64.Default.encode()</code> 및 <code>Base64.Default.decode()</code> 대신 <code>Base64.encode()</code> 및 <code>Base64.decode()</code>로 함수를 호출할 수 있습니다.</p></div></li><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.io.encoding/-base64/-default/-url-safe.html" target="_blank" rel="noreferrer"><code>Base64.UrlSafe</code></a>는 <a href="https://www.rfc-editor.org/rfc/rfc4648#section-5" target="_blank" rel="noreferrer">&quot;URL 및 파일명 안전&quot;</a> 인코딩 방식을 사용합니다.</p></li><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.io.encoding/-base64/-default/-mime.html" target="_blank" rel="noreferrer"><code>Base64.Mime</code></a>은 <a href="https://www.rfc-editor.org/rfc/rfc2045#section-6.8" target="_blank" rel="noreferrer">MIME</a> 인코딩 방식을 사용하며, 인코딩 시 76자마다 줄 구분 기호를 삽입하고 디코딩 시 유효하지 않은 문자를 건너뜁니다.</p></li><li><p><code>Base64.Pem</code>은 <code>Base64.Mime</code>처럼 데이터를 인코딩하지만 줄 길이를 64자로 제한합니다.</p></li></ul><p>Base64 API를 사용하여 바이너리 데이터를 Base64 문자열로 인코딩하고 다시 바이트로 디코딩할 수 있습니다.</p><p>다음은 예시입니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foBytes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;fo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.code.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toByte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toByteArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Base64.Default.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">encode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foBytes) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;Zm8=&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 다른 방법:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Base64.encode(foBytes)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foobarBytes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;foobar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.code.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toByte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toByteArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Base64.UrlSafe.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">encode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foobarBytes) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;Zm9vYmFy&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Base64.Default.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">decode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Zm8=&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// foBytes</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 다른 방법:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Base64.decode(&quot;Zm8=&quot;)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Base64.UrlSafe.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">decode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Zm9vYmFy&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// foobarBytes</span></span></code></pre></div><p>JVM에서는 <code>.encodingWith()</code> 및 <code>.decodingWith()</code> 확장 함수를 사용하여 입력 및 출력 스트림으로 Base64를 인코딩 및 디코딩할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.io.encoding.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> java.io.ByteArrayOutputStream</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> output </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ByteArrayOutputStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> base64Output </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> output.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">encodingWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Base64.Default)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    base64Output.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { stream </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        stream.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello World!!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">encodeToByteArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(output.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // SGVsbG8gV29ybGQhIQ==</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="hexformat-api를-사용한-stable-16진수-파싱-및-포매팅" tabindex="-1"><code>HexFormat</code> API를 사용한 Stable 16진수 파싱 및 포매팅 <a class="header-anchor" href="#hexformat-api를-사용한-stable-16진수-파싱-및-포매팅" aria-label="Permalink to &quot;\`HexFormat\` API를 사용한 Stable 16진수 파싱 및 포매팅&quot;">​</a></h3><p><a href="/ko/kotlin/whatsnew19#new-hexformat-class-to-format-and-parse-hexadecimals">Kotlin 1.9.0</a>에서 도입된 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.text/-hex-format/" target="_blank" rel="noreferrer"><code>HexFormat</code> API</a>는 이제 <a href="/ko/kotlin/components-stability#stability-levels-explained">Stable</a>입니다. 이를 사용하여 숫자 값과 16진수 문자열 간을 변환할 수 있습니다.</p><p>예시:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">93</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toHexString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>자세한 내용은 <a href="/ko/kotlin/whatsnew19#new-hexformat-class-to-format-and-parse-hexadecimals">새 HexFormat 클래스를 이용한 16진수 포매팅 및 파싱</a>을 참조하세요.</p><h2 id="compose-컴파일러" tabindex="-1">Compose 컴파일러 <a class="header-anchor" href="#compose-컴파일러" aria-label="Permalink to &quot;Compose 컴파일러&quot;">​</a></h2><p>이번 릴리스에서 Compose 컴파일러는 컴포저블 함수 참조에 대한 지원을 도입하고 여러 기능 플래그의 기본값을 변경합니다.</p><h3 id="composable-함수-참조-지원" tabindex="-1"><code>@Composable</code> 함수 참조 지원 <a class="header-anchor" href="#composable-함수-참조-지원" aria-label="Permalink to &quot;\`@Composable\` 함수 참조 지원&quot;">​</a></h3><p>Compose 컴파일러는 Kotlin 2.2.0 릴리스부터 컴포저블 함수 참조의 선언 및 사용을 지원합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> content: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Composable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (String) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Unit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Text</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Composable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;My App&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>컴포저블 함수 참조는 런타임에 컴포저블 람다 객체와 약간 다르게 동작합니다. 특히, 컴포저블 람다는 <code>ComposableLambda</code> 클래스를 확장하여 건너뛰기(skipping)에 대한 더 세밀한 제어를 허용합니다. 함수 참조는 <code>KCallable</code> 인터페이스를 구현할 것으로 예상되므로 동일한 최적화를 적용할 수 없습니다.</p><h3 id="pausablecomposition-기능-플래그-기본-활성화" tabindex="-1"><code>PausableComposition</code> 기능 플래그 기본 활성화 <a class="header-anchor" href="#pausablecomposition-기능-플래그-기본-활성화" aria-label="Permalink to &quot;\`PausableComposition\` 기능 플래그 기본 활성화&quot;">​</a></h3><p><code>PausableComposition</code> 기능 플래그는 Kotlin 2.2.0부터 기본적으로 활성화됩니다. 이 플래그는 다시 시작 가능한 함수에 대한 Compose 컴파일러 출력을 조정하여, 런타임이 건너뛰기 동작을 강제하고 각 함수를 건너뛰어 효과적으로 컴포지션을 일시 중지할 수 있도록 합니다. 이는 무거운 컴포지션을 프레임별로 분할할 수 있도록 허용하며, 향후 릴리스에서 프리페칭(prefetching)에 사용될 예정입니다.</p><p>이 기능 플래그를 비활성화하려면 Gradle 구성에 다음을 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">composeCompiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    featureFlag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ComposeFeatureFlag.PausableComposition.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disabled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="optimizenonskippinggroups-기능-플래그-기본-활성화" tabindex="-1"><code>OptimizeNonSkippingGroups</code> 기능 플래그 기본 활성화 <a class="header-anchor" href="#optimizenonskippinggroups-기능-플래그-기본-활성화" aria-label="Permalink to &quot;\`OptimizeNonSkippingGroups\` 기능 플래그 기본 활성화&quot;">​</a></h3><p><code>OptimizeNonSkippingGroups</code> 기능 플래그는 Kotlin 2.2.0부터 기본적으로 활성화됩니다. 이 최적화는 건너뛰지 않는(non-skipping) 컴포저블 함수에 대해 생성된 그룹 호출을 제거하여 런타임 성능을 향상시킵니다. 런타임에 눈에 띄는 동작 변경은 발생하지 않아야 합니다.</p><p>문제가 발생하는 경우, 이 변경이 문제의 원인인지 확인하려면 기능 플래그를 비활성화하여 검증할 수 있습니다. <a href="https://issuetracker.google.com/issues/new?component=610764&amp;template=1424126" target="_blank" rel="noreferrer">Jetpack Compose 이슈 트래커</a>에 문제점을 보고해 주세요.</p><p><code>OptimizeNonSkippingGroups</code> 플래그를 비활성화하려면 Gradle 구성에 다음을 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">composeCompiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    featureFlag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ComposeFeatureFlag.OptimizeNonSkippingGroups.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disabled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="더-이상-사용되지-않는-기능-플래그" tabindex="-1">더 이상 사용되지 않는 기능 플래그 <a class="header-anchor" href="#더-이상-사용되지-않는-기능-플래그" aria-label="Permalink to &quot;더 이상 사용되지 않는 기능 플래그&quot;">​</a></h3><p><code>StrongSkipping</code> 및 <code>IntrinsicRemember</code> 기능 플래그는 이제 더 이상 사용되지 않으며 향후 릴리스에서 제거될 예정입니다. 이러한 기능 플래그를 비활성화해야 하는 문제가 발생하면 <a href="https://issuetracker.google.com/issues/new?component=610764&amp;template=1424126" target="_blank" rel="noreferrer">Jetpack Compose 이슈 트래커</a>에 보고해 주세요.</p><h2 id="호환성이-깨지는-변경-사항-및-지원-중단" tabindex="-1">호환성이 깨지는 변경 사항 및 지원 중단 <a class="header-anchor" href="#호환성이-깨지는-변경-사항-및-지원-중단" aria-label="Permalink to &quot;호환성이 깨지는 변경 사항 및 지원 중단&quot;">​</a></h2><p>이 섹션에서는 주목할 만한 중요한 호환성이 깨지는 변경 사항 및 지원 중단 사항을 강조합니다. 이 릴리스의 모든 호환성이 깨지는 변경 사항 및 지원 중단 사항에 대한 전체 개요는 <a href="/ko/kotlin/compatibility-guide-22">호환성 가이드</a>를 참조하세요.</p><ul><li><p>Kotlin 2.2.0부터 <a href="/ko/kotlin/ant"></a> 빌드 시스템에 대한 지원이 중단됩니다. Ant에 대한 Kotlin 지원은 오랫동안 활발히 개발되지 않았으며, 상대적으로 작은 사용자 기반으로 인해 더 이상 유지보수할 계획이 없습니다.</p><p>2.3.0에서는 Ant 지원을 제거할 계획입니다. 그러나 Kotlin은 <a href="/ko/kotlin/contribute">기여</a>에 열려 있습니다. Ant의 외부 유지보수자가 되는 데 관심이 있다면, <a href="https://youtrack.jetbrains.com/issue/KT-75875/" target="_blank" rel="noreferrer">이 YouTrack 이슈</a>에 &quot;jetbrains-team&quot; 가시성 설정을 사용하여 댓글을 남겨주세요.</p></li><li><p>Kotlin 2.2.0은 Gradle의 <a href="/ko/kotlin/compatibility-guide-22#deprecate-kotlinoptions-dsl"><code>kotlinOptions{}</code> 블록의 지원 중단 수준을 오류로 상향</a>합니다. 대신 <code>compilerOptions{}</code> 블록을 사용하세요. 빌드 스크립트 업데이트에 대한 지침은 <a href="/ko/kotlin/gradle-compiler-options#migrate-from-kotlinoptions-to-compileroptions"><code>kotlinOptions{}</code>에서 <code>compilerOptions{}</code>로 마이그레이션</a>을 참조하세요.</p></li><li><p>Kotlin 스크립팅은 Kotlin 생태계의 중요한 부분으로 남아 있지만, 더 나은 경험을 제공하기 위해 사용자 지정 스크립팅과 <code>gradle.kts</code>, <code>main.kts</code> 스크립트와 같은 특정 사용 사례에 중점을 두고 있습니다. 자세한 내용은 업데이트된 <a href="https://blog.jetbrains.com/kotlin/2024/11/state-of-kotlin-scripting-2024/" target="_blank" rel="noreferrer">블로그 게시물</a>을 참조하세요. 결과적으로 Kotlin 2.2.0은 다음 지원을 중단합니다:</p><ul><li>REPL: <code>kotlinc</code>를 통해 REPL을 계속 사용하려면 <code>-Xrepl</code> 컴파일러 옵션으로 옵트인하세요.</li><li>JSR-223: 이 <a href="https://jcp.org/en/jsr/detail?id=223" target="_blank" rel="noreferrer">JSR</a>은 <strong>철회(Withdrawn)</strong> 상태이므로, JSR-223 구현은 언어 버전 1.9와 계속 작동하지만 향후 K2 컴파일러를 사용하도록 마이그레이션되지 않습니다.</li><li><code>KotlinScriptMojo</code> Maven 플러그인: 이 플러그인에 대한 충분한 인기를 확인하지 못했습니다. 계속 사용하면 컴파일러 경고가 표시될 것입니다.</li></ul></li><li></li><li><p>Kotlin 2.2.0에서 <a href="https://kotlinlang.org/api/kotlin-gradle-plugin/kotlin-gradle-plugin-api/org.jetbrains.kotlin.gradle.tasks/-kotlin-compile-tool/#" target="_blank" rel="noreferrer"><code>KotlinCompileTool</code></a>의 <a href="https://kotlinlang.org/api/kotlin-gradle-plugin/kotlin-gradle-plugin-api/org.jetbrains.kotlin.gradle.tasks/-kotlin-compile-tool/set-source.html#" target="_blank" rel="noreferrer"><code>setSource()</code></a> 함수는 이제 <a href="/ko/kotlin/compatibility-guide-22#correct-setsource-function-in-kotlincompiletool-to-replace-sources">구성된 소스를 추가하는 대신 교체</a>합니다. 기존 소스를 교체하지 않고 추가하려면 <a href="https://kotlinlang.org/api/kotlin-gradle-plugin/kotlin-gradle-plugin-api/org.jetbrains.kotlin.gradle.tasks/-kotlin-compile-tool/source.html#" target="_blank" rel="noreferrer"><code>source()</code></a> 함수를 사용하세요.</p></li><li><p><code>BaseKapt</code>의 <a href="https://kotlinlang.org/api/kotlin-gradle-plugin/kotlin-gradle-plugin-api/org.jetbrains.kotlin.gradle.tasks/-base-kapt/annotation-processor-option-providers.html#" target="_blank" rel="noreferrer"><code>annotationProcessorOptionProviders</code></a> 속성 타입이 <a href="/ko/kotlin/compatibility-guide-22#deprecate-basekapt-annotationprocessoroptionproviders-property"><code>MutableList&lt;Any&gt;</code>에서 <code>MutableList&lt;CommandLineArgumentProvider&gt;</code>로 변경</a>되었습니다. 코드가 현재 목록을 단일 요소로 추가하는 경우, <code>add()</code> 함수 대신 <code>addAll()</code> 함수를 사용하세요.</p></li><li><p>레거시 Kotlin/JS 백엔드에서 사용되던 dead code elimination (DCE) 도구의 지원 중단에 따라, DCE와 관련된 나머지 DSL은 Kotlin Gradle 플러그인에서 제거되었습니다:</p><ul><li><code>org.jetbrains.kotlin.gradle.dsl.KotlinJsDce</code> 인터페이스</li><li><code>org.jetbrains.kotlin.gradle.targets.js.dsl.KotlinJsBrowserDsl.dceTask(body: Action&lt;KotlinJsDce&gt;)</code> 함수</li><li><code>org.jetbrains.kotlin.gradle.dsl.KotlinJsDceCompilerToolOptions</code> 인터페이스</li><li><code>org.jetbrains.kotlin.gradle.dsl.KotlinJsDceOptions</code> 인터페이스</li></ul><p>현재 <a href="/ko/kotlin/js-ir-compiler">JS IR 컴파일러</a>는 DCE를 기본적으로 지원하며, <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.js/-js-export/" target="_blank" rel="noreferrer"><code>@JsExport</code></a> 어노테이션을 사용하여 DCE 중 유지할 Kotlin 함수와 클래스를 지정할 수 있습니다.</p></li><li><p>더 이상 사용되지 않는 <code>kotlin-android-extensions</code> 플러그인은 <a href="/ko/kotlin/compatibility-guide-22#deprecate-kotlin-android-extensions-plugin">Kotlin 2.2.0에서 제거</a>되었습니다. <code>Parcelable</code> 구현 생성기에는 <code>kotlin-parcelize</code> 플러그인을 사용하고, 합성 뷰(synthetic views)에는 Android Jetpack의 <a href="https://developer.android.com/topic/libraries/view-binding" target="_blank" rel="noreferrer">뷰 바인딩</a>을 사용하세요.</p></li><li><p>실험적 <code>kotlinArtifacts</code> API는 <a href="/ko/kotlin/compatibility-guide-22#deprecate-kotlinartifacts-api">Kotlin 2.2.0에서 지원 중단</a>되었습니다. 최종 네이티브 바이너리를 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-build-native-binaries.html" target="_blank" rel="noreferrer">빌드</a>하려면 Kotlin Gradle 플러그인에서 현재 사용 가능한 DSL을 사용하세요. 마이그레이션에 충분하지 않다면, <a href="https://youtrack.jetbrains.com/issue/KT-74953" target="_blank" rel="noreferrer">이 YT 이슈</a>에 댓글을 남겨주세요.</p></li><li><p>Kotlin 1.9.0에서 지원 중단된 <code>KotlinCompilation.source</code>는 이제 <a href="/ko/kotlin/compatibility-guide-22#deprecate-kotlincompilation-source-api">Kotlin Gradle 플러그인에서 제거</a>되었습니다.</p></li><li><p>실험적인 공통화 모드(commonization modes)의 파라미터는 <a href="/ko/kotlin/compatibility-guide-22#deprecate-commonization-parameters">Kotlin 2.2.0에서 지원 중단</a>되었습니다. 유효하지 않은 컴파일 아티팩트를 삭제하려면 공통화 캐시를 지우세요.</p></li><li><p>지원 중단된 <code>konanVersion</code> 프로퍼티는 이제 <a href="/ko/kotlin/compatibility-guide-22#deprecate-konanversion-in-cinteropprocess"><code>CInteropProcess</code> 태스크에서 제거</a>되었습니다. 대신 <code>CInteropProcess.kotlinNativeVersion</code>을 사용하세요.</p></li><li><p>지원 중단된 <code>destinationDir</code> 프로퍼티 사용은 이제 <a href="/ko/kotlin/compatibility-guide-22#deprecate-destinationdir-in-cinteropprocess">오류를 발생</a>시킵니다. 대신 <code>CInteropProcess.destinationDirectory.set()</code>을 사용하세요.</p></li></ul><h2 id="문서-업데이트" tabindex="-1">문서 업데이트 <a class="header-anchor" href="#문서-업데이트" aria-label="Permalink to &quot;문서 업데이트&quot;">​</a></h2><p>이번 릴리스에서는 Kotlin Multiplatform 문서가 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/get-started.html" target="_blank" rel="noreferrer">KMP 포털</a>로 마이그레이션되는 것을 포함하여 주목할 만한 문서 변경 사항이 있습니다.</p><p>또한 문서 설문조사를 시작하고, 새로운 페이지와 튜토리얼을 만들고, 기존 페이지를 개편했습니다.</p><h3 id="kotlin-문서-설문조사" tabindex="-1">Kotlin 문서 설문조사 <a class="header-anchor" href="#kotlin-문서-설문조사" aria-label="Permalink to &quot;Kotlin 문서 설문조사&quot;">​</a></h3><p>Kotlin 문서 개선을 위한 진정한 피드백을 찾고 있습니다.</p><p>설문조사는 약 15분 정도 소요되며, 귀하의 의견은 Kotlin 문서의 미래를 형성하는 데 도움이 될 것입니다.</p><p><a href="https://surveys.jetbrains.com/s3/Kotlin-Docs-2025" target="_blank" rel="noreferrer">여기서 설문조사에 참여하세요</a>.</p><h3 id="새롭고-개편된-튜토리얼" tabindex="-1">새롭고 개편된 튜토리얼 <a class="header-anchor" href="#새롭고-개편된-튜토리얼" aria-label="Permalink to &quot;새롭고 개편된 튜토리얼&quot;">​</a></h3><ul><li><a href="/ko/kotlin/kotlin-tour-welcome">Kotlin 중급 투어</a> – Kotlin에 대한 이해를 다음 단계로 끌어올리세요. 확장 함수, 인터페이스, 클래스 등을 언제 사용해야 하는지 배우세요.</li><li><a href="/ko/kotlin/spring-ai-guide">Spring AI를 사용하는 Kotlin 앱 구축</a> – OpenAI 및 벡터 데이터베이스를 사용하여 질문에 답변하는 Kotlin 앱을 만드는 방법을 배우세요.</li><li><a href="/ko/kotlin/jvm-create-project-with-spring-boot"></a> – IntelliJ IDEA의 <strong>새 프로젝트</strong> 마법사를 사용하여 Gradle로 Spring Boot 프로젝트를 만드는 방법을 배우세요.</li><li><a href="/ko/kotlin/mapping-primitive-data-types-from-c">Kotlin 및 C 매핑 튜토리얼 시리즈</a> – Kotlin과 C 간에 다른 타입 및 구성 요소가 어떻게 매핑되는지 배우세요.</li><li><a href="/ko/kotlin/native-app-with-c-and-libcurl">C interop 및 libcurl을 사용하여 앱 생성</a> – libcurl C 라이브러리를 사용하여 네이티브로 실행할 수 있는 간단한 HTTP 클라이언트를 만드세요.</li><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/create-kotlin-multiplatform-library.html" target="_blank" rel="noreferrer">Kotlin Multiplatform 라이브러리 생성</a> – IntelliJ IDEA를 사용하여 멀티플랫폼 라이브러리를 생성하고 게시하는 방법을 배우세요.</li><li><a href="https://ktor.io/docs/full-stack-development-with-kotlin-multiplatform.html" target="_blank" rel="noreferrer">Ktor 및 Kotlin Multiplatform로 풀스택 애플리케이션 구축</a> – 이 튜토리얼은 이제 Fleet 대신 IntelliJ IDEA를 Material 3 및 최신 버전의 Ktor와 Kotlin과 함께 사용합니다.</li><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-resource-environment.html" target="_blank" rel="noreferrer">Compose Multiplatform 앱에서 로컬 리소스 환경 관리</a> – 인앱 테마 및 언어와 같은 애플리케이션의 리소스 환경을 관리하는 방법을 배우세요.</li></ul><h3 id="새롭고-개편된-페이지" tabindex="-1">새롭고 개편된 페이지 <a class="header-anchor" href="#새롭고-개편된-페이지" aria-label="Permalink to &quot;새롭고 개편된 페이지&quot;">​</a></h3><ul><li><a href="/ko/kotlin/kotlin-ai-apps-development-overview">AI용 Kotlin 개요</a> – AI 기반 애플리케이션 구축을 위한 Kotlin의 기능을 알아보세요.</li><li><a href="https://kotlinlang.org/docs/dokka-migration.html" target="_blank" rel="noreferrer">Dokka 마이그레이션 가이드</a> – Dokka Gradle 플러그인 v2로 마이그레이션하는 방법을 배우세요.</li><li><a href="/ko/kotlin/metadata-jvm"></a> – JVM용으로 컴파일된 Kotlin 클래스에 대한 메타데이터를 읽고, 수정하고, 생성하는 지침을 살펴보세요.</li><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-overview.html" target="_blank" rel="noreferrer">CocoaPods 통합</a> – 튜토리얼과 샘플 프로젝트를 통해 환경 설정, Pod 종속성 추가 또는 Kotlin 프로젝트를 CocoaPod 종속성으로 사용하는 방법을 배우세요.</li><li>iOS Stable 릴리스를 지원하기 위한 Compose Multiplatform의 새로운 페이지: <ul><li>특히 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-navigation.html" target="_blank" rel="noreferrer">내비게이션</a> 및 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-navigation-deep-links.html" target="_blank" rel="noreferrer">딥 링크</a>.</li><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-layout.html" target="_blank" rel="noreferrer">Compose에서 레이아웃 구현</a>.</li><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-localize-strings.html" target="_blank" rel="noreferrer">문자열 현지화</a> 및 RTL 언어 지원과 같은 기타 i18n 페이지.</li></ul></li><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-hot-reload.html" target="_blank" rel="noreferrer">Compose Hot Reload</a> – 데스크톱 타겟에서 Compose Hot Reload를 사용하는 방법과 기존 프로젝트에 추가하는 방법을 배우세요.</li><li><a href="https://www.jetbrains.com/help/exposed/migrations.html" target="_blank" rel="noreferrer">Exposed 마이그레이션</a> – 데이터베이스 스키마 변경 관리를 위해 Exposed가 제공하는 도구에 대해 배우세요.</li></ul><h2 id="kotlin-2-2-0으로-업데이트하는-방법" tabindex="-1">Kotlin 2.2.0으로 업데이트하는 방법 <a class="header-anchor" href="#kotlin-2-2-0으로-업데이트하는-방법" aria-label="Permalink to &quot;Kotlin 2.2.0으로 업데이트하는 방법&quot;">​</a></h2><p>Kotlin 플러그인은 IntelliJ IDEA 및 Android Studio에 번들 플러그인으로 배포됩니다.</p><p>새로운 Kotlin 버전으로 업데이트하려면 빌드 스크립트에서 Kotlin 버전을 2.2.0으로 <a href="/ko/kotlin/releases#update-to-a-new-kotlin-version">변경</a>하세요.</p>`,70))])}const C=p(r,[["render",d]]);export{F as __pageData,C as default};
