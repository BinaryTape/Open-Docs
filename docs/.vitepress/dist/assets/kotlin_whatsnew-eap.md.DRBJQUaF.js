import{_ as t}from"./chunks/xcode-swift-export-run-script-phase.CN5rl4tW.js";import{_ as l}from"./chunks/default-hierarchy-example-with-web.De_8QTGQ.js";import{_ as e,C as p,c as h,o as k,ag as i,G as n}from"./chunks/framework.Bksy39di.js";const b=JSON.parse('{"title":"Kotlin 2.2.20-Beta2 有哪些新变化","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/whatsnew-eap.md","filePath":"kotlin/whatsnew-eap.md","lastUpdated":1754307826000}'),r={name:"kotlin/whatsnew-eap.md"};function o(d,s,c,g,E,y){const a=p("TopicTitle");return k(),h("div",null,[s[0]||(s[0]=i(`<h1 id="kotlin-2-2-20-beta2-有哪些新变化" tabindex="-1">Kotlin 2.2.20-Beta2 有哪些新变化 <a class="header-anchor" href="#kotlin-2-2-20-beta2-有哪些新变化" aria-label="Permalink to &quot;Kotlin 2.2.20-Beta2 有哪些新变化&quot;">​</a></h1><p><em><a href="/kotlin/eap#build-details">发布时间：July 29, 2025</a></em></p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>本文档并未涵盖抢先体验预览 (EAP) 版本的所有特性， 但它突出介绍了一些主要的改进。 欲查看完整的更改列表，请参阅 <a href="https://github.com/JetBrains/kotlin/releases/tag/v2.2.20-Beta2" target="_blank" rel="noreferrer">GitHub changelog</a>。</p></div><p>Kotlin 2.2.20-Beta2 版本已发布！ 以下是该 EAP 版本的一些详细信息：</p><ul><li>Kotlin Multiplatform：<a href="#swift-export-available-by-default">Swift export 默认可用</a>，<a href="#shared-source-set-for-js-and-wasmjs-targets">js 和 wasmJs 目标的共享源代码集</a>，<a href="#stable-cross-platform-compilation-for-kotlin-libraries">Kotlin 库的稳定跨平台编译</a>，以及<a href="#new-approach-for-declaring-common-dependencies">声明公共依赖项的新方法</a>。</li><li>语言：<a href="#improved-overload-resolution-for-lambdas-with-suspend-function-types">传递 lambda 到挂起函数类型重载时改进的重载解析</a>。</li><li>Kotlin/Native：<a href="#support-for-stack-canaries-in-binaries">支持二进制文件中的栈金丝雀</a> 和 <a href="#smaller-binary-size-for-ios-targets">更小的 iOS 目标二进制文件大小</a>。</li><li>Kotlin/Wasm：<a href="#improved-exception-handling-in-kotlin-wasm-and-javascript-interop">改进的 Kotlin/Wasm 和 JavaScript 互操作异常处理</a>。</li><li>Kotlin/JS：<a href="#usage-of-bigint-type-to-represent-kotlin-s-long-type"><code>Long</code> 值编译为 JavaScript <code>BigInt</code></a>。</li></ul><h2 id="ide-支持" tabindex="-1">IDE 支持 <a class="header-anchor" href="#ide-支持" aria-label="Permalink to &quot;IDE 支持&quot;">​</a></h2><p>支持 Kotlin 2.2.20-Beta2 的 Kotlin 插件已与最新版本的 IntelliJ IDEA 和 Android Studio 捆绑。 您无需更新 IDE 中的 Kotlin 插件。 您只需在构建脚本中将 <a href="/kotlin/configure-build-for-eap">Kotlin 版本更改</a> 为 2.2.20-Beta2 即可。</p><p>关于详细信息，请参阅 <a href="/kotlin/releases#update-to-a-new-kotlin-version">更新到新版本</a>。</p><h2 id="语言" tabindex="-1">语言 <a class="header-anchor" href="#语言" aria-label="Permalink to &quot;语言&quot;">​</a></h2><p>在 Kotlin 2.2.20-Beta2 中，您可以尝试 Kotlin 2.3.0 计划推出的一些语言特性，包括 <a href="#improved-overload-resolution-for-lambdas-with-suspend-function-types">传递 lambda 到挂起函数类型重载时改进的重载解析</a> 以及 <a href="#support-for-return-statements-in-expression-bodies-with-explicit-return-types">支持在带有显式返回类型的表达式体中使用 return 语句</a>。</p><h3 id="传递-lambda-到挂起函数类型重载时改进的重载解析" tabindex="-1">传递 lambda 到挂起函数类型重载时改进的重载解析 <a class="header-anchor" href="#传递-lambda-到挂起函数类型重载时改进的重载解析" aria-label="Permalink to &quot;传递 lambda 到挂起函数类型重载时改进的重载解析&quot;">​</a></h3><p>以前，当 lambda 传递给同时具有常规函数类型和 <code>suspend</code> 函数类型的函数重载时，会导致歧义错误。您可以通过显式类型转换来解决此错误，但编译器会错误地报告 <code>No cast needed</code> 警告：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Defines two overloads</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Int) {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">suspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Int) {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Fails with overload resolution ambiguity</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Uses an explicit cast, but compiler incorrectly reports a &quot;No cast needed&quot; warning</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Int)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>进行此更改后，当您同时定义常规函数类型重载和 <code>suspend</code> 函数类型重载时，不带类型转换的 lambda 将解析为常规重载。使用 <code>suspend</code> 关键字可显式解析为挂起重载：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Resolves to transform(() -&gt; Int)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Resolves to transform(suspend () -&gt; Int)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p>此行为将在 Kotlin 2.3.0 中默认启用。要立即测试此特性，请使用以下编译器选项将语言版本设置为 <code>2.3</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">language</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">version </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.3</span></span></code></pre></div><p>或者在您的 <code>build.gradle(.kts)</code> 文件中配置：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        languageVersion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_2_3)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我们非常感谢您在我们的问题跟踪器 <a href="https://youtrack.jetbrains.com/issue/KT-23610" target="_blank" rel="noreferrer">YouTrack</a> 中提供反馈。</p><h3 id="支持在带有显式返回类型的表达式体中使用-return-语句" tabindex="-1">支持在带有显式返回类型的表达式体中使用 return 语句 <a class="header-anchor" href="#支持在带有显式返回类型的表达式体中使用-return-语句" aria-label="Permalink to &quot;支持在带有显式返回类型的表达式体中使用 return 语句&quot;">​</a></h3><p>以前，在表达式体中使用 <code>return</code> 会导致编译器错误，因为它可能导致函数的返回类型被推断为 <code>Nothing</code>。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Error: Returns are prohibited for functions with an expression body</span></span></code></pre></div><p>进行此更改后，只要显式编写返回类型，您现在就可以在表达式体中使用 <code>return</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Specifies the return type explicitly</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDisplayNameOrDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userId: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDisplayName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userId ?: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;default&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Fails because it doesn&#39;t specify the return type explicitly</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDisplayNameOrDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userId: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDisplayName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userId ?: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;default&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>同样，在表达式函数体中，lambda 和嵌套表达式内部的 <code>return</code> 语句过去会被意外编译。Kotlin 现在支持这些情况，只要显式指定返回类型即可。没有显式返回类型的情况将在 Kotlin 2.3.0 中弃用：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Return type isn&#39;t explicitly specified, and the return statement is inside a lambda</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// which will be deprecated</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> returnInsideLambda</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Return type isn&#39;t explicitly specified, and the return statement is inside the initializer</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// of a local variable, which will be deprecated</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> returnInsideIf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">someCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> else</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;value&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        result</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此行为将在 Kotlin 2.3.0 中默认启用。要立即测试此特性，请使用以下编译器选项将语言版本设置为 <code>2.3</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">language</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">version </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.3</span></span></code></pre></div><p>或者在您的 <code>build.gradle(.kts)</code> 文件中配置：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        languageVersion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_2_3)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我们非常感谢您在我们的问题跟踪器 <a href="https://youtrack.jetbrains.com/issue/KT-76926" target="_blank" rel="noreferrer">YouTrack</a> 中提供反馈。</p>`,32)),n(a,{id:"kotlin-jvm-支持-when-表达式的-invokedynamic",level:"2",title:"Kotlin/JVM：支持 `when` 表达式的 invokedynamic",labelRef:"experimental-opt-in"}),s[1]||(s[1]=i(` <p>在 Kotlin 2.2.20-Beta2 中，您现在可以使用 <code>invokedynamic</code> 编译 <code>when</code> 表达式。 以前，具有多个类型检测的 <code>when</code> 表达式会编译成字节码中一长串的 <code>instanceof</code> 检测。</p><p>现在，您可以在 <code>when</code> 表达式中使用 <code>invokedynamic</code> 来生成更小的字节码，类似于 Java <code>switch</code> 语句生成的字节码，前提是满足以下条件：</p><ul><li>除了 <code>else</code> 之外的所有条件都是 <code>is</code> 或 <code>null</code> 检测。</li><li>表达式不包含 <a href="/kotlin/control-flow#guard-conditions-in-when-expressions">守卫条件 (<code>if</code>)</a>。</li><li>条件不包含无法直接进行类型检测的类型，例如可变 Kotlin 集合 (<code>MutableList</code>) 或函数类型 (<code>kotlin.Function1</code>、<code>kotlin.Function2</code> 等)。</li><li>除了 <code>else</code> 之外，至少有两个条件。</li><li>所有分支都检测 <code>when</code> 表达式的相同主题。</li></ul><p>例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">open</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Example</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Uses invokedynamic with SwitchBootstraps.typeSwitch</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> C </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>启用此新特性后，此示例中的 <code>when</code> 表达式会编译为一个 <code>invokedynamic</code> 类型切换，而不是多个 <code>instanceof</code> 检测。</p><p>要启用此特性，请使用 JVM 目标 21 或更高版本编译您的 Kotlin 代码，并添加以下编译器选项：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">-Xwhen-expressions</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">indy</span></span></code></pre></div><p>或者将其添加到 <code>build.gradle(.kts)</code> 文件的 <code>compilerOptions {}</code> 代码块中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xwhen-expressions=indy&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此特性是<a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>。如果您有任何反馈或问题，请在 <a href="https://youtrack.jetbrains.com/issue/KT-65688" target="_blank" rel="noreferrer">YouTrack</a> 中分享。</p><h2 id="kotlin-multiplatform" tabindex="-1">Kotlin Multiplatform <a class="header-anchor" href="#kotlin-multiplatform" aria-label="Permalink to &quot;Kotlin Multiplatform&quot;">​</a></h2><p>Kotlin 2.2.20-Beta2 为 Kotlin Multiplatform 带来了重大更改：Swift export 默认可用，引入了新的共享源代码集，并且您可以尝试一种管理公共依赖项的新方法。</p>`,14)),n(a,{id:"swift-export-默认可用",level:"3",title:"Swift export 默认可用",labelRef:"experimental-general"}),s[2]||(s[2]=i(' <p>Kotlin 2.2.20-Beta2 引入了 Swift export 的实验性支持。它允许您直接导出 Kotlin 源代码并以地道的 Swift 方式调用 Kotlin 代码，从而无需 Objective-C 头文件。</p><p>这应该会显著改进 Apple 目标平台的跨平台开发。例如，如果您有一个包含顶层函数的 Kotlin 模块，Swift export 可以实现干净的、模块特有的导入，从而消除令人困惑的 Objective-C 下划线和名字修饰。</p><p>主要特性包括：</p><ul><li><strong>多模块支持</strong>。每个 Kotlin 模块都作为一个单独的 Swift 模块导出，从而简化了函数调用。</li><li><strong>包支持</strong>。Kotlin 包在导出期间会显式保留，从而避免生成的 Swift 代码中出现命名冲突。</li><li><strong>类型别名</strong>。Kotlin 类型别名在 Swift 中被导出并保留，提高了可读性。</li><li><strong>增强的原语可空性</strong>。与 Objective-C 互操作（需要将 <code>Int?</code> 等类型装箱到 <code>KotlinInt</code> 等包装类以保留可空性）不同，Swift export 直接转换可空性信息。</li><li><strong>重载</strong>。您可以在 Swift 中调用 Kotlin 的重载函数而不会出现歧义。</li><li><strong>扁平化包结构</strong>。您可以将 Kotlin 包转换为 Swift 枚举，从而从生成的 Swift 代码中删除包前缀。</li><li><strong>模块名称自定义</strong>。您可以在 Kotlin 项目的 Gradle 配置中自定义生成的 Swift 模块名称。</li></ul><h4 id="如何启用-swift-export" tabindex="-1">如何启用 Swift export <a class="header-anchor" href="#如何启用-swift-export" aria-label="Permalink to &quot;如何启用 Swift export&quot;">​</a></h4><p>此特性目前是<a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>，并且仅适用于使用<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-direct-integration.html" target="_blank" rel="noreferrer">直接集成</a> 将 iOS framework 连接到 Xcode 项目的项目。这是使用 IntelliJ IDEA 中的 Kotlin Multiplatform 插件或通过 <a href="https://kmp.jetbrains.com/" target="_blank" rel="noreferrer">web wizard</a> 创建的 Kotlin Multiplatform 项目的标准配置。</p><p>要试用 Swift export，请配置您的 Xcode 项目：</p><ol><li>在 Xcode 中，打开项目设置。</li><li>在 <strong>Build Phases</strong> 选项卡中，找到包含 <code>embedAndSignAppleFrameworkForXcode</code> 任务的 <strong>Run Script</strong> 阶段。</li><li>调整脚本，使其在运行脚本阶段使用 <code>embedSwiftExportForXcode</code> 任务：</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./gradlew</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> :</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Shared</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> module</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nam</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">:embedSwiftExportForXcode</span></span></code></pre></div><p><img src="'+t+`" alt="Add the Swift export script" width="700"></p><ol start="4"><li>构建项目。Swift 模块在构建输出目录中生成。</li></ol><p>此特性默认可用。如果您在以前的版本中已启用此特性，则现在可以从 <code>gradle.properties</code> 文件中移除 <code>kotlin.experimental.swift-export.enabled</code>。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>为了节省时间，请克隆我们已设置好 Swift export 的 <a href="https://github.com/Kotlin/swift-export-sample" target="_blank" rel="noreferrer">公共示例</a>。</p></div><p>关于 Swift export 的更多信息，请参阅其 <a href="https://github.com/JetBrains/kotlin/tree/master/docs/swift-export#readme" target="_blank" rel="noreferrer">README</a>。</p><h4 id="留下反馈" tabindex="-1">留下反馈 <a class="header-anchor" href="#留下反馈" aria-label="Permalink to &quot;留下反馈&quot;">​</a></h4><p>我们计划在未来的 Kotlin 版本中扩展并逐步稳定 Swift export 支持。在 Kotlin 2.2.20 之后，我们将专注于改进 Kotlin 和 Swift 之间的互操作性，尤其是在协程和流方面。</p><p>对 Swift export 的支持是 Kotlin Multiplatform 的一项重大更改。我们非常感谢您的反馈：</p><ul><li>直接在 Kotlin Slack 中联系开发团队 – <a href="https://surveys.jetbrains.com/s3/kotlin-slack-sign-up?_gl=1*ju6cbn*_ga*MTA3MTk5NDkzMC4xNjQ2MDY3MDU4*_ga_9J976DJZ68*MTY1ODMzNzA3OS4xMDAuMS4xNjU4MzQwODEwLjYw" target="_blank" rel="noreferrer">获取邀请</a> 并加入 <a href="https://kotlinlang.slack.com/archives/C073GUW6WN9" target="_blank" rel="noreferrer">#swift-export</a> 频道。</li><li>在 <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack</a> 中报告您在使用 Swift export 时遇到的任何问题。</li></ul><h3 id="js-和-wasmjs-目标的共享源代码集" tabindex="-1">js 和 wasmJs 目标的共享源代码集 <a class="header-anchor" href="#js-和-wasmjs-目标的共享源代码集" aria-label="Permalink to &quot;js 和 wasmJs 目标的共享源代码集&quot;">​</a></h3><p>以前，Kotlin Multiplatform 默认不包含 JavaScript (<code>js</code>) 和 WebAssembly (<code>wasmJs</code>) web 目标的共享源代码集。为了在 <code>js</code> 和 <code>wasmJs</code> 之间共享代码，您必须手动配置自定义源代码集或在两个地方编写代码，一个版本用于 <code>js</code>，另一个版本用于 <code>wasmJs</code>。例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// commonMain</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">expect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readCopiedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// jsMain</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Navigator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clipboard: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Different interop in JS and Wasm</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; } </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Navigator</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readCopiedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Different interop in JS and Wasm</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.clipboard.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// wasmJsMain</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Navigator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clipboard: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JsString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Navigator</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readCopiedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.clipboard.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>从该版本开始，当使用默认层级模板时，Kotlin Gradle 插件会为 web 添加一个新的共享源代码集（包含 <code>webMain</code> 和 <code>webTest</code>）。</p><p>进行此更改后，<code>web</code> 源代码集将成为 <code>js</code> 和 <code>wasmJs</code> 源代码集的父级。更新后的源代码集层级结构如下所示：</p><p><img src="`+l+`" alt="An example of using the default hierarchy template with web"></p><p>新的源代码集允许您为 <code>js</code> 和 <code>wasmJs</code> 目标编写一份代码。您可以将共享代码放在 <code>webMain</code> 中，它会自动适用于这两个目标：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// commonMain</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">expect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readCopiedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// webMain</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Navigator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clipboard: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JsString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Navigator</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readCopiedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.clipboard.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此更新简化了 <code>js</code> 和 <code>wasmJs</code> 目标之间的代码共享。它在两种情况下特别有用：</p><ul><li>对于希望添加对 <code>js</code> 和 <code>wasmJs</code> 目标的支持而无需复制代码的库作者。</li><li>对于构建面向 Web 的 Compose Multiplatform 应用程序的开发者，它支持跨编译到 <code>js</code> 和 <code>wasmJs</code> 目标，以实现更广泛的浏览器兼容性。有了这种回退模式，当您创建网站时，它将开箱即用地在所有浏览器上运行：现代浏览器使用 <code>wasmJs</code>，而旧浏览器使用 <code>js</code>。</li></ul><p>要试用此特性，请在 <code>build.gradle(.kts)</code> 文件的 <code>kotlin {}</code> 代码块中使用 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-hierarchy.html#default-hierarchy-template" target="_blank" rel="noreferrer">默认层级模板</a>。</p><p>在使用默认层级之前，如果您有包含自定义共享源代码集或已重命名 <code>js(&quot;web&quot;)</code> 目标的项目，请仔细考虑任何潜在冲突。要解决这些冲突，请重命名冲突的源代码集或目标，或者不使用默认层级。</p><h3 id="kotlin-库的稳定跨平台编译" tabindex="-1">Kotlin 库的稳定跨平台编译 <a class="header-anchor" href="#kotlin-库的稳定跨平台编译" aria-label="Permalink to &quot;Kotlin 库的稳定跨平台编译&quot;">​</a></h3><p>Kotlin 2.2.20-Beta2 完成了一项重要的<a href="https://youtrack.jetbrains.com/issue/KT-71290" target="_blank" rel="noreferrer">路线图项目</a>，稳定了 Kotlin 库的跨平台编译。</p><p>您现在可以使用任何宿主来生成 <code>.klib</code> artifact，用于发布 Kotlin 库。这显著简化了发布过程，特别是对于以前需要 Mac 机器的 Apple 目标平台。</p><p>此特性默认可用。如果您已通过 <code>kotlin.native.enableKlibsCrossCompilation=true</code> 启用跨编译，则现在可以从您的 <code>gradle.properties</code> 文件中移除它。</p><p>不幸的是，仍然存在一些限制。在以下情况下，您仍然需要使用 Mac 机器：</p><ul><li>您的库具有 <a href="/kotlin/native-c-interop">cinterop 依赖项</a>。</li><li>您在项目中设置了 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-overview.html" target="_blank" rel="noreferrer">CocoaPods 集成</a>。</li><li>您需要为 Apple 目标平台构建或测试 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-build-native-binaries.html" target="_blank" rel="noreferrer">最终二进制文件</a>。</li></ul><p>关于多平台库的发布信息，请参阅我们的<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-publish-lib-setup.html" target="_blank" rel="noreferrer">文档</a>。</p>`,38)),n(a,{id:"声明公共依赖项的新方法",level:"3",title:"声明公共依赖项的新方法",labelRef:"experimental-opt-in"}),s[3]||(s[3]=i(`<p>为了简化使用 Gradle 设置多平台项目，Kotlin 2.2.20-Beta2 现在允许您通过使用顶层 <code>dependencies {}</code> 代码块在 <code>kotlin {}</code> 代码块中声明公共依赖项。这些依赖项的行为就像它们在 <code>commonMain</code> 源代码集中声明一样。此特性与您用于 Kotlin/JVM 和仅限 Android 项目的依赖项代码块类似，现在在 Kotlin Multiplatform 中是<a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>。在项目级别声明公共依赖项可以减少跨源代码集的重复配置，并有助于简化您的构建设置。您仍然可以根据需要在每个源代码集中添加平台特有的依赖项。</p><p>要试用此特性，请在顶层 <code>dependencies {}</code> 代码块之前添加 <code>@OptIn(ExperimentalKotlinGradlePluginApi::class)</code> 注解来选择启用。例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalKotlinGradlePluginApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        implementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我们非常感谢您在 <a href="https://youtrack.jetbrains.com/issue/KT-76446" target="_blank" rel="noreferrer">YouTrack</a> 中对该特性提供反馈。</p><h2 id="kotlin-native" tabindex="-1">Kotlin/Native <a class="header-anchor" href="#kotlin-native" aria-label="Permalink to &quot;Kotlin/Native&quot;">​</a></h2><p>Kotlin 2.2.20-Beta2 为 Kotlin/Native 二进制文件和调试带来了改进。</p><h3 id="支持二进制文件中的栈金丝雀" tabindex="-1">支持二进制文件中的栈金丝雀 <a class="header-anchor" href="#支持二进制文件中的栈金丝雀" aria-label="Permalink to &quot;支持二进制文件中的栈金丝雀&quot;">​</a></h3><p>从 2.2.20-Beta2 开始，Kotlin 在生成的 Kotlin/Native 二进制文件中添加了对栈金丝雀的支持。作为栈保护的一部分，此安全特性可防止栈溢出攻击，从而减轻一些常见的应用程序漏洞。它已在 Swift 和 Objective-C 中可用，现在 Kotlin 也支持它。</p><h4 id="如何启用栈金丝雀" tabindex="-1">如何启用栈金丝雀 <a class="header-anchor" href="#如何启用栈金丝雀" aria-label="Permalink to &quot;如何启用栈金丝雀&quot;">​</a></h4><p>Kotlin/Native 中栈保护的实现遵循 <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-fstack-protector" target="_blank" rel="noreferrer">Clang</a> 中栈保护器的行为。</p><p>要启用栈金丝雀，请将以下属性添加到您的 <code>gradle.properties</code> 文件中：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.stackProtector=yes</span></span></code></pre></div><p>此属性为所有易受栈溢出攻击的 Kotlin 函数启用此特性。替代模式包括：</p><ul><li><code>kotlin.native.binary.stackProtector=strong</code>，它对易受栈溢出攻击的函数使用更强的启发式方法。</li><li><code>kotlin.native.binary.stackProtector=all</code>，它为所有函数启用栈保护器。</li></ul><p>请注意，在某些情况下，栈保护可能会带来性能开销。</p>`,15)),n(a,{id:"更小的-ios-目标二进制文件大小",level:"3",title:"更小的 iOS 目标二进制文件大小",labelRef:"experimental-general"}),s[4]||(s[4]=i(` <p>Kotlin 2.2.20-Beta2 引入了 <code>smallBinary</code> 选项，可以帮助您减小 iOS 目标的二进制文件大小。新选项有效地将 <code>-Oz</code> 设置为 LLVM 编译阶段编译器默认的优化实参。</p><p>启用 <code>smallBinary</code> 选项后，可以使发布二进制文件更小并改善构建时间。但是，在某些情况下，它可能会影响运行时性能。</p><h4 id="如何启用更小的二进制文件大小" tabindex="-1">如何启用更小的二进制文件大小 <a class="header-anchor" href="#如何启用更小的二进制文件大小" aria-label="Permalink to &quot;如何启用更小的二进制文件大小&quot;">​</a></h4><p>此新特性目前是<a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>。要在您的项目中试用它，请使用 <code>-Xbinary=smallBinary=true</code> 编译器选项或更新您的 <code>gradle.properties</code> 文件：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.smallBinary=true</span></span></code></pre></div><p>对于特定的二进制文件，请在您的 <code>build.gradle(.kts)</code> 文件中设置 <code>binaryOption(&quot;smallBinary&quot;, &quot;true&quot;)</code>。例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        iosX64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        iosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        iosSimulatorArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        it.binaries.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">framework</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            binaryOption</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;smallBinary&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;true&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Kotlin 团队感谢 <a href="https://github.com/troelsbjerre" target="_blank" rel="noreferrer">Troels Lund</a> 在实现此特性方面提供的帮助。</p><p>关于 Kotlin/Native 中调试的更多信息，请参阅<a href="/kotlin/native-debugging">文档</a>。</p><h3 id="改进的调试器对象摘要" tabindex="-1">改进的调试器对象摘要 <a class="header-anchor" href="#改进的调试器对象摘要" aria-label="Permalink to &quot;改进的调试器对象摘要&quot;">​</a></h3><p>Kotlin/Native 现在为 LLDB 和 GDB 等调试器工具生成更清晰的对象摘要。这提高了生成的调试信息的可读性并简化了您的调试体验。</p><p>以前，如果您探查一个对象，例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> point </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>您会看到有限的信息，包括指向内存地址的指针：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(lldb) v point</span></span>
<span class="line"><span>(ObjHeader *) point = [x: ..., y: ...]</span></span>
<span class="line"><span>(lldb) v point-&gt;x</span></span>
<span class="line"><span>(int32_t *) x = 0x0000000100274048</span></span></code></pre></div><p>使用 Kotlin 2.2.20-Beta2 后，调试器会显示更丰富的信息，包括实际值：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(lldb) v point</span></span>
<span class="line"><span>(ObjHeader *) point = Point(x=1, y=2)</span></span>
<span class="line"><span>(lldb) v point-&gt;x</span></span>
<span class="line"><span>(int32_t) point-&gt;x = 1</span></span></code></pre></div><p>Kotlin 团队感谢 <a href="https://github.com/nikita-nazarov" target="_blank" rel="noreferrer">Nikita Nazarov</a> 在实现此特性方面提供的帮助。</p><p>关于 Kotlin/Native 中调试的更多信息，请参阅<a href="/kotlin/native-debugging">文档</a>。</p><h2 id="kotlin-wasm" tabindex="-1">Kotlin/Wasm <a class="header-anchor" href="#kotlin-wasm" aria-label="Permalink to &quot;Kotlin/Wasm&quot;">​</a></h2><p>Kotlin/Wasm 获得了一些质量改进，包括分离的 npm 依赖项和改进的 JavaScript 互操作异常处理。</p><h3 id="分离的-npm-依赖项" tabindex="-1">分离的 npm 依赖项 <a class="header-anchor" href="#分离的-npm-依赖项" aria-label="Permalink to &quot;分离的 npm 依赖项&quot;">​</a></h3><p>以前，在您的 Kotlin/Wasm 项目中，所有 <a href="https://www.npmjs.com/" target="_blank" rel="noreferrer">npm</a> 依赖项都一起安装在您的项目文件夹中。它包括您自己的依赖项和 Kotlin 工具依赖项。这些依赖项也一起记录在您项目的锁定文件（<code>package-lock.json</code> 或 <code>yarn.lock</code>）中。</p><p>因此，每当 Kotlin 工具依赖项更新时，即使您没有添加或更改任何内容，也必须更新您的锁定文件。</p><p>从 Kotlin 2.2.20-Beta2 开始，Kotlin 工具 npm 依赖项安装在您的项目之外。现在，工具和用户依赖项具有单独的目录：</p><ul><li><p><strong>工具依赖项目录：</strong></p><p><code>&lt;kotlin-user-home&gt;/kotlin-npm-tooling/&lt;yarn|npm&gt;/hash/node_modules</code></p></li><li><p><strong>用户依赖项目录：</strong></p><p><code>build/wasm/node_modules</code></p></li></ul><p>此外，项目目录中的锁定文件只包含用户定义的依赖项。</p><p>此改进使您的锁定文件仅关注您自己的依赖项，有助于维护更整洁的项目，并减少对文件的非必要更改。</p><p>此更改默认对 <code>wasm-js</code> 目标启用。此更改尚未针对 <code>js</code> 目标实现。虽然计划在未来的版本中实现它，但在 Kotlin 2.2.20-Beta2 中，<code>js</code> 目标的 npm 依赖项行为保持不变。</p><h3 id="改进的-kotlin-wasm-和-javascript-互操作异常处理" tabindex="-1">改进的 Kotlin/Wasm 和 JavaScript 互操作异常处理 <a class="header-anchor" href="#改进的-kotlin-wasm-和-javascript-互操作异常处理" aria-label="Permalink to &quot;改进的 Kotlin/Wasm 和 JavaScript 互操作异常处理&quot;">​</a></h3><p>以前，Kotlin 难以理解在 JavaScript (JS) 中抛出并跨越到 Kotlin/Wasm 代码的异常（错误）。</p><p>在某些情况下，当异常通过 Wasm 代码抛出或传递到 JS 并被包装到 <code>WebAssembly.Exception</code> 中而没有任何详细信息时，也会出现相反方向的问题。这些 Kotlin 异常处理问题使调试变得困难。</p><p>从 Kotlin 2.2.20-Beta2 开始，异常的开发者体验在两个方向上都得到了改进：</p><ul><li>当 JavaScript 抛出异常时：您可以在 Kotlin 端看到更多信息。当此类异常通过 Kotlin 传播回 JS 时，它不再包装到 WebAssembly 中。</li><li>当 Kotlin 抛出异常时：它们现在可以作为 JS 错误在 JavaScript 端被捕获。</li></ul><p>新的异常处理在支持 <a href="https://webassembly.github.io/exception-handling/js-api/#dom-webassembly-jstag" target="_blank" rel="noreferrer"><code>WebAssembly.JSTag</code></a> 特性的现代浏览器中自动工作：</p><ul><li>Chrome 115+</li><li>Firefox 129+</li><li>Safari 18.4+</li></ul><p>在旧浏览器中，异常处理行为保持不变。</p><h2 id="kotlin-js" tabindex="-1">Kotlin/JS <a class="header-anchor" href="#kotlin-js" aria-label="Permalink to &quot;Kotlin/JS&quot;">​</a></h2><p>Kotlin 2.2.20-Beta2 支持使用 <code>BigInt</code> 类型来表示 Kotlin 的 <code>Long</code> 类型，从而在导出的声明中启用 <code>Long</code>。此外，此版本还添加了一个 DSL 函数来清理 Node.js 实参。</p>`,40)),n(a,{id:"使用-bigint-类型表示-kotlin-的-long-类型",level:"3",title:"使用 BigInt 类型表示 Kotlin 的 Long 类型",labelRef:"experimental-opt-in"}),s[5]||(s[5]=i(`<p>在 ES2020 标准之前，JavaScript (JS) 不支持用于表示大于 53 位的精确整数的原语类型。</p><p>因此，Kotlin/JS 过去将 <code>Long</code> 值（64 位宽）表示为包含两个 <code>number</code> 属性的 JavaScript 对象。这种自定义实现使得 Kotlin 和 JavaScript 之间的互操作性更加复杂。</p><p>从 Kotlin 2.2.20-Beta2 开始，Kotlin/JS 现在在编译到现代 JavaScript (ES2020) 时，使用 JavaScript 的内置 <code>BigInt</code> 类型来表示 Kotlin 的 <code>Long</code> 值。</p><p>此更改支持 <a href="#usage-of-long-in-exported-declarations">将 <code>Long</code> 类型导出到 JavaScript</a>，这也是 2.2.20-Beta2 中引入的一项特性。因此，此更改简化了 Kotlin 和 JavaScript 之间的互操作性。</p><p>要启用它，请将以下编译器选项添加到您的 <code>build.gradle(.kts)</code> 文件中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xes-long-as-bigint&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此特性仍是<a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>。请在我们的问题跟踪器 <a href="https://youtrack.jetbrains.com/issue/KT-57128" target="_blank" rel="noreferrer">YouTrack</a> 中报告任何问题。</p><h4 id="long-在导出声明中的用法" tabindex="-1">Long 在导出声明中的用法 <a class="header-anchor" href="#long-在导出声明中的用法" aria-label="Permalink to &quot;Long 在导出声明中的用法&quot;">​</a></h4><p>由于 Kotlin/JS 使用自定义的 <code>Long</code> 表示，因此很难提供一种直接的方式来从 JavaScript 与 Kotlin 的 <code>Long</code> 进行交互。因此，您无法将使用 <code>Long</code> 类型的 Kotlin 代码导出到 JavaScript。此问题影响了所有使用 <code>Long</code> 的代码，例如函数形参、类属性或构造函数。</p><p>现在 Kotlin 的 <code>Long</code> 类型可以编译为 JavaScript 的 <code>BigInt</code> 类型，Kotlin/JS 支持将 <code>Long</code> 值导出到 JavaScript，从而简化了 Kotlin 和 JavaScript 代码之间的互操作性。</p><p>要启用此特性：</p><ol><li><p>允许在 Kotlin/JS 中导出 <code>Long</code>。将以下编译器实参添加到您的 <code>build.gradle(.kts)</code> 文件中的 <code>freeCompilerArgs</code> 属性：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {                   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-XXLanguage:+JsAllowLongInExportedDeclarations&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>启用 <code>BigInt</code> 类型。关于如何启用它，请参见 <a href="#usage-of-bigint-type-to-represent-kotlin-s-long-type">使用 <code>BigInt</code> 类型表示 Kotlin 的 <code>Long</code> 类型</a>。</p></li></ol><h3 id="用于清理实参的新-dsl-函数" tabindex="-1">用于清理实参的新 DSL 函数 <a class="header-anchor" href="#用于清理实参的新-dsl-函数" aria-label="Permalink to &quot;用于清理实参的新 DSL 函数&quot;">​</a></h3><p>使用 Node.js 运行 Kotlin/JS 应用程序时，传递给程序的实参（<code>args</code>）通常包含：</p><ul><li>可执行文件 <code>Node</code> 的路径。</li><li>脚本的路径。</li><li>您提供的实际命令行实参。</li></ul><p>然而，<code>args</code> 的预期行为是仅包含命令行实参。为此，您必须在 <code>build.gradle(.kts)</code> 文件或 Kotlin 代码中使用 <code>drop()</code> 函数手动跳过前两个实参：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">drop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">joinToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;, &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这种变通方法重复、容易出错，并且在跨平台共享代码时效果不佳。</p><p>为了解决此问题，Kotlin 2.2.20-Beta2 引入了一个名为 <code>passCliArgumentsToMainFunction()</code> 的新 DSL 函数。</p><p>使用此函数，实参将仅包含命令行实参，并排除 <code>Node</code> 和脚本路径：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // No need for drop() and only your custom arguments are included </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">joinToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;, &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此更改减少了样板代码，避免了手动删除实参导致的错误，并提高了跨平台兼容性。</p><p>要启用此特性，请将以下 DSL 函数添加到您的 <code>build.gradle(.kts)</code> 文件中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        nodejs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            passCliArgumentsToMainFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="gradle-kotlin-native-任务的构建报告中新增编译器性能指标" tabindex="-1">Gradle：Kotlin/Native 任务的构建报告中新增编译器性能指标 <a class="header-anchor" href="#gradle-kotlin-native-任务的构建报告中新增编译器性能指标" aria-label="Permalink to &quot;Gradle：Kotlin/Native 任务的构建报告中新增编译器性能指标&quot;">​</a></h2><p>在 Kotlin 1.7.0 中，我们引入了<a href="/kotlin/gradle-compilation-and-caches#build-reports">构建报告</a> 来帮助跟踪编译器性能。从那时起，我们添加了更多指标，使这些报告更加详细，对于调查性能问题也更有用。</p><p>在 Kotlin 2.2.20-Beta2 中，构建报告现在包含 Kotlin/Native 任务的编译器性能指标。</p><p>要了解有关构建报告以及如何配置它们的更多信息，请参阅<a href="/kotlin/gradle-compilation-and-caches#enabling-build-reports">启用构建报告</a>。</p><h2 id="maven-kotlin-maven-plugin-中对-kotlin-daemon-的支持" tabindex="-1">Maven：kotlin-maven-plugin 中对 Kotlin daemon 的支持 <a class="header-anchor" href="#maven-kotlin-maven-plugin-中对-kotlin-daemon-的支持" aria-label="Permalink to &quot;Maven：kotlin-maven-plugin 中对 Kotlin daemon 的支持&quot;">​</a></h2><p>随着 <a href="/kotlin/whatsnew22#new-experimental-build-tools-api">Kotlin 2.2.0 中构建工具 API</a> 的引入，Kotlin 2.2.20-Beta2 通过在 <code>kotlin-maven-plugin</code> 中添加对 Kotlin daemon 的支持，更进一步。使用 Kotlin daemon 时，Kotlin 编译器在独立的进程中运行，这可以防止其他 Maven 插件覆盖系统属性。您可以在此 <a href="https://youtrack.jetbrains.com/issue/KT-43894/Maven-Windows-error-RuntimeException-Could-not-find-installation-home-path" target="_blank" rel="noreferrer">YouTrack 问题</a> 中查看示例。</p><p>从 Kotlin 2.2.20-Beta2 开始，Kotlin daemon 默认启用。这为您带来了<a href="/kotlin/maven#enable-incremental-compilation">增量编译</a> 的额外好处，有助于加快构建时间。如果您想恢复到以前的行为，请通过在 <code>pom.xml</code> 文件中将以下属性设置为 <code>false</code> 来选择停用：</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">properties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kotlin.compiler.daemon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;false&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kotlin.compiler.daemon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">properties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Kotlin 2.2.20-Beta2 还引入了一个新的 <code>jvmArgs</code> 属性，您可以使用它来自定义 Kotlin daemon 的默认 JVM 实参。例如，要覆盖 <code>-Xmx</code> 和 <code>-Xms</code> 选项，请将以下内容添加到您的 <code>pom.xml</code> 文件中：</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">properties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kotlin.compiler.daemon.jvmArgs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Xmx1500m,Xms500m&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kotlin.compiler.daemon.jvmArgs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">properties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div>`,34)),n(a,{id:"标准库-支持通过反射在-kotlin-js-中识别接口类型",level:"2",title:"标准库：支持通过反射在 Kotlin/JS 中识别接口类型",labelRef:"experimental-opt-in"}),s[6]||(s[6]=i(`<p>Kotlin 2.2.20-Beta2 向 Kotlin/JS 标准库添加了实验性的 <code>KClass.isInterface</code> 属性。</p><p>使用此属性，您现在可以检测类引用是否表示 Kotlin 接口。这使 Kotlin/JS 更接近与 Kotlin/JVM 的对等状态，在 Kotlin/JVM 中，您可以使用 <code>KClass.java.isInterface</code> 来检测类是否表示接口。</p><p>要选择启用，请使用 <code>@OptIn(ExperimentalStdlibApi::class)</code> 注解：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalStdlibApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inspect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(klass: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;*&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Prints true for interfaces</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(klass.isInterface)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我们非常感谢您在我们的问题跟踪器 <a href="https://youtrack.jetbrains.com/issue/KT-78581" target="_blank" rel="noreferrer">YouTrack</a> 中提供反馈。</p>`,5))])}const v=e(r,[["render",o]]);export{b as __pageData,v as default};
