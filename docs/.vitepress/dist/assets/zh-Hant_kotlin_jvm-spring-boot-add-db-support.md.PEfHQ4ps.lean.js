import{_ as g}from"./chunks/icon-1-done.ZX9lW-aj.js";import{_ as o}from"./chunks/icon-2-done.DCMUaFG5.js";import{_ as y}from"./chunks/icon-3.BwKvTetO.js";import{_ as F}from"./chunks/icon-4-todo.GaeEmerm.js";import{_ as c,a as u,b as C,c as B}from"./chunks/retrieve-message-by-its-id.Bu3w1K2P.js";import{_ as m,C as k,c as A,o as D,j as s,G as n,ag as p,a,w as l}from"./chunks/framework.Bksy39di.js";const j=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/jvm-spring-boot-add-db-support.md","filePath":"zh-Hant/kotlin/jvm-spring-boot-add-db-support.md","lastUpdated":1754307826000}'),b={name:"zh-Hant/kotlin/jvm-spring-boot-add-db-support.md"};function v(q,i,f,M,S,T){const r=k("web-summary"),d=k("tldr"),h=k("code-block"),t=k("def"),e=k("deflist"),E=k("list");return D(),A("div",null,[i[31]||(i[31]=s("h1",{id:"新增資料庫支援到-spring-boot-專案",tabindex:"-1"},[a("新增資料庫支援到 Spring Boot 專案 "),s("a",{class:"header-anchor",href:"#新增資料庫支援到-spring-boot-專案","aria-label":'Permalink to "新增資料庫支援到 Spring Boot 專案"'},"​")],-1)),n(r,null,{default:l(()=>i[0]||(i[0]=[a("為以 Kotlin 編寫的 Sprint Boot 專案新增資料庫支援，使用 JDBC 模板。")])),_:1}),n(d,null,{default:l(()=>i[1]||(i[1]=[s("p",null,[a("這是「"),s("strong",null,"Spring Boot 與 Kotlin 入門"),a("」教學的第三部分。在繼續之前，請確保您已完成先前的步驟：")],-1),s("br",null,null,-1),s("p",null,[s("img",{src:g,width:"20",alt:"First step"}),a(),s("a",{href:"/zh-Hant/kotlin/jvm-create-project-with-spring-boot"},"使用 Kotlin 建立 Spring Boot 專案"),s("br"),s("img",{src:o,width:"20",alt:"Second step"}),a(),s("a",{href:"/zh-Hant/kotlin/jvm-spring-boot-add-data-class"},"將資料類別新增至 Spring Boot 專案"),s("br"),s("img",{src:y,width:"20",alt:"Third step"}),a(),s("strong",null,"為 Spring Boot 專案新增資料庫支援"),s("br"),s("img",{src:F,width:"20",alt:"Fourth step"}),a(" 使用 Spring Data CrudRepository 進行資料庫存取")],-1)])),_:1}),i[32]||(i[32]=p("",5)),n(e,{collapsible:"true"},{default:l(()=>[n(t,{title:"建構子引數與依賴注入 – (private val db: JdbcTemplate)"},{default:l(()=>[i[3]||(i[3]=s("p",null,[a("Kotlin 中的類別有一個主建構子。它也可以有一個或多個 "),s("a",{href:"/zh-Hant/kotlin/classes#secondary-constructors"},"次級建構子"),a("。 "),s("em",null,"主建構子"),a(" 是類別標頭的一部分，位於類別名稱和可選的型別參數之後。在我們的例子中，建構子是 "),s("code",null,"(val db: JdbcTemplate)"),a("。")],-1)),i[4]||(i[4]=s("p",null,[s("code",null,"val db: JdbcTemplate"),a(" 是建構子的引數：")],-1)),n(h,{lang:"kotlin"},{default:l(()=>i[2]||(i[2]=[a(" @Service class MessageService(private val db: JdbcTemplate) ")])),_:1})]),_:1}),n(t,{title:"尾隨 Lambda 和 SAM 轉換"},{default:l(()=>[i[8]||(i[8]=s("p",null,[s("code",null,"findMessages()"),a(" 函數呼叫 "),s("code",null,"JdbcTemplate"),a(" 類別的 "),s("code",null,"query()"),a(" 函數。"),s("code",null,"query()"),a(" 函數接受兩個引數：一個作為 String 實例的 SQL 查詢，以及一個將每一列映射為一個物件的回呼：")],-1)),n(h,{lang:"sql"},{default:l(()=>i[5]||(i[5]=[a(' db.query("...", RowMapper { ... } ) ')])),_:1}),i[9]||(i[9]=s("br",null,null,-1)),i[10]||(i[10]=s("p",null,[s("code",null,"RowMapper"),a(" 介面只宣告了一個方法，因此可以透過省略介面名稱的 Lambda 表達式來實作它。Kotlin 編譯器知道 Lambda 表達式需要轉換成的介面，因為您將它作為函數呼叫的參數。這在 Kotlin 中被稱為 "),s("a",{href:"/zh-Hant/kotlin/java-interop#sam-conversions"},"SAM 轉換"),a("：")],-1)),n(h,{lang:"sql"},{default:l(()=>i[6]||(i[6]=[a(' db.query("...", { ... } ) ')])),_:1}),i[11]||(i[11]=s("br",null,null,-1)),i[12]||(i[12]=s("p",null,[a("在 SAM 轉換之後，查詢函數最終有兩個引數：第一個位置是一個 String，最後一個位置是一個 Lambda 表達式。根據 Kotlin 慣例，如果函數的最後一個參數是一個函數，那麼作為相應引數傳遞的 Lambda 表達式可以放在圓括號之外。這種語法也被稱為 "),s("a",{href:"/zh-Hant/kotlin/lambdas#passing-trailing-lambdas"},"尾隨 Lambda"),a("：")],-1)),n(h,{lang:"sql"},{default:l(()=>i[7]||(i[7]=[a(' db.query("...") { ... } ')])),_:1})]),_:1}),n(t,{title:"未使用 Lambda 引數的底線"},{default:l(()=>[i[14]||(i[14]=s("p",null,[a("對於具有多個參數的 Lambda，您可以使用底線 "),s("code",null,"_"),a(" 字元來替換您未使用的參數名稱。")],-1)),i[15]||(i[15]=s("p",null,"因此，查詢函數呼叫的最終語法看起來像這樣：",-1)),n(h,{lang:"kotlin"},{default:l(()=>i[13]||(i[13]=[a(' db.query("select * from messages") { response, _ -> Message(response.getString("id"), response.getString("text")) } ')])),_:1})]),_:1})]),_:1}),i[33]||(i[33]=p("",3)),n(e,{collapsible:"true"},{default:l(()=>[n(t,{title:"@PostMapping 註解"},{default:l(()=>i[16]||(i[16]=[s("p",null,[a("負責處理 HTTP POST 請求的方法需要使用 "),s("code",null,"@PostMapping"),a(" 註解進行標記。為了能夠將作為 HTTP Body 內容傳送的 JSON 轉換為物件，您需要對方法引數使用 "),s("code",null,"@RequestBody"),a(" 註解。由於應用程式的 classpath 中有 Jackson 函式庫，轉換會自動發生。")],-1)])),_:1}),n(t,{title:"ResponseEntity"},{default:l(()=>i[17]||(i[17]=[s("p",null,[s("code",null,"ResponseEntity"),a(" 代表整個 HTTP 回應：狀態碼、標頭和主體。")],-1),s("p",null,[a(" 使用 "),s("code",null,"created()"),a(" 方法可以配置回應狀態碼 (201) 並設定 location 標頭，指示所建立資源的上下文路徑。")],-1)])),_:1})]),_:1}),i[34]||(i[34]=p("",6)),n(e,{collapsible:"true"},{default:l(()=>[n(t,{title:"Elvis 運算子 – ?:"},{default:l(()=>i[18]||(i[18]=[s("p",null,[a("程式碼 "),s("code",null,"message.id ?: UUID.randomUUID().toString()"),a(" 使用了 "),s("a",{href:"/zh-Hant/kotlin/null-safety#elvis-operator"},[a("Elvis 運算子（非空即取捷徑）"),s("code",null,"?:")]),a("。如果 "),s("code",null,"?:"),a(" 左側的表達式不為 "),s("code",null,"null"),a("，Elvis 運算子會傳回它；否則，它會傳回右側的表達式。請注意，只有在左側為 "),s("code",null,"null"),a(" 時，右側的表達式才會被評估。")],-1)])),_:1})]),_:1}),i[35]||(i[35]=p("",7)),i[36]||(i[36]=s("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"執行請求的替代方法",tabindex:"-1"},[a("執行請求的替代方法 "),s("a",{class:"header-anchor",href:"#執行請求的替代方法","aria-label":'Permalink to "執行請求的替代方法 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),i[37]||(i[37]=p("",4)),s("ol",null,[s("li",null,[i[23]||(i[23]=p("",2)),n(e,{collapsible:"true"},{default:l(()=>[n(t,{title:"參數列表中 vararg 引數的位置"},{default:l(()=>[i[20]||(i[20]=s("p",null,[s("code",null,"query()"),a(" 函數接受三個引數：")],-1)),n(E,null,{default:l(()=>i[19]||(i[19]=[s("li",null,"執行時需要參數的 SQL 查詢字串",-1),s("li",null,[s("code",null,"id"),a("，它是 String 型別的參數")],-1),s("li",null,[s("code",null,"RowMapper"),a(" 實例，它由 Lambda 表達式實作")],-1)])),_:1}),i[21]||(i[21]=s("p",null,[s("code",null,"query()"),a(" 函數的第二個參數被宣告為 "),s("em",null,"可變引數"),a(" ("),s("code",null,"vararg"),a(")。在 Kotlin 中，可變引數參數的位置不一定需要在參數列表的最後。")],-1))]),_:1}),n(t,{title:"singleOrNull() 函數"},{default:l(()=>i[22]||(i[22]=[s("p",null,[s("a",{href:"https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.collections/single-or-null.html"},[s("code",null,"singleOrNull()")]),a(" 函數返回單個元素，如果陣列為空或包含多個相同值的元素，則返回 "),s("code",null,"null"),a("。")],-1)])),_:1})]),_:1}),i[24]||(i[24]=s("div",{class:"danger custom-block"},[s("p",{class:"custom-block-title"},"WARNING"),s("p",null,[a("用於透過 ID 獲取訊息的 "),s("code",null,".query()"),a(" 函數是 Spring Framework 提供的 "),s("a",{href:"/zh-Hant/kotlin/extensions#extension-functions"},"Kotlin 擴充函數"),a("。它需要額外的匯入 "),s("code",null,"import org.springframework.jdbc.core.query"),a("，如上方程式碼所示。")])],-1))]),s("li",null,[i[30]||(i[30]=p("",2)),n(e,{collapsible:"true"},{default:l(()=>[n(t,{title:"從上下文路徑擷取值"},{default:l(()=>i[25]||(i[25]=[s("p",null,[a("訊息 "),s("code",null,"id"),a(" 由 Spring Framework 從上下文路徑中擷取，因為您使用 "),s("code",null,'@GetMapping("/{id}")'),a(" 註解了新函數。透過使用 "),s("code",null,"@PathVariable"),a(" 註解函數引數，您告訴框架將擷取到的值用作函數引數。新函數呼叫 "),s("code",null,"MessageService"),a(" 以透過其 ID 擷取個別訊息。")],-1)])),_:1}),n(t,{title:"具有可空接收者的擴充函數"},{default:l(()=>[i[27]||(i[27]=s("p",null,[a("擴充可以定義為可空接收者類型。如果接收者為 "),s("code",null,"null"),a("，則 "),s("code",null,"this"),a(" 也為 "),s("code",null,"null"),a("。因此，在定義具有可空接收者類型的擴充時，建議在函數主體內執行 "),s("code",null,"this == null"),a(" 檢查。")],-1)),i[28]||(i[28]=s("p",null,[a("您還可以使用空安全呼叫運算子 ("),s("code",null,"?."),a(") 來執行空檢查，如上方 "),s("code",null,"toResponseEntity()"),a(" 函數所示：")],-1)),n(h,{lang:"kotlin"},{default:l(()=>i[26]||(i[26]=[a(" this?.let { ResponseEntity.ok(it) } ")])),_:1})]),_:1}),n(t,{title:"ResponseEntity"},{default:l(()=>i[29]||(i[29]=[s("p",null,[s("code",null,"ResponseEntity"),a(" 代表 HTTP 回應，包括狀態碼、標頭和主體。它是一個泛型封裝器，允許您將自訂的 HTTP 回應傳送回用戶端，並對內容有更多的控制。")],-1)])),_:1})]),_:1})])]),i[38]||(i[38]=p("",11))])}const H=m(b,[["render",v]]);export{j as __pageData,H as default};
