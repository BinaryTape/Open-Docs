import{_ as o,C as i,c as s,o as n,j as a,G as r,ag as l,a as c}from"./chunks/framework.Bksy39di.js";const q=JSON.parse('{"title":"2.0.x에서 2.2.x로 마이그레이션","description":"","frontmatter":{},"headers":[],"relativePath":"ko/ktor/migration-to-22x.md","filePath":"ko/ktor/migration-to-22x.md","lastUpdated":1755457140000}'),d={name:"ko/ktor/migration-to-22x.md"};function h(p,e,u,k,g,m){const t=i("show-structure");return n(),s("div",null,[e[0]||(e[0]=a("h1",{id:"_2-0-x에서-2-2-x로-마이그레이션",tabindex:"-1"},[c("2.0.x에서 2.2.x로 마이그레이션 "),a("a",{class:"header-anchor",href:"#_2-0-x에서-2-2-x로-마이그레이션","aria-label":'Permalink to "2.0.x에서 2.2.x로 마이그레이션"'},"​")],-1)),r(t,{for:"chapter",depth:"2"}),e[1]||(e[1]=l(`<p>이 가이드는 Ktor 애플리케이션을 2.0.x 버전에서 2.2.x 버전으로 마이그레이션하는 방법을 설명합니다.</p><blockquote><p><code>WARNING</code> 사용 중단 수준으로 표시된 API는 3.0.0 릴리스까지 계속 작동합니다. 사용 중단 수준에 대한 자세한 내용은 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-deprecated/" target="_blank" rel="noreferrer">Deprecated</a>에서 확인할 수 있습니다.</p></blockquote><h2 id="server" tabindex="-1">Ktor 서버 <a class="header-anchor" href="#server" aria-label="Permalink to &quot;Ktor 서버 {id=&quot;server&quot;}&quot;">​</a></h2><h3 id="cookies" tabindex="-1">쿠키 <a class="header-anchor" href="#cookies" aria-label="Permalink to &quot;쿠키 {id=&quot;cookies&quot;}&quot;">​</a></h3><p>v2.2.0부터 응답 <a href="./server-responses#cookies">쿠키</a> 구성과 관련된 다음 API 멤버가 변경되었습니다:</p><ul><li><code>append</code> 함수에 전달되는 <code>maxAge</code> 매개변수 타입이 <code>Int</code>에서 <code>Long</code>으로 변경되었습니다.</li><li><code>appendExpired</code> 함수는 더 이상 사용되지 않습니다. 대신 <code>expires</code> 매개변수와 함께 <code>append</code> 함수를 사용하세요.</li></ul><h3 id="request-address-info" tabindex="-1">요청 주소 정보 <a class="header-anchor" href="#request-address-info" aria-label="Permalink to &quot;요청 주소 정보 {id=&quot;request-address-info&quot;}&quot;">​</a></h3><p>2.2.0 버전부터, 요청이 이루어진 호스트 이름/포트를 가져오는 데 사용되는 <code>RequestConnectionPoint.host</code> 및 <code>RequestConnectionPoint.port</code> 속성은 더 이상 사용되지 않습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> originHost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> call.request.origin.host</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> originPort </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> call.request.origin.port</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>대신 <code>RequestConnectionPoint.serverHost</code> 및 <code>RequestConnectionPoint.serverPort</code>를 사용하세요. 또한 요청이 수신된 호스트 이름/포트를 반환하는 <code>localHost</code>/<code>localPort</code> 속성도 추가했습니다. <a href="./server-forward-headers#original-request-information">원본 요청 정보</a>에서 자세히 알아볼 수 있습니다.</p><h3 id="merge-configs" tabindex="-1">구성 병합 <a class="header-anchor" href="#merge-configs" aria-label="Permalink to &quot;구성 병합 {id=&quot;merge-configs&quot;}&quot;">​</a></h3><p>v2.2.0 이전에는 <code>List&lt;ApplicationConfig&gt;.merge()</code> 함수가 애플리케이션 구성을 병합하는 데 사용됩니다. 두 구성이 동일한 키를 가질 경우, 결과 구성은 첫 번째 구성에서 값을 가져옵니다. 이번 릴리스에서는 이 동작을 개선하기 위해 다음 API가 도입되었습니다:</p><ul><li><code>public fun ApplicationConfig.withFallback(other: ApplicationConfig): ApplicationConfig</code>: 이 함수는 <code>merge()</code>와 동일하게 작동하며 첫 번째 구성에서 값을 가져옵니다.</li><li><code>public fun ApplicationConfig.mergeWith(other: ApplicationConfig): ApplicationConfig</code>: 결과 구성은 두 번째 구성에서 값을 가져옵니다.</li></ul><h2 id="client" tabindex="-1">Ktor 클라이언트 <a class="header-anchor" href="#client" aria-label="Permalink to &quot;Ktor 클라이언트 {id=&quot;client&quot;}&quot;">​</a></h2><h3 id="persistent-storage" tabindex="-1">캐싱: 영구 저장소 <a class="header-anchor" href="#persistent-storage" aria-label="Permalink to &quot;캐싱: 영구 저장소 {id=&quot;persistent-storage&quot;}&quot;">​</a></h3><p>v2.2.0부터 응답 <a href="./client-caching">캐싱</a>과 관련된 다음 API는 더 이상 사용되지 않습니다:</p><ul><li><code>HttpCacheStorage</code> 클래스는 <code>CacheStorage</code> 인터페이스로 대체되었으며, 이 인터페이스는 필요한 플랫폼을 위한 영구 저장소를 구현하는 데 사용될 수 있습니다.</li><li><code>publicStorage</code>/<code>privateStorage</code> 속성은 <code>CacheStorage</code> 인스턴스를 허용하는 해당 함수로 대체되었습니다.</li></ul><h3 id="custom-plugins" tabindex="-1">사용자 지정 플러그인 <a class="header-anchor" href="#custom-plugins" aria-label="Permalink to &quot;사용자 지정 플러그인 {id=&quot;custom-plugins&quot;}&quot;">​</a></h3><p>2.2.0 릴리스부터 Ktor는 사용자 지정 클라이언트 플러그인을 생성하기 위한 새로운 API를 제공합니다. 자세한 내용은 <a href="./client-custom-plugins">사용자 지정 클라이언트 플러그인</a>을 참조하세요.</p><h2 id="new-mm" tabindex="-1">새로운 메모리 모델 <a class="header-anchor" href="#new-mm" aria-label="Permalink to &quot;새로운 메모리 모델 {id=&quot;new-mm&quot;}&quot;">​</a></h2><p>v2.2.0부터 Ktor는 Kotlin 1.7.20 버전을 사용하며, 이 버전에서는 새로운 Kotlin/Native 메모리 모델이 <a href="https://kotlinlang.org/docs/whatsnew1720.html#the-new-kotlin-native-memory-manager-enabled-by-default" target="_blank" rel="noreferrer">기본적으로 활성화</a>됩니다. 이는 <a href="./server-native">네이티브 서버</a>나 <a href="./client-engines#native">Kotlin/Native</a>를 대상으로 하는 클라이언트 엔진에 대해 명시적으로 활성화할 필요가 없다는 것을 의미합니다.</p>`,21))])}const b=o(d,[["render",h]]);export{q as __pageData,b as default};
