import{_ as k,a as r,b as d,c as E,d as o,e as g,f as c,g as y,h as F,i as u,j as C,k as b,l as B,m as D,n as A,o as v,p as m,q,r as f,s as _}from"./chunks/time-comparison.B6DZdO43.js";import{_ as T,C as e,c as x,o as R,ag as n,j as i,G as l,a,w as t}from"./chunks/framework.Bksy39di.js";const V=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/coroutines-and-channels.md","filePath":"ko/kotlin/coroutines-and-channels.md","lastUpdated":1754307826000}'),S={name:"ko/kotlin/coroutines-and-channels.md"};function P(I,s,U,w,L,N){const p=e("def"),h=e("deflist");return R(),x("div",null,[s[4]||(s[4]=n('<h1 id="코루틴과-채널-−-튜토리얼" tabindex="-1">코루틴과 채널 − 튜토리얼 <a class="header-anchor" href="#코루틴과-채널-−-튜토리얼" aria-label="Permalink to &quot;코루틴과 채널 − 튜토리얼&quot;">​</a></h1><p>이 튜토리얼에서는 IntelliJ IDEA에서 코루틴을 사용하여 기본 스레드나 콜백을 차단하지 않고 네트워크 요청을 수행하는 방법을 배웁니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>코루틴에 대한 사전 지식은 필수가 아니지만, 기본적인 Kotlin 문법에 익숙해야 합니다.</p></div><p>다음 내용을 배울 것입니다:</p><ul><li>네트워크 요청을 수행하기 위해 중단 함수(suspending function)를 사용해야 하는 이유와 방법.</li><li>코루틴을 사용하여 요청을 동시적으로 보내는 방법.</li><li>채널을 사용하여 다른 코루틴 간에 정보를 공유하는 방법.</li></ul><p>네트워크 요청에는 <a href="https://square.github.io/retrofit/" target="_blank" rel="noreferrer">Retrofit</a> 라이브러리가 필요하지만, 이 튜토리얼에서 보여주는 접근 방식은 코루틴을 지원하는 다른 모든 라이브러리에도 유사하게 작동합니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>모든 작업의 솔루션은 <a href="http://github.com/kotlin-hands-on/intro-coroutines" target="_blank" rel="noreferrer">프로젝트 저장소</a>의 <code>solutions</code> 브랜치에서 찾을 수 있습니다.</p></div><h2 id="시작하기-전에" tabindex="-1">시작하기 전에 <a class="header-anchor" href="#시작하기-전에" aria-label="Permalink to &quot;시작하기 전에&quot;">​</a></h2><ol><li><p>최신 버전의 <a href="https://www.jetbrains.com/idea/download/index.html" target="_blank" rel="noreferrer">IntelliJ IDEA</a>를 다운로드하여 설치합니다.</p></li><li><p>환영 화면에서 <strong>Get from VCS</strong>를 선택하거나 <strong>File | New | Project from Version Control</strong>을 선택하여 <a href="http://github.com/kotlin-hands-on/intro-coroutines" target="_blank" rel="noreferrer">프로젝트 템플릿</a>을 복제합니다.</p><p>명령줄에서도 복제할 수 있습니다:</p><div class="language-Bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clone</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://github.com/kotlin-hands-on/intro-coroutines</span></span></code></pre></div></li></ol><h3 id="github-개발자-토큰-생성" tabindex="-1">GitHub 개발자 토큰 생성 <a class="header-anchor" href="#github-개발자-토큰-생성" aria-label="Permalink to &quot;GitHub 개발자 토큰 생성&quot;">​</a></h3><p>프로젝트에서 GitHub API를 사용할 것입니다. 접근하려면 GitHub 계정 이름과 암호 또는 토큰을 제공해야 합니다. 2단계 인증이 활성화되어 있다면 토큰만으로 충분합니다.</p><p><a href="https://github.com/settings/tokens/new" target="_blank" rel="noreferrer">귀하의 계정</a>에서 GitHub API를 사용할 새 GitHub 토큰을 생성하십시오:</p><ol><li><p>토큰의 이름을 지정합니다 (예: <code>coroutines-tutorial</code>):</p><p><img src="'+o+'" alt="새 GitHub 토큰 생성" width="700"></p></li><li><p>어떤 스코프도 선택하지 마십시오. 페이지 하단의 <strong>Generate token</strong>을 클릭합니다.</p></li><li><p>생성된 토큰을 복사합니다.</p></li></ol><h3 id="코드-실행" tabindex="-1">코드 실행 <a class="header-anchor" href="#코드-실행" aria-label="Permalink to &quot;코드 실행&quot;">​</a></h3><p>이 프로그램은 주어진 조직(기본적으로 &quot;kotlin&quot;) 아래의 모든 저장소에 대한 기여자를 로드합니다. 나중에 기여 수를 기준으로 사용자를 정렬하는 로직을 추가할 것입니다.</p><ol><li><p><code>src/contributors/main.kt</code> 파일을 열고 <code>main()</code> 함수를 실행합니다. 다음 창이 나타날 것입니다:</p><p><img src="'+g+`" alt="첫 번째 창" width="500"></p><p>글꼴이 너무 작으면 <code>main()</code> 함수의 <code>setDefaultFontSize(18f)</code> 값을 변경하여 조정하십시오.</p></li><li><p>해당 필드에 GitHub 사용자 이름과 토큰(또는 암호)을 제공합니다.</p></li><li><p><em>Variant</em> 드롭다운 메뉴에서 <em>BLOCKING</em> 옵션이 선택되어 있는지 확인합니다.</p></li><li><p>_Load contributors_를 클릭합니다. UI가 잠시 멈춘 다음 기여자 목록이 표시될 것입니다.</p></li><li><p>데이터가 로드되었는지 확인하기 위해 프로그램 출력을 엽니다. 기여자 목록은 각 성공적인 요청 후에 로깅됩니다.</p></li></ol><p>이 로직을 구현하는 여러 가지 방법이 있습니다: <a href="#blocking-requests">블로킹 요청</a> 또는 <a href="#callbacks">콜백</a>을 사용하는 것입니다. 이러한 솔루션을 <a href="#coroutines">코루틴</a>을 사용하는 솔루션과 비교하고, <a href="#channels">채널</a>을 사용하여 여러 코루틴 간에 정보를 공유하는 방법을 살펴볼 것입니다.</p><h2 id="블로킹-요청" tabindex="-1">블로킹 요청 <a class="header-anchor" href="#블로킹-요청" aria-label="Permalink to &quot;블로킹 요청&quot;">​</a></h2><p><a href="https://square.github.io/retrofit/" target="_blank" rel="noreferrer">Retrofit</a> 라이브러리를 사용하여 GitHub에 HTTP 요청을 수행할 것입니다. 이 라이브러리를 사용하면 주어진 조직 아래의 저장소 목록과 각 저장소에 대한 기여자 목록을 요청할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;orgs/{org}/repos?per_page=100&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getOrgReposCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) org: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Repo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;repos/{owner}/{repo}/contributors?per_page=100&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getRepoContributorsCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;owner&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) owner: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;repo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) repo: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 API는 <code>loadContributorsBlocking()</code> 함수에서 주어진 조직에 대한 기여자 목록을 가져오는 데 사용됩니다.</p><ol><li><p><code>src/tasks/Request1Blocking.kt</code>를 열어 구현을 확인합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> service</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrgReposCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org)   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req, it) } </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() ?: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emptyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #4</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">flatMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        service</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributorsCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                                   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, it) }                 </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                                  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>먼저 주어진 조직 아래의 저장소 목록을 가져와 <code>repos</code> 목록에 저장합니다. 그런 다음 각 저장소에 대한 기여자 목록을 요청하고, 모든 목록을 하나의 최종 기여자 목록으로 병합합니다.</li><li><code>getOrgReposCall()</code> 및 <code>getRepoContributorsCall()</code>은 모두 <code>*Call</code> 클래스의 인스턴스를 반환합니다(<code> #1</code>). 이 시점에서는 어떤 요청도 보내지지 않습니다.</li><li><code>*Call.execute()</code>가 호출되어 요청을 수행합니다(<code> #2</code>). <code>execute()</code>는 기본 스레드를 블로킹하는 동기 호출입니다.</li><li>응답을 받으면 특정 <code>logRepos()</code> 및 <code>logUsers()</code> 함수를 호출하여 결과를 로깅합니다(<code> #3</code>). HTTP 응답에 오류가 포함되어 있으면 해당 오류가 여기에 로깅됩니다.</li><li>마지막으로 필요한 데이터가 포함된 응답의 본문을 가져옵니다. 이 튜토리얼에서는 오류가 발생한 경우 빈 목록을 결과로 사용하고 해당 오류를 로깅합니다(<code> #4</code>).</li></ul></li><li><p><code>.body() ?: emptyList()</code>의 반복을 피하기 위해 확장 함수 <code>bodyList()</code>가 선언됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() ?: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emptyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>프로그램을 다시 실행하고 IntelliJ IDEA의 시스템 출력을 살펴보십시오. 다음과 유사한 내용이 표시되어야 합니다:</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1770 [AWT-EventQueue-0] INFO  Contributors - kotlin: loaded 40 repos</span></span>
<span class="line"><span>2025 [AWT-EventQueue-0] INFO  Contributors - kotlin-examples: loaded 23 contributors</span></span>
<span class="line"><span>2229 [AWT-EventQueue-0] INFO  Contributors - kotlin-koans: loaded 45 contributors</span></span>
<span class="line"><span>...</span></span></code></pre></div><ul><li>각 줄의 첫 번째 항목은 프로그램 시작 이후 경과한 밀리초 수이고, 그 다음은 대괄호 안의 스레드 이름입니다. 로딩 요청이 어느 스레드에서 호출되었는지 확인할 수 있습니다.</li><li>각 줄의 마지막 항목은 실제 메시지입니다: 로드된 저장소 또는 기여자의 수.</li></ul><p>이 로그 출력은 모든 결과가 메인 스레드에서 로깅되었음을 보여줍니다. <em>BLOCKING</em> 옵션으로 코드를 실행하면 로딩이 완료될 때까지 창이 멈추고 입력에 반응하지 않습니다. 모든 요청은 <code>loadContributorsBlocking()</code>이 호출된 스레드와 동일한 스레드(Swing에서는 AWT 이벤트 디스패칭 스레드)에서 실행됩니다. 이 메인 스레드가 블로킹되어 UI가 멈추게 됩니다:</p><p><img src="`+c+`" alt="블로킹된 메인 스레드" width="700"></p><p>기여자 목록이 로드되면 결과가 업데이트됩니다.</p></li><li><p><code>src/contributors/Contributors.kt</code>에서 기여자가 로드되는 방식을 선택하는 <code>loadContributors()</code> 함수를 찾아 <code>loadContributorsBlocking()</code>이 어떻게 호출되는지 확인합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getSelectedVariant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    BLOCKING </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Blocking UI thread</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service, req)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users, startTime)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>updateResults()</code> 호출은 <code>loadContributorsBlocking()</code> 호출 바로 다음에 옵니다.</li><li><code>updateResults()</code>는 UI를 업데이트하므로 항상 UI 스레드에서 호출되어야 합니다.</li><li><code>loadContributorsBlocking()</code>도 UI 스레드에서 호출되므로 UI 스레드가 블로킹되고 UI가 멈춥니다.</li></ul></li></ol><h3 id="작업-1" tabindex="-1">작업 1 <a class="header-anchor" href="#작업-1" aria-label="Permalink to &quot;작업 1&quot;">​</a></h3><p>첫 번째 작업은 작업 도메인에 익숙해지는 데 도움이 됩니다. 현재 각 기여자의 이름이 참여한 모든 프로젝트에 대해 한 번씩 여러 번 반복됩니다. 각 기여자가 한 번만 추가되도록 사용자를 결합하는 <code>aggregate()</code> 함수를 구현하십시오. <code>User.contributions</code> 속성은 주어진 사용자가 <em>모든</em> 프로젝트에 기여한 총 수를 포함해야 합니다. 결과 목록은 기여 수에 따라 내림차순으로 정렬되어야 합니다.</p><p><code>src/tasks/Aggregation.kt</code>를 열고 <code>List&lt;User&gt;.aggregate()</code> 함수를 구현하십시오. 사용자는 총 기여 수에 따라 정렬되어야 합니다.</p><p>해당 테스트 파일 <code>test/tasks/AggregationKtTest.kt</code>는 예상 결과의 예를 보여줍니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><a href="https://www.jetbrains.com/help/idea/create-tests.html#test-code-navigation" target="_blank" rel="noreferrer">IntelliJ IDEA 단축키</a> <code>Ctrl+Shift+T</code> / <code>⇧ ⌘ T</code>를 사용하여 소스 코드와 테스트 클래스 사이를 자동으로 이동할 수 있습니다.</p></div><p>이 작업을 구현한 후 &quot;kotlin&quot; 조직의 결과 목록은 다음과 유사해야 합니다:</p><p><img src="`+y+'" alt="kotlin 조직 목록" width="500"></p>',29)),s[5]||(s[5]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"작업-1-솔루션",tabindex:"-1"},[a("작업 1 솔루션 "),i("a",{class:"header-anchor",href:"#작업-1-솔루션","aria-label":'Permalink to "작업 1 솔루션 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[6]||(s[6]=n(`<ol><li><p>사용자를 로그인별로 그룹화하려면 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/group-by.html" target="_blank" rel="noreferrer"><code>groupBy()</code></a>를 사용하십시오. 이 함수는 로그인을 키로, 이 로그인으로 여러 저장소에 나타나는 모든 사용자 인스턴스를 값으로 하는 맵을 반환합니다.</p></li><li><p>각 맵 항목에 대해 각 사용자의 총 기여 수를 계산하고, 주어진 이름과 총 기여 수로 <code>User</code> 클래스의 새 인스턴스를 생성합니다.</p></li><li><p>결과 목록을 내림차순으로 정렬합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">User</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    groupBy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.login }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { (login, group) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(login, group.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sumOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.contributions }) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sortedByDescending</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.contributions }</span></span></code></pre></div></li></ol><p>대안 솔루션은 <code>groupBy()</code> 대신 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/grouping-by.html" target="_blank" rel="noreferrer"><code>groupingBy()</code></a> 함수를 사용하는 것입니다.</p><h2 id="콜백" tabindex="-1">콜백 <a class="header-anchor" href="#콜백" aria-label="Permalink to &quot;콜백&quot;">​</a></h2><p>이전 솔루션은 작동하지만, 스레드를 블로킹하여 UI를 멈추게 합니다. 이를 피하는 전통적인 접근 방식은 _콜백_을 사용하는 것입니다.</p><p>작업 완료 직후 호출되어야 하는 코드를 직접 호출하는 대신, 이를 별도의 콜백(종종 람다)으로 추출하여 호출자에게 전달하여 나중에 호출되도록 할 수 있습니다.</p><p>UI를 반응형으로 만들려면 전체 연산을 별도의 스레드로 옮기거나, 블로킹 호출 대신 콜백을 사용하는 Retrofit API로 전환할 수 있습니다.</p><h3 id="백그라운드-스레드-사용" tabindex="-1">백그라운드 스레드 사용 <a class="header-anchor" href="#백그라운드-스레드-사용" aria-label="Permalink to &quot;백그라운드 스레드 사용&quot;">​</a></h3><ol><li><p><code>src/tasks/Request2Background.kt</code>를 열어 구현을 확인합니다. 먼저 전체 연산을 다른 스레드로 옮깁니다. <code>thread()</code> 함수는 새 스레드를 시작합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    loadContributorsBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service, req)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이제 모든 로딩이 별도의 스레드로 옮겨졌으므로 메인 스레드는 자유로워 다른 작업을 수행할 수 있습니다:</p><p><img src="`+F+`" alt="자유로워진 메인 스레드" width="700"></p></li><li><p><code>loadContributorsBackground()</code> 함수의 시그니처가 변경됩니다. 모든 로딩이 완료된 후 호출할 <code>updateResults()</code> 콜백을 마지막 인수로 받습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsBackground</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    updateResults: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div></li><li><p>이제 <code>loadContributorsBackground()</code>가 호출되면 <code>updateResults()</code> 호출은 이전처럼 즉시 뒤따라오는 것이 아니라 콜백에서 발생합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loadContributorsBackground</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service, req) { users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SwingUtilities.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invokeLater</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users, startTime)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>SwingUtilities.invokeLater</code>를 호출함으로써 결과를 업데이트하는 <code>updateResults()</code> 호출이 메인 UI 스레드(AWT 이벤트 디스패칭 스레드)에서 발생하도록 보장합니다.</p></li></ol><p>그러나 <code>BACKGROUND</code> 옵션을 통해 기여자를 로드하려고 하면 목록은 업데이트되지만 아무것도 변경되지 않는 것을 볼 수 있습니다.</p><h3 id="작업-2" tabindex="-1">작업 2 <a class="header-anchor" href="#작업-2" aria-label="Permalink to &quot;작업 2&quot;">​</a></h3><p>결과 목록이 UI에 표시되도록 <code>src/tasks/Request2Background.kt</code> 파일의 <code>loadContributorsBackground()</code> 함수를 수정하십시오.</p>`,11)),s[7]||(s[7]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"작업-2-솔루션",tabindex:"-1"},[a("작업 2 솔루션 "),i("a",{class:"header-anchor",href:"#작업-2-솔루션","aria-label":'Permalink to "작업 2 솔루션 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[8]||(s[8]=n(`<p>기여자를 로드하려고 하면 로그에서 기여자가 로드되지만 결과가 표시되지 않는 것을 볼 수 있습니다. 이를 수정하려면 결과 사용자 목록에 대해 <code>updateResults()</code>를 호출하십시오:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loadContributorsBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service, req))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>콜백으로 전달된 로직을 명시적으로 호출해야 합니다. 그렇지 않으면 아무 일도 일어나지 않습니다.</p><h3 id="retrofit-콜백-api-사용" tabindex="-1">Retrofit 콜백 API 사용 <a class="header-anchor" href="#retrofit-콜백-api-사용" aria-label="Permalink to &quot;Retrofit 콜백 API 사용&quot;">​</a></h3><p>이전 솔루션에서 전체 로딩 로직은 백그라운드 스레드로 옮겨졌지만, 여전히 리소스 사용에 최선은 아닙니다. 모든 로딩 요청은 순차적으로 진행되며 스레드는 로딩 결과를 기다리는 동안 블로킹되어 다른 작업에 사용될 수 있는 기회를 잃습니다. 특히, 스레드는 전체 결과를 더 빨리 받기 위해 다른 요청을 로드하기 시작할 수 있습니다.</p><p>각 저장소에 대한 데이터 처리는 두 부분으로 나뉘어져야 합니다: 로딩 및 결과 응답 처리. 두 번째 <em>처리</em> 부분은 콜백으로 추출되어야 합니다.</p><p>각 저장소에 대한 로딩은 이전 저장소의 결과가 수신되기 전(그리고 해당 콜백이 호출되기 전)에 시작될 수 있습니다:</p><p><img src="`+u+`" alt="콜백 API 사용" width="700"></p><p>Retrofit 콜백 API는 이를 달성하는 데 도움이 될 수 있습니다. <code>Call.enqueue()</code> 함수는 HTTP 요청을 시작하고 인수로 콜백을 받습니다. 이 콜백에서 각 요청 후에 무엇을 해야 할지 지정해야 합니다.</p><p><code>src/tasks/Request3Callbacks.kt</code>를 열어 이 API를 사용하는 <code>loadContributorsCallbacks()</code>의 구현을 확인합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsCallbacks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    updateResults: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrgReposCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { responseRepos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // #1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        logRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req, responseRepos)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> responseRepos.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mutableListOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributorsCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { responseUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // #2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, responseUsers)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> responseUsers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // TODO: Why doesn&#39;t this code work? How to fix that?</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allUsers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><ul><li>편의를 위해 이 코드 조각은 같은 파일에 선언된 <code>onResponse()</code> 확장 함수를 사용합니다. 이 함수는 객체 표현식 대신 람다를 인수로 받습니다.</li><li>응답을 처리하는 로직은 콜백으로 추출됩니다: 해당 람다는 <code>#1</code> 및 <code>#2</code> 줄에서 시작됩니다.</li></ul><p>그러나 제공된 솔루션은 작동하지 않습니다. 프로그램을 실행하고 <em>CALLBACKS</em> 옵션을 선택하여 기여자를 로드하면 아무것도 표시되지 않는 것을 볼 수 있습니다. 그러나 <code>Request3CallbacksKtTest</code>의 테스트는 성공적으로 통과했음을 즉시 반환합니다.</p><p>주어진 코드가 예상대로 작동하지 않는 이유를 생각해 보고 수정하거나, 아래 솔루션을 참조하십시오.</p><h3 id="작업-3-선택-사항" tabindex="-1">작업 3 (선택 사항) <a class="header-anchor" href="#작업-3-선택-사항" aria-label="Permalink to &quot;작업 3 (선택 사항)&quot;">​</a></h3><p><code>src/tasks/Request3Callbacks.kt</code> 파일의 코드를 다시 작성하여 로드된 기여자 목록이 표시되도록 하십시오.</p>`,16)),s[9]||(s[9]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"작업-3의-첫-번째-시도-솔루션",tabindex:"-1"},[a("작업 3의 첫 번째 시도 솔루션 "),i("a",{class:"header-anchor",href:"#작업-3의-첫-번째-시도-솔루션","aria-label":'Permalink to "작업 3의 첫 번째 시도 솔루션 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[10]||(s[10]=n(`<p>현재 솔루션에서는 많은 요청이 동시적으로 시작되어 총 로딩 시간이 줄어듭니다. 그러나 결과가 로드되지 않습니다. 이는 <code>updateResults()</code> 콜백이 모든 로딩 요청이 시작된 직후에 호출되기 때문입니다. 즉, <code>allUsers</code> 목록이 데이터로 채워지기 전에 호출됩니다.</p><p>다음과 같은 변경으로 이를 수정할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mutableListOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((index, repo) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withIndex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributorsCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { responseUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, responseUsers)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> responseUsers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.lastIndex) {    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allUsers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>먼저 인덱스와 함께 저장소 목록을 반복합니다(<code> #1</code>).</li><li>그런 다음 각 콜백에서 마지막 반복인지 확인합니다(<code> #2</code>).</li><li>그리고 그렇다면 결과가 업데이트됩니다.</li></ul><p>그러나 이 코드도 우리의 목표를 달성하지 못합니다. 직접 답을 찾거나, 아래 솔루션을 참조하십시오.</p>`,5)),s[11]||(s[11]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"작업-3의-두-번째-시도-솔루션",tabindex:"-1"},[a("작업 3의 두 번째 시도 솔루션 "),i("a",{class:"header-anchor",href:"#작업-3의-두-번째-시도-솔루션","aria-label":'Permalink to "작업 3의 두 번째 시도 솔루션 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[12]||(s[12]=n(`<p>로딩 요청이 동시적으로 시작되므로 마지막 요청의 결과가 마지막으로 온다는 보장은 없습니다. 결과는 어떤 순서로든 올 수 있습니다.</p><p>따라서 완료 조건으로 현재 인덱스를 <code>lastIndex</code>와 비교하면 일부 저장소에 대한 결과를 잃을 위험이 있습니다.</p><p>만약 마지막 저장소를 처리하는 요청이 이전 요청보다 더 빨리 반환된다면(그럴 가능성이 높음), 더 많은 시간이 걸리는 요청들의 모든 결과가 손실될 것입니다.</p><p>이를 수정하는 한 가지 방법은 인덱스를 도입하고 모든 저장소가 이미 처리되었는지 확인하는 것입니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Collections.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">synchronizedList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mutableListOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;())</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numberOfProcessed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AtomicInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributorsCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { responseUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, responseUsers)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> responseUsers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (numberOfProcessed.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">incrementAndGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.size) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allUsers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 코드는 동기화된 버전의 목록과 <code>AtomicInteger()</code>를 사용합니다. 왜냐하면 일반적으로 <code>getRepoContributors()</code> 요청을 처리하는 다른 콜백이 항상 동일한 스레드에서 호출된다는 보장이 없기 때문입니다.</p>`,6)),s[13]||(s[13]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"작업-3의-세-번째-시도-솔루션",tabindex:"-1"},[a("작업 3의 세 번째 시도 솔루션 "),i("a",{class:"header-anchor",href:"#작업-3의-세-번째-시도-솔루션","aria-label":'Permalink to "작업 3의 세 번째 시도 솔루션 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[14]||(s[14]=n(`<p>더 나은 솔루션은 <code>CountDownLatch</code> 클래스를 사용하는 것입니다. 이 클래스는 저장소 수로 초기화된 카운터를 저장합니다. 이 카운터는 각 저장소를 처리한 후 감소합니다. 그런 다음 래치가 0이 될 때까지 기다린 다음 결과를 업데이트합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> countDownLatch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CountDownLatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repos.size)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributorsCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { responseUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // processing repository</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            countDownLatch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">countDown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">countDownLatch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allUsers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>결과는 메인 스레드에서 업데이트됩니다. 이는 로직을 자식 스레드에 위임하는 것보다 더 직접적인 방법입니다.</p><p>이 세 가지 솔루션 시도를 검토한 결과, 콜백으로 올바른 코드를 작성하는 것은 특히 여러 기본 스레드와 동기화가 발생할 때 사소하지 않고 오류가 발생하기 쉽다는 것을 알 수 있습니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>추가 연습으로, RxJava 라이브러리를 사용하여 반응형 접근 방식으로 동일한 로직을 구현할 수 있습니다. 필요한 모든 종속성과 RxJava 사용을 위한 솔루션은 별도의 <code>rx</code> 브랜치에서 찾을 수 있습니다. 이 튜토리얼을 완료하고 제안된 Rx 버전을 구현하거나 확인하여 적절한 비교를 하는 것도 가능합니다.</p></div><h2 id="중단-함수" tabindex="-1">중단 함수 <a class="header-anchor" href="#중단-함수" aria-label="Permalink to &quot;중단 함수&quot;">​</a></h2><p>중단 함수(suspending function)를 사용하여 동일한 로직을 구현할 수 있습니다. <code>Call&lt;List&lt;Repo&gt;&gt;</code>를 반환하는 대신, 다음과 같이 API 호출을 <a href="/ko/kotlin/composing-suspending-functions">중단 함수</a>로 정의합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;orgs/{org}/repos?per_page=100&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getOrgRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) org: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Repo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>getOrgRepos()</code>는 <code>suspend</code> 함수로 정의됩니다. 중단 함수를 사용하여 요청을 수행할 때 기본 스레드는 블로킹되지 않습니다. 이것이 어떻게 작동하는지에 대한 자세한 내용은 나중에 다룰 것입니다.</li><li><code>getOrgRepos()</code>는 <code>Call</code>을 반환하는 대신 결과를 직접 반환합니다. 결과가 실패하면 예외가 발생합니다.</li></ul><p>대안으로, Retrofit은 결과를 <code>Response</code>로 래핑하여 반환할 수 있습니다. 이 경우, 결과 본문이 제공되며 수동으로 오류를 확인할 수 있습니다. 이 튜토리얼에서는 <code>Response</code>를 반환하는 버전을 사용합니다.</p><p><code>src/contributors/GitHubService.kt</code>에서 <code>GitHubService</code> 인터페이스에 다음 선언을 추가합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // getOrgReposCall &amp; getRepoContributorsCall declarations</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;orgs/{org}/repos?per_page=100&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getOrgRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) org: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Response</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Repo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;repos/{owner}/{repo}/contributors?per_page=100&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getRepoContributors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;owner&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) owner: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        @Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;repo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) repo: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Response</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="작업-4" tabindex="-1">작업 4 <a class="header-anchor" href="#작업-4" aria-label="Permalink to &quot;작업 4&quot;">​</a></h3><p>귀하의 임무는 기여자를 로드하는 함수의 코드를 변경하여 두 개의 새로운 중단 함수인 <code>getOrgRepos()</code>와 <code>getRepoContributors()</code>를 사용하도록 하는 것입니다. 새로운 <code>loadContributorsSuspend()</code> 함수는 새 API를 사용하기 위해 <code>suspend</code>로 표시됩니다.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>중단 함수는 모든 곳에서 호출될 수 없습니다. <code>loadContributorsBlocking()</code>에서 중단 함수를 호출하면 &quot;Suspend function &#39;getOrgRepos&#39; should be called only from a coroutine or another suspend function&quot; 메시지와 함께 오류가 발생할 것입니다.</p></div><ol><li><code>src/tasks/Request1Blocking.kt</code>에 정의된 <code>loadContributorsBlocking()</code>의 구현을 <code>src/tasks/Request4Suspend.kt</code>에 정의된 <code>loadContributorsSuspend()</code>로 복사합니다.</li><li><code>Call</code>을 반환하는 함수 대신 새로운 중단 함수가 사용되도록 코드를 수정합니다.</li><li><em>SUSPEND</em> 옵션을 선택하여 프로그램을 실행하고 GitHub 요청이 수행되는 동안 UI가 계속 반응하는지 확인합니다.</li></ol>`,16)),s[15]||(s[15]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"작업-4-솔루션",tabindex:"-1"},[a("작업 4 솔루션 "),i("a",{class:"header-anchor",href:"#작업-4-솔루션","aria-label":'Permalink to "작업 4 솔루션 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[16]||(s[16]=n(`<p><code>.getOrgReposCall(req.org).execute()</code>를 <code>.getOrgRepos(req.org)</code>로 바꾸고 두 번째 &quot;기여자&quot; 요청에 대해서도 동일한 교체를 반복합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsSuspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> service</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrgRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">flatMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>loadContributorsSuspend()</code>는 <code>suspend</code> 함수로 정의되어야 합니다.</li><li>이전에는 <code>Response</code>를 반환했던 <code>execute</code>를 더 이상 호출할 필요가 없습니다. 이제 API 함수가 <code>Response</code>를 직접 반환하기 때문입니다. 이 세부 사항은 Retrofit 라이브러리에만 해당됩니다. 다른 라이브러리에서는 API가 다르겠지만, 개념은 동일합니다.</li></ul><h2 id="코루틴" tabindex="-1">코루틴 <a class="header-anchor" href="#코루틴" aria-label="Permalink to &quot;코루틴&quot;">​</a></h2><p>중단 함수를 사용한 코드는 &quot;블로킹&quot; 버전과 유사하게 보입니다. 블로킹 버전과의 주요 차이점은 스레드를 블로킹하는 대신 코루틴이 중단된다는 것입니다:</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>block -&gt; suspend</span></span>
<span class="line"><span>thread -&gt; coroutine</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>코루틴은 종종 경량 스레드(lightweight thread)라고 불리는데, 이는 스레드에서 코드를 실행하는 방식과 유사하게 코루틴에서 코드를 실행할 수 있기 때문입니다. 이전에는 블로킹되어 피해야 했던 작업들이 이제 코루틴을 중단시킬 수 있습니다.</p></div><h3 id="새-코루틴-시작" tabindex="-1">새 코루틴 시작 <a class="header-anchor" href="#새-코루틴-시작" aria-label="Permalink to &quot;새 코루틴 시작&quot;">​</a></h3><p><code>src/contributors/Contributors.kt</code>에서 <code>loadContributorsSuspend()</code>가 어떻게 사용되는지 살펴보면, <code>launch</code> 내에서 호출되는 것을 볼 수 있습니다. <code>launch</code>는 람다를 인수로 받는 라이브러리 함수입니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsSuspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users, startTime)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>여기서 <code>launch</code>는 데이터를 로드하고 결과를 표시하는 역할을 하는 새로운 연산을 시작합니다. 이 연산은 중단 가능합니다. 네트워크 요청을 수행할 때 연산은 중단되고 기본 스레드를 해제합니다. 네트워크 요청이 결과를 반환하면 연산이 재개됩니다.</p><p>이러한 중단 가능한 연산을 _코루틴_이라고 합니다. 따라서 이 경우 <code>launch</code>는 데이터를 로드하고 결과를 표시하는 역할을 하는 _새 코루틴을 시작_합니다.</p><p>코루틴은 스레드 위에서 실행되며 중단될 수 있습니다. 코루틴이 중단되면 해당 연산은 일시 중지되고, 스레드에서 제거되어 메모리에 저장됩니다. 그동안 스레드는 다른 작업을 수행할 수 있도록 자유로워집니다:</p><p><img src="`+C+'" alt="코루틴 중단 프로세스" width="700"></p><p>연산이 계속될 준비가 되면 (반드시 같은 스레드는 아님) 스레드로 반환됩니다.</p><p><code>loadContributorsSuspend()</code> 예시에서 각 &quot;기여자&quot; 요청은 이제 중단 메커니즘을 사용하여 결과를 기다립니다. 먼저 새 요청이 전송됩니다. 그런 다음 응답을 기다리는 동안 <code>launch</code> 함수에 의해 시작된 전체 &quot;기여자 로드&quot; 코루틴이 중단됩니다.</p><p>코루틴은 해당 응답이 수신된 후에만 재개됩니다:</p><p><img src="'+b+`" alt="요청 중단" width="700"></p><p>응답을 기다리는 동안 스레드는 다른 작업을 수행할 수 있도록 자유로워집니다. 모든 요청이 메인 UI 스레드에서 이루어지고 있음에도 불구하고 UI는 계속 반응합니다:</p><ol><li><p><em>SUSPEND</em> 옵션을 사용하여 프로그램을 실행합니다. 로그는 모든 요청이 메인 UI 스레드로 전송되었음을 확인합니다:</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>2538 [AWT-EventQueue-0 @coroutine#1] INFO  Contributors - kotlin: loaded 30 repos</span></span>
<span class="line"><span>2729 [AWT-EventQueue-0 @coroutine#1] INFO  Contributors - ts2kt: loaded 11 contributors</span></span>
<span class="line"><span>3029 [AWT-EventQueue-0 @coroutine#1] INFO  Contributors - kotlin-koans: loaded 45 contributors</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>11252 [AWT-EventQueue-0 @coroutine#1] INFO  Contributors - kotlin-coroutines-workshop: loaded 1 contributors</span></span></code></pre></div></li><li><p>로그는 해당 코드가 실행되는 코루틴을 보여줄 수 있습니다. 이를 활성화하려면 <strong>Run | Edit configurations</strong>를 열고 <code>-Dkotlinx.coroutines.debug</code> VM 옵션을 추가하십시오:</p><p><img src="`+B+`" alt="실행 구성 편집" width="500"></p><p>이 옵션을 사용하여 <code>main()</code>이 실행되는 동안 코루틴 이름이 스레드 이름에 첨부됩니다. 모든 Kotlin 파일을 실행하기 위한 템플릿을 수정하고 이 옵션을 기본적으로 활성화할 수도 있습니다.</p></li></ol><p>이제 모든 코드는 위에서 언급한 &quot;@coroutine#1&quot;로 표시된 &quot;기여자 로드&quot; 코루틴 하나에서 실행됩니다. 결과를 기다리는 동안 다른 요청을 보내기 위해 스레드를 재사용해서는 안 됩니다. 코드가 순차적으로 작성되었기 때문입니다. 새 요청은 이전 결과가 수신된 후에만 전송됩니다.</p><p>중단 함수는 스레드를 공정하게 처리하며 &quot;대기&quot;를 위해 스레드를 블로킹하지 않습니다. 그러나 이것은 아직 동시성을 가져오지 않습니다.</p><h2 id="동시성" tabindex="-1">동시성 <a class="header-anchor" href="#동시성" aria-label="Permalink to &quot;동시성&quot;">​</a></h2><p>Kotlin 코루틴은 스레드보다 훨씬 적은 리소스를 사용합니다. 비동기적으로 새로운 연산을 시작하고 싶을 때마다 새 코루틴을 생성할 수 있습니다.</p><p>새 코루틴을 시작하려면 주요 <em>코루틴 빌더</em> 중 하나인 <code>launch</code>, <code>async</code>, 또는 <code>runBlocking</code>을 사용하십시오. 다른 라이브러리들은 추가적인 코루틴 빌더를 정의할 수 있습니다.</p><p><code>async</code>는 새로운 코루틴을 시작하고 <code>Deferred</code> 객체를 반환합니다. <code>Deferred</code>는 <code>Future</code> 또는 <code>Promise</code>와 같은 다른 이름으로 알려진 개념을 나타냅니다. 이것은 연산을 저장하지만, 최종 결과를 얻는 시점을 _지연_시키고; _미래_의 어느 시점에 결과를 _약속_합니다.</p><p><code>async</code>와 <code>launch</code>의 주요 차이점은 <code>launch</code>는 특정 결과를 반환하지 않을 것으로 예상되는 연산을 시작하는 데 사용된다는 것입니다. <code>launch</code>는 코루틴을 나타내는 <code>Job</code>을 반환합니다. <code>Job.join()</code>을 호출하여 완료될 때까지 기다릴 수 있습니다.</p><p><code>Deferred</code>는 <code>Job</code>을 확장하는 제네릭 타입입니다. <code>async</code> 호출은 람다가 반환하는 내용(람다 내부의 마지막 표현식이 결과)에 따라 <code>Deferred&lt;Int&gt;</code> 또는 <code>Deferred&lt;CustomType&gt;</code>를 반환할 수 있습니다.</p><p>코루틴의 결과를 얻으려면 <code>Deferred</code> 인스턴스에서 <code>await()</code>를 호출할 수 있습니다. 결과를 기다리는 동안 <code>await()</code>가 호출된 코루틴은 중단됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deferred: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Deferred</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        loadData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;waiting...&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(deferred.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;loading...&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;loaded!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>runBlocking</code>은 일반 함수와 중단 함수 사이, 또는 블로킹 세계와 비블로킹 세계 사이의 다리(bridge) 역할을 합니다. 이는 최상위 메인 코루틴을 시작하기 위한 어댑터로 작동합니다. 주로 <code>main()</code> 함수 및 테스트에서 사용하도록 의도되었습니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>코루틴에 대한 더 나은 이해를 위해 <a href="https://www.youtube.com/watch?v=zEZc5AmHQhk" target="_blank" rel="noreferrer">이 비디오</a>를 시청하십시오.</p></div><p>지연 객체 목록이 있는 경우 <code>awaitAll()</code>을 호출하여 모든 결과를 기다릴 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deferreds: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Deferred</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000L</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> it)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Loading </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$it</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            it</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deferreds.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">awaitAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$sum</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>각 &quot;기여자&quot; 요청이 새 코루틴에서 시작되면 모든 요청이 비동기적으로 시작됩니다. 이전 요청의 결과가 수신되기 전에 새 요청을 보낼 수 있습니다:</p><p><img src="`+D+'" alt="동시 코루틴" width="700"></p><p>총 로딩 시간은 <em>CALLBACKS</em> 버전과 거의 동일하지만, 콜백이 필요 없습니다. 더 나아가, <code>async</code>는 코드에서 어떤 부분이 동시적으로 실행되는지 명시적으로 강조합니다.</p><h3 id="작업-5" tabindex="-1">작업 5 <a class="header-anchor" href="#작업-5" aria-label="Permalink to &quot;작업 5&quot;">​</a></h3><p><code>Request5Concurrent.kt</code> 파일에서 이전 <code>loadContributorsSuspend()</code> 함수를 사용하여 <code>loadContributorsConcurrent()</code> 함수를 구현하십시오.</p>',39)),s[17]||(s[17]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"작업-5-팁",tabindex:"-1"},[a("작업 5 팁 "),i("a",{class:"header-anchor",href:"#작업-5-팁","aria-label":'Permalink to "작업 5 팁 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[18]||(s[18]=n(`<p>코루틴은 코루틴 스코프 내에서만 시작할 수 있습니다. <code>loadContributorsSuspend()</code>의 내용을 <code>coroutineScope</code> 호출로 복사하여 <code>async</code> 함수를 호출할 수 있도록 하십시오:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> coroutineScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>다음 스키마를 기반으로 솔루션을 만드십시오:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deferreds: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Deferred</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 각 저장소의 기여자 로드</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">deferreds.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">awaitAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// List&lt;List&lt;User&gt;&gt;</span></span></code></pre></div>`,4)),s[19]||(s[19]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"작업-5-솔루션",tabindex:"-1"},[a("작업 5 솔루션 "),i("a",{class:"header-anchor",href:"#작업-5-솔루션","aria-label":'Permalink to "작업 5 솔루션 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[20]||(s[20]=n(`<p>각 &quot;기여자&quot; 요청을 <code>async</code>로 감싸서 저장소 수만큼 코루틴을 생성합니다. <code>async</code>는 <code>Deferred&lt;List&lt;User&gt;&gt;</code>를 반환합니다. 새 코루틴을 생성하는 것은 리소스 집약적이지 않으므로 필요한 만큼 생성할 수 있다는 점은 문제가 되지 않습니다.</p><ol><li><p><code>flatMap</code>은 더 이상 사용할 수 없습니다. <code>map</code>의 결과가 이제 목록의 목록이 아니라 <code>Deferred</code> 객체 목록이기 때문입니다. <code>awaitAll()</code>은 <code>List&lt;List&lt;User&gt;&gt;</code>를 반환하므로 <code>flatten().aggregate()</code>를 호출하여 결과를 얻습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> coroutineScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> service</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrgRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deferreds: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Deferred</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    deferreds.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">awaitAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">flatten</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>코드를 실행하고 로그를 확인하십시오. 멀티스레딩이 아직 사용되지 않았기 때문에 모든 코루틴은 여전히 메인 UI 스레드에서 실행되지만, 코루틴을 동시적으로 실행하는 이점을 이미 볼 수 있습니다.</p></li><li><p>이 코드를 변경하여 &quot;기여자&quot; 코루틴을 공통 스레드 풀의 다른 스레드에서 실행하려면 <code>async</code> 함수의 컨텍스트 인수로 <code>Dispatchers.Default</code>를 지정하십시오:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dispatchers.Default) { }</span></span></code></pre></div><ul><li><code>CoroutineDispatcher</code>는 해당 코루틴이 실행될 스레드를 결정합니다. 인수로 지정하지 않으면 <code>async</code>는 외부 스코프의 디스패처를 사용합니다.</li><li><code>Dispatchers.Default</code>는 JVM의 공유 스레드 풀을 나타냅니다. 이 풀은 병렬 실행을 위한 수단을 제공합니다. 사용 가능한 CPU 코어 수만큼의 스레드로 구성되지만, 코어가 하나만 있어도 두 개의 스레드를 가집니다.</li></ul></li><li><p><code>loadContributorsConcurrent()</code> 함수의 코드를 수정하여 공통 스레드 풀의 다른 스레드에서 새 코루틴을 시작하도록 합니다. 또한 요청을 보내기 전에 추가 로깅을 추가하십시오:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dispatchers.Default) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;starting loading for \${repo.name}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>프로그램을 다시 실행하십시오. 로그에서 각 코루틴이 스레드 풀의 한 스레드에서 시작되어 다른 스레드에서 재개될 수 있음을 볼 수 있습니다:</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1946 [DefaultDispatcher-worker-2 @coroutine#4] INFO  Contributors - starting loading for kotlin-koans</span></span>
<span class="line"><span>1946 [DefaultDispatcher-worker-3 @coroutine#5] INFO  Contributors - starting loading for dokka</span></span>
<span class="line"><span>1946 [DefaultDispatcher-worker-1 @coroutine#3] INFO  Contributors - starting loading for ts2kt</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>2178 [DefaultDispatcher-worker-1 @coroutine#4] INFO  Contributors - kotlin-koans: loaded 45 contributors</span></span>
<span class="line"><span>2569 [DefaultDispatcher-worker-1 @coroutine#5] INFO  Contributors - dokka: loaded 36 contributors</span></span>
<span class="line"><span>2821 [DefaultDispatcher-worker-2 @coroutine#3] INFO  Contributors - ts2kt: loaded 11 contributors</span></span></code></pre></div><p>예를 들어, 이 로그 발췌문에서 <code>coroutine#4</code>는 <code>worker-2</code> 스레드에서 시작되어 <code>worker-1</code> 스레드에서 계속됩니다.</p></li></ol><p><code>src/contributors/Contributors.kt</code>에서 <em>CONCURRENT</em> 옵션의 구현을 확인하십시오:</p><ol><li><p>코루틴을 메인 UI 스레드에서만 실행하려면 <code>Dispatchers.Main</code>을 인수로 지정하십시오:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dispatchers.Main) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>새 코루틴을 메인 스레드에서 시작할 때 메인 스레드가 바쁘면, 코루틴은 중단되고 이 스레드에서 실행되도록 스케줄링됩니다. 코루틴은 스레드가 자유로워질 때만 재개됩니다.</li><li>각 엔드포인트에 명시적으로 지정하는 대신 외부 스코프의 디스패처를 사용하는 것이 좋은 관행으로 간주됩니다. <code>Dispatchers.Default</code>를 인수로 전달하지 않고 <code>loadContributorsConcurrent()</code>를 정의하면, 이 함수를 <code>Default</code> 디스패처, 메인 UI 스레드 또는 사용자 지정 디스패처와 같은 어떤 컨텍스트에서도 호출할 수 있습니다.</li><li>나중에 보겠지만, 테스트에서 <code>loadContributorsConcurrent()</code>를 호출할 때 <code>TestDispatcher</code> 컨텍스트에서 호출할 수 있어 테스트를 단순화합니다. 이는 이 솔루션을 훨씬 더 유연하게 만듭니다.</li></ul></li><li><p>호출자 측에서 디스패처를 지정하려면, <code>loadContributorsConcurrent</code>가 상속된 컨텍스트에서 코루틴을 시작하도록 하면서 프로젝트에 다음 변경 사항을 적용하십시오:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dispatchers.Default) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service, req)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    withContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dispatchers.Main) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users, startTime)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>updateResults()</code>는 메인 UI 스레드에서 호출되어야 하므로 <code>Dispatchers.Main</code> 컨텍스트로 호출합니다.</li><li><code>withContext()</code>는 지정된 코루틴 컨텍스트로 주어진 코드를 호출하고, 완료될 때까지 중단되며, 결과를 반환합니다. 이를 표현하는 또 다른 방법이지만 더 장황한 방법은 새 코루틴을 시작하고 완료될 때까지 명시적으로 기다리는(중단하는) 것입니다: <code>launch(context) { ... }.join()</code>.</li></ul></li><li><p>코드를 실행하고 코루틴이 스레드 풀의 스레드에서 실행되는지 확인하십시오.</p></li></ol><h2 id="구조화된-동시성" tabindex="-1">구조화된 동시성 <a class="header-anchor" href="#구조화된-동시성" aria-label="Permalink to &quot;구조화된 동시성&quot;">​</a></h2><ul><li>_코루틴 스코프_는 서로 다른 코루틴 간의 구조와 부모-자식 관계를 담당합니다. 새 코루틴은 일반적으로 스코프 내에서 시작되어야 합니다.</li><li>_코루틴 컨텍스트_는 코루틴의 사용자 지정 이름이나 코루틴이 스케줄링될 스레드를 지정하는 디스패처와 같이 주어진 코루틴을 실행하는 데 사용되는 추가 기술 정보를 저장합니다.</li></ul><p><code>launch</code>, <code>async</code>, 또는 <code>runBlocking</code>이 새 코루틴을 시작하는 데 사용되면 자동으로 해당 스코프를 생성합니다. 이 모든 함수는 리시버를 가진 람다를 인수로 받으며, <code>CoroutineScope</code>가 암묵적 리시버 타입입니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* this: CoroutineScope */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><ul><li>새 코루틴은 스코프 내에서만 시작할 수 있습니다.</li><li><code>launch</code>와 <code>async</code>는 <code>CoroutineScope</code>의 확장으로 선언되었으므로, 이들을 호출할 때는 항상 암묵적 또는 명시적 리시버가 전달되어야 합니다.</li><li><code>runBlocking</code>에 의해 시작된 코루틴은 유일한 예외입니다. <code>runBlocking</code>은 최상위 함수로 정의되어 있기 때문입니다. 그러나 현재 스레드를 블로킹하므로 주로 <code>main()</code> 함수 및 테스트에서 브릿지 함수로 사용됩니다.</li></ul><p><code>runBlocking</code>, <code>launch</code>, 또는 <code>async</code> 내에서 새 코루틴은 스코프 내에서 자동으로 시작됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* this: CoroutineScope */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // the same as:   </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>runBlocking</code> 내에서 <code>launch</code>를 호출할 때, 이것은 <code>CoroutineScope</code> 타입의 암묵적 리시버에 대한 확장으로 호출됩니다. 대안으로, <code>this.launch</code>를 명시적으로 작성할 수도 있습니다.</p><p>(이 예시에서 <code>launch</code>에 의해 시작된) 중첩 코루틴은 외부 코루틴(<code>runBlocking</code>에 의해 시작된)의 자식으로 간주될 수 있습니다. 이 &quot;부모-자식&quot; 관계는 스코프를 통해 작동합니다. 자식 코루틴은 부모 코루틴에 해당하는 스코프에서 시작됩니다.</p><p>새 코루틴을 시작하지 않고도 <code>coroutineScope</code> 함수를 사용하여 새 스코프를 생성할 수 있습니다. <code>suspend</code> 함수 내에서 외부 스코프에 대한 접근 없이 구조화된 방식으로 새 코루틴을 시작하려면, 이 <code>suspend</code> 함수가 호출된 외부 스코프의 자식 스코프가 자동으로 되는 새 코루틴 스코프를 생성할 수 있습니다. <code>loadContributorsConcurrent()</code>가 좋은 예입니다.</p><p>또한 <code>GlobalScope.async</code> 또는 <code>GlobalScope.launch</code>를 사용하여 전역 스코프에서 새 코루틴을 시작할 수 있습니다. 이렇게 하면 최상위 &quot;독립&quot; 코루틴이 생성됩니다.</p><p>코루틴의 구조를 뒷받침하는 메커니즘을 <em>구조화된 동시성</em>(structured concurrency)이라고 합니다. 이는 전역 스코프에 비해 다음과 같은 이점을 제공합니다:</p><ul><li>스코프는 일반적으로 자식 코루틴을 담당하며, 자식 코루틴의 수명은 스코프의 수명에 연결됩니다.</li><li>스코프는 문제가 발생하거나 사용자가 마음을 바꾸어 작업을 취소하기로 결정한 경우 자식 코루틴을 자동으로 취소할 수 있습니다.</li><li>스코프는 모든 자식 코루틴의 완료를 자동으로 기다립니다. 따라서 스코프가 코루틴에 해당한다면, 부모 코루틴은 해당 스코프에서 시작된 모든 코루틴이 완료될 때까지 완료되지 않습니다.</li></ul><p><code>GlobalScope.async</code>를 사용할 경우, 여러 코루틴을 더 작은 스코프에 묶는 구조가 없습니다. 전역 스코프에서 시작된 코루틴은 모두 독립적입니다. 이들의 수명은 전체 애플리케이션의 수명에 의해서만 제한됩니다. 전역 스코프에서 시작된 코루틴에 대한 참조를 저장하고 명시적으로 완료를 기다리거나 취소할 수 있지만, 구조화된 동시성에서처럼 자동으로 발생하지는 않습니다.</p><h3 id="기여자-로딩-취소" tabindex="-1">기여자 로딩 취소 <a class="header-anchor" href="#기여자-로딩-취소" aria-label="Permalink to &quot;기여자 로딩 취소&quot;">​</a></h3><p>기여자 목록을 로드하는 함수의 두 가지 버전을 생성합니다. 부모 코루틴을 취소하려고 할 때 두 버전이 어떻게 작동하는지 비교합니다. 첫 번째 버전은 <code>coroutineScope</code>를 사용하여 모든 자식 코루틴을 시작하고, 두 번째 버전은 <code>GlobalScope</code>를 사용합니다.</p><ol><li><p><code>Request5Concurrent.kt</code>에서 <code>loadContributorsConcurrent()</code> 함수에 3초 지연을 추가합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> coroutineScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;starting loading for \${repo.name}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 저장소 기여자 로드</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 지연은 요청을 보내는 모든 코루틴에 영향을 미치므로, 코루틴이 시작된 후 요청이 보내지기 전에 로딩을 취소할 충분한 시간을 확보합니다.</p></li><li><p>로딩 함수의 두 번째 버전을 생성합니다. <code>loadContributorsConcurrent()</code>의 구현을 <code>Request5NotCancellable.kt</code>의 <code>loadContributorsNotCancellable()</code>로 복사한 다음, 새 <code>coroutineScope</code> 생성을 제거합니다.</p></li><li><p>이제 <code>async</code> 호출이 해결되지 않으므로, <code>GlobalScope.async</code>를 사용하여 이들을 시작합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsNotCancellable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    GlobalScope.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;starting loading for \${repo.name}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 저장소 기여자 로드</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deferreds.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">awaitAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">flatten</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>이제 함수는 람다 내부의 마지막 표현식이 아닌 결과를 직접 반환합니다(<code> #1</code> 및 <code>#3</code> 줄).</li><li>모든 &quot;기여자&quot; 코루틴은 코루틴 스코프의 자식이 아닌 <code>GlobalScope</code> 내에서 시작됩니다(<code> #2</code> 줄).</li></ul></li><li><p>프로그램을 실행하고 <em>CONCURRENT</em> 옵션을 선택하여 기여자를 로드합니다.</p></li><li><p>모든 &quot;기여자&quot; 코루틴이 시작될 때까지 기다린 다음 _Cancel_을 클릭합니다. 로그에 새 결과가 표시되지 않는데, 이는 모든 요청이 실제로 취소되었음을 의미합니다:</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>2896 [AWT-EventQueue-0 @coroutine#1] INFO  Contributors - kotlin: loaded 40 repos</span></span>
<span class="line"><span>2901 [DefaultDispatcher-worker-2 @coroutine#4] INFO  Contributors - starting loading for kotlin-koans</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>2909 [DefaultDispatcher-worker-5 @coroutine#36] INFO  Contributors - starting loading for mpp-example</span></span>
<span class="line"><span>/* &#39;cancel&#39; 클릭 */</span></span>
<span class="line"><span>/* 요청이 전송되지 않음 */</span></span></code></pre></div></li><li><p>5단계를 반복하되, 이번에는 <code>NOT_CANCELLABLE</code> 옵션을 선택합니다:</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>2570 [AWT-EventQueue-0 @coroutine#1] INFO  Contributors - kotlin: loaded 30 repos</span></span>
<span class="line"><span>2579 [DefaultDispatcher-worker-1 @coroutine#4] INFO  Contributors - starting loading for kotlin-koans</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>2586 [DefaultDispatcher-worker-6 @coroutine#36] INFO  Contributors - starting loading for mpp-example</span></span>
<span class="line"><span>/* &#39;cancel&#39; 클릭 */</span></span>
<span class="line"><span>/* 그러나 모든 요청은 여전히 전송됨: */</span></span>
<span class="line"><span>6402 [DefaultDispatcher-worker-5 @coroutine#4] INFO  Contributors - kotlin-koans: loaded 45 contributors</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>9555 [DefaultDispatcher-worker-8 @coroutine#36] INFO  Contributors - mpp-example: loaded 8 contributors</span></span></code></pre></div><p>이 경우 어떤 코루틴도 취소되지 않으며 모든 요청은 여전히 전송됩니다.</p></li><li><p>&quot;기여자&quot; 프로그램에서 취소가 어떻게 트리거되는지 확인합니다. <em>Cancel</em> 버튼을 클릭하면 메인 &quot;로딩&quot; 코루틴이 명시적으로 취소되고 자식 코루틴은 자동으로 취소됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Contributors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getSelectedVariant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            CONCURRENT </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service, req)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users, startTime)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setUpCancellation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Job</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setUpCancellation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loadingJob </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // #2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // &#39;cancel&#39; 버튼이 클릭되면 로딩 작업을 취소합니다:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> listener </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ActionListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            loadingJob.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cancel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()            </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #3</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            updateLoadingStatus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CANCELED)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // &#39;cancel&#39; 버튼에 리스너를 추가합니다:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        addCancelListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(listener)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 로딩 작업이 완료된 후 상태를 업데이트하고 리스너를 제거합니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ol><p><code>launch</code> 함수는 <code>Job</code>의 인스턴스를 반환합니다. <code>Job</code>은 모든 데이터를 로드하고 결과를 업데이트하는 &quot;로딩 코루틴&quot;에 대한 참조를 저장합니다. <code>Job</code> 인스턴스를 리시버로 전달하여 <code>setUpCancellation()</code> 확장 함수를 호출할 수 있습니다(<code> #1</code> 줄).</p><p>이를 표현하는 또 다른 방법은 다음과 같이 명시적으로 작성하는 것입니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> job </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">job.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setUpCancellation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li>가독성을 위해 함수 내부에서 <code>setUpCancellation()</code> 함수의 리시버를 새로운 <code>loadingJob</code> 변수(<code> #2</code> 줄)로 참조할 수 있습니다.</li><li>그런 다음 <em>Cancel</em> 버튼에 리스너를 추가하여 클릭될 때 <code>loadingJob</code>이 취소되도록 할 수 있습니다(<code> #3</code> 줄).</li></ul><p>구조화된 동시성을 사용하면 부모 코루틴만 취소하면 되고, 이는 모든 자식 코루틴으로 자동으로 취소가 전파됩니다.</p><h3 id="외부-스코프의-컨텍스트-사용" tabindex="-1">외부 스코프의 컨텍스트 사용 <a class="header-anchor" href="#외부-스코프의-컨텍스트-사용" aria-label="Permalink to &quot;외부 스코프의 컨텍스트 사용&quot;">​</a></h3><p>주어진 스코프 내에서 새 코루틴을 시작하면 모든 코루틴이 동일한 컨텍스트로 실행되도록 훨씬 쉽게 보장할 수 있습니다. 또한 필요한 경우 컨텍스트를 교체하기도 훨씬 쉽습니다.</p><p>이제 외부 스코프의 디스패처를 사용하는 방법을 알아볼 차례입니다. <code>coroutineScope</code> 또는 코루틴 빌더에 의해 생성된 새 스코프는 항상 외부 스코프로부터 컨텍스트를 상속합니다. 이 경우 외부 스코프는 <code>suspend loadContributorsConcurrent()</code> 함수가 호출된 스코프입니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dispatchers.Default) {  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 외부 스코프</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service, req)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>모든 중첩 코루틴은 상속된 컨텍스트로 자동으로 시작됩니다. 디스패처는 이 컨텍스트의 일부입니다. 따라서 <code>async</code>에 의해 시작된 모든 코루틴은 기본 디스패처의 컨텍스트로 시작됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> coroutineScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 이 스코프는 외부 스코프에서 컨텍스트를 상속합니다</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 상속된 컨텍스트로 시작된 중첩 코루틴</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>구조화된 동시성을 사용하면 최상위 코루틴을 생성할 때 주요 컨텍스트 요소(예: 디스패처)를 한 번 지정할 수 있습니다. 그러면 모든 중첩 코루틴은 컨텍스트를 상속받고 필요할 때만 수정합니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>예를 들어 안드로이드와 같은 UI 애플리케이션에서 코루틴 코드를 작성할 때, 기본적으로 최상위 코루틴에 <code>CoroutineDispatchers.Main</code>을 사용하고, 다른 스레드에서 코드를 실행해야 할 때 명시적으로 다른 디스패처를 지정하는 것이 일반적인 관행입니다.</p></div><h2 id="진행-상황-표시" tabindex="-1">진행 상황 표시 <a class="header-anchor" href="#진행-상황-표시" aria-label="Permalink to &quot;진행 상황 표시&quot;">​</a></h2><p>일부 저장소에 대한 정보는 상당히 빠르게 로드되지만, 사용자는 모든 데이터가 로드된 후에야 최종 목록을 볼 수 있습니다. 그때까지 로더 아이콘은 진행 상황을 표시하지만, 현재 상태나 이미 로드된 기여자 정보는 없습니다.</p><p>중간 결과를 더 일찍 표시하고 각 저장소에 대한 데이터 로딩 후 모든 기여자를 표시할 수 있습니다:</p><p><img src="`+A+`" alt="데이터 로딩 중" width="500"></p><p>이 기능을 구현하려면 <code>src/tasks/Request6Progress.kt</code>에서 UI를 업데이트하는 로직을 콜백으로 전달해야 합니다. 이렇게 하면 각 중간 상태에서 호출됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsProgress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    updateResults: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">suspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">completed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 데이터 로딩</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 중간 상태에서 \`updateResults()\` 호출</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>Contributors.kt</code>의 호출 사이트에서는 <em>PROGRESS</em> 옵션에 대해 <code>Main</code> 스레드에서 결과를 업데이트하기 위해 콜백이 전달됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dispatchers.Default) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    loadContributorsProgress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service, req) { users, completed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        withContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dispatchers.Main) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users, startTime, completed)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>updateResults()</code> 매개변수는 <code>loadContributorsProgress()</code>에서 <code>suspend</code>로 선언됩니다. 해당 람다 인수 내에서 <code>suspend</code> 함수인 <code>withContext</code>를 호출해야 합니다.</li><li><code>updateResults()</code> 콜백은 로딩이 완료되었고 결과가 최종적인지 여부를 지정하는 추가적인 Boolean 매개변수를 인수로 받습니다.</li></ul><h3 id="작업-6" tabindex="-1">작업 6 <a class="header-anchor" href="#작업-6" aria-label="Permalink to &quot;작업 6&quot;">​</a></h3><p><code>Request6Progress.kt</code> 파일에서 중간 진행 상황을 보여주는 <code>loadContributorsProgress()</code> 함수를 구현하십시오. <code>Request4Suspend.kt</code>의 <code>loadContributorsSuspend()</code> 함수를 기반으로 하십시오.</p><ul><li>동시성을 사용하지 않는 간단한 버전을 사용하십시오. 동시성은 다음 섹션에서 추가할 것입니다.</li><li>기여자의 중간 목록은 각 저장소에 대해 로드된 사용자 목록이 아니라 &quot;집계된&quot; 상태로 표시되어야 합니다.</li><li>각 사용자의 총 기여 수는 각 새 저장소에 대한 데이터가 로드될 때마다 증가해야 합니다.</li></ul>`,46)),s[21]||(s[21]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"작업-6-솔루션",tabindex:"-1"},[a("작업 6 솔루션 "),i("a",{class:"header-anchor",href:"#작업-6-솔루션","aria-label":'Permalink to "작업 6 솔루션 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[22]||(s[22]=n(`<p>&quot;모든 기여자&quot; 목록의 중간 상태를 저장하려면 사용자 목록을 저장하는 <code>allUsers</code> 변수를 정의한 다음, 각 새 저장소에 대한 기여자가 로드된 후 이를 업데이트하십시오:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsProgress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    updateResults: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">suspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">completed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> service</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrgRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> emptyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((index, repo) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withIndex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allUsers, index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.lastIndex)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="순차적-vs-동시적" tabindex="-1">순차적 vs 동시적 <a class="header-anchor" href="#순차적-vs-동시적" aria-label="Permalink to &quot;순차적 vs 동시적&quot;">​</a></h4><p><code>updateResults()</code> 콜백은 각 요청이 완료된 후 호출됩니다:</p><p><img src="`+v+'" alt="요청 진행 상황" width="700"></p><p>이 코드에는 동시성이 포함되어 있지 않습니다. 순차적이므로 동기화가 필요하지 않습니다.</p><p>가장 좋은 옵션은 요청을 동시에 보내고 각 저장소에 대한 응답을 받은 후 중간 결과를 업데이트하는 것입니다:</p><p><img src="'+m+'" alt="동시 요청" width="700"></p><p>동시성을 추가하려면 _채널_을 사용하십시오.</p><h2 id="채널" tabindex="-1">채널 <a class="header-anchor" href="#채널" aria-label="Permalink to &quot;채널&quot;">​</a></h2><p>공유 가능한 가변 상태를 가진 코드를 작성하는 것은 상당히 어렵고 오류가 발생하기 쉽습니다(콜백을 사용하는 솔루션처럼). 더 간단한 방법은 공통 가변 상태를 사용하는 대신 통신을 통해 정보를 공유하는 것입니다. 코루틴은 _채널_을 통해 서로 통신할 수 있습니다.</p><p>채널은 코루틴 간에 데이터를 전달할 수 있는 통신 프리미티브입니다. 한 코루틴은 채널에 일부 정보를 <em>보내고</em>, 다른 코루틴은 채널에서 해당 정보를 <em>받을</em> 수 있습니다:</p><p><img src="'+q+'" alt="채널 사용"></p><p>정보를 보내는(생산하는) 코루틴을 종종 생산자(producer)라고 부르며, 정보를 받는(소비하는) 코루틴을 소비자(consumer)라고 부릅니다. 하나 또는 여러 코루틴이 동일한 채널에 정보를 보낼 수 있으며, 하나 또는 여러 코루틴이 채널에서 데이터를 받을 수 있습니다:</p><p><img src="'+f+`" alt="다수의 코루틴과 함께 채널 사용"></p><p>여러 코루틴이 동일한 채널에서 정보를 받을 때, 각 요소는 소비자 중 하나에 의해 한 번만 처리됩니다. 요소가 처리되면 즉시 채널에서 제거됩니다.</p><p>채널을 요소의 컬렉션, 더 정확히는 요소가 한쪽 끝에 추가되고 다른 쪽 끝에서 수신되는 큐와 유사하다고 생각할 수 있습니다. 그러나 중요한 차이점이 있습니다. 동기화된 버전의 컬렉션과 달리 채널은 <code>send()</code> 및 <code>receive()</code> 작업을 _중단_시킬 수 있습니다. 이는 채널이 비어 있거나 가득 찼을 때 발생합니다. 채널 크기에 상한이 있다면 채널이 가득 찰 수 있습니다.</p><p><code>Channel</code>은 <code>SendChannel</code>, <code>ReceiveChannel</code>, 그리고 이 둘을 확장하는 <code>Channel</code>의 세 가지 인터페이스로 표현됩니다. 일반적으로 채널을 생성하고 생산자에게 <code>SendChannel</code> 인스턴스로 제공하여 생산자만 채널에 정보를 보낼 수 있도록 합니다. 소비자에게는 <code>ReceiveChannel</code> 인스턴스로 채널을 제공하여 소비자만 채널에서 데이터를 받을 수 있도록 합니다. <code>send</code>와 <code>receive</code> 메서드는 모두 <code>suspend</code>로 선언됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SendChannel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">in</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> E</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(element: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReceiveChannel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">out</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> E</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> receive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">E</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SendChannel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, ReceiveChannel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">E</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>생산자는 더 이상 요소가 오지 않을 것임을 나타내기 위해 채널을 닫을 수 있습니다.</p><p>라이브러리에는 여러 유형의 채널이 정의되어 있습니다. 이들은 내부적으로 저장할 수 있는 요소 수와 <code>send()</code> 호출이 중단될 수 있는지 여부에서 다릅니다. 모든 채널 유형에 대해 <code>receive()</code> 호출은 유사하게 작동합니다. 채널이 비어 있지 않으면 요소를 수신하고, 그렇지 않으면 중단됩니다.</p>`,21)),l(h,{collapsible:"true"},{default:t(()=>[l(p,{title:"무제한 채널 (Unlimited channel)"},{default:t(()=>s[0]||(s[0]=[i("p",null,[a("무제한 채널은 큐에 가장 가까운 비유입니다. 생산자는 이 채널에 요소를 보낼 수 있으며, 채널은 무한히 커질 것입니다. "),i("code",null,"send()"),a(" 호출은 결코 중단되지 않습니다. 프로그램의 메모리가 부족해지면 "),i("code",null,"OutOfMemoryException"),a("이 발생할 것입니다. 무제한 채널과 큐의 차이점은 소비자가 빈 채널에서 받으려고 시도할 때, 새 요소가 전송될 때까지 중단된다는 점입니다.")],-1),i("img",{src:k,alt:"무제한 채널",width:"500"},null,-1)])),_:1}),l(p,{title:"버퍼링된 채널 (Buffered channel)"},{default:t(()=>s[1]||(s[1]=[i("p",null,[a("버퍼링된 채널의 크기는 지정된 숫자로 제한됩니다. 생산자는 크기 제한에 도달할 때까지 이 채널에 요소를 보낼 수 있습니다. 모든 요소는 내부적으로 저장됩니다. 채널이 가득 차면, 다음 "),i("code",null,"send"),a(" 호출은 더 많은 빈 공간이 사용 가능해질 때까지 중단됩니다.")],-1),i("img",{src:r,alt:"버퍼링된 채널",width:"500"},null,-1)])),_:1}),l(p,{title:"랑데부 채널 (Rendezvous channel)"},{default:t(()=>s[2]||(s[2]=[i("p",null,[a('"랑데부" 채널은 버퍼가 없는 채널로, 크기가 0인 버퍼링된 채널과 같습니다. 두 함수('),i("code",null,"send()"),a(" 또는 "),i("code",null,"receive()"),a(") 중 하나는 다른 하나가 호출될 때까지 항상 중단됩니다. ")],-1),i("p",null,[a("만약 "),i("code",null,"send()"),a(" 함수가 호출되었고, 해당 요소를 처리할 준비가 된 중단된 "),i("code",null,"receive()"),a(" 호출이 없다면 "),i("code",null,"send()"),a("는 중단됩니다. 유사하게, "),i("code",null,"receive()"),a(" 함수가 호출되었고 채널이 비어 있거나, 다른 말로, 요소를 보낼 준비가 된 중단된 "),i("code",null,"send()"),a(" 호출이 없다면 "),i("code",null,"receive()"),a(" 호출은 중단됩니다. ")],-1),i("p",null,[a('"랑데부"라는 이름("합의된 시간과 장소에서의 만남")은 '),i("code",null,"send()"),a("와 "),i("code",null,"receive()"),a('가 "제때 만나야" 한다는 사실을 나타냅니다.')],-1),i("img",{src:d,alt:"랑데부 채널",width:"500"},null,-1)])),_:1}),l(p,{title:"Conflated 채널 (Conflated channel)"},{default:t(()=>s[3]||(s[3]=[i("p",null,[a("Conflated 채널로 전송된 새 요소는 이전에 전송된 요소를 덮어씁니다. 따라서 수신자는 항상 최신 요소만 받게 됩니다. "),i("code",null,"send()"),a(" 호출은 결코 중단되지 않습니다.")],-1),i("img",{src:E,alt:"Conflated 채널",width:"500"},null,-1)])),_:1})]),_:1}),s[23]||(s[23]=n(`<p>채널을 생성할 때, 유형이나 버퍼 크기를 지정합니다(버퍼링된 채널이 필요한 경우):</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rendezvousChannel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bufferedChannel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> conflatedChannel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(CONFLATED)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unlimitedChannel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(UNLIMITED)</span></span></code></pre></div><p>기본적으로 &quot;랑데부&quot; 채널이 생성됩니다.</p><p>다음 작업에서는 &quot;랑데부&quot; 채널, 두 개의 생산자 코루틴, 그리고 하나의 소비자 코루틴을 생성할 것입니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.channels.Channel</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> channel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A done&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;B1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;B done&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">receive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;[\${Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">().name}] </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$message</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>채널에 대한 더 나은 이해를 위해 <a href="https://www.youtube.com/watch?v=HpWQUoVURWQ" target="_blank" rel="noreferrer">이 비디오</a>를 시청하십시오.</p></div><h3 id="작업-7" tabindex="-1">작업 7 <a class="header-anchor" href="#작업-7" aria-label="Permalink to &quot;작업 7&quot;">​</a></h3><p><code>src/tasks/Request7Channels.kt</code>에서 모든 GitHub 기여자를 동시에 요청하고 동시에 중간 진행 상황을 보여주는 <code>loadContributorsChannels()</code> 함수를 구현하십시오.</p><p>이전 함수인 <code>Request5Concurrent.kt</code>의 <code>loadContributorsConcurrent()</code>와 <code>Request6Progress.kt</code>의 <code>loadContributorsProgress()</code>를 사용하십시오.</p>`,9)),s[24]||(s[24]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"작업-7-팁",tabindex:"-1"},[a("작업 7 팁 "),i("a",{class:"header-anchor",href:"#작업-7-팁","aria-label":'Permalink to "작업 7 팁 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[25]||(s[25]=n(`<p>다양한 저장소에 대한 기여자 목록을 동시에 수신하는 다른 코루틴은 수신된 모든 결과를 동일한 채널로 보낼 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> channel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TODO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>그러면 이 채널의 요소들을 하나씩 수신하여 처리할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repos.size) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">receive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>receive()</code> 호출은 순차적이므로 추가적인 동기화는 필요하지 않습니다.</p>`,5)),s[26]||(s[26]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"작업-7-솔루션",tabindex:"-1"},[a("작업 7 솔루션 "),i("a",{class:"header-anchor",href:"#작업-7-솔루션","aria-label":'Permalink to "작업 7 솔루션 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[27]||(s[27]=n(`<p><code>loadContributorsProgress()</code> 함수와 마찬가지로, &quot;모든 기여자&quot; 목록의 중간 상태를 저장할 <code>allUsers</code> 변수를 생성한 다음, 각 새 저장소에 대한 기여자가 로드된 후 이를 업데이트할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsChannels</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GitHubService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    updateResults: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">suspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">completed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> coroutineScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> service</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrgRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logRepos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> channel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRepoContributors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.org, repo.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">logUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repo, it) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bodyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(users)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> emptyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repos.size) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">receive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (allUsers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> users).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        updateResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allUsers, it </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repos.lastIndex)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>다른 저장소의 결과는 준비되는 즉시 채널에 추가됩니다. 처음에는 모든 요청이 전송되고 데이터가 수신되지 않을 때 <code>receive()</code> 호출이 중단됩니다. 이 경우 전체 &quot;기여자 로드&quot; 코루틴이 중단됩니다.</li><li>그런 다음 사용자 목록이 채널로 전송되면 &quot;기여자 로드&quot; 코루틴이 재개되고 <code>receive()</code> 호출이 이 목록을 반환하며 결과가 즉시 업데이트됩니다.</li></ul><p>이제 프로그램을 실행하고 <em>CHANNELS</em> 옵션을 선택하여 기여자를 로드하고 결과를 볼 수 있습니다.</p><p>코루틴과 채널이 동시성으로 인한 복잡성을 완전히 제거하지는 않지만, 상황을 이해해야 할 때 작업을 더 쉽게 만듭니다.</p><h2 id="코루틴-테스트하기" tabindex="-1">코루틴 테스트하기 <a class="header-anchor" href="#코루틴-테스트하기" aria-label="Permalink to &quot;코루틴 테스트하기&quot;">​</a></h2><p>이제 모든 솔루션을 테스트하여 동시 코루틴을 사용하는 솔루션이 <code>suspend</code> 함수를 사용하는 솔루션보다 빠른지 확인하고, 채널을 사용하는 솔루션이 단순한 &quot;진행 상황&quot; 솔루션보다 빠른지 확인해 봅시다.</p><p>다음 작업에서는 솔루션의 총 실행 시간을 비교합니다. GitHub 서비스를 모의(mock)하고 이 서비스가 주어진 타임아웃 후에 결과를 반환하도록 할 것입니다:</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>저장소 요청 - 1000ms 지연 내에 응답 반환</span></span>
<span class="line"><span>repo-1 - 1000ms 지연</span></span>
<span class="line"><span>repo-2 - 1200ms 지연</span></span>
<span class="line"><span>repo-3 - 800ms 지연</span></span></code></pre></div><p><code>suspend</code> 함수를 사용하는 순차적 솔루션은 약 4000ms가 소요되어야 합니다 (4000 = 1000 + (1000 + 1200 + 800)). 동시 솔루션은 약 2200ms가 소요되어야 합니다 (2200 = 1000 + max(1000, 1200, 800)).</p><p>진행 상황을 보여주는 솔루션의 경우, 타임스탬프와 함께 중간 결과를 확인할 수도 있습니다.</p><p>해당 테스트 데이터는 <code>test/contributors/testData.kt</code>에 정의되어 있으며, <code>Request4SuspendKtTest</code>, <code>Request7ChannelsKtTest</code> 등은 모의 서비스 호출을 사용하는 간단한 테스트를 포함합니다.</p><p>그러나 여기에 두 가지 문제가 있습니다:</p><ul><li>이 테스트는 실행하는 데 너무 오래 걸립니다. 각 테스트는 약 2초에서 4초가 걸리며, 매번 결과를 기다려야 합니다. 효율적이지 않습니다.</li><li>코드를 준비하고 실행하는 데 추가 시간이 걸리기 때문에 솔루션이 실행되는 정확한 시간에 의존할 수 없습니다. 상수를 추가할 수는 있지만, 그러면 기계마다 시간이 다를 것입니다. 모의 서비스 지연은 이 상수보다 높아야 차이를 볼 수 있습니다. 만약 상수가 0.5초라면, 지연을 0.1초로 만드는 것은 충분하지 않을 것입니다.</li></ul><p>더 나은 방법은 특수 프레임워크를 사용하여 동일한 코드를 여러 번 실행하면서 타이밍을 테스트하는 것이지만(이는 총 시간을 더 증가시킵니다), 이는 배우고 설정하기에 복잡합니다.</p><p>이러한 문제를 해결하고 제공된 테스트 지연을 사용하여 솔루션이 예상대로 작동하는지, 즉 하나가 다른 것보다 빠른지 확인하려면 특수 테스트 디스패처를 사용하여 _가상 시간_을 사용하십시오. 이 디스패처는 시작 이후 경과된 가상 시간을 추적하고 모든 것을 실시간으로 즉시 실행합니다. 이 디스패처에서 코루틴을 실행하면 <code>delay</code>가 즉시 반환되고 가상 시간을 진행시킬 것입니다.</p><p>이 메커니즘을 사용하는 테스트는 빠르게 실행되지만, 가상 시간의 다른 순간에 무엇이 발생하는지 여전히 확인할 수 있습니다. 총 실행 시간은 급격히 감소합니다:</p><p><img src="`+_+`" alt="총 실행 시간 비교" width="700"></p><p>가상 시간을 사용하려면 <code>runBlocking</code> 호출을 <code>runTest</code>로 바꾸십시오. <code>runTest</code>는 <code>TestScope</code>에 대한 확장 람다를 인수로 받습니다. 이 특수 스코프 내에서 <code>suspend</code> 함수에서 <code>delay</code>를 호출하면 <code>delay</code>는 실제 시간으로 지연시키는 대신 가상 시간을 증가시킵니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testDelayInSuspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> realStartTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentTimeMillis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> virtualStartTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\${System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentTimeMillis</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> realStartTime} ms&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ~ 6 ms</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\${currentTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> virtualStartTime} ms&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)             </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1000 ms</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 지연 없이 자동 진행</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// foo()가 호출되면 즉시 실행</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>TestScope</code>의 <code>currentTime</code> 속성을 사용하여 현재 가상 시간을 확인할 수 있습니다.</p><p>이 예제에서 실제 실행 시간은 몇 밀리초인 반면, 가상 시간은 지연 인수와 동일한 1000 밀리초입니다.</p><p>자식 코루틴에서 &quot;가상&quot; <code>delay</code>의 완전한 효과를 얻으려면 모든 자식 코루틴을 <code>TestDispatcher</code>로 시작해야 합니다. 그렇지 않으면 작동하지 않습니다. 이 디스패처는 다른 디스패처를 제공하지 않는 한 다른 <code>TestScope</code>에서 자동으로 상속됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testDelayInLaunch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> realStartTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentTimeMillis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> virtualStartTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\${System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentTimeMillis</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> realStartTime} ms&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ~ 11 ms</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\${currentTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> virtualStartTime} ms&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)             </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1000 ms</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> coroutineScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 지연 없이 자동 진행</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// bar()가 호출되면 즉시 실행</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>위 예제에서 <code>launch</code>가 <code>Dispatchers.Default</code> 컨텍스트로 호출되면 테스트가 실패할 것입니다. 작업이 아직 완료되지 않았다는 예외가 발생할 것입니다.</p><p><code>loadContributorsConcurrent()</code> 함수를 이 방식으로 테스트할 수 있는 경우는, 자식 코루틴을 상속된 컨텍스트로 시작하고 <code>Dispatchers.Default</code> 디스패처를 사용하여 컨텍스트를 수정하지 않는 경우뿐입니다.</p><p>디스패처와 같은 컨텍스트 요소를 함수를 _정의_할 때가 아니라 _호출_할 때 지정할 수 있어, 더 유연하고 테스트하기 쉽습니다.</p><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>가상 시간을 지원하는 테스트 API는 <a href="/ko/kotlin/components-stability">실험적</a>이며 향후 변경될 수 있습니다.</p></div><p>기본적으로 컴파일러는 실험적인 테스트 API를 사용하면 경고를 표시합니다. 이러한 경고를 억제하려면 <code>@OptIn(ExperimentalCoroutinesApi::class)</code>로 테스트 함수 또는 테스트를 포함하는 전체 클래스에 어노테이션을 달아주십시오. 컴파일러에 실험적 API를 사용하고 있음을 지시하는 컴파일러 인수를 추가하십시오:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compileTestKotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    kotlinOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeCompilerArgs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;-Xuse-experimental=kotlin.Experimental&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 튜토리얼에 해당하는 프로젝트에서는 Gradle 스크립트에 컴파일러 인수가 이미 추가되어 있습니다.</p><h3 id="작업-8" tabindex="-1">작업 8 <a class="header-anchor" href="#작업-8" aria-label="Permalink to &quot;작업 8&quot;">​</a></h3><p><code>tests/tasks/</code>의 다음 테스트를 실제 시간 대신 가상 시간을 사용하도록 리팩터링하십시오:</p><ul><li>Request4SuspendKtTest.kt</li><li>Request5ConcurrentKtTest.kt</li><li>Request6ProgressKtTest.kt</li><li>Request7ChannelsKtTest.kt</li></ul><p>리팩터링 적용 전후의 총 실행 시간을 비교하십시오.</p>`,35)),s[28]||(s[28]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"작업-8-팁",tabindex:"-1"},[a("작업 8 팁 "),i("a",{class:"header-anchor",href:"#작업-8-팁","aria-label":'Permalink to "작업 8 팁 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[29]||(s[29]=n(`<ol><li><p><code>runBlocking</code> 호출을 <code>runTest</code>로 바꾸고, <code>System.currentTimeMillis()</code>를 <code>currentTime</code>으로 바꾸십시오:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // action</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> totalTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startTime</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // testing result</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>정확한 가상 시간을 확인하는 어설션을 주석 해제하십시오.</p></li><li><p><code>@UseExperimental(ExperimentalCoroutinesApi::class)</code>를 추가하는 것을 잊지 마십시오.</p></li></ol>`,1)),s[30]||(s[30]=i("h4",{"initial-collapse-state":"collapsed",collapsible:"true",id:"작업-8-솔루션",tabindex:"-1"},[a("작업 8 솔루션 "),i("a",{class:"header-anchor",href:"#작업-8-솔루션","aria-label":'Permalink to "작업 8 솔루션 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[31]||(s[31]=n(`<p>다음은 동시성 및 채널 경우에 대한 솔루션입니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadContributorsConcurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MockGithubService, testRequestData)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Assert.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">assertEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Wrong result for &#39;loadContributorsConcurrent&#39;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, expectedConcurrentResults.users, result)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> totalTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startTime</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Assert.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">assertEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;The calls run concurrently, so the total virtual time should be 2200 ms: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                &quot;1000 for repos request plus max(1000, 1200, 800) = 1200 for concurrent contributors requests)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        expectedConcurrentResults.timeFromStart, totalTime</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>먼저, 예상 가상 시간에 정확히 결과가 사용 가능한지 확인한 다음, 결과 자체를 확인합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testChannels</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    loadContributorsChannels</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MockGithubService, testRequestData) { users, _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> expected </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> concurrentProgressResults[index</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> time </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startTime</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Assert.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">assertEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            &quot;Expected intermediate results after \${expected.timeFromStart} ms:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            expected.timeFromStart, time</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Assert.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">assertEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Wrong intermediate results after </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$time</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, expected.users, users)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>채널을 사용하는 마지막 버전의 첫 번째 중간 결과는 진행 상황 버전보다 더 빨리 사용할 수 있으며, 가상 시간을 사용하는 테스트에서 차이를 볼 수 있습니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>나머지 &quot;suspend&quot; 및 &quot;progress&quot; 작업에 대한 테스트는 매우 유사합니다. 프로젝트의 <code>solutions</code> 브랜치에서 찾을 수 있습니다.</p></div><h2 id="다음-단계" tabindex="-1">다음 단계 <a class="header-anchor" href="#다음-단계" aria-label="Permalink to &quot;다음 단계&quot;">​</a></h2><ul><li>KotlinConf의 <a href="https://kotlinconf.com/workshops/" target="_blank" rel="noreferrer">Kotlin을 사용한 비동기 프로그래밍</a> 워크숍을 확인하십시오.</li><li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/" target="_blank" rel="noreferrer">가상 시간 및 실험적 테스트 패키지</a> 사용에 대해 자세히 알아보십시오.</li></ul>`,8))])}const H=T(S,[["render",P]]);export{V as __pageData,H as default};
