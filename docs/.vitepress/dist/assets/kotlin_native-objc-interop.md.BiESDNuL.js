import{_ as o,C as h,c as d,o as k,ag as a,G as e,j as i,w as l,a as t}from"./chunks/framework.Bksy39di.js";const F=JSON.parse('{"title":"与 Swift/Objective-C 的互操作性","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/native-objc-interop.md","filePath":"kotlin/native-objc-interop.md","lastUpdated":1754307826000}'),r={name:"kotlin/native-objc-interop.md"};function c(g,s,E,y,b,f){const n=h("tab"),p=h("tabs");return k(),d("div",null,[s[2]||(s[2]=a(`<h1 id="与-swift-objective-c-的互操作性" tabindex="-1">与 Swift/Objective-C 的互操作性 <a class="header-anchor" href="#与-swift-objective-c-的互操作性" aria-label="Permalink to &quot;与 Swift/Objective-C 的互操作性&quot;">​</a></h1><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Objective-C 库的导入功能目前处于 <a href="/kotlin/native-c-interop-stability">Beta</a> 阶段。 所有由 cinterop 工具从 Objective-C 库生成的 Kotlin 声明都应带有 <code>@ExperimentalForeignApi</code> 注解。 Kotlin/Native 附带的原生平台 库（例如 Foundation、UIKit 和 POSIX）仅对部分 API 要求选择启用。</p></div><p>Kotlin/Native 通过 Objective-C 提供与 Swift 的间接互操作。本文档涵盖了如何在 Swift/Objective-C 代码中使用 Kotlin 声明，以及如何在 Kotlin 代码中使用 Objective-C 声明。</p><p>你可能会发现以下其他资源很有用：</p><ul><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia" target="_blank" rel="noreferrer">Kotlin-Swift interopedia</a>，一个关于如何在 Swift 代码中使用 Kotlin 声明的示例集合。</li><li><a href="/kotlin/native-arc-integration">与 Swift/Objective-C ARC 集成</a> 部分，涵盖了 Kotlin 的跟踪 GC 与 Objective-C 的 ARC 之间集成的详细信息。</li></ul><h2 id="将-swift-objective-c-库导入-kotlin" tabindex="-1">将 Swift/Objective-C 库导入 Kotlin <a class="header-anchor" href="#将-swift-objective-c-库导入-kotlin" aria-label="Permalink to &quot;将 Swift/Objective-C 库导入 Kotlin&quot;">​</a></h2><p>Objective-C framework 和库如果正确导入到构建中（系统 framework 默认导入），就可以在 Kotlin 代码中使用。有关更多详细信息，请参见：</p><ul><li><a href="/kotlin/native-definition-file">创建并配置库定义文件</a></li><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-configure-compilations.html#configure-interop-with-native-languages" target="_blank" rel="noreferrer">配置原生 库的编译</a></li></ul><p>如果 Swift 库的 API 使用 <code>@objc</code> 导出到 Objective-C，则可以在 Kotlin 代码中使用。纯 Swift 模块尚不支持。</p><h2 id="在-swift-objective-c-中使用-kotlin" tabindex="-1">在 Swift/Objective-C 中使用 Kotlin <a class="header-anchor" href="#在-swift-objective-c-中使用-kotlin" aria-label="Permalink to &quot;在 Swift/Objective-C 中使用 Kotlin&quot;">​</a></h2><p>如果 Kotlin 模块编译成 framework，则可以在 Swift/Objective-C 代码中使用：</p><ul><li>请参阅 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-build-native-binaries.html#declare-binaries" target="_blank" rel="noreferrer">构建最终 原生 二进制文件</a> 以了解如何声明二进制文件。</li><li>请查看 <a href="https://github.com/Kotlin/kmm-basic-sample" target="_blank" rel="noreferrer">Kotlin Multiplatform 示例 项目</a> 获取示例。</li></ul><h3 id="从-objective-c-和-swift-隐藏-kotlin-声明" tabindex="-1">从 Objective-C 和 Swift 隐藏 Kotlin 声明 <a class="header-anchor" href="#从-objective-c-和-swift-隐藏-kotlin-声明" aria-label="Permalink to &quot;从 Objective-C 和 Swift 隐藏 Kotlin 声明&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>@HiddenFromObjC</code> 注解是<a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>，并且需要<a href="/kotlin/opt-in-requirements">选择启用</a>。</p></div><p>为了让你的 Kotlin 代码对 Swift/Objective-C 更友好，请使用 <code>@HiddenFromObjC</code> 注解来从 Objective-C 和 Swift 中隐藏 Kotlin 声明。它会禁用函数或属性导出到 Objective-C。</p><p>或者，你可以使用 <code>internal</code> 修饰符标记 Kotlin 声明，以限制它们在编译模块中的可见性。如果你想从 Objective-C 和 Swift 中隐藏 Kotlin 声明，同时又希望它对其他 Kotlin 模块可见，请使用 <code>@HiddenFromObjC</code>。</p><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/HiddenFromObjC.md" target="_blank" rel="noreferrer">在 Kotlin-Swift interopedia 中查看示例</a>。</p><h3 id="在-swift-中使用-refining" tabindex="-1">在 Swift 中使用 refining <a class="header-anchor" href="#在-swift-中使用-refining" aria-label="Permalink to &quot;在 Swift 中使用 refining&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>@ShouldRefineInSwift</code> 注解是<a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>，并且需要<a href="/kotlin/opt-in-requirements">选择启用</a>。</p></div><p><code>@ShouldRefineInSwift</code> 有助于将 Kotlin 声明替换为 Swift 编写的包装器。此注解在生成的 Objective-C API 中将函数或属性标记为 <code>swift_private</code>。此类声明会获得 <code>__</code> 前缀，这使得它们在 Swift 中不可见。</p><p>你仍然可以在 Swift 代码中使用这些声明来创建对 Swift 友好的 API，但它们不会在 Xcode 自动补全中被建议。</p><ul><li>有关在 Swift 中 refining Objective-C 声明的更多信息，请参阅 <a href="https://developer.apple.com/documentation/swift/improving-objective-c-api-declarations-for-swift" target="_blank" rel="noreferrer">官方 Apple 文档</a>。</li><li>有关如何使用 <code>@ShouldRefineInSwift</code> 注解的示例，请参阅 <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/ShouldRefineInSwift.md" target="_blank" rel="noreferrer">Kotlin-Swift interopedia</a>。</li></ul><h3 id="更改声明名称" tabindex="-1">更改声明名称 <a class="header-anchor" href="#更改声明名称" aria-label="Permalink to &quot;更改声明名称&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>@ObjCName</code> 注解是<a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>，并且需要<a href="/kotlin/opt-in-requirements">选择启用</a>。</p></div><p>为了避免重命名 Kotlin 声明，请使用 <code>@ObjCName</code> 注解。它指示 Kotlin 编译器为带注解的类、接口或任何其他 Kotlin 实体使用自定义的 Objective-C 和 Swift 名称：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@ObjCName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(swiftName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;MySwiftArray&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyKotlinArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @ObjCName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@ObjCName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;of&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) element: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TODO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Usage with the ObjCName annotations</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MySwiftArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(of: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;element&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/ObjCName.md" target="_blank" rel="noreferrer">在 Kotlin-Swift interopedia 中查看另一个示例</a>。</p><h3 id="使用-kdoc-注释提供文档" tabindex="-1">使用 KDoc 注释提供文档 <a class="header-anchor" href="#使用-kdoc-注释提供文档" aria-label="Permalink to &quot;使用 KDoc 注释提供文档&quot;">​</a></h3><p>文档对于理解任何 API 都至关重要。为共享的 Kotlin API 提供文档，使你能够就用法、注意事项等与用户进行沟通。</p><p>默认情况下，在生成 Objective-C 头文件时，<a href="/kotlin/kotlin-doc">KDocs</a> 注释不会被翻译成相应的注释。例如，以下带有 KDoc 的 Kotlin 代码：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Prints the sum of the arguments.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Properly handles the case when the sum doesn&#39;t fit in 32-bit integer.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLong</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b)</span></span></code></pre></div><p>将生成一个没有任何注释的 Objective-C 声明：</p><div class="language-objc vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">objc</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)printSumA:(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)a b:(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)b </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">swift_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;printSum(a:b:)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)));</span></span></code></pre></div><p>要启用 KDoc 注释的导出，请将以下编译器选项添加到你的 <code>build.gradle(.kts)</code> 中：</p>`,34)),e(p,{group:"build-script"},{default:l(()=>[e(n,{title:"Kotlin","group-key":"kotlin"},{default:l(()=>s[0]||(s[0]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),t(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    targets."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"withType"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"org"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"jetbrains"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"gradle"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"plugin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"mpp"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"KotlinNativeTarget"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"> {")]),t(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        compilations."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"get"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"main"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},").compilerOptions.options.freeCompilerArgs."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"add"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"-Xexport-kdoc"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")]),t(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),t(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),e(n,{title:"Groovy","group-key":"groovy"},{default:l(()=>s[1]||(s[1]=[i("div",{class:"language-groovy vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"groovy"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"kotlin {")]),t(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    targets"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"withType("),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTarget"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),t(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        compilations"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"get("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"main"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"compilerOptions"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"options"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"freeCompilerArgs"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"add("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"-Xexport-kdoc"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")]),t(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),t(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),s[3]||(s[3]=a(`<p>之后，Objective-C 头文件将包含相应的注释：</p><div class="language-objc vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">objc</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Prints the sum of the arguments.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Properly handles the case when the sum doesn&#39;t fit in 32-bit integer.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)printSumA:(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)a b:(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)b </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">swift_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;printSum(a:b:)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)));</span></span></code></pre></div><p>你将能够在自动补全中看到类和方法的注释，例如在 Xcode 中。如果你查看函数定义（在 <code>.h</code> 文件中），你将看到 <code>@param</code>、<code>@return</code> 等的注释。</p><p>已知限制：</p><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>将 KDoc 注释导出到生成的 Objective-C 头文件的能力是<a href="/kotlin/components-stability">实验性的</a>。它可能随时被放弃或更改。需要选择启用（详情见下文），并且你应仅将其用于评估目的。我们非常感谢你在 <a href="https://youtrack.com/issue/KT-38600" target="_blank" rel="noreferrer">YouTrack</a> 上提供反馈。</p></div><ul><li>依赖项文档不会被导出，除非它本身也使用 <code>-Xexport-kdoc</code> 编译。此特性是实验性的，因此使用此选项编译的库可能与其他编译器版本不兼容。</li><li>KDoc 注释大多按原样导出。许多 KDoc 特性，例如 <code>@property</code>，尚不支持。</li></ul><h2 id="映射" tabindex="-1">映射 <a class="header-anchor" href="#映射" aria-label="Permalink to &quot;映射&quot;">​</a></h2><p>下表展示了 Kotlin 概念如何映射到 Swift/Objective-C，反之亦然。</p><p>“-&gt;” 和 “&lt;-” 表示映射仅单向进行。</p><table tabindex="0"><thead><tr><th style="text-align:left;">Kotlin</th><th style="text-align:left;">Swift</th><th style="text-align:left;">Objective-C</th><th style="text-align:left;">Notes</th></tr></thead><tbody><tr><td style="text-align:left;"><code>class</code></td><td style="text-align:left;"><code>class</code></td><td style="text-align:left;"><code>@interface</code></td><td style="text-align:left;"><a href="#classes">备注</a></td></tr><tr><td style="text-align:left;"><code>interface</code></td><td style="text-align:left;"><code>protocol</code></td><td style="text-align:left;"><code>@protocol</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>constructor</code>/<code>create</code></td><td style="text-align:left;">Initializer</td><td style="text-align:left;">Initializer</td><td style="text-align:left;"><a href="#initializers">备注</a></td></tr><tr><td style="text-align:left;">Property</td><td style="text-align:left;">Property</td><td style="text-align:left;">Property</td><td style="text-align:left;"><a href="#top-level-functions-and-properties">备注 1</a>，<a href="#setters">备注 2</a></td></tr><tr><td style="text-align:left;">Method</td><td style="text-align:left;">Method</td><td style="text-align:left;">Method</td><td style="text-align:left;"><a href="#top-level-functions-and-properties">备注 1</a>，<a href="#method-names-translation">备注 2</a></td></tr><tr><td style="text-align:left;"><code>enum class</code></td><td style="text-align:left;"><code>class</code></td><td style="text-align:left;"><code>@interface</code></td><td style="text-align:left;"><a href="#enums">备注</a></td></tr><tr><td style="text-align:left;"><code>suspend</code> -&gt;</td><td style="text-align:left;"><code>completionHandler:</code>/ <code>async</code></td><td style="text-align:left;"><code>completionHandler:</code></td><td style="text-align:left;"><a href="#errors-and-exceptions">备注 1</a>，<a href="#suspending-functions">备注 2</a></td></tr><tr><td style="text-align:left;"><code>@Throws fun</code></td><td style="text-align:left;"><code>throws</code></td><td style="text-align:left;"><code>error:(NSError**)error</code></td><td style="text-align:left;"><a href="#errors-and-exceptions">备注</a></td></tr><tr><td style="text-align:left;">Extension</td><td style="text-align:left;">Extension</td><td style="text-align:left;">Category member</td><td style="text-align:left;"><a href="#extensions-and-category-members">备注</a></td></tr><tr><td style="text-align:left;"><code>companion</code> member &lt;-</td><td style="text-align:left;">Class method or property</td><td style="text-align:left;">Class method or property</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>null</code></td><td style="text-align:left;"><code>nil</code></td><td style="text-align:left;"><code>nil</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>Singleton</code></td><td style="text-align:left;"><code>shared</code> or <code>companion</code> property</td><td style="text-align:left;"><code>shared</code> or <code>companion</code> property</td><td style="text-align:left;"><a href="#kotlin-singletons">备注</a></td></tr><tr><td style="text-align:left;">Primitive type</td><td style="text-align:left;">Primitive type / <code>NSNumber</code></td><td style="text-align:left;"></td><td style="text-align:left;"><a href="#primitive-types">备注</a></td></tr><tr><td style="text-align:left;"><code>Unit</code> return type</td><td style="text-align:left;"><code>Void</code></td><td style="text-align:left;"><code>void</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>String</code></td><td style="text-align:left;"><code>String</code></td><td style="text-align:left;"><code>NSString</code></td><td style="text-align:left;"><a href="#strings">备注</a></td></tr><tr><td style="text-align:left;"><code>String</code></td><td style="text-align:left;"><code>NSMutableString</code></td><td style="text-align:left;"><code>NSMutableString</code></td><td style="text-align:left;"><a href="#nsmutablestring">备注</a></td></tr><tr><td style="text-align:left;"><code>List</code></td><td style="text-align:left;"><code>Array</code></td><td style="text-align:left;"><code>NSArray</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>MutableList</code></td><td style="text-align:left;"><code>NSMutableArray</code></td><td style="text-align:left;"><code>NSMutableArray</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>Set</code></td><td style="text-align:left;"><code>Set</code></td><td style="text-align:left;"><code>NSSet</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>MutableSet</code></td><td style="text-align:left;"><code>NSMutableSet</code></td><td style="text-align:left;"><code>NSMutableSet</code></td><td style="text-align:left;"><a href="#collections">备注</a></td></tr><tr><td style="text-align:left;"><code>Map</code></td><td style="text-align:left;"><code>Dictionary</code></td><td style="text-align:left;"><code>NSDictionary</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>MutableMap</code></td><td style="text-align:left;"><code>NSMutableDictionary</code></td><td style="text-align:left;"><code>NSMutableDictionary</code></td><td style="text-align:left;"><a href="#collections">备注</a></td></tr><tr><td style="text-align:left;">Function type</td><td style="text-align:left;">Function type</td><td style="text-align:left;">Block pointer type</td><td style="text-align:left;"><a href="#function-types">备注</a></td></tr><tr><td style="text-align:left;">Inline classes</td><td style="text-align:left;">Unsupported</td><td style="text-align:left;">Unsupported</td><td style="text-align:left;"><a href="#unsupported">备注</a></td></tr></tbody></table><h3 id="类" tabindex="-1">类 <a class="header-anchor" href="#类" aria-label="Permalink to &quot;类&quot;">​</a></h3><h4 id="名称翻译" tabindex="-1">名称翻译 <a class="header-anchor" href="#名称翻译" aria-label="Permalink to &quot;名称翻译&quot;">​</a></h4><p>Objective-C 类会以其原始名称导入到 Kotlin。协议（Protocols）会以 <code>Protocol</code> 名称后缀作为接口（interfaces）导入，例如 <code>@protocol Foo</code> -&gt; <code>interface FooProtocol</code>。 这些类和接口被放置在 <a href="#importing-swift-objective-c-libraries-to-kotlin">构建配置中指定的</a> 包中（预配置的系统 framework 使用 <code>platform.*</code> 包）。</p><p>当 Kotlin 类和接口导入到 Objective-C 时，它们的名称会被加上前缀。该前缀派生自 framework 名称。</p><p>Objective-C 不支持 framework 中的包。如果 Kotlin 编译器发现同一 framework 中存在同名但包不同的 Kotlin 类，它会对其进行重命名。此算法尚不稳定，并且可能在 Kotlin 版本之间发生变化。为了解决这个问题，你可以在 framework 中重命名冲突的 Kotlin 类。</p><h4 id="强链接" tabindex="-1">强链接 <a class="header-anchor" href="#强链接" aria-label="Permalink to &quot;强链接&quot;">​</a></h4><p>无论何时你在 Kotlin 源代码中使用 Objective-C 类，它都会被标记为强链接符号。生成的构建构件将相关符号列为强外部引用。</p><p>这意味着应用程序在启动时会尝试动态链接符号，如果它们不可用，应用程序就会崩溃。即使符号从未被使用过，也会发生崩溃。符号可能在特定设备或操作系统版本上不可用。</p><p>为了解决这个问题并避免“Symbol not found”错误，请使用一个 Swift 或 Objective-C 包装器来检测该类是否实际可用。<a href="https://github.com/JetBrains/compose-multiplatform-core/pull/1278/files" target="_blank" rel="noreferrer">请参阅 Compose Multiplatform framework 中如何实现此 workaround 的示例</a>。</p><h3 id="初始化器" tabindex="-1">初始化器 <a class="header-anchor" href="#初始化器" aria-label="Permalink to &quot;初始化器&quot;">​</a></h3><p>Swift/Objective-C 初始化器导入到 Kotlin 时，会作为构造函数或名为 <code>create</code> 的工厂方法。后者发生在 Objective-C 类别或 Swift 扩展中声明的初始化器，因为 Kotlin 没有扩展构造函数的概念。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在将 Swift 初始化器导入 Kotlin 之前，别忘了用 <code>@objc</code> 注解它们。</p></div><p>Kotlin 构造函数会作为初始化器导入到 Swift/Objective-C。</p><h3 id="setter" tabindex="-1">Setter <a class="header-anchor" href="#setter" aria-label="Permalink to &quot;Setter&quot;">​</a></h3><p>可写的 Objective-C 属性覆盖超类的只读属性时，会以属性 <code>foo</code> 的 <code>setFoo()</code> 方法形式呈现。协议的只读属性如果被实现为可变，也同样如此。</p><h3 id="顶层函数和属性" tabindex="-1">顶层函数和属性 <a class="header-anchor" href="#顶层函数和属性" aria-label="Permalink to &quot;顶层函数和属性&quot;">​</a></h3><p>顶层 Kotlin 函数和属性可作为特殊类的成员访问。每个 Kotlin 文件都会被翻译成这样一个类，例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// MyLibraryUtils.kt</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> my.library</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span></code></pre></div><p>然后你可以像这样从 Swift 调用 <code>foo()</code> 函数：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyLibraryUtilsKt.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>在 Kotlin-Swift interopedia 中查看访问顶层 Kotlin 声明的示例集合：</p><ul><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/Top-level%20functions.md" target="_blank" rel="noreferrer">顶层函数</a></li><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/functionsandproperties/Top-level%20val%20properties.md" target="_blank" rel="noreferrer">顶层只读属性</a></li><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/functionsandproperties/Top-level%20mutable%20var%20properties.md" target="_blank" rel="noreferrer">顶层可变属性</a></li></ul><h3 id="方法名称翻译" tabindex="-1">方法名称翻译 <a class="header-anchor" href="#方法名称翻译" aria-label="Permalink to &quot;方法名称翻译&quot;">​</a></h3><p>通常，Swift 实参标签和 Objective-C 选择器片段会映射到 Kotlin 形参名称。这两个概念具有不同的语义，因此有时 Swift/Objective-C 方法导入时可能与 Kotlin 签名冲突。 在这种情况下，可以使用命名实参从 Kotlin 调用冲突的方法，例如：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[player moveTo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LEFT byMeters</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[player moveTo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UP byInches</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>在 Kotlin 中，它表示为：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">player.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">moveTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(LEFT, byMeters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">player.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">moveTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UP, byInches </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>以下是 <code>kotlin.Any</code> 函数如何映射到 Swift/Objective-C 的方式：</p><table tabindex="0"><thead><tr><th style="text-align:left;">Kotlin</th><th style="text-align:left;">Swift</th><th style="text-align:left;">Objective-C</th></tr></thead><tbody><tr><td style="text-align:left;"><code>equals()</code></td><td style="text-align:left;"><code>isEquals(_:)</code></td><td style="text-align:left;"><code>isEquals:</code></td></tr><tr><td style="text-align:left;"><code>hashCode()</code></td><td style="text-align:left;"><code>hash</code></td><td style="text-align:left;"><code>hash</code></td></tr><tr><td style="text-align:left;"><code>toString()</code></td><td style="text-align:left;"><code>description</code></td><td style="text-align:left;"><code>description</code></td></tr></tbody></table><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Data%20classes.md" target="_blank" rel="noreferrer">在 Kotlin-Swift interopedia 中查看数据类的示例</a>。</p><p>你可以在 Swift 或 Objective-C 中指定一个更符合惯用法的名称，而不是使用 <a href="#change-declaration-names"><code>@ObjCName</code> 注解</a> 重命名 Kotlin 声明。</p><h3 id="错误与异常" tabindex="-1">错误与异常 <a class="header-anchor" href="#错误与异常" aria-label="Permalink to &quot;错误与异常&quot;">​</a></h3><p>所有 Kotlin 异常都是非检查型的，这意味着错误在运行时捕获。然而，Swift 只有在编译期处理的检查型错误。因此，如果 Swift 或 Objective-C 代码调用抛出异常的 Kotlin 方法，该 Kotlin 方法应使用 <code>@Throws</code> 注解标记，并指定“预期”异常类的列表。</p><p>当编译到 Swift/Objective-C framework 时，带有或继承 <code>@Throws</code> 注解的非 <code>suspend</code> 函数在 Objective-C 中表示为生成 <code>NSError*</code> 的方法，在 Swift 中表示为 <code>throws</code> 方法。<code>suspend</code> 函数的表示总是在 completion handler 中包含 <code>NSError*</code>/<code>Error</code> 形参。</p><p>当从 Swift/Objective-C 代码调用的 Kotlin 函数抛出属于 <code>@Throws</code> 指定类或其子类的异常实例时，该异常将作为 <code>NSError</code> 传播。其他到达 Swift/Objective-C 的 Kotlin 异常被视为未处理，并导致程序终止。</p><p>不带 <code>@Throws</code> 的 <code>suspend</code> 函数只传播 <code>CancellationException</code>（作为 <code>NSError</code>）。不带 <code>@Throws</code> 的非 <code>suspend</code> 函数则根本不传播 Kotlin 异常。</p><p>请注意，相反的逆向翻译尚未实现：Swift/Objective-C 的错误抛出方法不会作为异常抛出方法导入到 Kotlin。</p><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/Exceptions.md" target="_blank" rel="noreferrer">在 Kotlin-Swift interopedia 中查看示例</a>。</p><h3 id="枚举" tabindex="-1">枚举 <a class="header-anchor" href="#枚举" aria-label="Permalink to &quot;枚举&quot;">​</a></h3><p>Kotlin 枚举导入到 Objective-C 时作为 <code>@interface</code>，导入到 Swift 时作为 <code>class</code>。这些数据结构具有与每个枚举值对应的属性。考虑这段 Kotlin 代码：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Colors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RED, GREEN, BLUE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>你可以从 Swift 中访问此枚举类的属性，如下所示：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Swift</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Colors.red</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Colors.green</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Colors.blue</span></span></code></pre></div><p>要在 Swift <code>switch</code> 语句中使用 Kotlin 枚举的变量，请提供一个 default 语句以防止编译错误：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> color {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .red</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;It&#39;s red&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .green</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;It&#39;s green&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .blue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;It&#39;s blue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    default:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fatalError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;No such color&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Enum%20classes.md" target="_blank" rel="noreferrer">在 Kotlin-Swift interopedia 中查看另一个示例</a>。</p><h3 id="挂起函数" tabindex="-1">挂起函数 <a class="header-anchor" href="#挂起函数" aria-label="Permalink to &quot;挂起函数&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>从 Swift 代码调用 <code>suspend</code> 函数作为 <code>async</code> 的支持是<a href="/kotlin/components-stability">实验性的</a>。它可能随时被放弃或更改。请仅将其用于评估目的。我们非常感谢你在 <a href="https://youtrack.com/issue/KT-47610" target="_blank" rel="noreferrer">YouTrack</a> 上提供反馈。</p></div><p>Kotlin 的<a href="/kotlin/coroutines-basics">挂起函数</a> (<code>suspend</code>) 在生成的 Objective-C 头文件中呈现为带回调的函数，或 Swift/Objective-C 术语中的<a href="https://developer.apple.com/documentation/swift/calling_objective-c_apis_asynchronously" target="_blank" rel="noreferrer">完成处理程序</a>。</p><p>从 Swift 5.5 开始，Kotlin 的 <code>suspend</code> 函数也可以作为 <code>async</code> 函数从 Swift 调用，而无需使用完成处理程序。目前，此功能是高度实验性的，并且存在某些限制。有关详细信息，请参阅<a href="https://youtrack.com/issue/KT-47610" target="_blank" rel="noreferrer">此 YouTrack issue</a>。</p><ul><li>了解更多关于 Swift 文档中的 <a href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html" target="_blank" rel="noreferrer"><code>async</code>/<code>await</code> 机制</a>。</li><li>在 <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/coroutines/Suspend%20functions.md" target="_blank" rel="noreferrer">Kotlin-Swift interopedia</a> 中查看实现相同功能的第三方库的示例和建议。</li></ul><h3 id="扩展和类别成员" tabindex="-1">扩展和类别成员 <a class="header-anchor" href="#扩展和类别成员" aria-label="Permalink to &quot;扩展和类别成员&quot;">​</a></h3><p>Objective-C 类别和 Swift 扩展的成员通常作为扩展导入到 Kotlin。这就是为什么这些声明不能在 Kotlin 中被覆盖，并且扩展初始化器不能作为 Kotlin 构造函数使用。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>目前有两个例外。从 Kotlin 1.8.20 开始，与 NSView 类（来自 AppKit framework）或 UIView 类（来自 UIKit framework）在同一头文件中声明的类别成员将作为这些类的成员导入。这意味着你可以覆盖从 NSView 或 UIView 子类化的方法。</p></div><p>Kotlin 对“常规”Kotlin 类的扩展会分别作为扩展和类别成员导入到 Swift 和 Objective-C。Kotlin 对其他类型的扩展被视为带有额外接收者形参的<a href="#top-level-functions-and-properties">顶层声明</a>。这些类型包括：</p><ul><li>Kotlin <code>String</code> 类型</li><li>Kotlin 集合类型和子类型</li><li>Kotlin <code>interface</code> 类型</li><li>Kotlin 原生类型</li><li>Kotlin <code>inline</code> 类</li><li>Kotlin <code>Any</code> 类型</li><li>Kotlin 函数类型和子类型</li><li>Objective-C 类和协议</li></ul><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/tree/main/docs/extensions" target="_blank" rel="noreferrer">在 Kotlin-Swift interopedia 中查看示例集合</a>。</p><h3 id="kotlin-单例" tabindex="-1">Kotlin 单例 <a class="header-anchor" href="#kotlin-单例" aria-label="Permalink to &quot;Kotlin 单例&quot;">​</a></h3><p>Kotlin 单例（通过 <code>object</code> 声明创建，包括 <code>companion object</code>）导入到 Swift/Objective-C 时，会作为具有单个实例的类。</p><p>该实例通过 <code>shared</code> 和 <code>companion</code> 属性可用。</p><p>对于以下 Kotlin 代码：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">object</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Some value&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    companion</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Some value&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>按如下方式访问这些对象：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyObject.shared</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyObject.shared.x</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyClass.companion</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyClass.Companion.shared</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>在 Objective-C 中通过 <code>[MySingleton mySingleton]</code> 以及在 Swift 中通过 <code>MySingleton()</code> 访问对象的方式已被弃用。</p></div><p>在 Kotlin-Swift interopedia 中查看更多示例：</p><ul><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Objects.md" target="_blank" rel="noreferrer">如何使用 <code>shared</code> 访问 Kotlin 对象</a></li><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Companion%20objects.md" target="_blank" rel="noreferrer">如何从 Swift 访问 Kotlin companion object 的成员</a>。</li></ul><h3 id="原生类型" tabindex="-1">原生类型 <a class="header-anchor" href="#原生类型" aria-label="Permalink to &quot;原生类型&quot;">​</a></h3><p>Kotlin 原生类型包装器映射到特殊的 Swift/Objective-C 类。例如，<code>kotlin.Int</code> 包装器在 Swift 中表示为 <code>KotlinInt</code> 类实例（或在 Objective-C 中表示为 <code>\${prefix}Int</code> 实例，其中 <code>prefix</code> 是 framework 的名称前缀）。这些类派生自 <code>NSNumber</code>，因此这些实例是支持所有相应操作的 <code>NSNumber</code>。</p><p>当 <code>NSNumber</code> 类型用作 Swift/Objective-C 形参类型或返回值时，它不会自动转换为 Kotlin 原生类型。原因是 <code>NSNumber</code> 类型没有提供足够关于包装的原生值类型的信息，例如，<code>NSNumber</code> 在静态上不确定是 <code>Byte</code>、<code>Boolean</code> 还是 <code>Double</code>。因此，Kotlin 原生值应<a href="#casting-between-mapped-types">手动与 <code>NSNumber</code> 之间进行类型转换</a>。</p><h3 id="字符串" tabindex="-1">字符串 <a class="header-anchor" href="#字符串" aria-label="Permalink to &quot;字符串&quot;">​</a></h3><p>当 Kotlin <code>String</code> 传递给 Swift 时，它首先作为 Objective-C 对象导出，然后 Swift 编译器会再次复制它以进行 Swift 转换。这会导致额外的运行时开销。</p><p>为了避免这种情况，请直接在 Swift 中将 Kotlin 字符串作为 Objective-C <code>NSString</code> 访问。 <a href="#see-the-conversion-example">查看转换示例</a>。</p><h4 id="nsmutablestring" tabindex="-1"><code>NSMutableString</code> <a class="header-anchor" href="#nsmutablestring" aria-label="Permalink to &quot;\`NSMutableString\`&quot;">​</a></h4><p><code>NSMutableString</code> Objective-C 类在 Kotlin 中不可用。<code>NSMutableString</code> 的所有实例在传递给 Kotlin 时都会被复制。</p><h3 id="集合" tabindex="-1">集合 <a class="header-anchor" href="#集合" aria-label="Permalink to &quot;集合&quot;">​</a></h3><h4 id="kotlin-objective-c-swift" tabindex="-1">Kotlin -&gt; Objective-C -&gt; Swift <a class="header-anchor" href="#kotlin-objective-c-swift" aria-label="Permalink to &quot;Kotlin -&gt; Objective-C -&gt; Swift&quot;">​</a></h4><p>当 Kotlin 集合传递给 Swift 时，它首先转换为 Objective-C 等效类型，然后 Swift 编译器复制整个集合并将其转换为 Swift 原生集合，如<a href="#mappings">映射表</a> 中所述。</p><p>最后这种转换会导致性能开销。为防止这种情况，在 Swift 中使用 Kotlin 集合时，请将其显式转换为其 Objective-C 对应类型：<code>NSDictionary</code>、<code>NSArray</code> 或 <code>NSSet</code>。</p>`,89)),s[4]||(s[4]=i("h5",{"initial-collapse-state":"collapsed",collapsible:"true",id:"查看转换示例",tabindex:"-1"},[t("查看转换示例 "),i("a",{class:"header-anchor",href:"#查看转换示例","aria-label":'Permalink to "查看转换示例 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[5]||(s[5]=a(`<p>例如，以下 Kotlin 声明：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> map: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>在 Swift 中，可能看起来像这样：</p><div class="language-Swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map[key]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ??</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre></div><p>在这里，<code>map</code> 会隐式转换为 Swift 的 <code>Dictionary</code>，其字符串值会映射到 Swift 的 <code>String</code>。这会导致性能开销。</p><p>为了避免这种转换，请将 <code>map</code> 显式转换为 Objective-C 的 <code>NSDictionary</code>，并以 <code>NSString</code> 形式访问值：</p><div class="language-Swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsMap: NSDictionary </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> map </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NSDictionary</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nsMap[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NSString)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">??</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre></div><p>这确保了 Swift 编译器不会执行额外的转换步骤。</p><h4 id="swift-objective-c-kotlin" tabindex="-1">Swift -&gt; Objective-C -&gt; Kotlin <a class="header-anchor" href="#swift-objective-c-kotlin" aria-label="Permalink to &quot;Swift -&gt; Objective-C -&gt; Kotlin&quot;">​</a></h4><p>Swift/Objective-C 集合映射到 Kotlin 的方式如<a href="#mappings">映射表</a> 所述，但 <code>NSMutableSet</code> 和 <code>NSMutableDictionary</code> 除外。</p><p><code>NSMutableSet</code> 不会转换为 Kotlin 的 <code>MutableSet</code>。要将对象传递到 Kotlin <code>MutableSet</code>，请显式创建这种 Kotlin 集合。为此，例如，可以在 Kotlin 中使用 <code>mutableSetOf()</code> 函数，或者在 Swift 中使用 <code>KotlinMutableSet</code> 类，以及在 Objective-C 中使用 <code>\${prefix}MutableSet</code>（<code>prefix</code> 是 framework 名称前缀）。<code>MutableMap</code> 也是如此。</p><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/Collections.md" target="_blank" rel="noreferrer">在 Kotlin-Swift interopedia 中查看示例</a>。</p><h3 id="函数类型" tabindex="-1">函数类型 <a class="header-anchor" href="#函数类型" aria-label="Permalink to &quot;函数类型&quot;">​</a></h3><p>Kotlin 函数类型对象（例如 lambda 表达式）在 Swift 中转换为函数，在 Objective-C 中转换为 block。 <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/functionsandproperties/Functions%20returning%20function%20type.md" target="_blank" rel="noreferrer">在 Kotlin-Swift interopedia 中查看带有 lambda 的 Kotlin 函数示例</a>。</p><p>然而，在翻译函数和函数类型时，形参和返回值的类型映射方式有所不同。在后一种情况下，原生类型会映射到它们的包装表示。Kotlin <code>Unit</code> 返回值在 Swift/Objective-C 中表示为相应的 <code>Unit</code> 单例。此单例的值可以像任何其他 Kotlin <code>object</code> 一样获取。请参见<a href="#mappings">上表</a> 中的单例。</p><p>考虑以下 Kotlin 函数：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span></code></pre></div><p>它在 Swift 中的表示如下：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (KotlinInt) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KotlinUnit)</span></span></code></pre></div><p>你可以像这样调用它：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Int32)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> KotlinUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="泛型" tabindex="-1">泛型 <a class="header-anchor" href="#泛型" aria-label="Permalink to &quot;泛型&quot;">​</a></h3><p>Objective-C 支持在类中定义的“轻量级泛型”，其特性集相对有限。Swift 可以导入在类中定义的泛型，以帮助为编译器提供额外的类型信息。</p><p>Objective-C 和 Swift 对泛型特性的支持与 Kotlin 不同，因此翻译不可避免地会丢失一些信息，但支持的特性仍保留有意义的信息。</p><p>有关如何在 Swift 中使用 Kotlin 泛型的具体示例，请参阅 <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/ShouldRefineInSwift.md" target="_blank" rel="noreferrer">Kotlin-Swift interopedia</a>。</p><h4 id="限制" tabindex="-1">限制 <a class="header-anchor" href="#限制" aria-label="Permalink to &quot;限制&quot;">​</a></h4><p>Objective-C 泛型不支持 Kotlin 或 Swift 的所有特性，因此在翻译过程中会丢失一些信息。</p><p>泛型只能在类上定义，不能在接口（Objective-C 和 Swift 中的协议）或函数上定义。</p><h4 id="可空性" tabindex="-1">可空性 <a class="header-anchor" href="#可空性" aria-label="Permalink to &quot;可空性&quot;">​</a></h4><p>Kotlin 和 Swift 都将可空性定义为类型规范的一部分，而 Objective-C 则在方法的类型及其属性上定义可空性。因此，以下 Kotlin 代码：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在 Swift 中看起来像这样：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fun </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">myVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>为了支持可能的可空类型，Objective-C 头文件需要使用可空返回值来定义 <code>myVal</code>。</p><p>为了缓解这种情况，在定义泛型类时，如果泛型类型_绝不_可空，请提供一个非空类型约束：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这将强制 Objective-C 头文件将 <code>myVal</code> 标记为非空的。</p><h4 id="型变" tabindex="-1">型变 <a class="header-anchor" href="#型变" aria-label="Permalink to &quot;型变&quot;">​</a></h4><p>Objective-C 允许泛型被声明为协变或逆变。Swift 不支持型变。来自 Objective-C 的泛型类可以根据需要进行强制类型转换。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BaseData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GenVarOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">out</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arg: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> variOut </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GenVarOut</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SomeData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: sd)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> variOutAny : GenVarOut&lt;BaseData&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> variOut </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GenVarOut</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BaseData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><h4 id="约束" tabindex="-1">约束 <a class="header-anchor" href="#约束" aria-label="Permalink to &quot;约束&quot;">​</a></h4><p>在 Kotlin 中，你可以为泛型类型提供上界。Objective-C 也支持这一点，但在更复杂的情况下此支持不可用，并且目前在 Kotlin - Objective-C 互操作中也不支持。这里的例外是，一个非空的上界会使 Objective-C 方法/属性变为非空的。</p><h4 id="禁用" tabindex="-1">禁用 <a class="header-anchor" href="#禁用" aria-label="Permalink to &quot;禁用&quot;">​</a></h4><p>要生成不含泛型的 framework 头文件，请在你的构建文件中添加以下编译器选项：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">binaries.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">framework</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    freeCompilerArgs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;-Xno-objc-generics&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="前向声明" tabindex="-1">前向声明 <a class="header-anchor" href="#前向声明" aria-label="Permalink to &quot;前向声明&quot;">​</a></h3><p>要导入前向声明，请使用 <code>objcnames.classes</code> 和 <code>objcnames.protocols</code> 包。例如，要导入 Objective-C 库中 <code>library.package</code> 声明的 <code>objcprotocolName</code> 前向声明，请使用特殊的前向声明包：<code>import objcnames.protocols.objcprotocolName</code>。</p><p>考虑两个 objcinterop 库：一个使用 <code>objcnames.protocols.ForwardDeclaredProtocolProtocol</code>，另一个在不同的包中具有实际实现：</p><div class="language-ObjC vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ObjC</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// First objcinterop library</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;Foundation/Foundation.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@protocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredProtocol;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NSString</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> consumeProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;ForwardDeclaredProtocol&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NSString</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> stringWithUTF8String:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Protocol&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-ObjC vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ObjC</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Second objcinterop library</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Header:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;Foundation/Foundation.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@protocol</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ForwardDeclaredProtocol</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@end</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Implementation:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ForwardDeclaredProtocolImpl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NSObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;ForwardDeclaredProtocol&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;ForwardDeclaredProtocol&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">produceProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ForwardDeclaredProtocolImpl </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>要在两个库之间传输对象，请在你的 Kotlin 代码中使用显式 <code>as</code> 类型转换：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin code:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    consumeProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">produceProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> objcnames.protocols.ForwardDeclaredProtocolProtocol)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>你只能从相应的实际类转换为 <code>objcnames.protocols.ForwardDeclaredProtocolProtocol</code>。否则，你将收到错误。</p></div><h2 id="映射类型之间的类型转换" tabindex="-1">映射类型之间的类型转换 <a class="header-anchor" href="#映射类型之间的类型转换" aria-label="Permalink to &quot;映射类型之间的类型转换&quot;">​</a></h2><p>在编写 Kotlin 代码时，一个对象可能需要从 Kotlin 类型转换为等效的 Swift/Objective-C 类型（反之亦然）。在这种情况下，可以使用普通的 Kotlin 类型转换，例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NSArray</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsString </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsNumber </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NSNumber</span></span></code></pre></div><h2 id="子类化" tabindex="-1">子类化 <a class="header-anchor" href="#子类化" aria-label="Permalink to &quot;子类化&quot;">​</a></h2><h3 id="从-swift-objective-c-子类化-kotlin-类和接口" tabindex="-1">从 Swift/Objective-C 子类化 Kotlin 类和接口 <a class="header-anchor" href="#从-swift-objective-c-子类化-kotlin-类和接口" aria-label="Permalink to &quot;从 Swift/Objective-C 子类化 Kotlin 类和接口&quot;">​</a></h3><p>Kotlin 类和接口可以被 Swift/Objective-C 类和协议子类化。</p><h3 id="从-kotlin-子类化-swift-objective-c-类和协议" tabindex="-1">从 Kotlin 子类化 Swift/Objective-C 类和协议 <a class="header-anchor" href="#从-kotlin-子类化-swift-objective-c-类和协议" aria-label="Permalink to &quot;从 Kotlin 子类化 Swift/Objective-C 类和协议&quot;">​</a></h3><p>Swift/Objective-C 类和协议可以被 Kotlin 的 <code>final</code> 类子类化。继承 Swift/Objective-C 类型的非 <code>final</code> Kotlin 类尚不支持，因此无法声明继承 Swift/Objective-C 类型的复杂类层次结构。</p><p>可以使用 Kotlin 的 <code>override</code> 关键字覆盖普通方法。在这种情况下，覆盖方法必须与被覆盖方法具有相同的形参名称。</p><p>有时需要覆盖初始化器，例如在子类化 <code>UIViewController</code> 时。作为 Kotlin 构造函数导入的初始化器可以被标记有 <code>@OverrideInit</code> 注解的 Kotlin 构造函数覆盖：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ViewController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UIViewController </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @OverrideInit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">coder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: NSCoder) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coder)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>覆盖构造函数必须与被覆盖构造函数具有相同的形参名称和类型。</p><p>为了覆盖具有冲突 Kotlin 签名的不同方法，你可以将 <code>@ObjCSignatureOverride</code> 注解添加到类中。当从 Objective-C 类继承的多个函数具有相同的实参类型但不同的实参名称时，此注解指示 Kotlin 编译器忽略冲突的重载。</p><p>默认情况下，Kotlin/Native 编译器不允许将非指定 Objective-C 初始化器作为 <code>super()</code> 构造函数调用。如果 Objective-C 库中没有正确标记指定初始化器，则此行为可能会造成不便。要禁用这些编译器检查，请将 <code>disableDesignatedInitializerChecks = true</code> 添加到库的 <a href="/kotlin/native-definition-file"><code>.def</code> 文件</a> 中。</p><h2 id="c-特性" tabindex="-1">C 特性 <a class="header-anchor" href="#c-特性" aria-label="Permalink to &quot;C 特性&quot;">​</a></h2><p>有关库使用一些纯 C 特性（例如不安全指针、结构体等）的示例情况，请参阅<a href="/kotlin/native-c-interop">与 C 的互操作性</a>。</p><h2 id="不支持的特性" tabindex="-1">不支持的特性 <a class="header-anchor" href="#不支持的特性" aria-label="Permalink to &quot;不支持的特性&quot;">​</a></h2><p>Kotlin 编程语言的一些特性尚未映射到 Objective-C 或 Swift 的相应特性中。目前，以下特性未在生成的 framework 头文件中正确公开：</p><ul><li>内联类（实参映射为底层原生类型或 <code>id</code>）</li><li>实现标准 Kotlin 集合接口（<code>List</code>、<code>Map</code>、<code>Set</code>）及其他特殊类的自定义类</li><li>Objective-C 类的 Kotlin 子类</li></ul>`,73))])}const v=o(r,[["render",c]]);export{F as __pageData,v as default};
