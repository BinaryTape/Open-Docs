import{_ as e}from"./chunks/icon-1-done.ZX9lW-aj.js";import{_ as r}from"./chunks/icon-2-done.DCMUaFG5.js";import{_ as o}from"./chunks/icon-3.BwKvTetO.js";import{_ as d}from"./chunks/icon-4-todo.GaeEmerm.js";import{_ as E,C as h,c as g,o as c,j as s,G as t,ag as n,a,w as l}from"./chunks/framework.Bksy39di.js";const x=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/mapping-function-pointers-from-c.md","filePath":"kotlin/mapping-function-pointers-from-c.md","lastUpdated":1754307826000}'),y={name:"kotlin/mapping-function-pointers-from-c.md"};function F(u,i,C,m,f,A){const k=h("tldr"),p=h("shortcut");return c(),g("div",null,[i[10]||(i[10]=s("h1",{id:"映射-c-函数指针-–-教程",tabindex:"-1"},[a("映射 C 函数指针 – 教程 "),s("a",{class:"header-anchor",href:"#映射-c-函数指针-–-教程","aria-label":'Permalink to "映射 C 函数指针 – 教程"'},"​")],-1)),t(k,null,{default:l(()=>i[0]||(i[0]=[s("p",null,[a("这是 "),s("strong",null,"Kotlin 与 C 的映射"),a(" 教程系列的第三部分。在继续之前，请确保你已完成前面步骤。")],-1),s("p",null,[s("img",{src:e,width:"20",alt:"第一步"}),a(),s("a",{href:"/kotlin/mapping-primitive-data-types-from-c"},"映射 C 原生数据类型"),s("br"),s("img",{src:r,width:"20",alt:"第二步"}),a(),s("a",{href:"/kotlin/mapping-struct-union-types-from-c"},"映射 C 结构体与联合类型"),s("br"),s("img",{src:o,width:"20",alt:"第三步"}),a(),s("strong",null,"映射函数指针"),s("br"),s("img",{src:d,width:"20",alt:"第四步"}),a(),s("a",{href:"/kotlin/mapping-strings-from-c"},"映射 C 字符串"),s("br")],-1)])),_:1}),i[11]||(i[11]=n(`<div class="note custom-block"><p class="custom-block-title">NOTE</p><p>C 库导入处于 <a href="/kotlin/native-c-interop-stability">Beta</a> 阶段。所有由 cinterop 工具从 C 库生成的 Kotlin 声明都应具有 <code>@ExperimentalForeignApi</code> 注解。 随 Kotlin/Native 附带的原生平台库（例如 Foundation、UIKit 和 POSIX）仅对部分 API 需要显式选择启用 (opt-in)。</p></div><p>让我们探究从 Kotlin 中哪些 C 函数指针可见，并检查 Kotlin/Native 和 <a href="/kotlin/gradle-configure-project#targeting-multiple-platforms">多平台</a> Gradle 构建中 C 互操作相关的进阶用例。</p><p>在本教程中，你将：</p><ul><li><a href="#pass-kotlin-function-as-a-c-function-pointer">学习如何将 Kotlin 函数作为 C 函数指针传递</a></li><li><a href="#use-the-c-function-pointer-from-kotlin">在 Kotlin 中使用 C 函数指针</a></li></ul><h2 id="从-c-映射函数指针类型" tabindex="-1">从 C 映射函数指针类型 <a class="header-anchor" href="#从-c-映射函数指针类型" aria-label="Permalink to &quot;从 C 映射函数指针类型&quot;">​</a></h2><p>为了理解 Kotlin 与 C 之间的映射，让我们声明两个函数：一个接受函数指针作为形参，另一个返回函数指针。</p><p>在本系列<a href="/kotlin/mapping-primitive-data-types-from-c">第一部分</a>中，你已经创建了一个包含必要文件的 C 库。对于此步骤，请在 <code>---</code> 分隔符之后更新 <code>interop.def</code> 文件中的声明：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">---</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myFun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyFun)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> accept_fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyFun </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyFun </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">supply_fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myFun;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>interop.def</code> 文件提供了所有必需内容，用于在 IDE 中编译、运行或打开应用程序。</p><h2 id="探查-c-库生成的-kotlin-api" tabindex="-1">探查 C 库生成的 Kotlin API <a class="header-anchor" href="#探查-c-库生成的-kotlin-api" aria-label="Permalink to &quot;探查 C 库生成的 Kotlin API&quot;">​</a></h2><p>让我们看看 C 函数指针是如何映射到 Kotlin/Native 的，并更新你的项目：</p>`,11)),s("ol",null,[i[9]||(i[9]=n(`<li><p>在 <code>src/nativeMain/kotlin</code> 中，使用以下内容更新<a href="/kotlin/mapping-struct-union-types-from-c">上一教程</a>中的 <code>hello.kt</code> 文件：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> interop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.ExperimentalForeignApi</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello Kotlin/Native!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    accept_fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* fix me*/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> useMe </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> supply_fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li>`,1)),s("li",null,[s("p",null,[i[3]||(i[3]=a("使用 IntelliJ IDEA 的 ")),i[4]||(i[4]=s("a",{href:"https://www.jetbrains.com/help/rider/Navigation_and_Search__Go_to_Declaration.html",target:"_blank",rel:"noreferrer"},"转到声明",-1)),i[5]||(i[5]=a(" 命令 (")),t(p,null,{default:l(()=>i[1]||(i[1]=[a("Cmd + B")])),_:1}),i[6]||(i[6]=a("/")),t(p,null,{default:l(()=>i[2]||(i[2]=[a("Ctrl + B")])),_:1}),i[7]||(i[7]=a(") 导航到以下生成的 C 函数 API："))]),i[8]||(i[8]=n(`<div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myFun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.Int): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.Int</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> accept_fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlinx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cinterop.CPointer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kotlinx.cinterop.CFunction</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kotlin.Int) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlin.Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 来自: interop.MyFun? */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> supply_fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlinx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cinterop.CPointer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kotlinx.cinterop.CFunction</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kotlin.Int) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlin.Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 来自: interop.MyFun? */</span></span></code></pre></div>`,1))])]),i[12]||(i[12]=n(`<p>如你所见，C 函数指针在 Kotlin 中表示为 <code>CPointer&lt;CFunction&lt;...&gt;&gt;</code>。<code>accept_fun()</code> 函数接受一个可选的函数指针作为形参，而 <code>supply_fun()</code> 返回一个函数指针。</p><p><code>CFunction&lt;(Int) -&gt; Int&gt;</code> 表示函数签名，而 <code>CPointer&lt;CFunction&lt;...&gt;&gt;?</code> 表示一个可空的函数指针。所有 <code>CPointer&lt;CFunction&lt;...&gt;&gt;</code> 类型都提供一个 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/invoke.html" target="_blank" rel="noreferrer"><code>.invoke()</code></a> 操作符扩展函数，允许你像调用常规 Kotlin 函数一样调用函数指针。</p><h2 id="将-kotlin-函数作为-c-函数指针传递" tabindex="-1">将 Kotlin 函数作为 C 函数指针传递 <a class="header-anchor" href="#将-kotlin-函数作为-c-函数指针传递" aria-label="Permalink to &quot;将 Kotlin 函数作为 C 函数指针传递&quot;">​</a></h2><p>是时候尝试在 Kotlin 代码中使用 C 函数了。调用 <code>accept_fun()</code> 函数并将 C 函数指针传递给 Kotlin lambda 表达式：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> interop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.staticCFunction</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.ExperimentalForeignApi</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myFun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    accept_fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">staticCFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; { it </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此调用使用了来自 Kotlin/Native 的 <code>staticCFunction {}</code> 辅助函数，将 Kotlin lambda 表达式函数包装成 C 函数指针。它只允许非绑定且不捕获的 lambda 表达式函数。例如，它不能捕获函数中的局部变量，只能捕获全局可见的声明。</p><p>确保该函数不会抛出任何异常。从 <code>staticCFunction {}</code> 中抛出异常会导致非确定性副作用。</p><h2 id="在-kotlin-中使用-c-函数指针" tabindex="-1">在 Kotlin 中使用 C 函数指针 <a class="header-anchor" href="#在-kotlin-中使用-c-函数指针" aria-label="Permalink to &quot;在 Kotlin 中使用 C 函数指针&quot;">​</a></h2><p>下一步是调用从 <code>supply_fun()</code> 调用返回的 C 函数指针：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> interop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.ExperimentalForeignApi</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.invoke</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myFun2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> functionFromC </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> supply_fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() ?: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;No function is returned&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    functionFromC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Kotlin 将函数指针返回类型转换为可空的 <code>CPointer&lt;CFunction&lt;&gt;</code> 对象。你需要首先显式检测 <code>null</code>，这就是为什么代码中使用了 <a href="/kotlin/null-safety">Elvis 操作符</a>。cinterop 工具允许你将 C 函数指针作为常规 Kotlin 函数调用：<code>functionFromC(42)</code>。</p><h2 id="更新-kotlin-代码" tabindex="-1">更新 Kotlin 代码 <a class="header-anchor" href="#更新-kotlin-代码" aria-label="Permalink to &quot;更新 Kotlin 代码&quot;">​</a></h2><p>既然你已经看到了所有定义，尝试在你的项目中使用它们。<code>hello.kt</code> 文件中的代码可能如下所示：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> interop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.ExperimentalForeignApi</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.invoke</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.staticCFunction</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello Kotlin/Native!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cFunctionPointer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> staticCFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; { it </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    accept_fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cFunctionPointer)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> funFromC </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> supply_fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() ?: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;No function is returned&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    funFromC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>为了验证一切是否按预期工作，<a href="/kotlin/native-get-started#build-and-run-the-application">在你的 IDE 中</a>运行 <code>runDebugExecutableNative</code> Gradle 任务，或使用以下命令运行代码：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./gradlew</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> runDebugExecutableNative</span></span></code></pre></div><h2 id="下一步" tabindex="-1">下一步 <a class="header-anchor" href="#下一步" aria-label="Permalink to &quot;下一步&quot;">​</a></h2><p>在本系列的下一部分中，你将学习字符串如何在 Kotlin 和 C 之间映射：</p><p><strong><a href="/kotlin/mapping-strings-from-c">继续到下一部分</a></strong></p><h3 id="另请参阅" tabindex="-1">另请参阅 <a class="header-anchor" href="#另请参阅" aria-label="Permalink to &quot;另请参阅&quot;">​</a></h3><p>在 <a href="/kotlin/native-c-interop">与 C 的互操作性</a> 文档中了解更多信息，该文档涵盖了更进阶的场景。</p>`,21))])}const I=E(y,[["render",F]]);export{x as __pageData,I as default};
