import{_ as o,c as t,o as r,ag as n}from"./chunks/framework.Bksy39di.js";const d=JSON.parse('{"title":"Kotlin 1.6 兼容性指南","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/compatibility-guide-16.md","filePath":"kotlin/compatibility-guide-16.md","lastUpdated":1754307826000}'),a={name:"kotlin/compatibility-guide-16.md"};function l(i,e,s,c,p,g){return r(),t("div",null,e[0]||(e[0]=[n('<h1 id="kotlin-1-6-兼容性指南" tabindex="-1">Kotlin 1.6 兼容性指南 <a class="header-anchor" href="#kotlin-1-6-兼容性指南" aria-label="Permalink to &quot;Kotlin 1.6 兼容性指南&quot;">​</a></h1><p><em><a href="/kotlin/kotlin-evolution-principles">保持语言现代化</a></em> 和 <em><a href="/kotlin/kotlin-evolution-principles">舒适更新</a></em> 是 Kotlin 语言设计中的基本原则。前者指出，阻碍语言演进的构造应该被移除；后者指出，这种移除应该提前充分沟通，以便代码迁移尽可能顺利。</p><p>虽然大多数语言变更已通过其他渠道（例如更新日志或编译器警告）宣布，但本文档总结了所有这些变更，为从 Kotlin 1.5 迁移到 Kotlin 1.6 提供了完整的参考。</p><h2 id="基本术语" tabindex="-1">基本术语 <a class="header-anchor" href="#基本术语" aria-label="Permalink to &quot;基本术语&quot;">​</a></h2><p>本文档介绍了以下几种兼容性：</p><ul><li><em>源代码</em>：源代码不兼容的变更会使原本能够正常编译（无错误或警告）的代码无法再编译。</li><li><em>二进制</em>：如果两个二进制 artifact 相互替换不会导致加载或链接错误，则称它们是二进制兼容的。</li><li><em>行为</em>：如果同一个程序在应用变更前后表现出不同行为，则称该变更行为不兼容。</li></ul><p>请记住，这些定义仅针对纯 Kotlin 代码给出。从其他语言（例如 Java）的角度来看的 Kotlin 代码兼容性不在本文档的讨论范围之内。</p><h2 id="语言" tabindex="-1">语言 <a class="header-anchor" href="#语言" aria-label="Permalink to &quot;语言&quot;">​</a></h2><h3 id="默认情况下使带有-enum、sealed-和-boolean-类型主体的-when-语句穷尽所有情况" tabindex="-1">默认情况下使带有 enum、sealed 和 Boolean 类型主体的 when 语句穷尽所有情况 <a class="header-anchor" href="#默认情况下使带有-enum、sealed-和-boolean-类型主体的-when-语句穷尽所有情况" aria-label="Permalink to &quot;默认情况下使带有 enum、sealed 和 Boolean 类型主体的 when 语句穷尽所有情况&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-47709" target="_blank" rel="noreferrer">KT-47709</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.6 将对 <code>when</code> 语句使用 <code>enum</code>、<code>sealed</code> 或 <code>Boolean</code> 类型的主体但未穷尽所有情况时发出警告。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.0: 当 <code>when</code> 语句使用 <code>enum</code>、<code>sealed</code> 或 <code>Boolean</code> 类型的主体但未穷尽时引入警告（在渐进模式下为错误）。</li><li>1.7.0: 将此警告提升为错误。</li></ul></blockquote><h3 id="废弃-when-with-subject-中易混淆的语法" tabindex="-1">废弃 when-with-subject 中易混淆的语法 <a class="header-anchor" href="#废弃-when-with-subject-中易混淆的语法" aria-label="Permalink to &quot;废弃 when-with-subject 中易混淆的语法&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48385" target="_blank" rel="noreferrer">KT-48385</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.6 将废弃 <code>when</code> 条件表达式中几个易混淆的语法构造。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.20: 对受影响的表达式引入废弃警告。</li><li>1.8.0: 将此警告提升为错误。</li><li>&gt;= 1.8: 将一些已废弃的构造用于新的语言特性。</li></ul></blockquote><h3 id="禁止在伴生对象和嵌套对象的超类构造函数调用中访问类成员" tabindex="-1">禁止在伴生对象和嵌套对象的超类构造函数调用中访问类成员 <a class="header-anchor" href="#禁止在伴生对象和嵌套对象的超类构造函数调用中访问类成员" aria-label="Permalink to &quot;禁止在伴生对象和嵌套对象的超类构造函数调用中访问类成员&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-25289" target="_blank" rel="noreferrer">KT-25289</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.6 将对伴生对象和常规对象的超类构造函数调用的实参报告错误，如果此类实参的接收者引用了包含声明。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.5.20: 对存在问题的实参引入警告。</li><li>1.6.0: 将此警告提升为错误。</li><li><code>-XXLanguage:-ProhibitSelfCallsInNestedObjects</code> 可用于暂时恢复到 1.6 之前的行为。</li></ul></blockquote><h3 id="类型可空性增强改进" tabindex="-1">类型可空性增强改进 <a class="header-anchor" href="#类型可空性增强改进" aria-label="Permalink to &quot;类型可空性增强改进&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48623" target="_blank" rel="noreferrer">KT-48623</a></p><p><strong>Component</strong>: Kotlin/JVM</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.7 将改变其加载和解释 Java 代码中类型可空性注解的方式。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.4.30: 对更精确的类型可空性可能导致错误的情况引入警告。</li><li>1.7.0: 推断更精确的 Java 类型可空性。</li><li><code>-XXLanguage:-TypeEnhancementImprovementsInStrictMode</code> 可用于暂时恢复到 1.7 之前的行为。</li></ul></blockquote><h3 id="阻止不同数字类型之间的隐式强制转换" tabindex="-1">阻止不同数字类型之间的隐式强制转换 <a class="header-anchor" href="#阻止不同数字类型之间的隐式强制转换" aria-label="Permalink to &quot;阻止不同数字类型之间的隐式强制转换&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48645" target="_blank" rel="noreferrer">KT-48645</a></p><p><strong>Component</strong>: Kotlin/JVM</p><p><strong>Incompatible change type</strong>: behavioral</p><p><strong>Short summary</strong>: Kotlin 将避免在语义上只需要向下转型为原始数字类型的情况下，自动将数值转换为原始数字类型。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>&lt; 1.5.30: 所有受影响情况下的旧行为。</li><li>1.5.30: 修复生成的属性委托访问器中的向下转型行为。</li><li><code>-Xuse-old-backend</code> 可用于暂时恢复到 1.5.30 修复之前的行为。</li><li>&gt;= 1.6.20: 修复其他受影响情况下的向下转型行为。</li></ul></blockquote><h3 id="禁止声明容器注解违反-jls-规范的可重复注解类" tabindex="-1">禁止声明容器注解违反 JLS 规范的可重复注解类 <a class="header-anchor" href="#禁止声明容器注解违反-jls-规范的可重复注解类" aria-label="Permalink to &quot;禁止声明容器注解违反 JLS 规范的可重复注解类&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-47928" target="_blank" rel="noreferrer">KT-47928</a></p><p><strong>Component</strong>: Kotlin/JVM</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.6 将检测可重复注解的容器注解是否满足 JLS 9.6.3 中相同的要求：数组类型的 value 方法、保留策略和目标。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.5.30: 对违反 JLS 要求的可重复容器注解声明引入警告（在渐进模式下为错误）。</li><li>1.6.0: 将此警告提升为错误。</li><li><code>-XXLanguage:-RepeatableAnnotationContainerConstraints</code> 可用于暂时禁用错误报告。</li></ul></blockquote><h3 id="禁止在可重复注解类中声明名为-container-的嵌套类" tabindex="-1">禁止在可重复注解类中声明名为 Container 的嵌套类 <a class="header-anchor" href="#禁止在可重复注解类中声明名为-container-的嵌套类" aria-label="Permalink to &quot;禁止在可重复注解类中声明名为 Container 的嵌套类&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-47971" target="_blank" rel="noreferrer">KT-47971</a></p><p><strong>Component</strong>: Kotlin/JVM</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.6 将检测在 Kotlin 中声明的可重复注解是否具有名为 <code>Container</code> 的嵌套类。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.5.30: 对 Kotlin 可重复注解类中名为 <code>Container</code> 的嵌套类引入警告（在渐进模式下为错误）。</li><li>1.6.0: 将此警告提升为错误。</li><li><code>-XXLanguage:-RepeatableAnnotationContainerConstraints</code> 可用于暂时禁用错误报告。</li></ul></blockquote><h3 id="禁止在覆盖接口属性的主构造函数中的属性上使用-jvmfield-注解" tabindex="-1">禁止在覆盖接口属性的主构造函数中的属性上使用 @JvmField 注解 <a class="header-anchor" href="#禁止在覆盖接口属性的主构造函数中的属性上使用-jvmfield-注解" aria-label="Permalink to &quot;禁止在覆盖接口属性的主构造函数中的属性上使用 @JvmField 注解&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-32753" target="_blank" rel="noreferrer">KT-32753</a></p><p><strong>Component</strong>: Kotlin/JVM</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.6 将禁止在主构造函数中声明并覆盖接口属性的属性上使用 <code>@JvmField</code> 注解。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.5.20: 对主构造函数中此类属性上的 <code>@JvmField</code> 注解引入警告。</li><li>1.6.0: 将此警告提升为错误。</li><li><code>-XXLanguage:-ProhibitJvmFieldOnOverrideFromInterfaceInPrimaryConstructor</code> 可用于暂时禁用错误报告。</li></ul></blockquote><h3 id="废弃编译器选项-xjvm-default-的-enable-和-compatibility-模式" tabindex="-1">废弃编译器选项 -Xjvm-default 的 enable 和 compatibility 模式 <a class="header-anchor" href="#废弃编译器选项-xjvm-default-的-enable-和-compatibility-模式" aria-label="Permalink to &quot;废弃编译器选项 -Xjvm-default 的 enable 和 compatibility 模式&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-46329" target="_blank" rel="noreferrer">KT-46329</a></p><p><strong>Component</strong>: Kotlin/JVM</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.6.20 将对使用 <code>-Xjvm-default</code> 编译器选项的 <code>enable</code> 和 <code>compatibility</code> 模式发出警告。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.20: 对 <code>-Xjvm-default</code> 编译器选项的 <code>enable</code> 和 <code>compatibility</code> 模式引入警告。</li><li>&gt;= 1.8.0: 将此警告提升为错误。</li></ul></blockquote><h3 id="禁止从公共-abi-inline-函数中调用-super" tabindex="-1">禁止从公共 ABI inline 函数中调用 super <a class="header-anchor" href="#禁止从公共-abi-inline-函数中调用-super" aria-label="Permalink to &quot;禁止从公共 ABI inline 函数中调用 super&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-45379" target="_blank" rel="noreferrer">KT-45379</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.6 将禁止从公共或保护型的 inline 函数和属性中调用带有 <code>super</code> 限定符的函数。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.5.0: 对从公共或保护型的 inline 函数或属性访问器中调用 <code>super</code> 引入警告。</li><li>1.6.0: 将此警告提升为错误。</li><li><code>-XXLanguage:-ProhibitSuperCallsFromPublicInline</code> 可用于暂时禁用错误报告。</li></ul></blockquote><h3 id="禁止从公共-inline-函数中调用保护型构造函数" tabindex="-1">禁止从公共 inline 函数中调用保护型构造函数 <a class="header-anchor" href="#禁止从公共-inline-函数中调用保护型构造函数" aria-label="Permalink to &quot;禁止从公共 inline 函数中调用保护型构造函数&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48860" target="_blank" rel="noreferrer">KT-48860</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.6 将禁止从公共或保护型的 inline 函数和属性中调用保护型构造函数。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.4.30: 对从公共或保护型的 inline 函数或属性访问器中调用保护型构造函数引入警告。</li><li>1.6.0: 将此警告提升为错误。</li><li><code>-XXLanguage:-ProhibitProtectedConstructorCallFromPublicInline</code> 可用于暂时禁用错误报告。</li></ul></blockquote><h3 id="禁止从文件内私有类型中暴露私有嵌套类型" tabindex="-1">禁止从文件内私有类型中暴露私有嵌套类型 <a class="header-anchor" href="#禁止从文件内私有类型中暴露私有嵌套类型" aria-label="Permalink to &quot;禁止从文件内私有类型中暴露私有嵌套类型&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-20094" target="_blank" rel="noreferrer">KT-20094</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.6 将禁止从文件内私有类型中暴露私有嵌套类型和内部类。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.5.0: 对从文件内私有类型中暴露私有类型引入警告。</li><li>1.6.0: 将此警告提升为错误。</li><li><code>-XXLanguage:-PrivateInFileEffectiveVisibility</code> 可用于暂时禁用错误报告。</li></ul></blockquote><h3 id="针对类型上的注解-在某些情况下不再分析注解目标" tabindex="-1">针对类型上的注解，在某些情况下不再分析注解目标 <a class="header-anchor" href="#针对类型上的注解-在某些情况下不再分析注解目标" aria-label="Permalink to &quot;针对类型上的注解，在某些情况下不再分析注解目标&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-28449" target="_blank" rel="noreferrer">KT-28449</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.6 将不再允许在不适用于类型的类型上使用注解。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.5.20: 在渐进模式下引入错误。</li><li>1.6.0: 引入错误。</li><li><code>-XXLanguage:-ProperCheckAnnotationsTargetInTypeUsePositions</code> 可用于暂时禁用错误报告。</li></ul></blockquote><h3 id="禁止调用名为-suspend-且带尾部-lambda-表达式的函数" tabindex="-1">禁止调用名为 suspend 且带尾部 lambda 表达式的函数 <a class="header-anchor" href="#禁止调用名为-suspend-且带尾部-lambda-表达式的函数" aria-label="Permalink to &quot;禁止调用名为 suspend 且带尾部 lambda 表达式的函数&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-22562" target="_blank" rel="noreferrer">KT-22562</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.6 将不再允许调用名为 <code>suspend</code> 且其单一函数类型实参以尾部 lambda 表达式形式传递的函数。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.3.0: 对此类函数调用引入警告。</li><li>1.6.0: 将此警告提升为错误。</li><li>&gt;= 1.7.0: 对语言语法引入变更，以便将 <code>{</code> 前的 <code>suspend</code> 解析为关键字。</li></ul></blockquote><h2 id="标准库" tabindex="-1">标准库 <a class="header-anchor" href="#标准库" aria-label="Permalink to &quot;标准库&quot;">​</a></h2><h3 id="移除-minus-removeall-retainall-中脆弱的-contains-优化" tabindex="-1">移除 minus/removeAll/retainAll 中脆弱的 contains 优化 <a class="header-anchor" href="#移除-minus-removeall-retainall-中脆弱的-contains-优化" aria-label="Permalink to &quot;移除 minus/removeAll/retainAll 中脆弱的 contains 优化&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-45438" target="_blank" rel="noreferrer">KT-45438</a></p><p><strong>Component</strong>: kotlin-stdlib</p><p><strong>Incompatible change type</strong>: behavioral</p><p><strong>Short summary</strong>: Kotlin 1.6 将不再对从集合/可迭代对象/数组/序列中移除多个元素的函数和操作符的实参执行转换为 <code>set</code> 的优化。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>&lt; 1.6: 旧行为：在某些情况下实参会转换为 <code>set</code>。</li><li>1.6.0: 如果函数实参是集合，则不再转换为 <code>Set</code>。如果不是集合，则可以转换为 <code>List</code>。 旧行为可以通过设置系统属性 <code>kotlin.collections.convert_arg_to_set_in_removeAll=true</code> 在 JVM 上暂时恢复。</li><li>&gt;= 1.7: 上述系统属性将不再生效。</li></ul></blockquote><h3 id="更改-random-nextlong-中的值生成算法" tabindex="-1">更改 Random.nextLong 中的值生成算法 <a class="header-anchor" href="#更改-random-nextlong-中的值生成算法" aria-label="Permalink to &quot;更改 Random.nextLong 中的值生成算法&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-47304" target="_blank" rel="noreferrer">KT-47304</a></p><p><strong>Component</strong>: kotlin-stdlib</p><p><strong>Incompatible change type</strong>: behavioral</p><p><strong>Short summary</strong>: Kotlin 1.6 更改了 <code>Random.nextLong</code> 函数中的值生成算法，以避免生成超出指定区间的值。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.0: 行为立即修复。</li></ul></blockquote><h3 id="逐步将集合-min-和-max-函数的返回类型更改为非空的" tabindex="-1">逐步将集合 min 和 max 函数的返回类型更改为非空的 <a class="header-anchor" href="#逐步将集合-min-和-max-函数的返回类型更改为非空的" aria-label="Permalink to &quot;逐步将集合 min 和 max 函数的返回类型更改为非空的&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-38854" target="_blank" rel="noreferrer">KT-38854</a></p><p><strong>Component</strong>: kotlin-stdlib</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.7 中集合 <code>min</code> 和 <code>max</code> 函数的返回类型将更改为非空的。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.4.0: 引入 <code>...OrNull</code> 函数作为同义函数，并废弃受影响的 API（详情请参见 issue）。</li><li>1.5.0: 将受影响 API 的废弃级别提升为错误。</li><li>1.6.0: 从公共 API 中隐藏已废弃函数。</li><li>&gt;= 1.7: 重新引入受影响的 API，但返回类型为非空的。</li></ul></blockquote><h3 id="废弃浮点数数组函数-contains、indexof、lastindexof" tabindex="-1">废弃浮点数数组函数：contains、indexOf、lastIndexOf <a class="header-anchor" href="#废弃浮点数数组函数-contains、indexof、lastindexof" aria-label="Permalink to &quot;废弃浮点数数组函数：contains、indexOf、lastIndexOf&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-28753" target="_blank" rel="noreferrer">KT-28753</a></p><p><strong>Component</strong>: kotlin-stdlib</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 废弃了浮点数数组函数 <code>contains</code>、<code>indexOf</code>、<code>lastIndexOf</code>，这些函数使用 IEEE-754 顺序而不是全序比较值。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.4.0: 以警告废弃受影响的函数。</li><li>1.6.0: 将废弃级别提升为错误。</li><li>&gt;= 1.7: 从公共 API 中隐藏已废弃函数。</li></ul></blockquote><h3 id="将-kotlin-dom-和-kotlin-browser-包中的声明迁移到-kotlinx" tabindex="-1">将 kotlin.dom 和 kotlin.browser 包中的声明迁移到 kotlinx.* <a class="header-anchor" href="#将-kotlin-dom-和-kotlin-browser-包中的声明迁移到-kotlinx" aria-label="Permalink to &quot;将 kotlin.dom 和 kotlin.browser 包中的声明迁移到 kotlinx.*&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-39330" target="_blank" rel="noreferrer">KT-39330</a></p><p><strong>Component</strong>: kotlin-stdlib (JS)</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: <code>kotlin.dom</code> 和 <code>kotlin.browser</code> 包中的声明已移至对应的 <code>kotlinx.*</code> 包中，以准备将其从标准库中提取。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.4.0: 在 <code>kotlinx.dom</code> 和 <code>kotlinx.browser</code> 包中引入替代 API。</li><li>1.4.0: 废弃 <code>kotlin.dom</code> 和 <code>kotlin.browser</code> 包中的 API，并建议使用上述新 API 作为替代。</li><li>1.6.0: 将废弃级别提升为错误。</li><li>&gt;= 1.7: 从标准库中移除已废弃函数。</li><li>&gt;= 1.7: 将 <code>kotlinx.*</code> 包中的 API 移至单独的库。</li></ul></blockquote><h3 id="使-kotlin-js-中的-regex-replace-函数不再-inline" tabindex="-1">使 Kotlin/JS 中的 Regex.replace 函数不再 inline <a class="header-anchor" href="#使-kotlin-js-中的-regex-replace-函数不再-inline" aria-label="Permalink to &quot;使 Kotlin/JS 中的 Regex.replace 函数不再 inline&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-27738" target="_blank" rel="noreferrer">KT-27738</a></p><p><strong>Component</strong>: kotlin-stdlib (JS)</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin/JS 中带有函数式 <code>transform</code> 形参的 <code>Regex.replace</code> 函数将不再是 <code>inline</code> 函数。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.0: 从受影响的函数中移除 <code>inline</code> 修饰符。</li></ul></blockquote><h3 id="当替换字符串包含组引用时-jvm-和-js-中-regex-replace-函数的不同行为" tabindex="-1">当替换字符串包含组引用时，JVM 和 JS 中 Regex.replace 函数的不同行为 <a class="header-anchor" href="#当替换字符串包含组引用时-jvm-和-js-中-regex-replace-函数的不同行为" aria-label="Permalink to &quot;当替换字符串包含组引用时，JVM 和 JS 中 Regex.replace 函数的不同行为&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-28378" target="_blank" rel="noreferrer">KT-28378</a></p><p><strong>Component</strong>: kotlin-stdlib (JS)</p><p><strong>Incompatible change type</strong>: behavioral</p><p><strong>Short summary</strong>: Kotlin/JS 中带有替换模式字符串的 <code>Regex.replace</code> 函数将遵循与 Kotlin/JVM 中相同的模式语法。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.0: 更改 Kotlin/JS 标准库中 <code>Regex.replace</code> 的替换模式处理。</li></ul></blockquote><h3 id="在-js-regex-中使用-unicode-大小写折叠" tabindex="-1">在 JS Regex 中使用 Unicode 大小写折叠 <a class="header-anchor" href="#在-js-regex-中使用-unicode-大小写折叠" aria-label="Permalink to &quot;在 JS Regex 中使用 Unicode 大小写折叠&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-45928" target="_blank" rel="noreferrer">KT-45928</a></p><p><strong>Component</strong>: kotlin-stdlib (JS)</p><p><strong>Incompatible change type</strong>: behavioral</p><p><strong>Short summary</strong>: Kotlin/JS 中的 <code>Regex</code> 类在调用底层 JS 正则表达式引擎时，将使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/unicode" target="_blank" rel="noreferrer"><code>unicode</code></a> 标志来根据 Unicode 规则搜索和比较字符。这带来特定的 JS 环境版本要求，并导致对不必要的转义进行更严格的验证。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.5.0: 在 JS <code>Regex</code> 类的多数函数中启用 Unicode 大小写折叠。</li><li>1.6.0: 在 <code>Regex.replaceFirst</code> 函数中启用 Unicode 大小写折叠。</li></ul></blockquote><h3 id="废弃一些仅限-js-的-api" tabindex="-1">废弃一些仅限 JS 的 API <a class="header-anchor" href="#废弃一些仅限-js-的-api" aria-label="Permalink to &quot;废弃一些仅限 JS 的 API&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48587" target="_blank" rel="noreferrer">KT-48587</a></p><p><strong>Component</strong>: kotlin-stdlib (JS)</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 标准库中一些仅限 JS 的函数将被废弃并移除。其中包括：<code>String.concat(String)</code>、<code>String.match(regex: String)</code>、<code>String.matches(regex: String)</code>，以及接受比较函数的数组 <code>sort</code> 函数，例如 <code>Array&lt;out T&gt;.sort(comparison: (a: T, b: T) -&gt; Int)</code>。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.0: 以警告废弃受影响的函数。</li><li>1.7.0: 将废弃级别提升为错误。</li><li>1.8.0: 从公共 API 中移除已废弃函数。</li></ul></blockquote><h3 id="从-kotlin-js-类的公共-api-中隐藏实现和互操作特有的函数" tabindex="-1">从 Kotlin/JS 类的公共 API 中隐藏实现和互操作特有的函数 <a class="header-anchor" href="#从-kotlin-js-类的公共-api-中隐藏实现和互操作特有的函数" aria-label="Permalink to &quot;从 Kotlin/JS 类的公共 API 中隐藏实现和互操作特有的函数&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48587" target="_blank" rel="noreferrer">KT-48587</a></p><p><strong>Component</strong>: kotlin-stdlib (JS)</p><p><strong>Incompatible change type</strong>: source, binary</p><p><strong>Short summary</strong>: 函数 <code>HashMap.createEntrySet</code> 和 <code>AbstactMutableCollection.toJSON</code> 的可见性将更改为 <code>internal</code>。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.0: 将这些函数设为 <code>internal</code>，从而从公共 API 中移除它们。</li></ul></blockquote><h2 id="工具" tabindex="-1">工具 <a class="header-anchor" href="#工具" aria-label="Permalink to &quot;工具&quot;">​</a></h2><h3 id="废弃-kotlingradlesubplugin-类" tabindex="-1">废弃 KotlinGradleSubplugin 类 <a class="header-anchor" href="#废弃-kotlingradlesubplugin-类" aria-label="Permalink to &quot;废弃 KotlinGradleSubplugin 类&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48830" target="_blank" rel="noreferrer">KT-48830</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: <code>KotlinGradleSubplugin</code> 类将被废弃，转而支持 <code>KotlinCompilerPluginSupportPlugin</code>。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.0: 将废弃级别提升为错误。</li><li>&gt;= 1.7.0: 移除已废弃的类。</li></ul></blockquote><h3 id="移除-kotlin-usefallbackcompilersearch-构建选项" tabindex="-1">移除 kotlin.useFallbackCompilerSearch 构建选项 <a class="header-anchor" href="#移除-kotlin-usefallbackcompilersearch-构建选项" aria-label="Permalink to &quot;移除 kotlin.useFallbackCompilerSearch 构建选项&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-46719" target="_blank" rel="noreferrer">KT-46719</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 移除已废弃的 <code>kotlin.useFallbackCompilerSearch</code> 构建选项。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.5.0: 将废弃级别提升为警告。</li><li>1.6.0: 移除已废弃的选项。</li></ul></blockquote><h3 id="移除几个编译器选项" tabindex="-1">移除几个编译器选项 <a class="header-anchor" href="#移除几个编译器选项" aria-label="Permalink to &quot;移除几个编译器选项&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48847" target="_blank" rel="noreferrer">KT-48847</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 移除已废弃的 <code>noReflect</code> 和 <code>includeRuntime</code> 编译器选项。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.5.0: 将废弃级别提升为错误。</li><li>1.6.0: 移除已废弃的选项。</li></ul></blockquote><h3 id="废弃-useir-编译器选项" tabindex="-1">废弃 useIR 编译器选项 <a class="header-anchor" href="#废弃-useir-编译器选项" aria-label="Permalink to &quot;废弃 useIR 编译器选项&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48847" target="_blank" rel="noreferrer">KT-48847</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 隐藏已废弃的 <code>useIR</code> 编译器选项。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.5.0: 将废弃级别提升为警告。</li><li>1.6.0: 隐藏该选项。</li><li>&gt;= 1.7.0: 移除已废弃的选项。</li></ul></blockquote><h3 id="废弃-kapt-use-worker-api-gradle-属性" tabindex="-1">废弃 kapt.use.worker.api Gradle 属性 <a class="header-anchor" href="#废弃-kapt-use-worker-api-gradle-属性" aria-label="Permalink to &quot;废弃 kapt.use.worker.api Gradle 属性&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-48826" target="_blank" rel="noreferrer">KT-48826</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 废弃 <code>kapt.use.worker.api</code> 属性，该属性允许通过 Gradle Workers API 运行 kapt（默认值：<code>true</code>）。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.20: 将废弃级别提升为警告。</li><li>&gt;= 1.8.0: 移除此属性。</li></ul></blockquote><h3 id="移除-kotlin-parallel-tasks-in-project-gradle-属性" tabindex="-1">移除 kotlin.parallel.tasks.in.project Gradle 属性 <a class="header-anchor" href="#移除-kotlin-parallel-tasks-in-project-gradle-属性" aria-label="Permalink to &quot;移除 kotlin.parallel.tasks.in.project Gradle 属性&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-46406" target="_blank" rel="noreferrer">KT-46406</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 移除 <code>kotlin.parallel.tasks.in.project</code> 属性。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.5.20: 将废弃级别提升为警告。</li><li>1.6.20: 移除此属性。</li></ul></blockquote><h3 id="废弃-kotlin-experimental-coroutines-gradle-dsl-选项和-kotlin-coroutines-gradle-属性" tabindex="-1">废弃 kotlin.experimental.coroutines Gradle DSL 选项和 kotlin.coroutines Gradle 属性 <a class="header-anchor" href="#废弃-kotlin-experimental-coroutines-gradle-dsl-选项和-kotlin-coroutines-gradle-属性" aria-label="Permalink to &quot;废弃 kotlin.experimental.coroutines Gradle DSL 选项和 kotlin.coroutines Gradle 属性&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-50369" target="_blank" rel="noreferrer">KT-50369</a></p><p><strong>Component</strong>: Gradle</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 废弃 <code>kotlin.experimental.coroutines</code> Gradle DSL 选项和 <code>kotlin.coroutines</code> 属性。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.6.20: 将废弃级别提升为警告。</li><li>&gt;= 1.7.0: 移除 DSL 选项和属性。</li></ul></blockquote>',72)]))}const h=o(a,[["render",l]]);export{d as __pageData,h as default};
