import{_ as o,C as h,c as d,o as k,ag as t,G as e,j as i,w as n,a}from"./chunks/framework.Bksy39di.js";const F=JSON.parse('{"title":"Swift/Objective-C との相互運用","description":"","frontmatter":{},"headers":[],"relativePath":"ja/kotlin/native-objc-interop.md","filePath":"ja/kotlin/native-objc-interop.md","lastUpdated":1754307826000}'),r={name:"ja/kotlin/native-objc-interop.md"};function c(E,s,g,y,b,u){const l=h("tab"),p=h("tabs");return k(),d("div",null,[s[2]||(s[2]=t(`<h1 id="swift-objective-c-との相互運用" tabindex="-1">Swift/Objective-C との相互運用 <a class="header-anchor" href="#swift-objective-c-との相互運用" aria-label="Permalink to &quot;Swift/Objective-C との相互運用&quot;">​</a></h1><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Objective-Cライブラリのインポートは<a href="/ja/kotlin/native-c-interop-stability">ベータ版</a>です。 cinteropツールによってObjective-Cライブラリから生成されるすべてのKotlin宣言には、<code>@ExperimentalForeignApi</code>アノテーションが付与されている必要があります。 Kotlin/Nativeに同梱されているネイティブプラットフォームライブラリ（Foundation、UIKit、POSIXなど）は、一部のAPIでのみオプトインが必要です。</p></div><p>Kotlin/Nativeは、Objective-Cを介してSwiftとの間接的な相互運用性を提供します。このドキュメントでは、Swift/Objective-CコードでKotlin宣言を使用する方法と、KotlinコードでObjective-C宣言を使用する方法について説明します。</p><p>他に役立つ可能性のあるリソース：</p><ul><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia" target="_blank" rel="noreferrer">Kotlin-Swift interopedia</a>（SwiftコードでKotlin宣言を使用する方法の例集）。</li><li><a href="/ja/kotlin/native-arc-integration">Swift/Objective-C ARCとの統合</a>セクション（KotlinのトレースGCとObjective-CのARC間の統合の詳細を説明）。</li></ul><h2 id="kotlinへのswift-objective-cライブラリのインポート" tabindex="-1">KotlinへのSwift/Objective-Cライブラリのインポート <a class="header-anchor" href="#kotlinへのswift-objective-cライブラリのインポート" aria-label="Permalink to &quot;KotlinへのSwift/Objective-Cライブラリのインポート&quot;">​</a></h2><p>Objective-Cのフレームワークとライブラリは、ビルドに適切にインポートされていれば（システムフレームワークはデフォルトでインポートされます）、Kotlinコードで使用できます。 詳細については、以下を参照してください：</p><ul><li><a href="/ja/kotlin/native-definition-file">ライブラリ定義ファイルの作成と設定</a></li><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-configure-compilations.html#configure-interop-with-native-languages" target="_blank" rel="noreferrer">ネイティブライブラリのコンパイル設定</a></li></ul><p>Swiftライブラリは、そのAPIが<code>@objc</code>でObjective-Cにエクスポートされていれば、Kotlinコードで使用できます。 純粋なSwiftモジュールはまだサポートされていません。</p><h2 id="swift-objective-cでのkotlinの使用" tabindex="-1">Swift/Objective-CでのKotlinの使用 <a class="header-anchor" href="#swift-objective-cでのkotlinの使用" aria-label="Permalink to &quot;Swift/Objective-CでのKotlinの使用&quot;">​</a></h2><p>Kotlinモジュールは、フレームワークにコンパイルされていれば、Swift/Objective-Cコードで使用できます。</p><ul><li>バイナリの宣言方法については、<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-build-native-binaries.html#declare-binaries" target="_blank" rel="noreferrer">最終的なネイティブバイナリのビルド</a>を参照してください。</li><li>例については、<a href="https://github.com/Kotlin/kmm-basic-sample" target="_blank" rel="noreferrer">Kotlin Multiplatformサンプルプロジェクト</a>を確認してください。</li></ul><h3 id="objective-cとswiftからkotlin宣言を隠す" tabindex="-1">Objective-CとSwiftからKotlin宣言を隠す <a class="header-anchor" href="#objective-cとswiftからkotlin宣言を隠す" aria-label="Permalink to &quot;Objective-CとSwiftからKotlin宣言を隠す&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>@HiddenFromObjC</code>アノテーションは<a href="/ja/kotlin/components-stability#stability-levels-explained">実験的</a>であり、<a href="/ja/kotlin/opt-in-requirements">オプトイン</a>が必要です。</p></div><p>KotlinコードをSwift/Objective-Cによりフレンドリーにするには、<code>@HiddenFromObjC</code>アノテーションを使用してKotlin宣言をObjective-CおよびSwiftから隠します。これは、関数またはプロパティのObjective-Cへのエクスポートを無効にします。</p><p>あるいは、Kotlin宣言に<code>internal</code>修飾子を付けて、コンパイルモジュール内での可視性を制限することもできます。他のKotlinモジュールからは見えるようにしつつ、Objective-CとSwiftからKotlin宣言を隠したい場合は、<code>@HiddenFromObjC</code>を使用します。</p><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/HiddenFromObjC.md" target="_blank" rel="noreferrer">Kotlin-Swift interopediaで例を見る</a>。</p><h3 id="swiftでのリファインの使用" tabindex="-1">Swiftでのリファインの使用 <a class="header-anchor" href="#swiftでのリファインの使用" aria-label="Permalink to &quot;Swiftでのリファインの使用&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>@ShouldRefineInSwift</code>アノテーションは<a href="/ja/kotlin/components-stability#stability-levels-explained">実験的</a>であり、<a href="/ja/kotlin/opt-in-requirements">オプトイン</a>が必要です。</p></div><p><code>@ShouldRefineInSwift</code>は、Kotlin宣言をSwiftで書かれたラッパーに置き換えるのに役立ちます。このアノテーションは、生成されるObjective-C APIで関数またはプロパティを<code>swift_private</code>としてマークします。このような宣言には<code>__</code>プレフィックスが付き、Swiftからは見えなくなります。</p><p>SwiftフレンドリーなAPIを作成するために、Swiftコードでこれらの宣言を使用することはできますが、Xcodeのオートコンプリートでは提案されません。</p><ul><li>SwiftでのObjective-C宣言のリファインの詳細については、<a href="https://developer.apple.com/documentation/swift/improving-objective-c-api-declarations-for-swift" target="_blank" rel="noreferrer">Apple公式ドキュメント</a>を参照してください。</li><li><code>@ShouldRefineInSwift</code>アノテーションの使用例については、<a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/ShouldRefineInSwift.md" target="_blank" rel="noreferrer">Kotlin-Swift interopedia</a>を参照してください。</li></ul><h3 id="宣言名の変更" tabindex="-1">宣言名の変更 <a class="header-anchor" href="#宣言名の変更" aria-label="Permalink to &quot;宣言名の変更&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>@ObjCName</code>アノテーションは<a href="/ja/kotlin/components-stability#stability-levels-explained">実験的</a>であり、<a href="/ja/kotlin/opt-in-requirements">オプトイン</a>が必要です。</p></div><p>Kotlin宣言の名前変更を避けるには、<code>@ObjCName</code>アノテーションを使用します。これは、Kotlinコンパイラに、アノテーションが付けられたクラス、インターフェース、または他のKotlinエンティティに対して、カスタムのObjective-CおよびSwift名を使用するように指示します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@ObjCName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(swiftName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;MySwiftArray&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyKotlinArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @ObjCName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@ObjCName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;of&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) element: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TODO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Usage with the ObjCName annotations</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MySwiftArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(of: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;element&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/ObjCName.md" target="_blank" rel="noreferrer">Kotlin-Swift interopediaで別の例を見る</a>。</p><h3 id="kdocコメントによるドキュメントの提供" tabindex="-1">KDocコメントによるドキュメントの提供 <a class="header-anchor" href="#kdocコメントによるドキュメントの提供" aria-label="Permalink to &quot;KDocコメントによるドキュメントの提供&quot;">​</a></h3><p>ドキュメントは、あらゆるAPIを理解するために不可欠です。共有Kotlin APIのドキュメントを提供することで、そのユーザーと使用法、注意点などについてやり取りできます。</p><p>デフォルトでは、Objective-Cヘッダーを生成する際、<a href="/ja/kotlin/kotlin-doc">KDoc</a>コメントは対応するコメントに変換されません。例えば、KDocを含む以下のKotlinコード：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Prints the sum of the arguments.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Properly handles the case when the sum doesn&#39;t fit in 32-bit integer.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLong</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b)</span></span></code></pre></div><p>コメントなしのObjective-C宣言が生成されます：</p><div class="language-objc vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">objc</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)printSumA:(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)a b:(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)b </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">swift_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;printSum(a:b:)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)));</span></span></code></pre></div><p>KDocコメントのエクスポートを有効にするには、<code>build.gradle(.kts)</code>に以下のコンパイラオプションを追加します。</p>`,34)),e(p,{group:"build-script"},{default:n(()=>[e(l,{title:"Kotlin","group-key":"kotlin"},{default:n(()=>s[0]||(s[0]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    targets."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"withType"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"org"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"jetbrains"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"gradle"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"plugin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"mpp"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"KotlinNativeTarget"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"> {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        compilations."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"get"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"main"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},").compilerOptions.options.freeCompilerArgs."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"add"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"-Xexport-kdoc"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),e(l,{title:"Groovy","group-key":"groovy"},{default:n(()=>s[1]||(s[1]=[i("div",{class:"language-groovy vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"groovy"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"kotlin {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    targets"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"withType("),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTarget"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        compilations"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"get("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"main"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"compilerOptions"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"options"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"freeCompilerArgs"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"add("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"-Xexport-kdoc"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),s[3]||(s[3]=t(`<p>その後、Objective-Cヘッダーには対応するコメントが含まれます。</p><div class="language-objc vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">objc</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Prints the sum of the arguments.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Properly handles the case when the sum doesn&#39;t fit in 32-bit integer.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)printSumA:(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)a b:(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)b </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">swift_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;printSum(a:b:)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)));</span></span></code></pre></div><p>例えばXcodeで、オートコンプリート時にクラスやメソッドのコメントを見ることができるようになります。関数の定義（<code>.h</code>ファイル内）に移動すると、<code>@param</code>、<code>@return</code>などのコメントが表示されます。</p><p>既知の制限事項：</p><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>生成されたObjective-CヘッダーにKDocコメントをエクスポートする機能は<a href="/ja/kotlin/components-stability">実験的</a>です。 いつでも廃止または変更される可能性があります。 オプトインが必要であり（詳細は下記参照）、評価目的でのみ使用してください。<a href="https://youtrack.jetbrains.com/issue/KT-38600" target="_blank" rel="noreferrer">YouTrack</a>でのフィードバックをお待ちしております。</p></div><ul><li>依存関係のドキュメントは、それ自体が<code>-Xexport-kdoc</code>でコンパイルされていない限りエクスポートされません。この機能は実験的であるため、このオプションでコンパイルされたライブラリは他のコンパイラバージョンと互換性がない可能性があります。</li><li>KDocコメントはほとんどそのままエクスポートされます。<code>@property</code>など、多くのKDoc機能はサポートされていません。</li></ul><h2 id="マッピング" tabindex="-1">マッピング <a class="header-anchor" href="#マッピング" aria-label="Permalink to &quot;マッピング&quot;">​</a></h2><p>下の表は、Kotlinの概念がSwift/Objective-Cに、またその逆方向にもどのようにマッピングされるかを示しています。</p><p><code>-&gt;</code>と<code>&lt;-</code>は、マッピングが一方向のみであることを示します。</p><table tabindex="0"><thead><tr><th>Kotlin</th><th>Swift</th><th>Objective-C</th><th>Notes</th></tr></thead><tbody><tr><td><code>class</code></td><td><code>class</code></td><td><code>@interface</code></td><td><a href="#classes">注</a></td></tr><tr><td><code>interface</code></td><td><code>protocol</code></td><td><code>@protocol</code></td><td></td></tr><tr><td><code>constructor</code>/<code>create</code></td><td>Initializer</td><td>Initializer</td><td><a href="#initializers">注</a></td></tr><tr><td>プロパティ</td><td>Property</td><td>Property</td><td><a href="#top-level-functions-and-properties">注 1</a>, <a href="#setters">注 2</a></td></tr><tr><td>メソッド</td><td>Method</td><td>Method</td><td><a href="#top-level-functions-and-properties">注 1</a>, <a href="#method-names-translation">注 2</a></td></tr><tr><td><code>enum class</code></td><td><code>class</code></td><td><code>@interface</code></td><td><a href="#enums">注</a></td></tr><tr><td><code>suspend</code> -&gt;</td><td><code>completionHandler:</code>/ <code>async</code></td><td><code>completionHandler:</code></td><td><a href="#errors-and-exceptions">注 1</a>, <a href="#suspending-functions">注 2</a></td></tr><tr><td><code>@Throws fun</code></td><td><code>throws</code></td><td><code>error:(NSError**)error</code></td><td><a href="#errors-and-exceptions">注</a></td></tr><tr><td>拡張</td><td>Extension</td><td>Category member</td><td><a href="#extensions-and-category-members">注</a></td></tr><tr><td><code>companion</code>メンバー &lt;-</td><td>Class method or property</td><td>Class method or property</td><td></td></tr><tr><td><code>null</code></td><td><code>nil</code></td><td><code>nil</code></td><td></td></tr><tr><td>シングルトン</td><td><code>shared</code> or <code>companion</code> property</td><td><code>shared</code> or <code>companion</code> property</td><td><a href="#kotlin-singletons">注</a></td></tr><tr><td>プリミティブ型</td><td>Primitive type / <code>NSNumber</code></td><td></td><td><a href="#primitive-types">注</a></td></tr><tr><td><code>Unit</code>戻り値の型</td><td><code>Void</code></td><td><code>void</code></td><td></td></tr><tr><td><code>String</code></td><td><code>String</code></td><td><code>NSString</code></td><td><a href="#strings">注</a></td></tr><tr><td><code>String</code></td><td><code>NSMutableString</code></td><td><code>NSMutableString</code></td><td><a href="#nsmutablestring">注</a></td></tr><tr><td><code>List</code></td><td><code>Array</code></td><td><code>NSArray</code></td><td></td></tr><tr><td><code>MutableList</code></td><td><code>NSMutableArray</code></td><td><code>NSMutableArray</code></td><td></td></tr><tr><td><code>Set</code></td><td><code>Set</code></td><td><code>NSSet</code></td><td></td></tr><tr><td><code>MutableSet</code></td><td><code>NSMutableSet</code></td><td><code>NSMutableSet</code></td><td><a href="#collections">注</a></td></tr><tr><td><code>Map</code></td><td><code>Dictionary</code></td><td><code>NSDictionary</code></td><td></td></tr><tr><td><code>MutableMap</code></td><td><code>NSMutableDictionary</code></td><td><code>NSMutableDictionary</code></td><td><a href="#collections">注</a></td></tr><tr><td>関数型</td><td>Function type</td><td>Block pointer type</td><td><a href="#function-types">注</a></td></tr><tr><td>インラインクラス</td><td>Unsupported</td><td>Unsupported</td><td><a href="#unsupported">注</a></td></tr></tbody></table><h3 id="クラス" tabindex="-1">クラス <a class="header-anchor" href="#クラス" aria-label="Permalink to &quot;クラス&quot;">​</a></h3><h4 id="名前変換" tabindex="-1">名前変換 <a class="header-anchor" href="#名前変換" aria-label="Permalink to &quot;名前変換&quot;">​</a></h4><p>Objective-Cのクラスは、元の名前でKotlinにインポートされます。 プロトコルは、<code>Protocol</code>という名前のサフィックスを持つインターフェースとしてインポートされます。例えば、<code>@protocol Foo</code> -&gt; <code>interface FooProtocol</code>。 これらのクラスとインターフェースは、<a href="#importing-swift-objective-c-libraries-to-kotlin">ビルド設定で指定された</a>パッケージ（事前設定されたシステムフレームワークの場合は<code>platform.*</code>パッケージ）に配置されます。</p><p>Kotlinのクラスとインターフェースの名前は、Objective-Cにインポートされる際にプレフィックスが付けられます。 プレフィックスはフレームワーク名から派生します。</p><p>Objective-Cはフレームワーク内のパッケージをサポートしていません。Kotlinコンパイラが同じフレームワーク内で同じ名前だが異なるパッケージを持つKotlinクラスを見つけた場合、それらの名前を変更します。このアルゴリズムはまだ安定しておらず、Kotlinのリリース間で変更される可能性があります。これを回避するには、フレームワーク内の競合するKotlinクラスの名前を変更できます。</p><h4 id="強リンク" tabindex="-1">強リンク <a class="header-anchor" href="#強リンク" aria-label="Permalink to &quot;強リンク&quot;">​</a></h4><p>KotlinソースでObjective-Cクラスを使用すると、それは強リンクされたシンボルとしてマークされます。結果として生成されるビルド成果物には、関連するシンボルが強力な外部参照として記載されます。</p><p>これは、アプリが起動時にシンボルを動的にリンクしようとし、それらが利用できない場合はアプリがクラッシュすることを意味します。シンボルが一度も使用されなかったとしても、クラッシュは発生します。シンボルが特定のデバイスやOSバージョンで利用できない場合があります。</p><p>この問題を回避し、「シンボルが見つかりません」エラーを避けるには、クラスが実際に利用可能であるかをチェックするSwiftまたはObjective-Cのラッパーを使用してください。<a href="https://github.com/JetBrains/compose-multiplatform-core/pull/1278/files" target="_blank" rel="noreferrer">Compose Multiplatformフレームワークでこの回避策がどのように実装されたか</a>を参照してください。</p><h3 id="イニシャライザ" tabindex="-1">イニシャライザ <a class="header-anchor" href="#イニシャライザ" aria-label="Permalink to &quot;イニシャライザ&quot;">​</a></h3><p>Swift/Objective-Cのイニシャライザは、Kotlinにはコンストラクタまたは<code>create</code>という名前のファクトリメソッドとしてインポートされます。 後者は、Objective-CカテゴリまたはSwift拡張で宣言されたイニシャライザで発生します。これはKotlinに拡張コンストラクタの概念がないためです。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>SwiftのイニシャライザをKotlinにインポートする前に、<code>@objc</code>でアノテーションを付けることを忘れないでください。</p></div><p>Kotlinのコンストラクタは、Swift/Objective-Cにはイニシャライザとしてインポートされます。</p><h3 id="セッター" tabindex="-1">セッター <a class="header-anchor" href="#セッター" aria-label="Permalink to &quot;セッター&quot;">​</a></h3><p>スーパークラスの読み取り専用プロパティをオーバーライドする書き込み可能なObjective-Cプロパティは、プロパティ<code>foo</code>の<code>setFoo()</code>メソッドとして表現されます。可変として実装されたプロトコルの読み取り専用プロパティも同様です。</p><h3 id="トップレベル関数とプロパティ" tabindex="-1">トップレベル関数とプロパティ <a class="header-anchor" href="#トップレベル関数とプロパティ" aria-label="Permalink to &quot;トップレベル関数とプロパティ&quot;">​</a></h3><p>トップレベルのKotlin関数とプロパティは、特殊なクラスのメンバーとしてアクセスできます。 各Kotlinファイルは、例えば以下のように、そのようなクラスに変換されます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// MyLibraryUtils.kt</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> my.library</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span></code></pre></div><p>その後、Swiftから<code>foo()</code>関数を次のように呼び出すことができます。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyLibraryUtilsKt.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Kotlin-Swift interopediaでトップレベルのKotlin宣言にアクセスする例集を参照してください：</p><ul><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/Top-level%20functions.md" target="_blank" rel="noreferrer">トップレベル関数</a></li><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/functionsandproperties/Top-level%20val%20properties.md" target="_blank" rel="noreferrer">トップレベルの読み取り専用プロパティ</a></li><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/functionsandproperties/Top-level%20mutable%20var%20properties.md" target="_blank" rel="noreferrer">トップレベルの可変プロパティ</a></li></ul><h3 id="メソッド名の変換" tabindex="-1">メソッド名の変換 <a class="header-anchor" href="#メソッド名の変換" aria-label="Permalink to &quot;メソッド名の変換&quot;">​</a></h3><p>通常、Swiftの引数ラベルとObjective-Cのセレクタ要素は、Kotlinのパラメータ名にマッピングされます。これら2つの概念は異なるセマンティクスを持つため、Swift/Objective-Cのメソッドが、競合するKotlinシグネチャでインポートされることがあります。この場合、競合するメソッドは、例えば以下のように名前付き引数を使用してKotlinから呼び出すことができます。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[player moveTo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LEFT byMeters</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[player moveTo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UP byInches</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>Kotlinでは、次のようになります。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">player.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">moveTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(LEFT, byMeters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">player.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">moveTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UP, byInches </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><code>kotlin.Any</code>の関数はSwift/Objective-Cに次のようにマッピングされます。</p><table tabindex="0"><thead><tr><th>Kotlin</th><th>Swift</th><th>Objective-C</th></tr></thead><tbody><tr><td><code>equals()</code></td><td><code>isEquals(_:)</code></td><td><code>isEquals:</code></td></tr><tr><td><code>hashCode()</code></td><td><code>hash</code></td><td><code>hash</code></td></tr><tr><td><code>toString()</code></td><td><code>description</code></td><td><code>description</code></td></tr></tbody></table><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Data%20classes.md" target="_blank" rel="noreferrer">Kotlin-Swift interopediaのデータクラスの例を見る</a>。</p><p><a href="#change-declaration-names"><code>@ObjCName</code>アノテーション</a>でKotlin宣言の名前を変更する代わりに、SwiftまたはObjective-Cでより慣用的な名前を指定できます。</p><h3 id="エラーと例外" tabindex="-1">エラーと例外 <a class="header-anchor" href="#エラーと例外" aria-label="Permalink to &quot;エラーと例外&quot;">​</a></h3><p>すべてのKotlin例外は非チェック例外であり、エラーは実行時に捕捉されます。しかし、Swiftにはコンパイル時に処理されるチェック済みエラーしかありません。したがって、SwiftまたはObjective-Cコードが例外をスローするKotlinメソッドを呼び出す場合、そのKotlinメソッドには、&quot;予期される&quot;例外クラスのリストを指定する<code>@Throws</code>アノテーションを付ける必要があります。</p><p>Swift/Objective-Cフレームワークにコンパイルする際、<code>@Throws</code>アノテーションを持つか継承する非<code>suspend</code>関数は、Objective-Cでは<code>NSError*</code>を生成するメソッドとして、Swiftでは<code>throws</code>メソッドとして表現されます。<code>suspend</code>関数の表現は、常に完了ハンドラ内に<code>NSError*</code>/<code>Error</code>パラメータを持ちます。</p><p>Swift/Objective-Cコードから呼び出されたKotlin関数が、<code>@Throws</code>で指定されたクラスまたはそのサブクラスのいずれかのインスタンスである例外をスローした場合、その例外は<code>NSError</code>として伝播されます。Swift/Objective-Cに到達する他のKotlin例外は未処理と見なされ、プログラムの終了を引き起こします。</p><p><code>@Throws</code>なしの<code>suspend</code>関数は、<code>CancellationException</code>のみを伝播します（<code>NSError</code>として）。<code>@Throws</code>なしの非<code>suspend</code>関数は、Kotlin例外をまったく伝播しません。</p><p>逆方向の変換はまだ実装されていません。Swift/Objective-Cのエラーをスローするメソッドは、Kotlinに例外をスローするメソッドとしてインポートされません。</p><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/Exceptions.md" target="_blank" rel="noreferrer">Kotlin-Swift interopediaで例を見る</a>。</p><h3 id="enum" tabindex="-1">Enum <a class="header-anchor" href="#enum" aria-label="Permalink to &quot;Enum&quot;">​</a></h3><p>KotlinのenumはObjective-Cに<code>@interface</code>として、Swiftに<code>class</code>としてインポートされます。 これらのデータ構造には、各enum値に対応するプロパティがあります。このKotlinコードを考えてみましょう：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Colors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RED, GREEN, BLUE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>このenumクラスのプロパティには、Swiftから次のようにアクセスできます。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Swift</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Colors.red</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Colors.green</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Colors.blue</span></span></code></pre></div><p>Kotlin enumの変数をSwiftの<code>switch</code>文で使用するには、コンパイルエラーを防ぐために<code>default</code>文を提供します。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> color {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .red</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;It&#39;s red&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .green</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;It&#39;s green&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .blue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;It&#39;s blue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    default:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fatalError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;No such color&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Enum%20classes.md" target="_blank" rel="noreferrer">Kotlin-Swift interopediaで別の例を見る</a>。</p><h3 id="suspend-関数" tabindex="-1">suspend 関数 <a class="header-anchor" href="#suspend-関数" aria-label="Permalink to &quot;suspend 関数&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>Swiftコードから<code>suspend</code>関数を<code>async</code>として呼び出すサポートは<a href="/ja/kotlin/components-stability">実験的</a>です。 いつでも廃止または変更される可能性があります。 評価目的でのみ使用してください。<a href="https://youtrack.jetbrains.com/issue/KT-47610" target="_blank" rel="noreferrer">YouTrack</a>でのフィードバックをお待ちしております。</p></div><p>Kotlinの<a href="/ja/kotlin/coroutines-basics">サスペンド関数</a>（<code>suspend</code>）は、生成されるObjective-Cヘッダーではコールバック付き関数として、Swift/Objective-Cの用語では<a href="https://developer.apple.com/documentation/swift/calling_objective-c_apis_asynchronously" target="_blank" rel="noreferrer">完了ハンドラ</a>として表現されます。</p><p>Swift 5.5以降、Kotlinの<code>suspend</code>関数は、完了ハンドラを使用せずに<code>async</code>関数としてSwiftから呼び出すことも可能です。現在、この機能は非常に実験的であり、特定の制限があります。詳細については、<a href="https://youtrack.jetbrains.com/issue/KT-47610" target="_blank" rel="noreferrer">このYouTrackの課題</a>を参照してください。</p><ul><li>Swiftドキュメントの<a href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html" target="_blank" rel="noreferrer"><code>async</code>/<code>await</code>メカニズム</a>についてさらに学ぶ。</li><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/coroutines/Suspend%20functions.md" target="_blank" rel="noreferrer">Kotlin-Swift interopedia</a>で、同じ機能を実装するサードパーティライブラリの例と推奨事項を参照する。</li></ul><h3 id="拡張とカテゴリメンバー" tabindex="-1">拡張とカテゴリメンバー <a class="header-anchor" href="#拡張とカテゴリメンバー" aria-label="Permalink to &quot;拡張とカテゴリメンバー&quot;">​</a></h3><p>Objective-CカテゴリおよびSwift拡張のメンバーは、一般的にKotlinに拡張としてインポートされます。そのため、これらの宣言はKotlinでオーバーライドできず、拡張イニシャライザはKotlinコンストラクタとしては利用できません。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>現在、2つの例外があります。Kotlin 1.8.20以降、NSViewクラス（AppKitフレームワークから）またはUIViewクラス（UIKitフレームワークから）と同じヘッダーで宣言されているカテゴリメンバーは、これらのクラスのメンバーとしてインポートされます。これは、NSViewまたはUIViewをサブクラス化するメソッドをオーバーライドできることを意味します。</p></div><p>「通常の」KotlinクラスへのKotlin拡張は、それぞれSwiftおよびObjective-Cに拡張およびカテゴリメンバーとしてインポートされます。他の型へのKotlin拡張は、追加のレシーバーパラメータを持つ<a href="#top-level-functions-and-properties">トップレベル宣言</a>として扱われます。これらの型には以下が含まれます：</p><ul><li>Kotlinの<code>String</code>型</li><li>Kotlinのコレクション型とそのサブタイプ</li><li>Kotlinの<code>interface</code>型</li><li>Kotlinのプリミティブ型</li><li>Kotlinの<code>inline</code>クラス</li><li>Kotlinの<code>Any</code>型</li><li>Kotlinの関数型とそのサブタイプ</li><li>Objective-Cのクラスとプロトコル</li></ul><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/tree/main/docs/extensions" target="_blank" rel="noreferrer">Kotlin-Swift interopediaで例集を見る</a>。</p><h3 id="kotlinシングルトン" tabindex="-1">Kotlinシングルトン <a class="header-anchor" href="#kotlinシングルトン" aria-label="Permalink to &quot;Kotlinシングルトン&quot;">​</a></h3><p>Kotlinのシングルトン（<code>object</code>宣言、<code>companion object</code>を含む）は、Swift/Objective-Cに単一インスタンスを持つクラスとしてインポートされます。</p><p>インスタンスは<code>shared</code>および<code>companion</code>プロパティを通じて利用できます。</p><p>次のKotlinコードの場合：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">object</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Some value&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    companion</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Some value&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>これらのオブジェクトには次のようにアクセスします：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyObject.shared</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyObject.shared.x</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyClass.companion</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyClass.Companion.shared</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Objective-Cでの<code>[MySingleton mySingleton]</code>およびSwiftでの<code>MySingleton()</code>によるオブジェクトへのアクセスは非推奨になりました。</p></div><p>Kotlin-Swift interopediaでさらに多くの例を見る：</p><ul><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Objects.md" target="_blank" rel="noreferrer"><code>shared</code>を使用してKotlinオブジェクトにアクセスする方法</a></li><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Companion%20objects.md" target="_blank" rel="noreferrer">SwiftからKotlinコンパニオンオブジェクトのメンバーにアクセスする方法</a>。</li></ul><h3 id="プリミティブ型" tabindex="-1">プリミティブ型 <a class="header-anchor" href="#プリミティブ型" aria-label="Permalink to &quot;プリミティブ型&quot;">​</a></h3><p>Kotlinのプリミティブ型ボックスは、特殊なSwift/Objective-Cクラスにマッピングされます。例えば、<code>kotlin.Int</code>ボックスは、Swiftでは<code>KotlinInt</code>クラスのインスタンスとして（またはObjective-Cでは<code>\${prefix}Int</code>インスタンスとして、ここで<code>prefix</code>はフレームワークの名前プレフィックスです）表現されます。これらのクラスは<code>NSNumber</code>から派生しているため、インスタンスは対応するすべての操作をサポートする適切な<code>NSNumber</code>です。</p><p><code>NSNumber</code>型は、Swift/Objective-Cのパラメータ型または戻り値として使用された場合、Kotlinプリミティブ型に自動的に変換されません。その理由は、<code>NSNumber</code>型がラップされたプリミティブ値の型に関する十分な情報を提供しないためです。例えば、<code>NSNumber</code>が<code>Byte</code>、<code>Boolean</code>、または<code>Double</code>であることは静的に分かりません。したがって、Kotlinのプリミティブ値は、手動で<code>NSNumber</code>との間で<a href="#casting-between-mapped-types">キャスト</a>する必要があります。</p><h3 id="文字列" tabindex="-1">文字列 <a class="header-anchor" href="#文字列" aria-label="Permalink to &quot;文字列&quot;">​</a></h3><p>Kotlinの<code>String</code>がSwiftに渡される際、まずObjective-Cオブジェクトとしてエクスポートされ、その後SwiftコンパイラがSwiftへの変換のためにもう一度コピーします。これにより、追加のランタイムオーバーヘッドが発生します。</p><p>それを避けるには、SwiftでKotlin文字列にObjective-Cの<code>NSString</code>として直接アクセスします。<a href="#see-the-conversion-example">変換例を見る</a>。</p><h4 id="nsmutablestring" tabindex="-1">NSMutableString <a class="header-anchor" href="#nsmutablestring" aria-label="Permalink to &quot;NSMutableString&quot;">​</a></h4><p><code>NSMutableString</code> Objective-CクラスはKotlinからは利用できません。 <code>NSMutableString</code>のすべてのインスタンスは、Kotlinに渡される際にコピーされます。</p><h3 id="コレクション" tabindex="-1">コレクション <a class="header-anchor" href="#コレクション" aria-label="Permalink to &quot;コレクション&quot;">​</a></h3><h4 id="kotlin-objective-c-swift" tabindex="-1">Kotlin -&gt; Objective-C -&gt; Swift <a class="header-anchor" href="#kotlin-objective-c-swift" aria-label="Permalink to &quot;Kotlin -&gt; Objective-C -&gt; Swift&quot;">​</a></h4><p>KotlinコレクションがSwiftに渡される際、まずObjective-Cの同等物に変換され、その後Swiftコンパイラがコレクション全体をコピーし、<a href="#mappings">マッピング表</a>に記載されているようにSwiftネイティブのコレクションに変換します。</p><p>この最後の変換はパフォーマンスコストにつながります。これを防ぐには、SwiftでKotlinコレクションを使用する際に、明示的にObjective-Cの対応する型（<code>NSDictionary</code>、<code>NSArray</code>、<code>NSSet</code>）にキャストします。</p>`,89)),s[4]||(s[4]=i("h5",{"initial-collapse-state":"collapsed",collapsible:"true",id:"変換例を見る",tabindex:"-1"},[a("変換例を見る "),i("a",{class:"header-anchor",href:"#変換例を見る","aria-label":'Permalink to "変換例を見る {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[5]||(s[5]=t(`<p>例えば、以下のKotlin宣言：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> map: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Swiftでは、次のようになるかもしれません：</p><div class="language-Swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map[key]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ??</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre></div><p>ここで、<code>map</code>は暗黙的にSwiftの<code>Dictionary</code>に変換され、その文字列値はSwiftの<code>String</code>にマッピングされます。これによりパフォーマンスコストが発生します。</p><p>変換を避けるには、<code>map</code>を明示的にObjective-Cの<code>NSDictionary</code>にキャストし、代わりに値を<code>NSString</code>としてアクセスします。</p><div class="language-Swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsMap: NSDictionary </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> map </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NSDictionary</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nsMap[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NSString)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">??</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre></div><p>これにより、Swiftコンパイラが追加の変換ステップを実行しないことが保証されます。</p><h4 id="swift-objective-c-kotlin" tabindex="-1">Swift -&gt; Objective-C -&gt; Kotlin <a class="header-anchor" href="#swift-objective-c-kotlin" aria-label="Permalink to &quot;Swift -&gt; Objective-C -&gt; Kotlin&quot;">​</a></h4><p>Swift/Objective-Cコレクションは、<code>NSMutableSet</code>および<code>NSMutableDictionary</code>を除き、<a href="#mappings">マッピング表</a>に記載されているとおりにKotlinにマッピングされます。</p><p><code>NSMutableSet</code>はKotlinの<code>MutableSet</code>には変換されません。オブジェクトをKotlinの<code>MutableSet</code>に渡すには、この種のKotlinコレクションを明示的に作成します。これを行うには、例えばKotlinの<code>mutableSetOf()</code>関数、またはSwiftの<code>KotlinMutableSet</code>クラスとObjective-Cの<code>\${prefix}MutableSet</code>（<code>prefix</code>はフレームワーク名のプレフィックス）を使用します。<code>MutableMap</code>についても同様です。</p><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/Collections.md" target="_blank" rel="noreferrer">Kotlin-Swift interopediaで例を見る</a>。</p><h3 id="関数型" tabindex="-1">関数型 <a class="header-anchor" href="#関数型" aria-label="Permalink to &quot;関数型&quot;">​</a></h3><p>Kotlinの関数型オブジェクト（例：ラムダ）は、Swiftでは関数に、Objective-Cではブロックに変換されます。<a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/functionsandproperties/Functions%20returning%20function%20type.md" target="_blank" rel="noreferrer">Kotlin-Swift interopediaのラムダを持つKotlin関数の例を見る</a>。</p><p>しかし、関数と関数型を変換する際、パラメータと戻り値の型のマッピング方法には違いがあります。後者の場合、プリミティブ型はボックス化された表現にマッピングされます。Kotlinの<code>Unit</code>戻り値は、Swift/Objective-Cでは対応する<code>Unit</code>シングルトンとして表現されます。このシングルトンの値は、他のKotlinの<code>object</code>と同じ方法で取得できます。シングルトンは<a href="#mappings">上記の表</a>を参照してください。</p><p>以下のKotlin関数を考えてみましょう：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span></code></pre></div><p>Swiftでは次のように表現されます：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (KotlinInt) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KotlinUnit)</span></span></code></pre></div><p>そして、次のように呼び出すことができます：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Int32)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> KotlinUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="ジェネリクス" tabindex="-1">ジェネリクス <a class="header-anchor" href="#ジェネリクス" aria-label="Permalink to &quot;ジェネリクス&quot;">​</a></h3><p>Objective-Cは、比較的限られた機能セットを持つ、クラスで定義された「軽量ジェネリクス」をサポートしています。Swiftは、クラスで定義されたジェネリクスをインポートして、コンパイラに追加の型情報を提供するのに役立ちます。</p><p>Objective-CとSwiftのジェネリクス機能のサポートはKotlinとは異なるため、変換では必然的に一部の情報が失われますが、サポートされる機能は意味のある情報を保持します。</p><p>SwiftでKotlinジェネリクスを使用する方法の具体的な例については、<a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/ShouldRefineInSwift.md" target="_blank" rel="noreferrer">Kotlin-Swift interopedia</a>を参照してください。</p><h4 id="制限事項" tabindex="-1">制限事項 <a class="header-anchor" href="#制限事項" aria-label="Permalink to &quot;制限事項&quot;">​</a></h4><p>Objective-Cのジェネリクスは、KotlinまたはSwiftのすべての機能をサポートしているわけではないため、変換時に一部の情報が失われます。</p><p>ジェネリクスはクラスのみに定義でき、インターフェース（Objective-CおよびSwiftのプロトコル）や関数には定義できません。</p><h4 id="null許容性" tabindex="-1">Null許容性 <a class="header-anchor" href="#null許容性" aria-label="Permalink to &quot;Null許容性&quot;">​</a></h4><p>KotlinとSwiftはどちらも型指定の一部としてnull許容性を定義しますが、Objective-Cは型のメソッドとプロパティに対してnull許容性を定義します。したがって、以下のKotlinコード：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Swiftでは次のようになります：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fun </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">myVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>null許容の可能性がある型をサポートするには、Objective-Cヘッダーで<code>myVal</code>をnull許容の戻り値を持つものとして定義する必要があります。</p><p>これを軽減するには、ジェネリッククラスを定義する際、ジェネリック型が_決して_nullであってはならない場合に、非null許容の型制約を提供します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>これにより、Objective-Cヘッダーは<code>myVal</code>を非null許容としてマークするよう強制されます。</p><h4 id="共変性・反変性" tabindex="-1">共変性・反変性 <a class="header-anchor" href="#共変性・反変性" aria-label="Permalink to &quot;共変性・反変性&quot;">​</a></h4><p>Objective-Cでは、ジェネリクスを共変または反変として宣言できます。Swiftには分散性のサポートがありません。Objective-Cから来るジェネリッククラスは、必要に応じて強制キャストできます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BaseData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GenVarOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">out</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arg: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> variOut </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GenVarOut</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SomeData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: sd)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> variOutAny : GenVarOut&lt;BaseData&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> variOut </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GenVarOut</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BaseData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><h4 id="制約" tabindex="-1">制約 <a class="header-anchor" href="#制約" aria-label="Permalink to &quot;制約&quot;">​</a></h4><p>Kotlinでは、ジェネリック型に上限（upper bounds）を指定できます。Objective-Cもこれをサポートしていますが、より複雑なケースではそのサポートは利用できず、現在のKotlin-Objective-C相互運用ではサポートされていません。ここでの例外は、非null許容の上限がある場合、Objective-Cのメソッド/プロパティが非null許容になることです。</p><h4 id="無効にするには" tabindex="-1">無効にするには <a class="header-anchor" href="#無効にするには" aria-label="Permalink to &quot;無効にするには&quot;">​</a></h4><p>フレームワークヘッダーをジェネリクスなしで生成するには、ビルドファイルに以下のコンパイラオプションを追加します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">binaries.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">framework</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    freeCompilerArgs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;-Xno-objc-generics&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="前方宣言" tabindex="-1">前方宣言 <a class="header-anchor" href="#前方宣言" aria-label="Permalink to &quot;前方宣言&quot;">​</a></h3><p>前方宣言をインポートするには、<code>objcnames.classes</code>および<code>objcnames.protocols</code>パッケージを使用します。例えば、<code>library.package</code>を持つObjective-Cライブラリで宣言された<code>objcprotocolName</code>前方宣言をインポートするには、特別な前方宣言パッケージ<code>import objcnames.protocols.objcprotocolName</code>を使用します。</p><p>2つのobjcinteropライブラリを考えてみましょう。1つは<code>objcnames.protocols.ForwardDeclaredProtocolProtocol</code>を使用し、もう1つは別のパッケージに実際の__実装を持つものです。</p><div class="language-ObjC vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ObjC</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// First objcinterop library</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;Foundation/Foundation.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@protocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredProtocol;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NSString</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> consumeProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;ForwardDeclaredProtocol&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NSString</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> stringWithUTF8String:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Protocol&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-ObjC vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ObjC</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Second objcinterop library</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Header:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;Foundation/Foundation.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@protocol</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ForwardDeclaredProtocol</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@end</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Implementation:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ForwardDeclaredProtocolImpl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NSObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;ForwardDeclaredProtocol&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;ForwardDeclaredProtocol&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">produceProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ForwardDeclaredProtocolImpl </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>2つのライブラリ間でオブジェクトを転送するには、Kotlinコードで明示的な<code>as</code>キャストを使用します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin code:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    consumeProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">produceProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> objcnames.protocols.ForwardDeclaredProtocolProtocol)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>対応する実クラスからのみ、<code>objcnames.protocols.ForwardDeclaredProtocolProtocol</code>にキャストできます。 そうでなければ、エラーが発生します。</p></div><h2 id="マッピングされた型間のキャスト" tabindex="-1">マッピングされた型間のキャスト <a class="header-anchor" href="#マッピングされた型間のキャスト" aria-label="Permalink to &quot;マッピングされた型間のキャスト&quot;">​</a></h2><p>Kotlinコードを記述する際、オブジェクトをKotlin型から同等のSwift/Objective-C型に（またはその逆に）変換する必要がある場合があります。この場合、例えば以下のように通常のKotlinキャストを使用できます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NSArray</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsString </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsNumber </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NSNumber</span></span></code></pre></div><h2 id="サブクラス化" tabindex="-1">サブクラス化 <a class="header-anchor" href="#サブクラス化" aria-label="Permalink to &quot;サブクラス化&quot;">​</a></h2><h3 id="swift-objective-cからのkotlinクラスおよびインターフェースのサブクラス化" tabindex="-1">Swift/Objective-CからのKotlinクラスおよびインターフェースのサブクラス化 <a class="header-anchor" href="#swift-objective-cからのkotlinクラスおよびインターフェースのサブクラス化" aria-label="Permalink to &quot;Swift/Objective-CからのKotlinクラスおよびインターフェースのサブクラス化&quot;">​</a></h3><p>Kotlinのクラスとインターフェースは、Swift/Objective-Cのクラスとプロトコルによってサブクラス化できます。</p><h3 id="kotlinからのswift-objective-cクラスおよびプロトコルのサブクラス化" tabindex="-1">KotlinからのSwift/Objective-Cクラスおよびプロトコルのサブクラス化 <a class="header-anchor" href="#kotlinからのswift-objective-cクラスおよびプロトコルのサブクラス化" aria-label="Permalink to &quot;KotlinからのSwift/Objective-Cクラスおよびプロトコルのサブクラス化&quot;">​</a></h3><p>Swift/Objective-Cのクラスとプロトコルは、Kotlinの<code>final</code>クラスでサブクラス化できます。<code>final</code>でないKotlinクラスがSwift/Objective-C型を継承することはまだサポートされていないため、Swift/Objective-C型を継承する複雑なクラス階層を宣言することはできません。</p><p>通常のメソッドは、Kotlinの<code>override</code>キーワードを使用してオーバーライドできます。この場合、オーバーライドするメソッドは、オーバーライドされるメソッドと同じパラメータ名を持つ必要があります。</p><p>時にはイニシャライザをオーバーライドする必要がある場合があります。例えば、<code>UIViewController</code>をサブクラス化する際などです。Kotlinコンストラクタとしてインポートされたイニシャライザは、<code>@OverrideInit</code>アノテーションが付けられたKotlinコンストラクタによってオーバーライドできます。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ViewController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UIViewController </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @OverrideInit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">coder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: NSCoder) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coder)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>オーバーライドするコンストラクタは、オーバーライドされるコンストラクタと同じパラメータ名と型を持つ必要があります。</p><p>競合するKotlinシグネチャを持つ異なるメソッドをオーバーライドするには、クラスに<code>@ObjCSignatureOverride</code>アノテーションを追加できます。このアノテーションは、Objective-Cクラスから同じ引数型だが異なる引数名を持つ複数の関数が継承される場合に、Kotlinコンパイラに競合するオーバーロードを無視するように指示します。</p><p>デフォルトでは、Kotlin/Nativeコンパイラは、非指定Objective-Cイニシャライザを<code>super()</code>コンストラクタとして呼び出すことを許可しません。指定イニシャライザがObjective-Cライブラリで適切にマークされていない場合、この動作は不便なことがあります。これらのコンパイラチェックを無効にするには、ライブラリの<a href="/ja/kotlin/native-definition-file"><code>.def</code>ファイル</a>に<code>disableDesignatedInitializerChecks = true</code>を追加します。</p><h2 id="c機能" tabindex="-1">C機能 <a class="header-anchor" href="#c機能" aria-label="Permalink to &quot;C機能&quot;">​</a></h2><p>ライブラリがunsafeポインタや構造体などのプレーンなC機能を使用する場合の例については、<a href="/ja/kotlin/native-c-interop">Cとの相互運用</a>を参照してください。</p><h2 id="未サポート" tabindex="-1">未サポート <a class="header-anchor" href="#未サポート" aria-label="Permalink to &quot;未サポート&quot;">​</a></h2><p>Kotlinプログラミング言語の一部の機能は、Objective-CまたはSwiftのそれぞれの機能にまだマッピングされていません。現在、生成されるフレームワークヘッダーで適切に公開されていない機能は次のとおりです。</p><ul><li>インラインクラス（引数は基になるプリミティブ型または<code>id</code>としてマッピングされます）</li><li>標準的なKotlinコレクションインターフェース（<code>List</code>、<code>Map</code>、<code>Set</code>）やその他の特殊クラスを実装するカスタムクラス</li><li>Objective-CクラスのKotlinサブクラス</li></ul>`,73))])}const v=o(r,[["render",c]]);export{F as __pageData,v as default};
