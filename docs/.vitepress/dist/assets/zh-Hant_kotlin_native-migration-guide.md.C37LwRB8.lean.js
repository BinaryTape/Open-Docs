import{_ as c,C as o,c as f,o as g,ag as i,G as a,w as r,j as e,a as l}from"./chunks/framework.Bksy39di.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/native-migration-guide.md","filePath":"zh-Hant/kotlin/native-migration-guide.md","lastUpdated":1754307826000}'),p={name:"zh-Hant/kotlin/native-migration-guide.md"};function h(k,t,u,m,b,v){const d=o("list"),n=o("def"),s=o("deflist");return g(),f("div",null,[t[5]||(t[5]=i("",11)),a(s,{style:{}},{default:r(()=>[a(n,{title:"kotlinx.coroutines"},{default:r(()=>[t[1]||(t[1]=e("p",null,[l("更新到 1.6.0 或更高版本。請勿使用帶有 "),e("code",null,"native-mt"),l(" 尾碼的版本。")],-1)),t[2]||(t[2]=e("p",null,"關於新的記憶體管理器，您還應該記住一些具體注意事項：",-1)),a(d,null,{default:r(()=>t[0]||(t[0]=[e("li",null,"每個常見的原生類型（通道、流、協程）都能跨越 Worker 邊界工作，因為不再需要凍結。",-1),e("li",null,[e("code",null,"Dispatchers.Default"),l(" 在 Linux 和 Windows 上由 Worker 池支援，在 Apple 目標上由全域佇列支援。")],-1),e("li",null,[l("使用 "),e("code",null,"newSingleThreadContext"),l(" 建立一個由 Worker 支援的協程分發器。")],-1),e("li",null,[l("使用 "),e("code",null,"newFixedThreadPoolContext"),l(" 建立一個由一個包含 N 個 Worker 的池支援的協程分發器。")],-1),e("li",null,[e("code",null,"Dispatchers.Main"),l(" 在 Darwin 上由主佇列支援，在其他平台則由獨立的 Worker 支援。")],-1)])),_:1})]),_:1}),a(n,{title:"Ktor"},{default:r(()=>t[3]||(t[3]=[l(" 更新到 2.0 或更高版本。 ")])),_:1}),a(n,{title:"其他依賴項"},{default:r(()=>t[4]||(t[4]=[e("p",null,"大多數函式庫應該無需任何更改即可運作，但是，可能會有例外情況。",-1),e("p",null,"請確保您將依賴項更新到最新版本，並且舊版與新記憶體管理器的函式庫版本之間沒有差異。",-1)])),_:1})]),_:1}),t[6]||(t[6]=i("",5))])}const y=c(p,[["render",h]]);export{_ as __pageData,y as default};
