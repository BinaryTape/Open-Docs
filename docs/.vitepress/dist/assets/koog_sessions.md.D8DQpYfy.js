import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.Bksy39di.js";const E=JSON.parse('{"title":"LLM 会话与手动历史记录管理","description":"","frontmatter":{},"headers":[],"relativePath":"koog/sessions.md","filePath":"koog/sessions.md","lastUpdated":1755146406000}'),e={name:"koog/sessions.md"};function t(p,s,h,k,r,o){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="llm-会话与手动历史记录管理" tabindex="-1">LLM 会话与手动历史记录管理 <a class="header-anchor" href="#llm-会话与手动历史记录管理" aria-label="Permalink to &quot;LLM 会话与手动历史记录管理&quot;">​</a></h1><p>本页详细介绍了 LLM 会话，包括如何使用读写会话、管理对话历史记录以及向语言模型发送请求。</p><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><p>LLM 会话是一个基本概念，它提供了一种与语言模型 (LLMs) 交互的结构化方式。它们管理对话历史记录、处理 LLM 请求，并提供一致的接口来运行工具和处理响应。</p><h2 id="理解-llm-会话" tabindex="-1">理解 LLM 会话 <a class="header-anchor" href="#理解-llm-会话" aria-label="Permalink to &quot;理解 LLM 会话&quot;">​</a></h2><p>LLM 会话代表了与语言模型交互的上下文。它封装了：</p><ul><li>对话历史记录 (prompt)</li><li>可用工具</li><li>向 LLM 发送请求的方法</li><li>更新对话历史记录的方法</li><li>运行工具的方法</li></ul><p>会话由 <code>AIAgentLLMContext</code> 类管理，该类提供了创建读写会话的方法。</p><h3 id="会话类型" tabindex="-1">会话类型 <a class="header-anchor" href="#会话类型" aria-label="Permalink to &quot;会话类型&quot;">​</a></h3><p>Koog framework 提供了两种会话类型：</p><ol><li><p><strong>写入会话</strong> (<code>AIAgentLLMWriteSession</code>)：允许修改 prompt 和工具、发送 LLM 请求以及运行工具。在写入会话中所做的更改会持久化回 LLM 上下文。</p></li><li><p><strong>读取会话</strong> (<code>AIAgentLLMReadSession</code>)：提供对 prompt 和工具的只读访问。它们对于探查当前状态而无需进行更改很有用。</p></li></ol><p>关键区别在于写入会话可以修改对话历史记录，而读取会话不能。</p><h3 id="会话生命周期" tabindex="-1">会话生命周期 <a class="header-anchor" href="#会话生命周期" aria-label="Permalink to &quot;会话生命周期&quot;">​</a></h3><p>会话具有明确定义的生命周期：</p><ol><li><strong>创建</strong>：使用 <code>llm.writeSession { ... }</code> 或 <code>llm.readSession { ... }</code> 创建会话。</li><li><strong>活跃阶段</strong>：当 lambda 代码块执行时，会话处于活跃状态。</li><li><strong>终止</strong>：当 lambda 代码块完成时，会话会自动关闭。</li></ol><p>会话实现了 <code>AutoCloseable</code> 接口，确保即使发生异常也能正确清理。</p><h2 id="使用-llm-会话" tabindex="-1">使用 LLM 会话 <a class="header-anchor" href="#使用-llm-会话" aria-label="Permalink to &quot;使用 LLM 会话&quot;">​</a></h2><h3 id="创建会话" tabindex="-1">创建会话 <a class="header-anchor" href="#创建会话" aria-label="Permalink to &quot;创建会话&quot;">​</a></h3><p>会话是使用 <code>AIAgentLLMContext</code> 类的扩展函数创建的：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Creating a write session</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Session code here</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Creating a read session</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Session code here</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这些函数接受一个 lambda 代码块，该代码块在会话的上下文中运行。当该代码块完成时，会话会自动关闭。</p><h3 id="会话作用域与线程安全" tabindex="-1">会话作用域与线程安全 <a class="header-anchor" href="#会话作用域与线程安全" aria-label="Permalink to &quot;会话作用域与线程安全&quot;">​</a></h3><p>会话使用读写锁来确保线程安全：</p><ul><li>多个读取会话可以同时活跃。</li><li>一次只能有一个写入会话处于活跃状态。</li><li>写入会话会阻塞所有其他会话（包括读取和写入会话）。</li></ul><p>这确保了对话历史记录不会因并发修改而损坏。</p><h3 id="访问会话属性" tabindex="-1">访问会话属性 <a class="header-anchor" href="#访问会话属性" aria-label="Permalink to &quot;访问会话属性&quot;">​</a></h3><p>在会话中，你可以访问 prompt 和工具：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> messageCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prompt.messages.size</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> availableTools </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tools.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.name }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在写入会话中，你还可以修改这些属性：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Modify the prompt</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    updatePrompt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;New user message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Modify the tools</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    tools </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newTools</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>关于更多信息，请参见 <a href="https://api.koog.ai/agents/agents-core/ai.koog.agents.core.agent.session/-a-i-agent-l-l-m-read-session/index.html" target="_blank" rel="noreferrer">AIAgentLLMReadSession</a> 和 <a href="https://api.koog.ai/agents/agents-core/ai.koog.agents.core.agent.session/-a-i-agent-l-l-m-write-session/index.html" target="_blank" rel="noreferrer">AIAgentLLMWriteSession</a> 的详细 API 参考。</p><h2 id="发送-llm-请求" tabindex="-1">发送 LLM 请求 <a class="header-anchor" href="#发送-llm-请求" aria-label="Permalink to &quot;发送 LLM 请求&quot;">​</a></h2><h3 id="基本请求方法" tabindex="-1">基本请求方法 <a class="header-anchor" href="#基本请求方法" aria-label="Permalink to &quot;基本请求方法&quot;">​</a></h3><p>发送 LLM 请求最常用的方法有：</p><ol><li><p><code>requestLLM()</code>：使用当前 prompt 和工具向 LLM 发送请求，返回单个响应。</p></li><li><p><code>requestLLMMultiple()</code>：使用当前 prompt 和工具向 LLM 发送请求，返回多个响应。</p></li><li><p><code>requestLLMWithoutTools()</code>：使用当前 prompt 但不带任何工具向 LLM 发送请求，返回单个响应。</p></li><li><p><code>requestLLMForceOneTool</code>：使用当前 prompt 和工具向 LLM 发送请求，强制使用一个工具。</p></li><li><p><code>requestLLMOnlyCallingTools</code>：向 LLM 发送请求，该请求应仅通过使用工具来处理。</p></li></ol><p>示例：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Make a request with tools enabled</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> requestLLM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Make a request without tools</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> responseWithoutTools </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> requestLLMWithoutTools</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Make a request that returns multiple responses</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> responses </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> requestLLMMultiple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="请求的工作原理" tabindex="-1">请求的工作原理 <a class="header-anchor" href="#请求的工作原理" aria-label="Permalink to &quot;请求的工作原理&quot;">​</a></h3><p>当你显式调用其中一个请求方法时，LLM 请求就会被发送。需要理解的关键点是：</p><ol><li><strong>显式调用</strong>：请求仅在你调用 <code>requestLLM()</code>、<code>requestLLMWithoutTools()</code> 等方法时发生。</li><li><strong>即时执行</strong>：当你调用请求方法时，请求会立即发送，并且该方法会阻塞直到收到响应。</li><li><strong>自动历史记录更新</strong>：在写入会话中，响应会自动添加到对话历史记录中。</li><li><strong>无隐式请求</strong>：系统不会发送隐式请求；你需要显式调用请求方法。</li></ol><h3 id="带工具的请求方法" tabindex="-1">带工具的请求方法 <a class="header-anchor" href="#带工具的请求方法" aria-label="Permalink to &quot;带工具的请求方法&quot;">​</a></h3><p>当发送带工具的请求时，LLM 可能会以工具调用而非文本响应进行回应。请求方法会透明地处理这种情况：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> requestLLM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // The response might be a tool call or a text response</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (response </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Message.Tool.Call) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Handle tool call</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Handle text response</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在实践中，你通常无需手动检测响应类型，因为 agent 图会自动处理此路由。</p><h3 id="结构化与流式请求" tabindex="-1">结构化与流式请求 <a class="header-anchor" href="#结构化与流式请求" aria-label="Permalink to &quot;结构化与流式请求&quot;">​</a></h3><p>对于更高级的用例，平台提供了结构化和流式请求的方法：</p><ol><li><p><code>requestLLMStructured()</code>：请求 LLM 以特定的结构化格式提供响应。</p></li><li><p><code>requestLLMStructuredOneShot()</code>：类似于 <code>requestLLMStructured()</code>，但没有重试或更正。</p></li><li><p><code>requestLLMStreaming()</code>：向 LLM 发送流式请求，返回响应块的 flow。</p></li></ol><p>示例：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Make a structured request</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> structuredResponse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> requestLLMStructured</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JokeRating</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Make a streaming request</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> responseStream </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> requestLLMStreaming</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    responseStream.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">collect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { chunk </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Process each chunk as it arrives</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="管理对话历史记录" tabindex="-1">管理对话历史记录 <a class="header-anchor" href="#管理对话历史记录" aria-label="Permalink to &quot;管理对话历史记录&quot;">​</a></h2><h3 id="更新-prompt" tabindex="-1">更新 prompt <a class="header-anchor" href="#更新-prompt" aria-label="Permalink to &quot;更新 prompt&quot;">​</a></h3><p>在写入会话中，你可以使用 <code>updatePrompt</code> 方法更新 prompt（对话历史记录）：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    updatePrompt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Add a system message</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        system</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;You are a helpful assistant.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Add a user message</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, can you help me with a coding question?&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Add an assistant message</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        assistant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Of course! What&#39;s your question?&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Add a tool result</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        tool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myToolResult)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>你还可以使用 <code>rewritePrompt</code> 方法完全重写 prompt：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    rewritePrompt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { oldPrompt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Create a new prompt based on the old one</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        oldPrompt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">copy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(messages </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filteredMessages)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="响应时自动更新历史记录" tabindex="-1">响应时自动更新历史记录 <a class="header-anchor" href="#响应时自动更新历史记录" aria-label="Permalink to &quot;响应时自动更新历史记录&quot;">​</a></h3><p>当你在写入会话中发送 LLM 请求时，响应会自动添加到对话历史记录中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Add a user message</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    updatePrompt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;What&#39;s the capital of France?&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Make a request – the response is automatically added to the history</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> requestLLM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // The prompt now includes both the user message and the model&#39;s response</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这种自动历史记录更新是写入会话的关键特性，确保对话自然流畅。</p><h3 id="历史记录压缩" tabindex="-1">历史记录压缩 <a class="header-anchor" href="#历史记录压缩" aria-label="Permalink to &quot;历史记录压缩&quot;">​</a></h3><p>对于长时间运行的对话，历史记录可能会变得很大并消耗大量 token。平台提供了压缩历史记录的方法：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Compress the history using a TLDR approach</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    replaceHistoryWithTLDR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(HistoryCompressionStrategy.WholeHistory, preserveMemory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>你还可以在策略图中（strategy graph）使用 <code>nodeLLMCompressHistory</code> 节点在特定点压缩历史记录。</p><p>关于历史记录压缩和压缩策略的更多信息，请参见<a href="./history-compression">历史记录压缩</a>。</p><h2 id="在会话中运行工具" tabindex="-1">在会话中运行工具 <a class="header-anchor" href="#在会话中运行工具" aria-label="Permalink to &quot;在会话中运行工具&quot;">​</a></h2><h3 id="调用工具" tabindex="-1">调用工具 <a class="header-anchor" href="#调用工具" aria-label="Permalink to &quot;调用工具&quot;">​</a></h3><p>写入会话提供了几种调用工具的方法：</p><ol><li><p><code>callTool(tool, args)</code>：按引用调用工具。</p></li><li><p><code>callTool(toolName, args)</code>：按名称调用工具。</p></li><li><p><code>callTool(toolClass, args)</code>：按类调用工具。</p></li><li><p><code>callToolRaw(toolName, args)</code>：按名称调用工具并返回原始字符串结果。</p></li></ol><p>示例：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Call a tool by reference</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callTool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myTool, myArgs)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Call a tool by name</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callTool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myToolName&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, myArgs)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Call a tool by class</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callTool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyTool::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, myArgs)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Call a tool and get the raw result</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rawResult </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callToolRaw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myToolName&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, myArgs)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="并行工具运行" tabindex="-1">并行工具运行 <a class="header-anchor" href="#并行工具运行" aria-label="Permalink to &quot;并行工具运行&quot;">​</a></h3><p>要在并行运行多个工具，写入会话提供了 <code>Flow</code> 上的扩展函数：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Run tools in parallel</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    parseDataToArgs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toParallelToolCalls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyTool::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">collect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Process each result</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Run tools in parallel and get raw results</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    parseDataToArgs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toParallelToolCallsRaw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyTool::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">collect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { rawResult </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Process each raw result</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这对于高效处理大量数据很有用。</p><h2 id="最佳实践" tabindex="-1">最佳实践 <a class="header-anchor" href="#最佳实践" aria-label="Permalink to &quot;最佳实践&quot;">​</a></h2><p>在使用 LLM 会话时，请遵循以下最佳实践：</p><ol><li><p><strong>使用正确的会话类型</strong>：当你需要修改对话历史记录时使用写入会话，当你只需要读取它时使用读取会话。</p></li><li><p><strong>保持会话简短</strong>：会话应专注于特定任务，并尽快关闭以释放资源。</p></li><li><p><strong>处理异常</strong>：确保在会话中处理异常，以防止资源泄漏。</p></li><li><p><strong>管理历史记录大小</strong>：对于长时间运行的对话，请使用历史记录压缩来减少 token 使用。</p></li><li><p><strong>优先使用高级抽象</strong>：如果可能，请使用基于节点的 API。例如，使用 <code>nodeLLMRequest</code> 而非直接使用会话。</p></li><li><p><strong>注意线程安全</strong>：请记住，写入会话会阻塞其他会话，因此请尽可能缩短写入操作。</p></li><li><p><strong>对复杂数据使用结构化请求</strong>：当你需要 LLM 返回结构化数据时，请使用 <code>requestLLMStructured</code> 而非解析自由格式文本。</p></li><li><p><strong>对长响应使用流式传输</strong>：对于长响应，请使用 <code>requestLLMStreaming</code> 来处理到达的响应。</p></li></ol><h2 id="故障排除" tabindex="-1">故障排除 <a class="header-anchor" href="#故障排除" aria-label="Permalink to &quot;故障排除&quot;">​</a></h2><h3 id="会话已关闭" tabindex="-1">会话已关闭 <a class="header-anchor" href="#会话已关闭" aria-label="Permalink to &quot;会话已关闭&quot;">​</a></h3><p>如果你看到诸如 <code>Cannot use session after it was closed</code> 的错误，则表示你正在尝试在其 lambda 代码块完成之后使用会话。请确保所有会话操作都在会话代码块内执行。</p><h3 id="历史记录过大" tabindex="-1">历史记录过大 <a class="header-anchor" href="#历史记录过大" aria-label="Permalink to &quot;历史记录过大&quot;">​</a></h3><p>如果你的历史记录变得太大并消耗了过多的 token，请使用历史记录压缩技术：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    replaceHistoryWithTLDR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(HistoryCompressionStrategy.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FromLastNMessages</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), preserveMemory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>关于更多信息，请参见<a href="./history-compression">历史记录压缩</a></p><h3 id="未找到工具" tabindex="-1">未找到工具 <a class="header-anchor" href="#未找到工具" aria-label="Permalink to &quot;未找到工具&quot;">​</a></h3><p>如果你看到有关未找到工具的错误，请检查：</p><ul><li>该工具已在工具注册表中正确注册。</li><li>你正在使用正确的工具名称或类。</li></ul><h2 id="api-文档" tabindex="-1">API 文档 <a class="header-anchor" href="#api-文档" aria-label="Permalink to &quot;API 文档&quot;">​</a></h2><p>关于更多信息，请参见完整的 <a href="https://api.koog.ai/agents/agents-core/ai.koog.agents.core.agent.session/-a-i-agent-l-l-m-session/index.html" target="_blank" rel="noreferrer">AIAgentLLMSession</a> 和 <a href="https://api.koog.ai/agents/agents-core/ai.koog.agents.core.agent.context/-a-i-agent-l-l-m-context/index.html" target="_blank" rel="noreferrer">AIAgentLLMContext</a> 参考。</p>`,89)]))}const g=i(e,[["render",t]]);export{E as __pageData,g as default};
