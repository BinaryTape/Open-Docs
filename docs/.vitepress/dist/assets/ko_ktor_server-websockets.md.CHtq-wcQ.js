import{_ as F,C as t,c as b,o as m,G as a,ag as o,j as i,w as n,a as e}from"./chunks/framework.Bksy39di.js";const x=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ko/ktor/server-websockets.md","filePath":"ko/ktor/server-websockets.md","lastUpdated":1755457140000}'),v={name:"ko/ktor/server-websockets.md"};function C(f,s,S,B,w,q){const r=t("TopicTitle"),d=t("show-structure"),E=t("primary-label"),p=t("Links"),c=t("tldr"),g=t("link-summary"),y=t("snippet"),l=t("code-block"),k=t("TabItem"),h=t("Tabs"),u=t("list");return m(),b("div",null,[a(r,{labelRef:"server-plugin",title:"Ktor 서버에서 WebSockets"}),a(d,{for:"chapter",depth:"2"}),a(E,{ref:"server-plugin"},null,512),a(c,null,{default:n(()=>[s[3]||(s[3]=i("p",null,[i("b",null,"필수 종속성"),e(": "),i("code",null,"io.ktor:ktor-server-websockets")],-1)),s[4]||(s[4]=i("p",null,[i("b",null,"코드 예시"),e(": "),i("a",{href:"https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/server-websockets"}," server-websockets ")],-1)),i("p",null,[i("b",null,[a(p,{href:"/ktor/server-native",summary:"Ktor는 Kotlin/Native를 지원하며 추가 런타임이나 가상 머신 없이 서버를 실행할 수 있습니다."},{default:n(()=>s[0]||(s[0]=[e("네이티브 서버")])),_:1}),s[1]||(s[1]=e(" 지원"))]),s[2]||(s[2]=e(": ✅ "))])]),_:1}),a(g,null,{default:n(()=>s[5]||(s[5]=[e(" WebSockets 플러그인을 사용하면 서버와 클라이언트 간의 다방향 통신 세션을 생성할 수 있습니다. ")])),_:1}),a(y,{id:"websockets-description"},{default:n(()=>s[6]||(s[6]=[i("p",null,"WebSocket은 단일 TCP 연결을 통해 사용자의 브라우저와 서버 간에 전이중 통신 세션을 제공하는 프로토콜입니다. 서버로/부터 실시간 데이터 전송이 필요한 애플리케이션을 생성하는 데 특히 유용합니다.",-1),i("p",null,"Ktor는 서버 및 클라이언트 측 모두에서 WebSocket 프로토콜을 지원합니다.",-1)])),_:1}),s[19]||(s[19]=o('<p>Ktor를 사용하면 다음을 수행할 수 있습니다.</p><ul><li>기본 WebSocket 설정(예: 프레임 크기, 핑 주기 등)을 구성합니다.</li><li>서버와 클라이언트 간 메시지 교환을 위한 WebSocket 세션을 처리합니다.</li><li>WebSocket 확장 기능을 추가합니다. 예를 들어, <a href="./server-websocket-deflate">Deflate</a> 확장 기능을 사용하거나 <a href="./server-websocket-extensions">사용자 지정 확장 기능</a>을 구현할 수 있습니다.</li></ul><blockquote><p>클라이언트 측 WebSocket 지원에 대해 알아보려면 <a href="./client-websockets">WebSockets 클라이언트 플러그인</a>을 참조하세요.</p></blockquote><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>단방향 통신 세션의 경우 <a href="./server-server-sent-events">Server-Sent Events (SSE)</a> 사용을 고려해 보세요. SSE는 서버가 클라이언트에 이벤트 기반 업데이트를 전송해야 하는 경우에 특히 유용합니다.</p></div><h2 id="add_dependencies" tabindex="-1">의존성 추가 <a class="header-anchor" href="#add_dependencies" aria-label="Permalink to &quot;의존성 추가 {id=&quot;add_dependencies&quot;}&quot;">​</a></h2><p><code>WebSockets</code>을(를) 사용하려면 빌드 스크립트에 <code>ktor-server-websockets</code> 아티팩트를 포함해야 합니다: </p>',6)),a(h,{group:"languages"},{default:n(()=>[a(k,{title:"Gradle (Kotlin)","group-key":"kotlin"},{default:n(()=>[a(l,{lang:"Kotlin",code:'            implementation("io.ktor:ktor-server-websockets:$ktor_version")'})]),_:1}),a(k,{title:"Gradle (Groovy)","group-key":"groovy"},{default:n(()=>[a(l,{lang:"Groovy",code:'            implementation "io.ktor:ktor-server-websockets:$ktor_version"'})]),_:1}),a(k,{title:"Maven","group-key":"maven"},{default:n(()=>[a(l,{lang:"XML",code:`            <dependency>
                <groupId>io.ktor</groupId>
                <artifactId>ktor-server-websockets-jvm</artifactId>
                <version>\${ktor_version}</version>
            </dependency>`})]),_:1})]),_:1}),s[20]||(s[20]=i("h2",{id:"install_plugin",tabindex:"-1"},[e("WebSockets 설치 "),i("a",{class:"header-anchor",href:"#install_plugin","aria-label":'Permalink to "WebSockets 설치 {id="install_plugin"}"'},"​")],-1)),i("p",null,[s[8]||(s[8]=e(" 애플리케이션에 ")),s[9]||(s[9]=i("code",null,"WebSockets",-1)),s[10]||(s[10]=e(" 플러그인을 ")),s[11]||(s[11]=i("a",{href:"#install"},"설치",-1)),s[12]||(s[12]=e("하려면 지정된 ")),a(p,{href:"/ktor/server-modules",summary:"모듈을 사용하면 라우트를 그룹화하여 애플리케이션을 구성할 수 있습니다."},{default:n(()=>s[7]||(s[7]=[e("모듈")])),_:1}),s[13]||(s[13]=e("의 ")),s[14]||(s[14]=i("code",null,"install",-1)),s[15]||(s[15]=e(" 함수에 전달하세요. 아래 코드 스니펫은 ")),s[16]||(s[16]=i("code",null,"WebSockets",-1)),s[17]||(s[17]=e("을(를) 설치하는 방법을 보여줍니다... "))]),a(u,null,{default:n(()=>s[18]||(s[18]=[i("li",null,[e(" ... "),i("code",null,"embeddedServer"),e(" 함수 호출 내에서. ")],-1),i("li",null,[e(" ... "),i("code",null,"Application"),e(" 클래스의 확장 함수인 명시적으로 정의된 "),i("code",null,"module"),e(" 내에서. ")],-1)])),_:1}),a(h,null,{default:n(()=>[a(k,{title:"embeddedServer"},{default:n(()=>[a(l,{lang:"kotlin",code:`            import io.ktor.server.engine.*
            import io.ktor.server.netty.*
            import io.ktor.server.application.*
            import io.ktor.server.websocket.*

            fun main() {
                embeddedServer(Netty, port = 8080) {
                    install(WebSockets)
                    // ...
                }.start(wait = true)
            }`})]),_:1}),a(k,{title:"module"},{default:n(()=>[a(l,{lang:"kotlin",code:`            import io.ktor.server.application.*
            import io.ktor.server.websocket.*
            // ...
            fun Application.module() {
                install(WebSockets)
                // ...
            }`})]),_:1})]),_:1}),s[21]||(s[21]=o(`<h2 id="configure" tabindex="-1">WebSockets 구성 <a class="header-anchor" href="#configure" aria-label="Permalink to &quot;WebSockets 구성 {id=&quot;configure&quot;}&quot;">​</a></h2><p>선택적으로, <code>install</code> 블록 내에서 <a href="https://api.ktor.io/ktor-server/ktor-server-plugins/ktor-server-websockets/io.ktor.server.websocket/-web-sockets/-web-socket-options/index.html" target="_blank" rel="noreferrer">WebSocketOptions</a>을(를) 전달하여 플러그인을 구성할 수 있습니다:</p><ul><li><code>pingPeriod</code> 속성을 사용하여 핑 간의 지속 시간을 지정합니다.</li><li><code>timeout</code> 속성을 사용하여 연결이 닫힐 시간 초과를 설정합니다.</li><li><code>maxFrameSize</code> 속성을 사용하여 수신하거나 보낼 수 있는 최대 <code>Frame</code> 크기를 설정합니다.</li><li><code>masking</code> 속성을 사용하여 마스킹을 활성화할지 여부를 지정합니다.</li><li><code>contentConverter</code> 속성을 사용하여 직렬화/역직렬화를 위한 컨버터를 설정합니다.</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(WebSockets) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pingPeriod </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.seconds</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    timeout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.seconds</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    maxFrameSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Long.MAX_VALUE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    masking </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="handle-sessions" tabindex="-1">WebSockets 세션 처리 <a class="header-anchor" href="#handle-sessions" aria-label="Permalink to &quot;WebSockets 세션 처리 {id=&quot;handle-sessions&quot;}&quot;">​</a></h2><h3 id="api-overview" tabindex="-1">API 개요 <a class="header-anchor" href="#api-overview" aria-label="Permalink to &quot;API 개요 {id=&quot;api-overview&quot;}&quot;">​</a></h3><p><code>WebSockets</code> 플러그인을 설치하고 구성한 후 WebSocket 세션을 처리할 엔드포인트를 정의할 수 있습니다. 서버에 WebSocket 엔드포인트를 정의하려면 <a href="./server-routing#define_route">라우팅</a> 블록 내에서 <code>webSocket</code> 함수를 호출합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    webSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/echo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // Handle a WebSocket session</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 예시에서, <a href="./server-configuration-file">기본 구성</a>이 사용될 때 서버는 <code>ws://localhost:8080/echo</code>로 WebSocket 요청을 수락합니다.</p><p><code>webSocket</code> 블록 내에서 WebSocket 세션에 대한 핸들러를 정의하며, 이는 <a href="https://api.ktor.io/ktor-server/ktor-server-plugins/ktor-server-websockets/io.ktor.server.websocket/-default-web-socket-server-session/index.html" target="_blank" rel="noreferrer">DefaultWebSocketServerSession</a> 클래스로 표현됩니다. 블록 내에서 다음 함수와 속성을 사용할 수 있습니다:</p><ul><li><code>send</code> 함수를 사용하여 클라이언트에 텍스트 콘텐츠를 보냅니다.</li><li><code>incoming</code> 및 <code>outgoing</code> 속성을 사용하여 WebSocket 프레임을 수신하고 보내기 위한 채널에 접근합니다. 프레임은 <code>Frame</code> 클래스로 표현됩니다.</li><li><code>close</code> 함수를 사용하여 지정된 이유와 함께 종료 프레임을 보냅니다.</li></ul><p>세션을 처리할 때, 프레임 유형을 확인할 수 있습니다. 예를 들어:</p><ul><li><code>Frame.Text</code>는 텍스트 프레임입니다. 이 프레임 유형의 경우 <code>Frame.Text.readText()</code>를 사용하여 콘텐츠를 읽을 수 있습니다.</li><li><code>Frame.Binary</code>는 바이너리 프레임입니다. 이 유형의 경우 <code>Frame.Binary.readBytes()</code>를 사용하여 콘텐츠를 읽을 수 있습니다.</li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p><code>incoming</code> 채널에는 핑/퐁 또는 종료 프레임과 같은 제어 프레임이 포함되어 있지 않습니다. 제어 프레임을 처리하고 분할된 프레임을 재조립하려면 <a href="https://api.ktor.io/ktor-server/ktor-server-plugins/ktor-server-websockets/io.ktor.server.websocket/web-socket-raw.html" target="_blank" rel="noreferrer">webSocketRaw</a> 함수를 사용하여 WebSocket 세션을 처리하세요.</p></div><blockquote><p>클라이언트에 대한 정보(예: 클라이언트의 IP 주소)를 얻으려면 <code>call</code> 속성을 사용하세요. <a href="./server-requests#request_information">일반 요청 정보</a>에 대해 알아보세요.</p></blockquote><p>아래에서 이 API를 사용하는 예시를 살펴보겠습니다.</p><h3 id="handle-single-session" tabindex="-1">예시: 단일 세션 처리 <a class="header-anchor" href="#handle-single-session" aria-label="Permalink to &quot;예시: 단일 세션 처리 {id=&quot;handle-single-session&quot;}&quot;">​</a></h3><p>아래 예시는 단일 클라이언트와의 세션을 처리하기 위해 <code>echo</code> WebSocket 엔드포인트를 생성하는 방법을 보여줍니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    webSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/echo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Please enter your name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> incoming) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? Frame.Text ?: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">continue</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> receivedText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> frame.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (receivedText.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bye&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ignoreCase </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CloseReason</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CloseReason.Codes.NORMAL, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Client said BYE&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Frame.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hi, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$receivedText</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>전체 예시는 <a href="https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/server-websockets" target="_blank" rel="noreferrer">server-websockets</a>를 참조하세요.</p><h3 id="handle-multiple-session" tabindex="-1">예시: 다중 세션 처리 <a class="header-anchor" href="#handle-multiple-session" aria-label="Permalink to &quot;예시: 다중 세션 처리 {id=&quot;handle-multiple-session&quot;}&quot;">​</a></h3><p>여러 WebSocket 세션을 효율적으로 관리하고 브로드캐스팅을 처리하려면 Kotlin의 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/" target="_blank" rel="noreferrer"><code>SharedFlow</code></a>를 활용할 수 있습니다. 이 접근 방식은 WebSocket 통신을 관리하기 위한 확장 가능하고 동시성 친화적인 방법을 제공합니다. 이 패턴을 구현하는 방법은 다음과 같습니다:</p><ol><li>메시지 브로드캐스팅을 위한 <code>SharedFlow</code>를 정의합니다:</li></ol><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> messageResponseFlow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MutableSharedFlow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MessageResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sharedFlow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> messageResponseFlow.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asSharedFlow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ol start="2"><li>WebSocket 라우트에서 브로드캐스팅 및 메시지 처리 로직을 구현합니다:</li></ol><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        webSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/ws&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;You are connected to WebSocket!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> job </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                sharedFlow.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">collect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message.message)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            runCatching</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                incoming.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">consumeEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Frame.Text) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> receivedText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> frame.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> messageResponse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MessageResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(receivedText)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        messageResponseFlow.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(messageResponse)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onFailure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { exception </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;WebSocket exception: \${exception.localizedMessage}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">also</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                job.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cancel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span></code></pre></div><p><code>runCatching</code> 블록은 수신 메시지를 처리하고 <code>SharedFlow</code>로 내보내며, <code>SharedFlow</code>는 모든 컬렉터에게 브로드캐스팅합니다.</p><p>이 패턴을 사용하면 개별 연결을 수동으로 추적하지 않고도 여러 WebSocket 세션을 효율적으로 관리할 수 있습니다. 이 접근 방식은 동시 WebSocket 연결이 많은 애플리케이션에 잘 맞고, 메시지 브로드캐스팅을 처리하는 깔끔하고 반응적인 방법을 제공합니다.</p><p>전체 예시는 <a href="https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/server-websockets-sharedflow" target="_blank" rel="noreferrer">server-websockets-sharedflow</a>를 참조하세요.</p><h2 id="websocket-api" tabindex="-1">WebSocket API와 Ktor <a class="header-anchor" href="#websocket-api" aria-label="Permalink to &quot;WebSocket API와 Ktor {id=&quot;websocket-api&quot;}&quot;">​</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" target="_blank" rel="noreferrer">WebSocket API의 표준 이벤트</a>는 Ktor에 다음과 같이 매핑됩니다:</p><ul><li><code>onConnect</code>는 블록의 시작 부분에서 발생합니다.</li><li><code>onMessage</code>는 메시지를 성공적으로 읽은 후(예: <code>incoming.receive()</code> 사용) 또는 <code>for(frame in incoming)</code>과 같은 일시 중단된 반복을 사용할 때 발생합니다.</li><li><code>onClose</code>는 <code>incoming</code> 채널이 닫힐 때 발생합니다. 이는 일시 중단된 반복을 완료하거나 메시지를 수신하려고 할 때 <code>ClosedReceiveChannelException</code>을 발생시킵니다.</li><li><code>onError</code>는 다른 예외와 동일합니다.</li></ul><p><code>onClose</code>와 <code>onError</code> 모두에서 <code>closeReason</code> 속성이 설정됩니다.</p><p>다음 예시에서 무한 루프는 예외( <code>ClosedReceiveChannelException</code> 또는 다른 예외)가 발생할 때만 종료됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">webSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/echo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;onConnect&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> incoming){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> text </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Frame.Text).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;onMessage&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            received </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> text</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            outgoing.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Frame.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ClosedReceiveChannelException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;onClose \${closeReason.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Throwable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;onError \${closeReason.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,35))])}const _=F(v,[["render",C]]);export{x as __pageData,_ as default};
