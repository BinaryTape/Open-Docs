import{_ as i,c as e,o as t,ag as l}from"./chunks/framework.Bksy39di.js";const p=JSON.parse('{"title":"与 Java 的对比","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/comparison-to-java.md","filePath":"kotlin/comparison-to-java.md","lastUpdated":1754307826000}'),o={name:"kotlin/comparison-to-java.md"};function n(r,a,s,f,h,c){return t(),e("div",null,a[0]||(a[0]=[l('<h1 id="与-java-的对比" tabindex="-1">与 Java 的对比 <a class="header-anchor" href="#与-java-的对比" aria-label="Permalink to &quot;与 Java 的对比&quot;">​</a></h1><h2 id="kotlin-中解决的一些-java-问题" tabindex="-1">Kotlin 中解决的一些 Java 问题 <a class="header-anchor" href="#kotlin-中解决的一些-java-问题" aria-label="Permalink to &quot;Kotlin 中解决的一些 Java 问题&quot;">​</a></h2><p>Kotlin 解决了 Java 存在的一系列问题：</p><ul><li>空引用由<a href="/kotlin/null-safety">类型系统</a>控制。</li><li><a href="/kotlin/java-interop#java-generics-in-kotlin">无原始类型</a></li><li>Kotlin 中的数组是<a href="/kotlin/arrays">不型变的</a>。</li><li>Kotlin 拥有恰当的<a href="/kotlin/lambdas#function-types">函数类型</a>，而非 Java 的 SAM 转换。</li><li><a href="/kotlin/generics#use-site-variance-type-projections">使用处型变</a>而无需通配符</li><li>Kotlin 没有受检<a href="/kotlin/exceptions">异常</a>。</li><li><a href="/kotlin/collections-overview">只读集合和可变集合的独立接口</a></li></ul><h2 id="java-有而-kotlin-没有的特性" tabindex="-1">Java 有而 Kotlin 没有的特性 <a class="header-anchor" href="#java-有而-kotlin-没有的特性" aria-label="Permalink to &quot;Java 有而 Kotlin 没有的特性&quot;">​</a></h2><ul><li><a href="/kotlin/exceptions">受检异常</a></li><li>不是类的<a href="/kotlin/basic-types">基本类型</a>。字节码尽可能使用基本类型，但它们不<a href="/kotlin/basic-types">显式</a>可用。</li><li><a href="/kotlin/classes">静态成员</a>被 <a href="/kotlin/object-declarations#companion-objects">companion objects</a>、<a href="/kotlin/functions">顶层函数</a>、<a href="/kotlin/extensions#extension-functions">扩展函数</a>或 <a href="/kotlin/java-to-kotlin-interop#static-methods">@JvmStatic</a> 取代。</li><li><a href="/kotlin/generics">通配符类型</a>被<a href="/kotlin/generics#declaration-site-variance">声明处型变</a>和<a href="/kotlin/generics#type-projections">类型投影</a>取代。</li><li><a href="/kotlin/control-flow#if-expression">三元操作符 <code>a ? b : c</code></a>被 <a href="/kotlin/control-flow#if-expression">if 表达式</a>取代。</li><li><a href="https://openjdk.org/jeps/395" target="_blank" rel="noreferrer">Records</a></li><li><a href="https://openjdk.org/projects/amber/design-notes/patterns/pattern-matching-for-java" target="_blank" rel="noreferrer">Pattern Matching</a></li><li>包私有<a href="/kotlin/visibility-modifiers">可见性修饰符</a></li></ul><h2 id="kotlin-有而-java-没有的特性" tabindex="-1">Kotlin 有而 Java 没有的特性 <a class="header-anchor" href="#kotlin-有而-java-没有的特性" aria-label="Permalink to &quot;Kotlin 有而 Java 没有的特性&quot;">​</a></h2><ul><li><a href="/kotlin/lambdas">lambda 表达式</a> + <a href="/kotlin/inline-functions">内联函数</a> = 高性能的自定义控制结构</li><li><a href="/kotlin/extensions">扩展函数</a></li><li><a href="/kotlin/null-safety">空安全</a></li><li><a href="/kotlin/typecasts">智能类型转换</a>（<strong>Java 16</strong>：<a href="https://openjdk.org/jeps/394" target="_blank" rel="noreferrer">Pattern Matching for instanceof</a>）</li><li><a href="/kotlin/strings">字符串模板</a>（<strong>Java 21</strong>：<a href="https://openjdk.org/jeps/430" target="_blank" rel="noreferrer">String Templates (Preview)</a>）</li><li><a href="/kotlin/properties">属性</a></li><li><a href="/kotlin/classes">主构造函数</a></li><li><a href="/kotlin/delegation">头等委托</a></li><li><a href="/kotlin/basic-types">变量和属性的类型推断</a>（<strong>Java 10</strong>：<a href="https://openjdk.org/jeps/286" target="_blank" rel="noreferrer">Local-Variable Type Inference</a>）</li><li><a href="/kotlin/object-declarations">单例</a></li><li><a href="/kotlin/generics">声明处型变与类型投影</a></li><li><a href="/kotlin/ranges">区间表达式</a></li><li><a href="/kotlin/operator-overloading">操作符重载</a></li><li><a href="/kotlin/classes#companion-objects">Companion objects</a></li><li><a href="/kotlin/data-classes">数据类</a></li><li><a href="/kotlin/coroutines-overview">协程</a></li><li><a href="/kotlin/functions">顶层函数</a></li><li><a href="/kotlin/functions#parameters-with-default-values">带默认值的形参</a></li><li><a href="/kotlin/functions#named-arguments">具名形参</a></li><li><a href="/kotlin/functions#infix-notation">中缀函数</a></li><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-expect-actual.html" target="_blank" rel="noreferrer">预期与实际声明</a></li><li><a href="/kotlin/whatsnew14#explicit-api-mode-for-library-authors">显式 API 模式</a>和<a href="/kotlin/opt-in-requirements">更好地控制 API 面</a></li></ul><h2 id="接下来" tabindex="-1">接下来？ <a class="header-anchor" href="#接下来" aria-label="Permalink to &quot;接下来？&quot;">​</a></h2><p>了解如何：</p><ul><li>在 Java 和 Kotlin 中执行<a href="/kotlin/java-to-kotlin-idioms-strings">典型的字符串任务</a>。</li><li>在 Java 和 Kotlin 中执行<a href="/kotlin/java-to-kotlin-collections-guide">典型的集合任务</a>。</li><li><a href="/kotlin/java-to-kotlin-nullability-guide">处理 Java 和 Kotlin 中的可空性</a>。</li></ul>',11)]))}const d=i(o,[["render",n]]);export{p as __pageData,d as default};
