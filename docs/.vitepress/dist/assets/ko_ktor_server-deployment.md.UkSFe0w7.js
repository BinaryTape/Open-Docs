import{_ as n,C as t,c as s,o as p,j as a,G as r,ag as c,a as o,w as d}from"./chunks/framework.Bksy39di.js";const q=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ko/ktor/server-deployment.md","filePath":"ko/ktor/server-deployment.md","lastUpdated":1755457140000}'),h={name:"ko/ktor/server-deployment.md"};function u(f,e,g,k,m,b){const i=t("show-structure"),l=t("tldr");return p(),s("div",null,[e[1]||(e[1]=a("h1",{id:"배포",tabindex:"-1"},[o("배포 "),a("a",{class:"header-anchor",href:"#배포","aria-label":'Permalink to "배포"'},"​")],-1)),r(i,{for:"chapter",depth:"2"}),r(l,null,{default:d(()=>e[0]||(e[0]=[a("p",null,[a("b",null,"코드 예시"),o(": "),a("a",{href:"https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/deployment-ktor-plugin"}," deployment-ktor-plugin ")],-1)])),_:1}),e[2]||(e[2]=c('<p>이 토픽에서는 Ktor 애플리케이션을 배포하는 방법에 대해 간략히 살펴보겠습니다.</p><blockquote><p>서버 Ktor 애플리케이션의 배포 프로세스를 간소화하려면 <a href="https://github.com/ktorio/ktor-build-plugins" target="_blank" rel="noreferrer">Ktor</a> Gradle 플러그인을 사용할 수 있으며, 이 플러그인은 다음 기능을 제공합니다:</p><ul><li>Fat JAR 빌드.</li><li>애플리케이션 도커화.</li></ul></blockquote><h2 id="ktor-specifics" tabindex="-1">Ktor 배포의 특징 <a class="header-anchor" href="#ktor-specifics" aria-label="Permalink to &quot;Ktor 배포의 특징 {id=&quot;ktor-specifics&quot;}&quot;">​</a></h2><p>서버 Ktor 애플리케이션의 배포 프로세스는 다음 특징에 따라 달라집니다:</p><ul><li>애플리케이션을 자체 포함 패키지로 배포할지 또는 서블릿 컨테이너 내부에 배포할지 여부.</li><li>서버를 생성하고 구성하는 데 어떤 접근 방식을 사용하는지.</li></ul><h3 id="self-contained-vs-servlet" tabindex="-1">자체 포함 앱 vs 서블릿 컨테이너 <a class="header-anchor" href="#self-contained-vs-servlet" aria-label="Permalink to &quot;자체 포함 앱 vs 서블릿 컨테이너 {id=&quot;self-contained-vs-servlet&quot;}&quot;">​</a></h3><p>Ktor를 사용하면 애플리케이션 내에서 원하는 네트워크 <a href="./server-engines">엔진</a>(예: Netty, Jetty 또는 Tomcat)으로 서버를 생성하고 시작할 수 있습니다. 이 경우 엔진은 애플리케이션의 일부입니다. 애플리케이션이 엔진 설정, 연결 및 SSL 옵션을 제어합니다. 애플리케이션을 배포하려면 <a href="#packaging">패키징</a>하여 fat JAR 또는 실행 가능한 JVM 애플리케이션으로 만들 수 있습니다.</p><p>위 접근 방식과 달리, 서블릿 컨테이너는 애플리케이션 라이프사이클과 연결 설정을 제어해야 합니다. Ktor는 애플리케이션 제어를 서블릿 컨테이너에 위임하는 특수 <code>ServletApplicationEngine</code> 엔진을 제공합니다. 서블릿 컨테이너 내부에 배포하려면 <a href="./server-war">WAR 아카이브</a>를 생성해야 합니다.</p><h3 id="code-vs-config" tabindex="-1">구성: 코드 vs 구성 파일 <a class="header-anchor" href="#code-vs-config" aria-label="Permalink to &quot;구성: 코드 vs 구성 파일 {id=&quot;code-vs-config&quot;}&quot;">​</a></h3><p>배포를 위한 자체 포함 Ktor 애플리케이션 구성은 <a href="./server-create-and-configure">서버를 생성하고 구성하는</a> 데 사용된 접근 방식, 즉 코드에서 직접 하거나 <a href="./server-configuration-file">구성 파일</a>을 사용하는 방식에 따라 달라질 수 있습니다. 예를 들어, <a href="#publishing">호스팅 제공업체</a>는 들어오는 요청을 수신하는 데 사용되는 포트를 지정하도록 요구할 수 있습니다. 이 경우 코드 또는 <code>application.conf</code>/<code>application.yaml</code> 파일에서 포트를 <a href="./server-configuration-file">구성</a>해야 합니다.</p><h2 id="packaging" tabindex="-1">패키징 <a class="header-anchor" href="#packaging" aria-label="Permalink to &quot;패키징 {id=&quot;packaging&quot;}&quot;">​</a></h2><p>애플리케이션을 배포하기 전에 다음 방법 중 하나로 패키징해야 합니다:</p><ul><li><p><strong>Fat JAR</strong></p><p>Fat JAR는 모든 코드 종속성을 포함하는 실행 가능한 JAR입니다. Fat JAR를 지원하는 모든 <a href="#publishing">클라우드 서비스</a>에 배포할 수 있습니다. GraalVM용 네이티브 바이너리를 생성해야 하는 경우에도 Fat JAR가 필요합니다. Fat JAR를 생성하려면 Gradle용 <a href="./server-fatjar">Ktor</a> 플러그인 또는 Maven용 <a href="./maven-assembly-plugin">Assembly</a> 플러그인을 사용할 수 있습니다.</p></li><li><p><strong>실행 가능한 JVM 애플리케이션</strong></p><p>실행 가능한 JVM 애플리케이션은 코드 종속성과 생성된 시작 스크립트를 포함하는 패키징된 애플리케이션입니다. Gradle의 경우 <a href="./server-packaging">Application</a> 플러그인을 사용하여 애플리케이션을 생성할 수 있습니다.</p></li><li><p><strong>WAR</strong></p><p><a href="./server-war">WAR 아카이브</a>를 사용하면 Tomcat 또는 Jetty와 같은 서블릿 컨테이너 내부에 애플리케이션을 배포할 수 있습니다.</p></li><li><p><strong>GraalVM</strong></p><p>Ktor 서버 애플리케이션은 다양한 플랫폼을 위한 네이티브 이미지를 생성하기 위해 <a href="./graalvm">GraalVM</a>을 활용할 수 있습니다.</p></li></ul><h2 id="containerizing" tabindex="-1">컨테이너화 <a class="header-anchor" href="#containerizing" aria-label="Permalink to &quot;컨테이너화 {id=&quot;containerizing&quot;}&quot;">​</a></h2><p>애플리케이션을 패키징한 후(예: 실행 가능한 JVM 애플리케이션 또는 fat JAR로), 이 애플리케이션이 포함된 <a href="./docker">Docker 이미지</a>를 준비할 수 있습니다. 이 이미지는 Kubernetes, Swarm 또는 필요한 클라우드 서비스 컨테이너 인스턴스에서 애플리케이션을 실행하는 데 사용될 수 있습니다.</p><h2 id="publishing" tabindex="-1">배포 <a class="header-anchor" href="#publishing" aria-label="Permalink to &quot;배포 {id=&quot;publishing&quot;}&quot;">​</a></h2><p>아래 튜토리얼은 Ktor 애플리케이션을 특정 클라우드 제공업체에 배포하는 방법을 보여줍니다:</p><ul><li><a href="./google-app-engine">Google App Engine</a></li><li><a href="./heroku">Heroku</a></li><li><a href="./elastic-beanstalk">AWS Elastic Beanstalk</a></li></ul><h2 id="ssl" tabindex="-1">SSL <a class="header-anchor" href="#ssl" aria-label="Permalink to &quot;SSL {id=&quot;ssl&quot;}&quot;">​</a></h2><p>Ktor 서버가 리버스 프록시(예: Nginx 또는 Apache) 뒤에 있거나 서블릿 컨테이너(Tomcat 또는 Jetty) 내에서 실행되는 경우, SSL 설정은 리버스 프록시 또는 서블릿 컨테이너에 의해 관리됩니다. 필요한 경우 Java KeyStore를 사용하여 Ktor가 <a href="./server-ssl">SSL을 직접 제공</a>하도록 구성할 수 있습니다.</p><blockquote><p>Ktor 애플리케이션이 서블릿 컨테이너 내부에 배포될 때는 SSL 설정이 적용되지 않습니다.</p></blockquote>',21))])}const _=n(h,[["render",u]]);export{q as __pageData,_ as default};
