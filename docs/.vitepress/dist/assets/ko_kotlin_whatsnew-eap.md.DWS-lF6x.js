import{_ as t}from"./chunks/xcode-swift-export-run-script-phase.CN5rl4tW.js";import{_ as l}from"./chunks/default-hierarchy-example-with-web.De_8QTGQ.js";import{_ as e,C as p,c as h,o as k,ag as i,G as n}from"./chunks/framework.Bksy39di.js";const m=JSON.parse('{"title":"Kotlin 2.2.20-Beta2의 새로운 기능","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/whatsnew-eap.md","filePath":"ko/kotlin/whatsnew-eap.md","lastUpdated":1754307826000}'),r={name:"ko/kotlin/whatsnew-eap.md"};function o(d,s,c,E,g,y){const a=p("TopicTitle");return k(),h("div",null,[s[0]||(s[0]=i(`<h1 id="kotlin-2-2-20-beta2의-새로운-기능" tabindex="-1">Kotlin 2.2.20-Beta2의 새로운 기능 <a class="header-anchor" href="#kotlin-2-2-20-beta2의-새로운-기능" aria-label="Permalink to &quot;Kotlin 2.2.20-Beta2의 새로운 기능&quot;">​</a></h1><p><code>[//]: # (title: Kotlin 2.2.20-Beta2의 새로운 기능)</code></p><p><em><a href="/ko/kotlin/eap#build-details">릴리스 날짜: July 29, 2025</a></em></p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>이 문서는 얼리 액세스 프리뷰(EAP) 릴리스의 모든 기능을 다루지는 않지만, 몇 가지 주요 개선 사항을 강조합니다. 전체 변경 사항 목록은 <a href="https://github.com/JetBrains/kotlin/releases/tag/v2.2.20-Beta2" target="_blank" rel="noreferrer">GitHub 변경 로그</a>를 참조하세요.</p></div><p>Kotlin 2.2.20-Beta2이(가) 릴리스되었습니다! 이 EAP 릴리스의 세부 정보는 다음과 같습니다:</p><ul><li>Kotlin Multiplatform: <a href="#swift-export-available-by-default">Swift 내보내기 기본 지원</a>, <a href="#shared-source-set-for-js-and-wasmjs-targets"><code>js</code> 및 <code>wasmJs</code> 타겟을 위한 공유 소스셋</a>, <a href="#stable-cross-platform-compilation-for-kotlin-libraries">Kotlin 라이브러리를 위한 안정적인 크로스 플랫폼 컴파일</a>, 그리고 <a href="#new-approach-for-declaring-common-dependencies">공통 의존성 선언을 위한 새로운 접근 방식</a>.</li><li>Language: <a href="#improved-overload-resolution-for-lambdas-with-suspend-function-types">suspend 함수 타입의 오버로드에 람다를 전달할 때 개선된 오버로드 해결</a>.</li><li>Kotlin/Native: <a href="#support-for-stack-canaries-in-binaries">바이너리에서 스택 카나리 지원</a> 및 <a href="#smaller-binary-size-for-ios-targets">iOS 타겟을 위한 더 작은 바이너리 크기</a>.</li><li>Kotlin/Wasm: <a href="#improved-exception-handling-in-kotlin-wasm-and-javascript-interop">Kotlin/Wasm 및 JavaScript 상호 운용성에서 개선된 예외 처리</a>.</li><li>Kotlin/JS: <a href="#usage-of-bigint-type-to-represent-kotlin-s-long-type"><code>Long</code> 값이 JavaScript <code>BigInt</code>로 컴파일됨</a>.</li></ul><h2 id="ide-지원" tabindex="-1">IDE 지원 <a class="header-anchor" href="#ide-지원" aria-label="Permalink to &quot;IDE 지원&quot;">​</a></h2><p>Kotlin 2.2.20-Beta2을(를) 지원하는 Kotlin 플러그인은 IntelliJ IDEA 및 Android Studio의 최신 버전에 번들로 제공됩니다. IDE에서 Kotlin 플러그인을 업데이트할 필요가 없습니다. 빌드 스크립트에서 Kotlin 버전을 2.2.20-Beta2(으)로 <a href="/ko/kotlin/configure-build-for-eap">변경하기만</a> 하면 됩니다.</p><p>자세한 내용은 <a href="/ko/kotlin/releases#update-to-a-new-kotlin-version">새 릴리스로 업데이트</a>를 참조하세요.</p><h2 id="언어" tabindex="-1">언어 <a class="header-anchor" href="#언어" aria-label="Permalink to &quot;언어&quot;">​</a></h2><p>Kotlin 2.2.20-Beta2에서 <a href="#improved-overload-resolution-for-lambdas-with-suspend-function-types">suspend 함수 타입의 오버로드에 람다를 전달할 때 개선된 오버로드 해결</a>과 <a href="#support-for-return-statements-in-expression-bodies-with-explicit-return-types">명시적 반환 타입이 있는 표현식 본문에서 return 문 지원</a>을 포함하여 Kotlin 2.3.0에 계획된 향후 언어 기능을 시도해 볼 수 있습니다.</p><h3 id="suspend-함수-타입의-람다에-대한-오버로드-해결-개선" tabindex="-1">suspend 함수 타입의 람다에 대한 오버로드 해결 개선 <a class="header-anchor" href="#suspend-함수-타입의-람다에-대한-오버로드-해결-개선" aria-label="Permalink to &quot;suspend 함수 타입의 람다에 대한 오버로드 해결 개선&quot;">​</a></h3><p>이전에는 일반 함수 타입과 <code>suspend</code> 함수 타입 둘 다로 함수를 오버로드하면 람다를 전달할 때 모호성 오류가 발생했습니다. 이 오류는 명시적 타입 캐스트로 해결할 수 있었지만, 컴파일러는 <code>No cast needed</code> 경고를 잘못 보고했습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Defines two overloads</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Int) {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">suspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Int) {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Fails with overload resolution ambiguity</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Uses an explicit cast, but compiler incorrectly reports a &quot;No cast needed&quot; warning</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Int)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 변경 사항으로 일반 함수 타입 오버로드와 <code>suspend</code> 함수 타입 오버로드 둘 다를 정의할 때, 캐스트가 없는 람다는 일반 오버로드로 해결됩니다. <code>suspend</code> 키워드를 사용하여 suspend 오버로드로 명시적으로 해결할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Resolves to transform(() -&gt; Int)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Resolves to transform(suspend { 42 })</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p>이 동작은 Kotlin 2.3.0에서 기본적으로 활성화됩니다. 지금 테스트하려면 다음 컴파일러 옵션을 사용하여 언어 버전을 <code>2.3</code>으로 설정하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">language</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">version </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.3</span></span></code></pre></div><p>또는 <code>build.gradle(.kts)</code> 파일에서 구성하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        languageVersion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_2_3)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이슈 트래커인 <a href="https://youtrack.jetbrains.com/issue/KT-23610" target="_blank" rel="noreferrer">YouTrack</a>에 피드백을 주시면 감사하겠습니다.</p><h3 id="명시적-반환-타입이-있는-표현식-본문에서-return-문-지원" tabindex="-1">명시적 반환 타입이 있는 표현식 본문에서 return 문 지원 <a class="header-anchor" href="#명시적-반환-타입이-있는-표현식-본문에서-return-문-지원" aria-label="Permalink to &quot;명시적 반환 타입이 있는 표현식 본문에서 return 문 지원&quot;">​</a></h3><p>이전에는 표현식 본문에서 <code>return</code>을 사용하면 함수의 반환 타입이 <code>Nothing</code>으로 추론될 수 있었기 때문에 컴파일러 오류가 발생했습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Error: Returns are prohibited for functions with an expression body</span></span></code></pre></div><p>이 변경 사항으로 반환 타입이 명시적으로 작성되어 있는 한, 이제 표현식 본문에서 <code>return</code>을 사용할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Specifies the return type explicitly</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDisplayNameOrDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userId: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDisplayName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userId ?: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;default&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Fails because it doesn&#39;t specify the return type explicitly</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDisplayNameOrDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userId: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDisplayName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userId ?: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;default&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>마찬가지로, 표현식 본문이 있는 함수의 람다 및 중첩된 표현식 내부의 <code>return</code> 문이 의도치 않게 컴파일되곤 했습니다. Kotlin은 이제 반환 타입이 명시적으로 지정된 경우에 이러한 케이스를 지원합니다. 명시적 반환 타입이 없는 경우는 Kotlin 2.3.0에서 더 이상 사용되지 않을 예정입니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Return type isn&#39;t explicitly specified, and the return statement is inside a lambda</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// which will be deprecated</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> returnInsideLambda</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Return type isn&#39;t explicitly specified, and the return statement is inside the initializer</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// of a local variable, which will be deprecated</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> returnInsideIf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">someCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> else</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;value&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        result</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 동작은 Kotlin 2.3.0에서 기본적으로 활성화됩니다. 지금 테스트하려면 다음 컴파일러 옵션을 사용하여 언어 버전을 <code>2.3</code>으로 설정하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">language</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">version </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.3</span></span></code></pre></div><p>또는 <code>build.gradle(.kts)</code> 파일에서 구성하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        languageVersion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_2_3)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이슈 트래커인 <a href="https://youtrack.jetbrains.com/issue/KT-76926" target="_blank" rel="noreferrer">YouTrack</a>에 피드백을 주시면 감사하겠습니다.</p>`,33)),n(a,{id:"kotlin-jvm-when-표현식에서-invokedynamic-지원",level:"2",title:"Kotlin/JVM: when 표현식에서 invokedynamic 지원",labelRef:"experimental-opt-in"}),s[1]||(s[1]=i(` <p>Kotlin 2.2.20-Beta2에서 이제 <code>when</code> 표현식을 <code>invokedynamic</code>으로 컴파일할 수 있습니다. 이전에는 여러 타입 체크가 있는 <code>when</code> 표현식이 바이트코드에서 긴 <code>instanceof</code> 체크 체인으로 컴파일되었습니다.</p><p>이제 <code>when</code> 표현식과 함께 <code>invokedynamic</code>을 사용하여 Java <code>switch</code> 문으로 생성되는 바이트코드와 유사하게 더 작은 바이트코드를 생성할 수 있습니다. 다음 조건이 충족될 때 사용 가능합니다:</p><ul><li><code>else</code>를 제외한 모든 조건은 <code>is</code> 또는 <code>null</code> 체크입니다.</li><li>표현식에 <a href="/ko/kotlin/control-flow#guard-conditions-in-when-expressions">가드 조건(<code>if</code>)</a>이 포함되어 있지 않습니다.</li><li>조건에 직접 타입 체크할 수 없는 타입(예: 변경 가능한 Kotlin 컬렉션(<code>MutableList</code>) 또는 함수 타입(<code>kotlin.Function1</code>, <code>kotlin.Function2</code> 등))이 포함되어 있지 않습니다.</li><li><code>else</code> 외에 최소 두 개의 조건이 있습니다.</li><li>모든 브랜치가 <code>when</code> 표현식의 동일한 주체를 체크합니다.</li></ul><p>예시:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">open</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Example</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Uses invokedynamic with SwitchBootstraps.typeSwitch</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> C </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>새 기능이 활성화되면 이 예시의 <code>when</code> 표현식은 여러 <code>instanceof</code> 체크 대신 단일 <code>invokedynamic</code> 타입 스위치로 컴파일됩니다.</p><p>이 기능을 활성화하려면 JVM 타겟 21 이상으로 Kotlin 코드를 컴파일하고 다음 컴파일러 옵션을 추가하세요:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">-Xwhen-expressions</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">indy</span></span></code></pre></div><p>또는 <code>build.gradle(.kts)</code> 파일의 <code>compilerOptions {}</code> 블록에 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xwhen-expressions=indy&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 기능은 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적</a>입니다. 피드백이나 질문이 있다면 <a href="https://youtrack.jetbrains.com/issue/KT-65688" target="_blank" rel="noreferrer">YouTrack</a>에 공유해 주세요.</p><h2 id="kotlin-multiplatform" tabindex="-1">Kotlin Multiplatform <a class="header-anchor" href="#kotlin-multiplatform" aria-label="Permalink to &quot;Kotlin Multiplatform&quot;">​</a></h2><p>Kotlin 2.2.20-Beta2은 Kotlin Multiplatform에 중요한 변경 사항을 도입합니다: Swift 내보내기가 기본적으로 제공되며, 새로운 공유 소스셋이 있고, 공통 의존성을 관리하는 새로운 접근 방식을 시도할 수 있습니다.</p>`,14)),n(a,{id:"swift-내보내기-기본-지원",level:"3",title:"Swift 내보내기 기본 지원",labelRef:"experimental-general"}),s[2]||(s[2]=i(' <p>Kotlin 2.2.20-Beta2은 Swift 내보내기에 대한 실험적 지원을 도입합니다. 이 기능을 통해 Kotlin 소스를 직접 내보내고 Swift에서 Kotlin 코드를 관용적으로 호출할 수 있어 Objective-C 헤더가 필요 없습니다.</p><p>이는 Apple 타겟을 위한 멀티플랫폼 개발을 크게 개선할 것입니다. 예를 들어, 최상위 함수가 있는 Kotlin 모듈이 있다면 Swift 내보내기를 통해 깔끔하고 모듈별로 명확한 임포트를 사용할 수 있으며, 혼란스러운 Objective-C 밑줄과 변형된 이름을 제거합니다.</p><p>주요 기능은 다음과 같습니다:</p><ul><li><strong>다중 모듈 지원</strong>. 각 Kotlin 모듈은 별도의 Swift 모듈로 내보내져 함수 호출을 간소화합니다.</li><li><strong>패키지 지원</strong>. Kotlin 패키지는 내보내기 시 명시적으로 보존되어 생성된 Swift 코드의 이름 충돌을 방지합니다.</li><li><strong>타입 별칭</strong>. Kotlin 타입 별칭은 Swift로 내보내지고 보존되어 가독성을 향상시킵니다.</li><li><strong>기본 타입에 대한 향상된 널 가능성</strong>. 널 가능성을 보존하기 위해 <code>Int?</code>와 같은 타입을 <code>KotlinInt</code>와 같은 래퍼 클래스로 박싱해야 했던 Objective-C 상호 운용성과 달리, Swift 내보내기는 널 가능성 정보를 직접 변환합니다.</li><li><strong>오버로드</strong>. Swift에서 Kotlin의 오버로드된 함수를 모호함 없이 호출할 수 있습니다.</li><li><strong>평탄화된 패키지 구조</strong>. Kotlin 패키지를 Swift 열거형으로 변환하여 생성된 Swift 코드에서 패키지 접두사를 제거할 수 있습니다.</li><li><strong>모듈 이름 사용자 정의</strong>. Kotlin 프로젝트의 Gradle 구성에서 결과 Swift 모듈 이름을 사용자 정의할 수 있습니다.</li></ul><h4 id="swift-내보내기-활성화-방법" tabindex="-1">Swift 내보내기 활성화 방법 <a class="header-anchor" href="#swift-내보내기-활성화-방법" aria-label="Permalink to &quot;Swift 내보내기 활성화 방법&quot;">​</a></h4><p>이 기능은 현재 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적</a>이며 iOS 프레임워크를 Xcode 프로젝트에 연결하기 위해 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-direct-integration.html" target="_blank" rel="noreferrer">직접 통합</a>을 사용하는 프로젝트에서만 작동합니다. 이는 IntelliJ IDEA의 Kotlin Multiplatform 플러그인 또는 <a href="https://kmp.jetbrains.com/" target="_blank" rel="noreferrer">웹 위자드</a>를 통해 생성된 Kotlin Multiplatform 프로젝트의 표준 구성입니다.</p><p>Swift 내보내기를 사용해 보려면 Xcode 프로젝트를 구성하세요:</p><ol><li>Xcode에서 프로젝트 설정을 엽니다.</li><li><strong>Build Phases</strong> 탭에서 <code>embedAndSignAppleFrameworkForXcode</code> 태스크가 있는 <strong>Run Script</strong> 단계를 찾습니다.</li><li>실행 스크립트 단계에서 스크립트를 <code>embedSwiftExportForXcode</code> 태스크를 포함하도록 조정합니다:</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./gradlew</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> :</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Shared</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> module</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nam</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">:embedSwiftExportForXcode</span></span></code></pre></div><p><img src="'+t+`" alt="Add the Swift export script" width="700"></p><ol start="4"><li>프로젝트를 빌드합니다. Swift 모듈은 빌드 출력 디렉토리에 생성됩니다.</li></ol><p>이 기능은 기본적으로 제공됩니다. 이전 릴리스에서 이미 활성화했다면 이제 <code>gradle.properties</code> 파일에서 <code>kotlin.experimental.swift-export.enabled</code>를 제거할 수 있습니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>시간을 절약하려면 Swift 내보내기가 이미 설정되어 있는 <a href="https://github.com/Kotlin/swift-export-sample" target="_blank" rel="noreferrer">공개 샘플</a>을 클론하세요.</p></div><p>Swift 내보내기에 대한 자세한 내용은 <a href="https://github.com/JetBrains/kotlin/tree/master/docs/swift-export#readme" target="_blank" rel="noreferrer">README</a>를 참조하세요.</p><h4 id="피드백-남기기" tabindex="-1">피드백 남기기 <a class="header-anchor" href="#피드백-남기기" aria-label="Permalink to &quot;피드백 남기기&quot;">​</a></h4><p>향후 Kotlin 릴리스에서 Swift 내보내기 지원을 확장하고 점진적으로 안정화할 계획입니다. Kotlin 2.2.20 이후에는 Kotlin과 Swift 간의 상호 운용성, 특히 코루틴 및 Flow 주변의 상호 운용성 개선에 집중할 것입니다.</p><p>Swift 내보내기 지원은 Kotlin Multiplatform에 중요한 변경 사항입니다. 귀하의 피드백에 감사드립니다:</p><ul><li>Kotlin Slack에서 개발팀에 직접 문의하세요 – <a href="https://surveys.jetbrains.com/s3/kotlin-slack-sign-up?_gl=1*ju6cbn*_ga*MTA3MTk5NDkzMC4xNjQ2MDY3MDU4*_ga_9J976DJZ68*MTY1ODMzNzA3OS4xMDAuMS4xNjU4MzQwODEwLjYw" target="_blank" rel="noreferrer">초대 받기</a> 및 <a href="https://kotlinlang.slack.com/archives/C073GUW6WN9" target="_blank" rel="noreferrer">#swift-export</a> 채널에 참여하세요.</li><li>Swift 내보내기 사용 중 발생한 모든 문제를 <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack</a>에 보고하세요.</li></ul><h3 id="js-및-wasmjs-타겟을-위한-공유-소스셋" tabindex="-1">js 및 wasmJs 타겟을 위한 공유 소스셋 <a class="header-anchor" href="#js-및-wasmjs-타겟을-위한-공유-소스셋" aria-label="Permalink to &quot;js 및 wasmJs 타겟을 위한 공유 소스셋&quot;">​</a></h3><p>이전에는 Kotlin Multiplatform이 JavaScript (<code>js</code>) 및 WebAssembly (<code>wasmJs</code>) 웹 타겟을 위한 공유 소스셋을 기본적으로 포함하지 않았습니다. <code>js</code>와 <code>wasmJs</code> 간에 코드를 공유하려면 사용자 지정 소스셋을 수동으로 구성하거나, <code>js</code>용 버전 하나와 <code>wasmJs</code>용 버전 하나, 이렇게 두 곳에 코드를 작성해야 했습니다. 예시:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// commonMain</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">expect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readCopiedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// jsMain</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Navigator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clipboard: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Different interop in JS and Wasm</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; } </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Navigator</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readCopiedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Different interop in JS and Wasm</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.clipboard.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// wasmJsMain</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Navigator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clipboard: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JsString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Navigator</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readCopiedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.clipboard.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이번 릴리스부터 Kotlin Gradle 플러그인은 기본 계층 템플릿을 사용할 때 웹을 위한 새로운 공유 소스셋(<code>webMain</code> 및 <code>webTest</code>로 구성)을 추가합니다.</p><p>이 변경 사항으로 <code>web</code> 소스셋은 <code>js</code> 및 <code>wasmJs</code> 소스셋의 부모가 됩니다. 업데이트된 소스셋 계층은 다음과 같습니다:</p><p><img src="`+l+`" alt="An example of using the default hierarchy template with web"></p><p>새로운 소스셋을 통해 <code>js</code> 및 <code>wasmJs</code> 타겟 둘 다를 위해 하나의 코드 조각을 작성할 수 있습니다. 공유 코드를 <code>webMain</code>에 넣으면 두 타겟 모두에서 자동으로 작동합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// commonMain</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">expect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readCopiedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// webMain</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Navigator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clipboard: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JsString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Navigator</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readCopiedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.clipboard.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 업데이트는 <code>js</code> 및 <code>wasmJs</code> 타겟 간의 코드 공유를 간소화합니다. 특히 다음 두 가지 경우에 유용합니다:</p><ul><li>코드 중복 없이 <code>js</code> 및 <code>wasmJs</code> 타겟을 모두 지원하려는 라이브러리 작성자에게 유용합니다.</li><li>웹을 타겟으로 하는 Compose Multiplatform 애플리케이션을 빌드하는 개발자에게 유용합니다. 더 넓은 브라우저 호환성을 위해 <code>js</code> 및 <code>wasmJs</code> 타겟으로 크로스 컴파일을 가능하게 합니다. 이러한 폴백 모드가 주어지면 웹사이트를 만들 때 모든 브라우저에서 바로 작동합니다: 최신 브라우저는 <code>wasmJs</code>를 사용하고, 이전 브라우저는 <code>js</code>를 사용합니다.</li></ul><p>이 기능을 사용해 보려면 <code>build.gradle(.kts)</code> 파일의 <code>kotlin {}</code> 블록에서 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-hierarchy.html#default-hierarchy-template" target="_blank" rel="noreferrer">기본 계층 템플릿</a>을 사용하세요.</p><p>기본 계층을 사용하기 전에 사용자 지정 공유 소스셋이 있는 프로젝트가 있거나 <code>js(&quot;web&quot;)</code> 타겟의 이름을 변경했다면 잠재적인 충돌을 신중하게 고려하세요. 이러한 충돌을 해결하려면 충돌하는 소스셋 또는 타겟의 이름을 변경하거나 기본 계층을 사용하지 마세요.</p><h3 id="kotlin-라이브러리를-위한-안정적인-크로스-플랫폼-컴파일" tabindex="-1">Kotlin 라이브러리를 위한 안정적인 크로스 플랫폼 컴파일 <a class="header-anchor" href="#kotlin-라이브러리를-위한-안정적인-크로스-플랫폼-컴파일" aria-label="Permalink to &quot;Kotlin 라이브러리를 위한 안정적인 크로스 플랫폼 컴파일&quot;">​</a></h3><p>Kotlin 2.2.20-Beta2은 Kotlin 라이브러리를 위한 크로스 플랫폼 컴파일을 안정화하는 중요한 <a href="https://youtrack.jetbrains.com/issue/KT-71290" target="_blank" rel="noreferrer">로드맵 항목</a>을 완료합니다.</p><p>이제 어떤 호스트든 사용하여 Kotlin 라이브러리 게시를 위한 <code>.klib</code> 아티팩트를 생성할 수 있습니다. 이는 게시 프로세스를 크게 간소화하며, 특히 이전에는 Mac 머신이 필요했던 Apple 타겟의 경우 더욱 그렇습니다.</p><p>이 기능은 기본적으로 제공됩니다. <code>kotlin.native.enableKlibsCrossCompilation=true</code>를 사용하여 크로스 컴파일을 이미 활성화했다면, 이제 <code>gradle.properties</code> 파일에서 이를 제거할 수 있습니다.</p><p>안타깝게도 몇 가지 제한 사항이 여전히 존재합니다. 다음의 경우 여전히 Mac 머신을 사용해야 합니다:</p><ul><li>라이브러리에 <a href="/ko/kotlin/native-c-interop">cinterop 의존성</a>이 있는 경우.</li><li>프로젝트에 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-overview.html" target="_blank" rel="noreferrer">CocoaPods 통합</a>이 설정되어 있는 경우.</li><li>Apple 타겟을 위한 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-build-native-binaries.html" target="_blank" rel="noreferrer">최종 바이너리</a>를 빌드하거나 테스트해야 하는 경우.</li></ul><p>멀티플랫폼 라이브러리 게시에 대한 자세한 내용은 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-publish-lib-setup.html" target="_blank" rel="noreferrer">문서</a>를 참조하세요.</p>`,38)),n(a,{id:"공통-의존성-선언을-위한-새로운-접근-방식",level:"3",title:"공통 의존성 선언을 위한 새로운 접근 방식",labelRef:"experimental-opt-in"}),s[3]||(s[3]=i(`<p>Gradle로 멀티플랫폼 프로젝트 설정을 간소화하기 위해, Kotlin 2.2.20-Beta2에서는 이제 최상위 <code>dependencies {}</code> 블록을 사용하여 <code>kotlin {}</code> 블록에 공통 의존성을 선언할 수 있습니다. 이 의존성들은 <code>commonMain</code> 소스셋에 선언된 것처럼 동작합니다. 이 기능은 Kotlin/JVM 및 Android 전용 프로젝트에 사용하는 dependencies 블록과 유사하게 작동하며, 이제 Kotlin Multiplatform에서 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적</a>입니다. 프로젝트 수준에서 공통 의존성을 선언하면 소스셋 전반에 걸친 반복적인 구성을 줄이고 빌드 설정을 간소화하는 데 도움이 됩니다. 필요에 따라 각 소스셋에 플랫폼별 의존성을 추가할 수도 있습니다.</p><p>이 기능을 사용해 보려면 최상위 <code>dependencies {}</code> 블록 앞에 <code>@OptIn(ExperimentalKotlinGradlePluginApi::class)</code> 애노테이션을 추가하여 옵트인(opt-in)하세요. 예시:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalKotlinGradlePluginApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        implementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 기능에 대한 피드백을 <a href="https://youtrack.jetbrains.com/issue/KT-76446" target="_blank" rel="noreferrer">YouTrack</a>에 주시면 감사하겠습니다.</p><h2 id="kotlin-native" tabindex="-1">Kotlin/Native <a class="header-anchor" href="#kotlin-native" aria-label="Permalink to &quot;Kotlin/Native&quot;">​</a></h2><p>Kotlin 2.2.20-Beta2은 Kotlin/Native 바이너리 및 디버깅에 대한 개선 사항을 제공합니다.</p><h3 id="바이너리에서-스택-카나리-지원" tabindex="-1">바이너리에서 스택 카나리 지원 <a class="header-anchor" href="#바이너리에서-스택-카나리-지원" aria-label="Permalink to &quot;바이너리에서 스택 카나리 지원&quot;">​</a></h3><p>2.2.20-Beta2부터 Kotlin은 결과 Kotlin/Native 바이너리에서 스택 카나리 지원을 추가합니다. 스택 보호의 일부로 이 보안 기능은 스택 스매싱으로부터 보호하여 일부 일반적인 애플리케이션 취약성을 완화합니다. Swift와 Objective-C에서 이미 사용 가능하며, 이제 Kotlin에서도 지원됩니다.</p><h4 id="스택-카나리-활성화-방법" tabindex="-1">스택 카나리 활성화 방법 <a class="header-anchor" href="#스택-카나리-활성화-방법" aria-label="Permalink to &quot;스택 카나리 활성화 방법&quot;">​</a></h4><p>Kotlin/Native의 스택 보호 구현은 <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-fstack-protector" target="_blank" rel="noreferrer">Clang</a>의 스택 보호기 동작을 따릅니다.</p><p>스택 카나리를 활성화하려면 <code>gradle.properties</code> 파일에 다음 속성을 추가하세요:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.stackProtector=yes</span></span></code></pre></div><p>이 속성은 스택 스매싱에 취약한 모든 Kotlin 함수에 대해 이 기능을 활성화합니다. 대체 모드는 다음과 같습니다:</p><ul><li><code>kotlin.native.binary.stackProtector=strong</code>은 스택 스매싱에 취약한 함수에 대해 더 강력한 휴리스틱을 사용합니다.</li><li><code>kotlin.native.binary.stackProtector=all</code>은 모든 함수에 대해 스택 보호기를 활성화합니다.</li></ul><p>일부 경우에 스택 보호는 성능 비용을 수반할 수 있습니다.</p>`,15)),n(a,{id:"ios-타겟을-위한-더-작은-바이너리-크기",level:"3",title:"iOS 타겟을 위한 더 작은 바이너리 크기",labelRef:"experimental-general"}),s[4]||(s[4]=i(` <p>Kotlin 2.2.20-Beta2은 iOS 타겟의 바이너리 크기를 줄이는 데 도움이 되는 <code>smallBinary</code> 옵션을 도입합니다. 새 옵션은 LLVM 컴파일 단계에서 컴파일러의 기본 최적화 인수로 <code>-Oz</code>를 효과적으로 설정합니다.</p><p><code>smallBinary</code> 옵션을 활성화하면 릴리스 바이너리를 더 작게 만들고 빌드 시간을 개선할 수 있습니다. 하지만 일부 경우에 런타임 성능에 영향을 미칠 수 있습니다.</p><h4 id="더-작은-바이너리-크기-활성화-방법" tabindex="-1">더 작은 바이너리 크기 활성화 방법 <a class="header-anchor" href="#더-작은-바이너리-크기-활성화-방법" aria-label="Permalink to &quot;더 작은 바이너리 크기 활성화 방법&quot;">​</a></h4><p>새 기능은 현재 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적</a>입니다. 프로젝트에서 사용해 보려면 <code>-Xbinary=smallBinary=true</code> 컴파일러 옵션을 사용하거나 <code>gradle.properties</code> 파일을 다음과 같이 업데이트하세요:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.smallBinary=true</span></span></code></pre></div><p>특정 바이너리의 경우 <code>build.gradle(.kts)</code> 파일에서 <code>binaryOption(&quot;smallBinary&quot;, &quot;true&quot;)</code>를 설정하세요. 예시:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        iosX64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        iosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        iosSimulatorArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        it.binaries.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">framework</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            binaryOption</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;smallBinary&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;true&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Kotlin 팀은 이 기능 구현에 도움을 주신 <a href="https://github.com/troelsbjerre" target="_blank" rel="noreferrer">Troels Lund</a>님께 감사드립니다.</p><h3 id="디버거-객체-요약-개선" tabindex="-1">디버거 객체 요약 개선 <a class="header-anchor" href="#디버거-객체-요약-개선" aria-label="Permalink to &quot;디버거 객체 요약 개선&quot;">​</a></h3><p>Kotlin/Native는 이제 LLDB 및 GDB와 같은 디버거 도구를 위한 더 명확한 객체 요약을 생성합니다. 이는 생성된 디버그 정보의 가독성을 향상시키고 디버깅 경험을 간소화합니다.</p><p>이전에는 다음과 같은 객체를 검사했을 때:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> point </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>메모리 주소에 대한 포인터를 포함하여 제한된 정보를 볼 수 있었습니다:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(lldb) v point</span></span>
<span class="line"><span>(ObjHeader *) point = [x: ..., y: ...]</span></span>
<span class="line"><span>(lldb) v point-&gt;x</span></span>
<span class="line"><span>(int32_t *) x = 0x0000000100274048</span></span></code></pre></div><p>Kotlin 2.2.20-Beta2을(를) 사용하면 디버거가 실제 값을 포함하여 더 풍부한 세부 정보를 보여줍니다:</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(lldb) v point</span></span>
<span class="line"><span>(ObjHeader *) point = Point(x=1, y=2)</span></span>
<span class="line"><span>(lldb) v point-&gt;x</span></span>
<span class="line"><span>(int32_t) point-&gt;x = 1</span></span></code></pre></div><p>Kotlin 팀은 이 기능 구현에 도움을 주신 <a href="https://github.com/nikita-nazarov" target="_blank" rel="noreferrer">Nikita Nazarov</a>님께 감사드립니다.</p><p>Kotlin/Native에서의 디버깅에 대한 자세한 내용은 <a href="/ko/kotlin/native-debugging">문서</a>를 참조하세요.</p><h2 id="kotlin-wasm" tabindex="-1">Kotlin/Wasm <a class="header-anchor" href="#kotlin-wasm" aria-label="Permalink to &quot;Kotlin/Wasm&quot;">​</a></h2><p>Kotlin/Wasm은 분리된 npm 의존성 및 JavaScript 상호 운용성을 위한 개선된 예외 처리를 포함하여 일부 편의성 개선 사항을 받습니다.</p><h3 id="분리된-npm-의존성" tabindex="-1">분리된 npm 의존성 <a class="header-anchor" href="#분리된-npm-의존성" aria-label="Permalink to &quot;분리된 npm 의존성&quot;">​</a></h3><p>이전에는 Kotlin/Wasm 프로젝트에서 모든 <a href="https://www.npmjs.com/" target="_blank" rel="noreferrer">npm</a> 의존성이 프로젝트 폴더에 함께 설치되었습니다. 여기에는 사용자 자신의 의존성과 Kotlin 툴링 의존성이 모두 포함되었습니다. 이 의존성들은 프로젝트의 잠금 파일(<code>package-lock.json</code> 또는 <code>yarn.lock</code>)에도 함께 기록되었습니다.</p><p>결과적으로 Kotlin 툴링 의존성이 업데이트될 때마다 아무것도 추가하거나 변경하지 않았더라도 잠금 파일을 업데이트해야 했습니다.</p><p>Kotlin 2.2.20-Beta2부터 Kotlin 툴링 npm 의존성은 프로젝트 외부에 설치됩니다. 이제 툴링 및 사용자 의존성은 별도의 디렉토리를 가집니다:</p><ul><li><p><strong>툴링 의존성 디렉토리:</strong></p><p><code>&lt;kotlin-user-home&gt;/kotlin-npm-tooling/&lt;yarn|npm&gt;/hash/node_modules</code></p></li><li><p><strong>사용자 의존성 디렉토리:</strong></p><p><code>build/wasm/node_modules</code></p></li></ul><p>또한, 프로젝트 디렉토리 내부의 잠금 파일은 사용자 정의 의존성만 포함합니다.</p><p>이 개선 사항은 잠금 파일이 사용자 자신의 의존성에만 집중하도록 유지하여 더 깔끔한 프로젝트를 유지하고 파일의 불필요한 변경을 줄이는 데 도움이 됩니다.</p><p>이 변경 사항은 <code>wasm-js</code> 타겟에 대해 기본적으로 활성화됩니다. 이 변경 사항은 <code>js</code> 타겟에 아직 구현되지 않았습니다. 향후 릴리스에서 구현할 계획이 있지만, Kotlin 2.2.20-Beta2에서는 <code>js</code> 타겟의 npm 의존성 동작이 동일하게 유지됩니다.</p><h3 id="kotlin-wasm-및-javascript-상호-운용성에서-개선된-예외-처리" tabindex="-1">Kotlin/Wasm 및 JavaScript 상호 운용성에서 개선된 예외 처리 <a class="header-anchor" href="#kotlin-wasm-및-javascript-상호-운용성에서-개선된-예외-처리" aria-label="Permalink to &quot;Kotlin/Wasm 및 JavaScript 상호 운용성에서 개선된 예외 처리&quot;">​</a></h3><p>이전에는 Kotlin이 JavaScript(JS)에서 발생한 예외(오류)를 이해하고 Kotlin/Wasm 코드로 넘어가는 데 어려움이 있었습니다.</p><p>일부 경우에 문제는 역방향으로도 발생했습니다. 예외가 Wasm 코드를 통해 JS로 던져지거나 전달되어 아무런 세부 정보 없이 <code>WebAssembly.Exception</code>으로 래핑될 때였습니다. 이러한 Kotlin 예외 처리 문제는 디버깅을 어렵게 만들었습니다.</p><p>Kotlin 2.2.20-Beta2부터 예외 처리와 관련한 개발자 경험이 양방향으로 개선됩니다:</p><ul><li>JavaScript에서 예외가 발생할 때: Kotlin 쪽에서 더 많은 정보를 볼 수 있습니다. 그러한 예외가 Kotlin을 통해 다시 JS로 전파될 때, 더 이상 WebAssembly로 래핑되지 않습니다.</li><li>Kotlin에서 예외가 발생할 때: 이제 JavaScript 쪽에서 JS 오류로 Catch할 수 있습니다.</li></ul><p>새로운 예외 처리는 <a href="https://webassembly.github.io/exception-handling/js-api/#dom-webassembly-jstag" target="_blank" rel="noreferrer"><code>WebAssembly.JSTag</code></a> 기능을 지원하는 최신 브라우저에서 자동으로 작동합니다:</p><ul><li>Chrome 115+</li><li>Firefox 129+</li><li>Safari 18.4+</li></ul><p>이전 브라우저에서는 예외 처리 동작이 변경되지 않습니다.</p><h2 id="kotlin-js" tabindex="-1">Kotlin/JS <a class="header-anchor" href="#kotlin-js" aria-label="Permalink to &quot;Kotlin/JS&quot;">​</a></h2><p>Kotlin 2.2.20-Beta2은 Kotlin의 <code>Long</code> 타입을 나타내기 위해 <code>BigInt</code> 타입을 사용하는 것을 지원하여, 내보낸 선언에서 <code>Long</code>을 활성화합니다. 또한, 이번 릴리스에서는 Node.js 인수를 정리하는 DSL 함수를 추가합니다.</p>`,39)),n(a,{id:"kotlin의-long-타입을-나타내기-위한-bigint-타입-사용",level:"3",title:"Kotlin의 Long 타입을 나타내기 위한 BigInt 타입 사용",labelRef:"experimental-opt-in"}),s[5]||(s[5]=i(`<p>ES2020 표준 이전에는 JavaScript(JS)가 53비트보다 큰 정밀 정수를 위한 기본 타입을 지원하지 않았습니다.</p><p>이러한 이유로 Kotlin/JS는 <code>Long</code> 값(64비트)을 두 개의 <code>number</code> 속성을 포함하는 JavaScript 객체로 표현했습니다. 이 사용자 지정 구현은 Kotlin과 JavaScript 간의 상호 운용성을 더 복잡하게 만들었습니다.</p><p>Kotlin 2.2.20-Beta2부터 Kotlin/JS는 이제 현대 JavaScript(ES2020)로 컴파일할 때 JavaScript의 내장 <code>BigInt</code> 타입을 사용하여 Kotlin의 <code>Long</code> 값을 나타냅니다.</p><p>이 변경 사항은 Kotlin 2.2.20-Beta2에서도 도입된 기능인 <a href="#usage-of-long-in-exported-declarations">JavaScript로 <code>Long</code> 타입을 내보내는 것</a>을 가능하게 합니다. 결과적으로 이 변경 사항은 Kotlin과 JavaScript 간의 상호 운용성을 간소화합니다.</p><p>이를 활성화하려면 <code>build.gradle(.kts)</code> 파일에 다음 컴파일러 옵션을 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xes-long-as-bigint&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 기능은 아직 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적</a>입니다. 문제가 발생하면 이슈 트래커인 <a href="https://youtrack.jetbrains.com/issue/KT-57128" target="_blank" rel="noreferrer">YouTrack</a>에 보고해 주세요.</p><h4 id="내보낸-선언에서-long-사용" tabindex="-1">내보낸 선언에서 Long 사용 <a class="header-anchor" href="#내보낸-선언에서-long-사용" aria-label="Permalink to &quot;내보낸 선언에서 Long 사용&quot;">​</a></h4><p>Kotlin/JS가 사용자 지정 <code>Long</code> 표현을 사용했기 때문에 JavaScript에서 Kotlin의 <code>Long</code>과 상호 작용하는 간단한 방법을 제공하기 어려웠습니다. 결과적으로 <code>Long</code> 타입을 사용하는 Kotlin 코드를 JavaScript로 내보낼 수 없었습니다. 이 문제는 함수 파라미터, 클래스 속성 또는 생성자와 같이 <code>Long</code>을 사용하는 모든 코드에 영향을 미쳤습니다.</p><p>이제 Kotlin의 <code>Long</code> 타입을 JavaScript의 <code>BigInt</code> 타입으로 컴파일할 수 있으므로, Kotlin/JS는 JavaScript로 <code>Long</code> 값을 내보내는 것을 지원하여 Kotlin 및 JavaScript 코드 간의 상호 운용성을 간소화합니다.</p><p>이 기능을 활성화하려면:</p><ol><li><p>Kotlin/JS에서 <code>Long</code> 내보내기를 허용합니다. <code>build.gradle(.kts)</code> 파일의 <code>freeCompilerArgs</code> 속성에 다음 컴파일러 인수를 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {                   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-XXLanguage:+JsAllowLongInExportedDeclarations&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><code>BigInt</code> 타입을 활성화합니다. <a href="#usage-of-bigint-type-to-represent-kotlin-s-long-type">Kotlin의 <code>Long</code> 타입을 나타내기 위한 <code>BigInt</code> 타입 사용</a>에서 활성화 방법을 참조하세요.</p></li></ol><h3 id="더-깔끔한-인수를-위한-새로운-dsl-함수" tabindex="-1">더 깔끔한 인수를 위한 새로운 DSL 함수 <a class="header-anchor" href="#더-깔끔한-인수를-위한-새로운-dsl-함수" aria-label="Permalink to &quot;더 깔끔한 인수를 위한 새로운 DSL 함수&quot;">​</a></h3><p>Node.js로 Kotlin/JS 애플리케이션을 실행할 때, 프로그램에 전달되는 인수(<code>args</code>)에는 다음이 포함되었습니다:</p><ul><li>실행 파일 <code>Node</code>의 경로.</li><li>스크립트의 경로.</li><li>제공한 실제 명령줄 인수.</li></ul><p>하지만 <code>args</code>에 대한 예상 동작은 명령줄 인수만 포함하는 것이었습니다. 이를 달성하기 위해 <code>build.gradle(.kts)</code> 파일 내부 또는 Kotlin 코드에서 <code>drop()</code> 함수를 사용하여 처음 두 인수를 수동으로 건너뛰어야 했습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">drop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">joinToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;, &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 해결 방법은 반복적이고 오류 발생 가능성이 높았으며 플랫폼 간에 코드를 공유할 때 잘 작동하지 않았습니다.</p><p>이 문제를 해결하기 위해 Kotlin 2.2.20-Beta2은 <code>passCliArgumentsToMainFunction()</code>이라는 새로운 DSL 함수를 도입합니다.</p><p>이 함수를 사용하면 인수는 명령줄 인수만 포함하고 <code>Node</code> 및 스크립트 경로는 제외합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // No need for drop() and only your custom arguments are included </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">joinToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;, &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 변경 사항은 상용구 코드를 줄이고 수동으로 인수를 건너뛰어 발생하는 실수를 방지하며 크로스 플랫폼 호환성을 개선합니다.</p><p>이 기능을 활성화하려면 <code>build.gradle(.kts)</code> 파일 안에 다음 DSL 함수를 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        nodejs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            passCliArgumentsToMainFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="gradle-kotlin-native-태스크의-빌드-리포트에-새로운-컴파일러-성능-지표" tabindex="-1">Gradle: Kotlin/Native 태스크의 빌드 리포트에 새로운 컴파일러 성능 지표 <a class="header-anchor" href="#gradle-kotlin-native-태스크의-빌드-리포트에-새로운-컴파일러-성능-지표" aria-label="Permalink to &quot;Gradle: Kotlin/Native 태스크의 빌드 리포트에 새로운 컴파일러 성능 지표&quot;">​</a></h2><p>Kotlin 1.7.0에서 컴파일러 성능 추적에 도움이 되는 <a href="/ko/kotlin/gradle-compilation-and-caches#build-reports">빌드 리포트</a>를 도입했습니다. 그 이후로 이러한 리포트를 더욱 상세하고 성능 문제 조사에 유용하게 만들기 위해 더 많은 지표를 추가했습니다.</p><p>Kotlin 2.2.20-Beta2에서는 빌드 리포트에 Kotlin/Native 태스크에 대한 컴파일러 성능 지표가 포함됩니다.</p><p>빌드 리포트와 구성 방법에 대해 자세히 알아보려면 <a href="/ko/kotlin/gradle-compilation-and-caches#enabling-build-reports">빌드 리포트 활성화</a>를 참조하세요.</p><h2 id="maven-kotlin-maven-plugin에서-kotlin-데몬-지원" tabindex="-1">Maven: kotlin-maven-plugin에서 Kotlin 데몬 지원 <a class="header-anchor" href="#maven-kotlin-maven-plugin에서-kotlin-데몬-지원" aria-label="Permalink to &quot;Maven: kotlin-maven-plugin에서 Kotlin 데몬 지원&quot;">​</a></h2><p>Kotlin 2.2.0의 <a href="/ko/kotlin/whatsnew22#new-experimental-build-tools-api">빌드 도구 API</a> 도입과 함께, Kotlin 2.2.20-Beta2은 <code>kotlin-maven-plugin</code>에서 Kotlin 데몬 지원을 추가하여 한 단계 더 나아갑니다. Kotlin 데몬을 사용할 때 Kotlin 컴파일러는 별도의 격리된 프로세스에서 실행되어 다른 Maven 플러그인이 시스템 속성을 재정의하는 것을 방지합니다. 이 <a href="https://youtrack.jetbrains.com/issue/KT-43894/Maven-Windows-error-RuntimeException-Could-not-find-installation-home-path" target="_blank" rel="noreferrer">YouTrack 이슈</a>에서 예시를 볼 수 있습니다.</p><p>Kotlin 2.2.20-Beta2부터 Kotlin 데몬은 기본적으로 사용됩니다. 이는 빌드 시간을 단축하는 데 도움이 되는 <a href="/ko/kotlin/maven#enable-incremental-compilation">증분 컴파일</a>이라는 추가적인 이점을 제공합니다. 이전 동작으로 되돌리려면 <code>pom.xml</code> 파일에서 다음 속성을 <code>false</code>로 설정하여 옵트아웃(opt out)하세요.</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">properties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kotlin.compiler.daemon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;false&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kotlin.compiler.daemon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">properties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Kotlin 2.2.20-Beta2은 또한 새로운 <code>jvmArgs</code> 속성을 도입하며, 이 속성을 사용하여 Kotlin 데몬의 기본 JVM 인수를 사용자 정의할 수 있습니다. 예를 들어, <code>-Xmx</code> 및 <code>-Xms</code> 옵션을 재정의하려면 <code>pom.xml</code> 파일에 다음을 추가하세요:</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">properties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kotlin.compiler.daemon.jvmArgs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Xmx1500m,Xms500m&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kotlin.compiler.daemon.jvmArgs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">properties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div>`,34)),n(a,{id:"표준-라이브러리-kotlin-js에서-리플렉션을-통한-인터페이스-타입-식별-지원",level:"2",title:"표준 라이브러리: Kotlin/JS에서 리플렉션을 통한 인터페이스 타입 식별 지원",labelRef:"experimental-opt-in"}),s[6]||(s[6]=i(`<p>Kotlin 2.2.20-Beta2은 Kotlin/JS 표준 라이브러리에 실험적인 <code>KClass.isInterface</code> 속성을 추가합니다.</p><p>이 속성을 사용하면 이제 클래스 참조가 Kotlin 인터페이스를 나타내는지 확인할 수 있습니다. 이는 Kotlin/JVM과 Kotlin/JS의 동등성을 높여주며, Kotlin/JVM에서는 <code>KClass.java.isInterface</code>를 사용하여 클래스가 인터페이스를 나타내는지 확인할 수 있습니다.</p><p>옵트인(opt-in)하려면 <code>@OptIn(ExperimentalStdlibApi::class)</code> 애노테이션을 사용하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalStdlibApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inspect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(klass: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;*&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Prints true for interfaces</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(klass.isInterface)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이슈 트래커인 <a href="https://youtrack.jetbrains.com/issue/KT-78581" target="_blank" rel="noreferrer">YouTrack</a>에 피드백을 주시면 감사하겠습니다.</p>`,5))])}const v=e(r,[["render",o]]);export{m as __pageData,v as default};
