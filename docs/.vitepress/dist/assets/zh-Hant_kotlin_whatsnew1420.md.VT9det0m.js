import{_ as i,c as e,o as s,ag as t}from"./chunks/framework.Bksy39di.js";const k=JSON.parse('{"title":"Kotlin 1.4.20 有什麼新功能","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/whatsnew1420.md","filePath":"zh-Hant/kotlin/whatsnew1420.md","lastUpdated":1754307826000}'),l={name:"zh-Hant/kotlin/whatsnew1420.md"};function n(o,a,r,p,h,d){return s(),e("div",null,a[0]||(a[0]=[t(`<h1 id="kotlin-1-4-20-有什麼新功能" tabindex="-1">Kotlin 1.4.20 有什麼新功能 <a class="header-anchor" href="#kotlin-1-4-20-有什麼新功能" aria-label="Permalink to &quot;Kotlin 1.4.20 有什麼新功能&quot;">​</a></h1><p><em><a href="/zh-Hant/kotlin/releases#release-details">發佈日期：2020 年 11 月 23 日</a></em></p><p>Kotlin 1.4.20 提供多項新的實驗性功能，並對現有功能（包括 1.4.0 中新增的功能）進行了修正與改進。</p><p>您也可以透過 <a href="https://blog.jetbrains.com/kotlin/2020/11/kotlin-1-4-20-released/" target="_blank" rel="noreferrer">這篇部落格文章</a> 了解更多帶有範例的新功能。</p><h2 id="kotlin-jvm" tabindex="-1">Kotlin/JVM <a class="header-anchor" href="#kotlin-jvm" aria-label="Permalink to &quot;Kotlin/JVM&quot;">​</a></h2><p>Kotlin/JVM 的改進旨在使其與現代 Java 版本的特性保持同步：</p><ul><li><a href="#java-15-target">Java 15 目標</a></li><li><a href="#invokedynamic-string-concatenation">invokedynamic 字串串接</a></li></ul><h3 id="java-15-目標" tabindex="-1">Java 15 目標 <a class="header-anchor" href="#java-15-目標" aria-label="Permalink to &quot;Java 15 目標&quot;">​</a></h3><p>現在 Java 15 可作為 Kotlin/JVM 的目標版本。</p><h3 id="invokedynamic-字串串接" tabindex="-1">invokedynamic 字串串接 <a class="header-anchor" href="#invokedynamic-字串串接" aria-label="Permalink to &quot;invokedynamic 字串串接&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>invokedynamic</code> 字串串接為 <a href="/zh-Hant/kotlin/components-stability">實驗性</a> 功能。它可能隨時被移除或變更。需要明確啟用（詳情請見下文）。僅用於評估目的。我們非常感謝您在 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 上提供關於此功能的意見回饋。</p></div><p>Kotlin 1.4.20 可以在 JVM 9+ 目標上將字串串接編譯成 <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html#invokedynamic" target="_blank" rel="noreferrer">動態呼叫</a>，因此提升了效能。</p><p>目前，此功能為實驗性，涵蓋以下情況：</p><ul><li><code>String.plus</code> 在運算子 (<code>a + b</code>)、明確 (<code>a.plus(b)</code>) 和參考 (<code>(a::plus)(b)</code>) 形式中的使用。</li><li>內聯類別與資料類別上的 <code>toString</code>。</li><li>字串樣板，但單一非常數引數的樣板除外（請參見 <a href="https://youtrack.jetbrains.com/issue/KT-42457" target="_blank" rel="noreferrer">KT-42457</a>）。</li></ul><p>若要啟用 <code>invokedynamic</code> 字串串接，請新增 <code>-Xstring-concat</code> 編譯器選項並指定以下其中一個值：</p><ul><li><code>indy-with-constants</code>：使用 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/StringConcatFactory.html#makeConcatWithConstants-java.lang.invoke.MethodHandles.Lookup-java.lang.String-java.lang.invoke.MethodType-java.lang.String-java.lang.Object...-" target="_blank" rel="noreferrer">StringConcatFactory.makeConcatWithConstants()</a> 對字串執行 <code>invokedynamic</code> 串接。</li><li><code>indy</code>：使用 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/StringConcatFactory.html#makeConcat-java.lang.invoke.MethodHandles.Lookup-java.lang.String-java.lang.invoke.MethodType-" target="_blank" rel="noreferrer">StringConcatFactory.makeConcat()</a> 對字串執行 <code>invokedynamic</code> 串接。</li><li><code>inline</code>：切換回透過 <code>StringBuilder.append()</code> 進行的傳統串接。</li></ul><h2 id="kotlin-js" tabindex="-1">Kotlin/JS <a class="header-anchor" href="#kotlin-js" aria-label="Permalink to &quot;Kotlin/JS&quot;">​</a></h2><p>Kotlin/JS 繼續快速發展，在 1.4.20 中您可以找到多項實驗性功能與改進：</p><ul><li><a href="#gradle-dsl-changes">Gradle DSL 變更</a></li><li><a href="#new-wizard-templates">新的精靈範本</a></li><li><a href="#ignoring-compilation-errors-with-ir-compiler">IR 編譯器忽略編譯錯誤</a></li></ul><h3 id="gradle-dsl-變更" tabindex="-1">Gradle DSL 變更 <a class="header-anchor" href="#gradle-dsl-變更" aria-label="Permalink to &quot;Gradle DSL 變更&quot;">​</a></h3><p>Kotlin/JS 的 Gradle DSL 收到多項更新，這些更新簡化了專案設定與自訂。這包括 webpack 配置調整、自動生成 <code>package.json</code> 檔案的修改，以及對傳遞依賴項的改進控制。</p><h4 id="單一-webpack-配置點" tabindex="-1">單一 webpack 配置點 <a class="header-anchor" href="#單一-webpack-配置點" aria-label="Permalink to &quot;單一 webpack 配置點&quot;">​</a></h4><p>瀏覽器目標新增了 <code>commonWebpackConfig</code> 配置區塊。在其中，您可以從單一位置調整通用設定，而無需為 <code>webpackTask</code>、<code>runTask</code> 和 <code>testTask</code> 重複配置。</p><p>若要預設為所有三個任務啟用 CSS 支援，請在專案的 <code>build.gradle(.kts)</code> 中新增以下程式碼片段：</p><div class="language-groovy vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">groovy</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">browser {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    commonWebpackConfig {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        cssSupport</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">enabled </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    binaries</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">executable()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>了解更多關於 <a href="/zh-Hant/kotlin/js-project-setup#webpack-bundling">配置 webpack 打包</a> 的資訊。</p><h4 id="從-gradle-自訂-package-json" tabindex="-1">從 Gradle 自訂 package.json <a class="header-anchor" href="#從-gradle-自訂-package-json" aria-label="Permalink to &quot;從 Gradle 自訂 package.json&quot;">​</a></h4><p>為了更好地控制您的 Kotlin/JS 套件管理與分發，您現在可以透過 Gradle DSL 向專案檔案 <a href="https://nodejs.dev/learn/the-package-json-guide" target="_blank" rel="noreferrer"><code>package.json</code></a> 新增屬性。</p><p>若要為您的 <code>package.json</code> 新增自訂欄位，請在編譯的 <code>packageJson</code> 區塊中使用 <code>customField</code> 函式：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(BOTH) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        compilations[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">packageJson</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            customField</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mapOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;one&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> to </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;two&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> to </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>了解更多關於 <a href="/zh-Hant/kotlin/js-project-setup#package-json-customization"><code>package.json</code> 自訂</a> 的資訊。</p><h4 id="yarn-選擇性依賴項解析" tabindex="-1">Yarn 選擇性依賴項解析 <a class="header-anchor" href="#yarn-選擇性依賴項解析" aria-label="Permalink to &quot;Yarn 選擇性依賴項解析&quot;">​</a></h4><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>對 Yarn 選擇性依賴項解析的支援是 <a href="/zh-Hant/kotlin/components-stability">實驗性</a> 功能。它可能隨時被移除或變更。僅用於評估目的。我們非常感謝您在 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 上提供關於此功能的意見回饋。</p></div><p>Kotlin 1.4.20 提供了一種配置 Yarn <a href="https://classic.yarnpkg.com/en/docs/selective-version-resolutions/" target="_blank" rel="noreferrer">選擇性依賴項解析</a> 的方式——該機制用於覆寫您所依賴套件的依賴項。</p><p>您可以透過 Gradle 中 <code>YarnPlugin</code> 內部的 <code>YarnRootExtension</code> 來使用它。若要影響專案的套件解析版本，請使用 <code>resolution</code> 函式並傳入套件名稱選擇器（由 Yarn 指定）和應解析到的版本。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rootProject.plugins.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">YarnPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rootProject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">the</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">YarnRootExtension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        resolution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;react&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;16.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        resolution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;processor/decamelize&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;3.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在這裡，所有需要 <code>react</code> 的 npm 依賴項都將收到 <code>16.0.0</code> 版本，而 <code>processor</code> 將收到其依賴項 <code>decamelize</code> 的 <code>3.0.0</code> 版本。</p><h4 id="停用細粒度工作區" tabindex="-1">停用細粒度工作區 <a class="header-anchor" href="#停用細粒度工作區" aria-label="Permalink to &quot;停用細粒度工作區&quot;">​</a></h4><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>停用細粒度工作區是 <a href="/zh-Hant/kotlin/components-stability">實驗性</a> 功能。它可能隨時被移除或變更。僅用於評估目的。我們非常感謝您在 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 上提供關於此功能的意見回饋。</p></div><p>為了加速建置時間，Kotlin/JS Gradle 外掛程式只安裝特定 Gradle 任務所需的依賴項。例如，<code>webpack-dev-server</code> 套件僅在您執行 <code>*Run</code> 任務之一時安裝，而不是在您執行組裝任務時。這種行為在您並行執行多個 Gradle 處理程序時可能帶來問題。當依賴項需求衝突時，兩個 npm 套件的安裝可能導致錯誤。</p><p>為了解決此問題，Kotlin 1.4.20 包含一個選項來停用這些所謂的 <em>細粒度工作區</em>。此功能目前可透過 Gradle 中 <code>YarnPlugin</code> 內部的 <code>YarnRootExtension</code> 獲得。若要使用它，請將以下程式碼片段新增到您的 <code>build.gradle.kts</code> 檔案中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rootProject.plugins.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">YarnPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rootProject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">the</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">YarnRootExtension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disableGranularWorkspaces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="新的精靈範本" tabindex="-1">新的精靈範本 <a class="header-anchor" href="#新的精靈範本" aria-label="Permalink to &quot;新的精靈範本&quot;">​</a></h3><p>為了讓您在專案建立時更方便地自訂專案，Kotlin 的專案精靈帶來了新的 Kotlin/JS 應用程式範本：</p><ul><li><strong>Browser Application</strong> - 一個在瀏覽器中執行的最小 Kotlin/JS Gradle 專案。</li><li><strong>React Application</strong> - 一個使用適當 <code>kotlin-wrappers</code> 的 React 應用程式。 它提供啟用樣式表、導航元件或狀態容器整合的選項。</li><li><strong>Node.js Application</strong> - 一個在 Node.js 執行時中執行的最小專案。它帶有直接包含實驗性 <code>kotlinx-nodejs</code> 套件的選項。</li></ul><h3 id="ir-編譯器忽略編譯錯誤" tabindex="-1">IR 編譯器忽略編譯錯誤 <a class="header-anchor" href="#ir-編譯器忽略編譯錯誤" aria-label="Permalink to &quot;IR 編譯器忽略編譯錯誤&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><em>忽略編譯錯誤</em> 模式是 <a href="/zh-Hant/kotlin/components-stability">實驗性</a> 功能。它可能隨時被移除或變更。需要明確啟用（詳情請見下文）。僅用於評估目的。我們非常感謝您在 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 上提供關於此功能的意見回饋。</p></div><p>Kotlin/JS 的 <a href="/zh-Hant/kotlin/js-ir-compiler">IR 編譯器</a> 帶有新的實驗性模式——<em>帶錯誤編譯</em>。在此模式下，即使您的程式碼包含錯誤，您也可以執行它，例如，當整個應用程式尚未準備好時，您想嘗試某些東西。</p><p>此模式有兩種容錯策略：</p><ul><li><p><code>SEMANTIC</code>：編譯器將接受語法正確但語意上沒有意義的程式碼，例如 <code>val x: String = 3</code>。</p></li><li><p><code>SYNTAX</code>：編譯器將接受任何程式碼，即使它包含語法錯誤。</p></li></ul><p>若要允許帶錯誤編譯，請新增 <code>-Xerror-tolerance-policy=</code> 編譯器選項並指定上述其中一個值。</p><p><a href="/zh-Hant/kotlin/js-ir-compiler">了解更多關於 Kotlin/JS IR 編譯器</a> 的資訊。</p><h2 id="kotlin-native" tabindex="-1">Kotlin/Native <a class="header-anchor" href="#kotlin-native" aria-label="Permalink to &quot;Kotlin/Native&quot;">​</a></h2><p>Kotlin/Native 在 1.4.20 中的優先事項是效能和完善現有功能。以下是顯著的改進：</p><ul><li><a href="#escape-analysis">逃逸分析</a></li><li><a href="#performance-improvements-and-bug-fixes">效能改進與錯誤修正</a></li><li><a href="#opt-in-wrapping-of-objective-c-exceptions">明確啟用 Objective-C 異常包裝</a></li><li><a href="#cocoapods-plugin-improvements">CocoaPods 外掛程式改進</a></li><li><a href="#support-for-xcode-12-libraries">支援 Xcode 12 函式庫</a></li></ul><h3 id="逃逸分析" tabindex="-1">逃逸分析 <a class="header-anchor" href="#逃逸分析" aria-label="Permalink to &quot;逃逸分析&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>逃逸分析機制是 <a href="/zh-Hant/kotlin/components-stability">實驗性</a> 功能。它可能隨時被移除或變更。僅用於評估目的。我們非常感謝您在 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 上提供關於此功能的意見回饋。</p></div><p>Kotlin/Native 收到一個新的 <a href="https://en.wikipedia.org/wiki/Escape_analysis" target="_blank" rel="noreferrer">逃逸分析</a> 機制原型。它透過將特定物件分配到堆疊而非堆記憶體來改進執行時效能。該機制在我們的基準測試中顯示出平均 10% 的效能提升，我們將繼續改進它，使其能進一步加速程式。</p><p>逃逸分析在發行建置（帶有 <code>-opt</code> 編譯器選項）的一個獨立編譯階段執行。</p><p>如果您想停用逃逸分析階段，請使用 <code>-Xdisable-phases=EscapeAnalysis</code> 編譯器選項。</p><h3 id="效能改進與錯誤修正" tabindex="-1">效能改進與錯誤修正 <a class="header-anchor" href="#效能改進與錯誤修正" aria-label="Permalink to &quot;效能改進與錯誤修正&quot;">​</a></h3><p>Kotlin/Native 在各個元件中都收到了效能改進與錯誤修正，包括在 1.4.0 中新增的元件，例如 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-share-on-platforms.html#share-code-on-similar-platforms" target="_blank" rel="noreferrer">程式碼共享機制</a>。</p><h3 id="明確啟用-objective-c-異常包裝" tabindex="-1">明確啟用 Objective-C 異常包裝 <a class="header-anchor" href="#明確啟用-objective-c-異常包裝" aria-label="Permalink to &quot;明確啟用 Objective-C 異常包裝&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>Objective-C 異常包裝機制是 <a href="/zh-Hant/kotlin/components-stability">實驗性</a> 功能。它可能隨時被移除或變更。需要明確啟用（詳情請見下文）。僅用於評估目的。我們非常感謝您在 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 上提供關於此功能的意見回饋。</p></div><p>Kotlin/Native 現在可以在執行時處理從 Objective-C 程式碼拋出的異常，以避免程式崩潰。</p><p>您可以選擇將 <code>NSException</code> 包裝成 <code>ForeignException</code> 類型的 Kotlin 異常。它們持有對原始 <code>NSException</code> 的參考。這讓您可以獲取根本原因的資訊並正確處理它。</p><p>若要啟用 Objective-C 異常的包裝，請在 <code>cinterop</code> 呼叫中指定 <code>-Xforeign-exception-mode objc-wrap</code> 選項，或將 <code>foreignExceptionMode = objc-wrap</code> 屬性新增到 <code>.def</code> 檔案中。如果您使用 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-overview.html" target="_blank" rel="noreferrer">CocoaPods 整合</a>，請在依賴項的 <code>pod {}</code> 建置指令碼區塊中指定該選項，如下所示：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    extraOpts </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xforeign-exception-mode&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;objc-wrap&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>預設行為保持不變：當 Objective-C 程式碼拋出異常時，程式會終止。</p><h3 id="cocoapods-外掛程式改進" tabindex="-1">CocoaPods 外掛程式改進 <a class="header-anchor" href="#cocoapods-外掛程式改進" aria-label="Permalink to &quot;CocoaPods 外掛程式改進&quot;">​</a></h3><p>Kotlin 1.4.20 繼續改進 CocoaPods 整合。具體來說，您可以嘗試以下新功能：</p><ul><li><a href="#improved-task-execution">改進的任務執行</a></li><li><a href="#extended-dsl">擴展的 DSL</a></li><li><a href="#updated-integration-with-xcode">更新與 Xcode 的整合</a></li></ul><h4 id="改進的任務執行" tabindex="-1">改進的任務執行 <a class="header-anchor" href="#改進的任務執行" aria-label="Permalink to &quot;改進的任務執行&quot;">​</a></h4><p>CocoaPods 外掛程式獲得了改進的任務執行流程。例如，如果您新增一個新的 CocoaPods 依賴項，現有依賴項不會重新建置。新增一個額外目標也不會影響現有依賴項的重新建置。</p><h4 id="擴展的-dsl" tabindex="-1">擴展的 DSL <a class="header-anchor" href="#擴展的-dsl" aria-label="Permalink to &quot;擴展的 DSL&quot;">​</a></h4><p>將 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-overview.html" target="_blank" rel="noreferrer">CocoaPods</a> 依賴項新增到 Kotlin 專案的 DSL 獲得了新功能。</p><p>除了本地 Pods 和來自 CocoaPods 儲存庫的 Pods 之外，您還可以新增對以下類型函式庫的依賴項：</p><ul><li>來自自訂 spec 儲存庫的函式庫。</li><li>來自 Git 儲存庫的遠端函式庫。</li><li>來自歸檔的函式庫（也可用任意 HTTP 位址）。</li><li>靜態函式庫。</li><li>具有自訂 cinterop 選項的函式庫。</li></ul><p>了解更多關於在 Kotlin 專案中 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-libraries.html" target="_blank" rel="noreferrer">新增 CocoaPods 依賴項</a> 的資訊。在 <a href="https://github.com/Kotlin/kmm-with-cocoapods-sample" target="_blank" rel="noreferrer">Kotlin with CocoaPods 範例</a> 中找到範例。</p><h4 id="更新與-xcode-的整合" tabindex="-1">更新與 Xcode 的整合 <a class="header-anchor" href="#更新與-xcode-的整合" aria-label="Permalink to &quot;更新與 Xcode 的整合&quot;">​</a></h4><p>為了與 Xcode 正確配合，Kotlin 需要一些 Podfile 變更：</p><ul><li>如果您的 Kotlin Pod 有任何 Git、HTTP 或 specRepo Pod 依賴項，您也應該在 Podfile 中指定它。</li><li>當您從自訂 spec 新增函式庫時，您還應該在 Podfile 的開頭指定 spec 的 <a href="https://guides.cocoapods.org/syntax/podfile.html#source" target="_blank" rel="noreferrer">位置</a>。</li></ul><p>現在整合錯誤在 IDEA 中有詳細描述。因此，如果您的 Podfile 有問題，您會立即知道如何修正它們。</p><p>了解更多關於 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-xcode.html" target="_blank" rel="noreferrer">建立 Kotlin pods</a> 的資訊。</p><h3 id="支援-xcode-12-函式庫" tabindex="-1">支援 Xcode 12 函式庫 <a class="header-anchor" href="#支援-xcode-12-函式庫" aria-label="Permalink to &quot;支援 Xcode 12 函式庫&quot;">​</a></h3><p>我們增加了對 Xcode 12 隨附的新函式庫的支援。現在您可以從 Kotlin 程式碼中使用它們。</p><h2 id="kotlin-multiplatform" tabindex="-1">Kotlin Multiplatform <a class="header-anchor" href="#kotlin-multiplatform" aria-label="Permalink to &quot;Kotlin Multiplatform&quot;">​</a></h2><h3 id="更新了多平台函式庫發佈的結構" tabindex="-1">更新了多平台函式庫發佈的結構 <a class="header-anchor" href="#更新了多平台函式庫發佈的結構" aria-label="Permalink to &quot;更新了多平台函式庫發佈的結構&quot;">​</a></h3><p>從 Kotlin 1.4.20 開始，不再有單獨的元資料發佈。元資料構件現在包含在代表整個函式庫的 <em>根</em> 發佈中，當作為依賴項新增到通用原始碼集時，會自動解析為適當的特定平台構件。</p><p>了解更多關於 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-publish-lib-setup.html" target="_blank" rel="noreferrer">發佈多平台函式庫</a> 的資訊。</p><h4 id="與早期版本的相容性" tabindex="-1">與早期版本的相容性 <a class="header-anchor" href="#與早期版本的相容性" aria-label="Permalink to &quot;與早期版本的相容性&quot;">​</a></h4><p>此結構變更破壞了具有 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-share-on-platforms.html#share-code-on-similar-platforms" target="_blank" rel="noreferrer">分層專案結構</a> 的專案之間的相容性。如果多平台專案及其所依賴的函式庫都具有分層專案結構，那麼您需要同時將它們更新到 Kotlin 1.4.20 或更高版本。使用 Kotlin 1.4.20 發佈的函式庫不能用於早期版本發佈的專案。</p><p>不帶有分層專案結構的專案和函式庫保持相容。</p><h2 id="標準函式庫" tabindex="-1">標準函式庫 <a class="header-anchor" href="#標準函式庫" aria-label="Permalink to &quot;標準函式庫&quot;">​</a></h2><p>Kotlin 1.4.20 的標準函式庫為處理檔案提供了新的擴展，並提升了效能。</p><ul><li><a href="#extensions-for-java-nio-file-path">java.nio.file.Path 的擴展</a></li><li><a href="#improved-string-replace-function-performance">改進了 String.replace 函式效能</a></li></ul><h3 id="java-nio-file-path-的擴展" tabindex="-1">java.nio.file.Path 的擴展 <a class="header-anchor" href="#java-nio-file-path-的擴展" aria-label="Permalink to &quot;java.nio.file.Path 的擴展&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>java.nio.file.Path</code> 的擴展是 <a href="/zh-Hant/kotlin/components-stability">實驗性</a> 功能。它可能隨時被移除或變更。需要明確啟用（詳情請見下文）。僅用於評估目的。我們非常感謝您在 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 上提供關於此功能的意見回饋。</p></div><p>現在標準函式庫提供了 <code>java.nio.file.Path</code> 的實驗性擴展。 以慣用的 Kotlin 方式處理現代 JVM 檔案 API，現在類似於處理 <code>kotlin.io</code> 套件中的 <code>java.io.File</code> 擴展。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// construct path with the div (/) operator</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> baseDir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/base&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> subDir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> baseDir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;subdirectory&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// list files in a directory</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlinFiles: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/home/user&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listDirectoryEntries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;*.kt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>這些擴展在 <code>kotlin-stdlib-jdk7</code> 模組的 <code>kotlin.io.path</code> 套件中可用。 若要使用這些擴展，請 <a href="/zh-Hant/kotlin/opt-in-requirements">明確啟用</a> 實驗性註解 <code>@ExperimentalPathApi</code>。</p><h3 id="改進了-string-replace-函式效能" tabindex="-1">改進了 String.replace 函式效能 <a class="header-anchor" href="#改進了-string-replace-函式效能" aria-label="Permalink to &quot;改進了 String.replace 函式效能&quot;">​</a></h3><p><code>String.replace()</code> 的新實作加速了函式執行。 區分大小寫的變體使用基於 <code>indexOf</code> 的手動替換迴圈，而不區分大小寫的變體則使用正規表達式匹配。</p><h2 id="kotlin-android-extensions" tabindex="-1">Kotlin Android Extensions <a class="header-anchor" href="#kotlin-android-extensions" aria-label="Permalink to &quot;Kotlin Android Extensions&quot;">​</a></h2><p>在 1.4.20 中，Kotlin Android Extensions 外掛程式已棄用，<code>Parcelable</code> 實作生成器將移至一個單獨的外掛程式。</p><ul><li><a href="#deprecation-of-synthetic-views">棄用合成視圖</a></li><li><a href="#new-plugin-for-parcelable-implementation-generator">Parcelable 實作生成器的新外掛程式</a></li></ul><h3 id="棄用合成視圖" tabindex="-1">棄用合成視圖 <a class="header-anchor" href="#棄用合成視圖" aria-label="Permalink to &quot;棄用合成視圖&quot;">​</a></h3><p><em>合成視圖</em> 在 Kotlin Android Extensions 外掛程式中已推出一段時間，旨在簡化與 UI 元素的互動並減少樣板程式碼。現在 Google 提供了一個做同樣事情的原生機制——Android Jetpack 的 <a href="https://developer.android.com/topic/libraries/view-binding" target="_blank" rel="noreferrer">視圖綁定</a>，我們正在棄用合成視圖以支持這些。</p><p>我們將 Parcelable 實作生成器從 <code>kotlin-android-extensions</code> 中提取出來，並開始其餘部分的棄用週期——合成視圖。目前，它們將繼續工作並帶有棄用警告。將來，您需要將您的專案切換到另一個解決方案。以下是將您的 Android 專案從合成視圖遷移到視圖綁定的 <a href="https://goo.gle/kotlin-android-extensions-deprecation" target="_blank" rel="noreferrer">指南</a>。</p><h3 id="parcelable-實作生成器的新外掛程式" tabindex="-1">Parcelable 實作生成器的新外掛程式 <a class="header-anchor" href="#parcelable-實作生成器的新外掛程式" aria-label="Permalink to &quot;Parcelable 實作生成器的新外掛程式&quot;">​</a></h3><p><code>Parcelable</code> 實作生成器現在在新的 <code>kotlin-parcelize</code> 外掛程式中可用。請應用此外掛程式而非 <code>kotlin-android-extensions</code>。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p><code>kotlin-parcelize</code> 和 <code>kotlin-android-extensions</code> 不能在一個模組中一起應用。</p></div><p><code>@Parcelize</code> 註解已移至 <code>kotlinx.parcelize</code> 套件。</p><p>在 <a href="https://developer.android.com/kotlin/parcelize" target="_blank" rel="noreferrer">Android 文件</a> 中了解更多關於 <code>Parcelable</code> 實作生成器 的資訊。</p>`,114)]))}const E=i(l,[["render",n]]);export{k as __pageData,E as default};
