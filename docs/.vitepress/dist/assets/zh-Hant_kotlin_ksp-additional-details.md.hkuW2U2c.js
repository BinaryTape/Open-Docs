import{_ as a}from"./chunks/ksp-class-diagram.ClaR6pZl.js";import{_ as n,c as t,o as l,j as e,ag as o,a as s}from"./chunks/framework.Bksy39di.js";const f=JSON.parse('{"title":"KSP 如何模型化 Kotlin 程式碼","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/ksp-additional-details.md","filePath":"zh-Hant/kotlin/ksp-additional-details.md","lastUpdated":1754307826000}'),p={name:"zh-Hant/kotlin/ksp-additional-details.md"};function r(d,i,c,k,h,g){return l(),t("div",null,i[0]||(i[0]=[e("h1",{id:"ksp-如何模型化-kotlin-程式碼",tabindex:"-1"},[s("KSP 如何模型化 Kotlin 程式碼 "),e("a",{class:"header-anchor",href:"#ksp-如何模型化-kotlin-程式碼","aria-label":'Permalink to "KSP 如何模型化 Kotlin 程式碼"'},"​")],-1),e("p",null,[s("你可以在 "),e("a",{href:"https://github.com/google/ksp/tree/main/api/src/main/kotlin/com/google/devtools/ksp",target:"_blank",rel:"noreferrer"},"KSP GitHub 儲存庫"),s(" 找到 API 定義。 此圖表概述了 Kotlin 在 KSP 中是如何被"),e("a",{href:"https://github.com/google/ksp/tree/main/api/src/main/kotlin/com/google/devtools/ksp/symbol/",target:"_blank",rel:"noreferrer"},"模型化"),s("的：")],-1),e("p",null,[e("img",{src:a,alt:"類別圖表",thumbnail:"true",width:"800","thumbnail-same-file":"true"})],-1),o(`<div class="note custom-block"><p class="custom-block-title">NOTE</p><p><a href="https://kotlinlang.org/docs/images/ksp-class-diagram.svg" target="_blank" rel="noreferrer">查看完整大小的圖表</a>。</p></div><h2 id="型別與解析" tabindex="-1">型別與解析 <a class="header-anchor" href="#型別與解析" aria-label="Permalink to &quot;型別與解析&quot;">​</a></h2><p>解析會耗費底層 API 實作的大部分成本。因此，型別引用被設計為由處理器明確地解析（少數例外）。當一個 <em>型別</em> (例如 <code>KSFunctionDeclaration.returnType</code> 或 <code>KSAnnotation.annotationType</code>) 被引用時，它總是一個 <code>KSTypeReference</code>，後者是一個帶有 <code>annotations</code> 和 <code>modifiers</code> 的 <code>KSReferenceElement</code>。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> KSFunctionDeclaration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> returnType: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSTypeReference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> KSTypeReference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSAnnotated</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSModifierListOwner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> type: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSReferenceElement</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>一個 <code>KSTypeReference</code> 可以被解析為一個 <code>KSType</code>，後者指的是 Kotlin 型別系統中的一個型別。</p><p>一個 <code>KSTypeReference</code> 具有一個 <code>KSReferenceElement</code>，它模型化了 Kotlin 的程式結構：即引用是如何被撰寫的。它對應於 Kotlin 語法中的 <a href="https://kotlinlang.org/docs/reference/grammar.html#type" target="_blank" rel="noreferrer"><code>type</code></a> 元素。</p><p>一個 <code>KSReferenceElement</code> 可以是一個 <code>KSClassifierReference</code> 或 <code>KSCallableReference</code>，它們包含了許多有用的資訊，而無需解析。例如，<code>KSClassifierReference</code> 具有 <code>referencedName</code>，而 <code>KSCallableReference</code> 具有 <code>receiverType</code>、<code>functionArguments</code> 和 <code>returnType</code>。</p><p>如果需要 <code>KSTypeReference</code> 所引用的原始宣告，通常可以透過解析為 <code>KSType</code> 並透過 <code>KSType.declaration</code> 存取來找到它。從型別被提及的地方轉移到其類別被定義的地方，看起來像這樣：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ksType: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSType</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ksTypeReference.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ksDeclaration: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSDeclaration</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ksType.declaration</span></span></code></pre></div><p>型別解析代價高昂，因此具有明確的形式。一些從解析中獲取的資訊已在 <code>KSReferenceElement</code> 中可用。例如，<code>KSClassifierReference.referencedName</code> 可以過濾掉許多不相關的元素。你只應在需要從 <code>KSDeclaration</code> 或 <code>KSType</code> 獲取特定資訊時才解析型別。</p><p>指向函式型別的 <code>KSTypeReference</code> 大部分資訊都在其元素中。儘管它可以被解析為 <code>Function0</code>、<code>Function1</code> 等家族，但這些解析不會帶來比 <code>KSCallableReference</code> 更多的資訊。解析函式型別引用的一個用例是處理函式原型的識別。</p>`,11)]))}const m=n(p,[["render",r]]);export{f as __pageData,m as default};
