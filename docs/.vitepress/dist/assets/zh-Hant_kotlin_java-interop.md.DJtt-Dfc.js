import{_ as k,C as e,c as d,o,ag as h,j as s,G as t,a as i,w as n}from"./chunks/framework.Bksy39di.js";const v=JSON.parse('{"title":"從 Kotlin 呼叫 Java","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/java-interop.md","filePath":"zh-Hant/kotlin/java-interop.md","lastUpdated":1754307826000}'),r={name:"zh-Hant/kotlin/java-interop.md"};function E(c,a,g,y,u,F){const l=e("tab"),p=e("tabs");return o(),d("div",null,[a[2]||(a[2]=h(`<h1 id="從-kotlin-呼叫-java" tabindex="-1">從 Kotlin 呼叫 Java <a class="header-anchor" href="#從-kotlin-呼叫-java" aria-label="Permalink to &quot;從 Kotlin 呼叫 Java&quot;">​</a></h1><p>Kotlin 的設計考量到與 Java 的互通性。現有的 Java 程式碼可以很自然地從 Kotlin 中呼叫，而 Kotlin 程式碼也能相當流暢地在 Java 中使用。本節將詳細說明如何從 Kotlin 呼叫 Java 程式碼。</p><p>幾乎所有 Java 程式碼都可以毫無問題地使用：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> java.util.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> demo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(source: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // &#39;for&#39;-loops work for Java collections:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Operator conventions work as well:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">source.size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        list[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source[i] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// get and set are called</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="getters-和-setters" tabindex="-1">Getters 和 Setters <a class="header-anchor" href="#getters-和-setters" aria-label="Permalink to &quot;Getters 和 Setters&quot;">​</a></h2><p>遵循 Java getter 和 setter 慣例的方法（無參數方法名稱以 <code>get</code> 開頭，單參數方法名稱以 <code>set</code> 開頭）在 Kotlin 中表示為屬性。這類屬性也稱為<em>合成屬性</em>。<code>Boolean</code> 存取器方法（其中 getter 方法的名稱以 <code>is</code> 開頭，setter 方法的名稱以 <code>set</code> 開頭）表示為與 getter 方法同名的屬性。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> java.util.Calendar</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> calendarDemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> calendar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Calendar.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (calendar.firstDayOfWeek </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Calendar.SUNDAY) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// call getFirstDayOfWeek()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        calendar.firstDayOfWeek </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Calendar.MONDAY </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// call setFirstDayOfWeek()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">calendar.isLenient) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// call isLenient()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        calendar.isLenient </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // call setLenient()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>上方的 <code>calendar.firstDayOfWeek</code> 便是合成屬性的一個範例。</p><p>請注意，如果 Java 類別只有 setter，它在 Kotlin 中不會顯示為屬性，因為 Kotlin 不支援僅設定屬性。</p><h2 id="java-合成屬性參考" tabindex="-1">Java 合成屬性參考 <a class="header-anchor" href="#java-合成屬性參考" aria-label="Permalink to &quot;Java 合成屬性參考&quot;">​</a></h2><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>此功能為 <a href="/zh-Hant/kotlin/components-stability#stability-levels-explained">實驗性</a>。它可能隨時被移除或變更。 我們建議您僅將其用於評估目的。</p></div><p>從 Kotlin 1.8.20 開始，您可以建立對 Java 合成屬性的參考。考慮以下 Java 程式碼：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String name;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getAge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Kotlin 始終允許您編寫 <code>person.age</code>，其中 <code>age</code> 是一個合成屬性。現在，您也可以建立對 <code>Person::age</code> 和 <code>person::age</code> 的參考。這也適用於 <code>name</code>。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> persons </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Jack&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Sofie&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Peter&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    persons</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // Call a reference to Java synthetic property:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sortedBy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Person::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // Call Java getter via the Kotlin property syntax:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person.name) }</span></span></code></pre></div>`,15)),a[3]||(a[3]=s("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"如何啟用-java-合成屬性參考",tabindex:"-1"},[i("如何啟用 Java 合成屬性參考 "),s("a",{class:"header-anchor",href:"#如何啟用-java-合成屬性參考","aria-label":'Permalink to "如何啟用 Java 合成屬性參考 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),a[4]||(a[4]=s("p",null,[i("要啟用此功能，請設定 "),s("code",null,"-language-version 2.1"),i(" 編譯器選項。在 Gradle 專案中，您可以透過將以下內容新增到您的 "),s("code",null,"build.gradle(.kts)"),i(" 來實現：")],-1)),t(p,{group:"build-script"},{default:n(()=>[t(l,{title:"Kotlin","group-key":"kotlin"},{default:n(()=>a[0]||(a[0]=[s("div",{class:"language-kotlin vp-adaptive-theme"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"kotlin"),s("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"tasks")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    ."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"withType"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"org"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"jetbrains"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"gradle"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"tasks"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"KotlinCompilationTask"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<*>>()")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    ."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"configureEach"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        compilerOptions")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            .languageVersion")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            ."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"set"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"                org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_2_1")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            )")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")])])])],-1)])),_:1}),t(l,{title:"Groovy","group-key":"groovy"},{default:n(()=>a[1]||(a[1]=[s("div",{class:"language-groovy vp-adaptive-theme"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"groovy"),s("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"tasks")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    .withType("),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"org.jetbrains.kotlin.gradle.tasks.KotlinCompilationTask."),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"class)")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    .configureEach {")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        compilerOptions"),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"languageVersion")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"            ="),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}}," org.jetbrains.kotlin.gradle.dsl.KotlinVersion."),s("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"KOTLIN_2_1")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),a[5]||(a[5]=h(`<div class="note custom-block"><p class="custom-block-title">NOTE</p><p>在 Kotlin 1.9.0 之前，要啟用此功能，您需要設定 <code>-language-version 1.9</code> 編譯器選項。</p></div><h2 id="傳回-void-的方法" tabindex="-1">傳回 <code>void</code> 的方法 <a class="header-anchor" href="#傳回-void-的方法" aria-label="Permalink to &quot;傳回 \`void\` 的方法&quot;">​</a></h2><p>如果 Java 方法傳回 <code>void</code>，則從 Kotlin 呼叫時它將傳回 <code>Unit</code>。 如果有人碰巧使用了該傳回值，由於該值本身是預先已知的（為 <code>Unit</code>），Kotlin 編譯器將在呼叫點指派它。</p><h2 id="針對-kotlin-關鍵字的-java-識別字逸脫" tabindex="-1">針對 Kotlin 關鍵字的 Java 識別字逸脫 <a class="header-anchor" href="#針對-kotlin-關鍵字的-java-識別字逸脫" aria-label="Permalink to &quot;針對 Kotlin 關鍵字的 Java 識別字逸脫&quot;">​</a></h2><p>某些 Kotlin 關鍵字在 Java 中是有效的識別字：<code>in</code>、<code>object</code>、<code>is</code> 等。 如果 Java 函式庫使用 Kotlin 關鍵字作為方法，您仍然可以使用反引號 (<code>\`</code>) 字元逸脫它來呼叫該方法：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">\`is\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bar)</span></span></code></pre></div><h2 id="空值安全與平台類型" tabindex="-1">空值安全與平台類型 <a class="header-anchor" href="#空值安全與平台類型" aria-label="Permalink to &quot;空值安全與平台類型&quot;">​</a></h2><p>Java 中的任何參考都可能為 <code>null</code>，這使得 Kotlin 對於來自 Java 的物件的嚴格空值安全要求變得不切實際。 Java 宣告的類型在 Kotlin 中以特定方式處理，並稱為<em>平台類型</em>。對於這類類型，空值檢查會放寬，因此它們的安全保證與 Java 中的相同（詳見<a href="#mapped-types">下方</a>）。</p><p>考慮以下範例：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// non-null (constructor result)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Item&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list.size </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// non-null (primitive int)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// platform type inferred (ordinary Java object)</span></span></code></pre></div><p>當您在平台類型變數上呼叫方法時，Kotlin 在編譯時不會發出空值性錯誤，但呼叫可能在執行時失敗，因為會發生空指標例外或 Kotlin 為了防止 <code>null</code> 值傳播而生成的斷言：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">item.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">substring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// allowed, throws an exception if item == null</span></span></code></pre></div><p>平台類型是<em>不可表示的</em>，這意味著您無法在語言中明確地編寫它們。 當平台值指派給 Kotlin 變數時，您可以依賴類型推斷（變數將具有推斷的平台類型，如上述範例中的 <code>item</code>），或者您可以選擇您期望的類型（允許可空和不可空類型）：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nullable: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// allowed, always works</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> notNull: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// allowed, may fail at runtime</span></span></code></pre></div><p>如果您選擇不可空類型，編譯器將在指派時發出斷言。這可以防止 Kotlin 的不可空變數持有 <code>null</code> 值。當您將平台值傳遞給期望非空值的 Kotlin 函數以及在其他情況下，也會發出斷言。 總體而言，儘管有時由於泛型而無法完全消除，但編譯器會盡力防止 <code>null</code> 值在程式中傳播太遠。</p><h3 id="平台類型表示法" tabindex="-1">平台類型表示法 <a class="header-anchor" href="#平台類型表示法" aria-label="Permalink to &quot;平台類型表示法&quot;">​</a></h3><p>如前所述，平台類型無法在程式中明確提及，因此語言中沒有它們的語法。 然而，編譯器和 IDE 有時需要顯示它們（例如，在錯誤訊息或參數資訊中），因此有一種助記表示法：</p><ul><li><code>T!</code> 表示 &quot;<code>T</code> 或 <code>T?</code>&quot;，</li><li><code>(Mutable)Collection&lt;T&gt;!</code> 表示 &quot;Java 的 <code>T</code> 集合可能可變或不可變，可能可空或不可空&quot;，</li><li><code>Array&lt;(out) T&gt;!</code> 表示 &quot;Java 的 <code>T</code> 陣列（或 <code>T</code> 的子類型），可空或不可空&quot;</li></ul><h3 id="空值性註解" tabindex="-1">空值性註解 <a class="header-anchor" href="#空值性註解" aria-label="Permalink to &quot;空值性註解&quot;">​</a></h3><p>具有空值性註解的 Java 類型不表示為平台類型，而是表示為實際的可空或不可空 Kotlin 類型。編譯器支援多種空值性註解風格，包括：</p><ul><li><a href="https://www.jetbrains.com/idea/help/nullable-and-notnull-annotations.html" target="_blank" rel="noreferrer">JetBrains</a> (<code>@Nullable</code> 和 <code>@NotNull</code> 來自 <code>org.jetbrains.annotations</code> 套件)</li><li><a href="https://jspecify.dev/" target="_blank" rel="noreferrer">JSpecify</a> (<code>org.jspecify.annotations</code>)</li><li>Android (<code>com.android.annotations</code> 和 <code>android.support.annotations</code>)</li><li>JSR-305 (<code>javax.annotation</code>，更多細節見下方)</li><li>FindBugs (<code>edu.umd.cs.findbugs.annotations</code>)</li><li>Eclipse (<code>org.eclipse.jdt.annotation</code>)</li><li>Lombok (<code>lombok.NonNull</code>)</li><li>RxJava 3 (<code>io.reactivex.rxjava3.annotations</code>)</li></ul><p>您可以根據來自特定類型的空值性註解的資訊，指定編譯器是否報告空值性不匹配。使用編譯器選項 <code>-Xnullability-annotations=@&lt;package-name&gt;:&lt;report-level&gt;</code>。在參數中，指定完全合格的空值性註解套件以及以下報告層級之一：</p><ul><li><code>ignore</code> 忽略空值性不匹配</li><li><code>warn</code> 報告警告</li><li><code>strict</code> 報告錯誤。</li></ul><p>請參閱 <a href="https://github.com/JetBrains/kotlin/blob/master/core/compiler.common.jvm/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt" target="_blank" rel="noreferrer">Kotlin 編譯器原始碼</a>中支援的空值性註解完整列表。</p><h3 id="註解型別引數與型別參數" tabindex="-1">註解型別引數與型別參數 <a class="header-anchor" href="#註解型別引數與型別參數" aria-label="Permalink to &quot;註解型別引數與型別參數&quot;">​</a></h3><p>您也可以註解泛型型別的型別引數和型別參數，以提供它們的空值性資訊。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>本節中的所有範例都使用來自 <code>org.jetbrains.annotations</code> 套件的 JetBrains 空值性註解。</p></div><h4 id="型別引數" tabindex="-1">型別引數 <a class="header-anchor" href="#型別引數" aria-label="Permalink to &quot;型別引數&quot;">​</a></h4><p>考慮 Java 宣告中的這些註解：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Set</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Collection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elements) { ... }</span></span></code></pre></div><p>它們在 Kotlin 中產生以下簽章：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mutable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Collection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) : (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mutable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span></code></pre></div><p>當型別引數中缺少 <code>@NotNull</code> 註解時，您會得到一個平台類型：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mutable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Collection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">!&gt;) : (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mutable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">!&gt; { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span></code></pre></div><p>Kotlin 也會考慮基礎類別和介面中型別引數上的空值性註解。例如，有兩個 Java 類別，其簽章如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Derived</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nullable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p>在 Kotlin 程式碼中，當假設 <code>Base&lt;String&gt;</code> 處傳遞 <code>Derived</code> 的實例時，會產生警告。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> takeBaseOfNotNullStrings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    takeBaseOfNotNullStrings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Derived</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// warning: nullability mismatch</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>Derived</code> 的上限設定為 <code>Base&lt;String?&gt;</code>，這與 <code>Base&lt;String&gt;</code> 不同。</p><p>了解更多關於 <a href="#java-generics-in-kotlin">Kotlin 中的 Java 泛型</a>。</p><h4 id="型別參數" tabindex="-1">型別參數 <a class="header-anchor" href="#型別參數" aria-label="Permalink to &quot;型別參數&quot;">​</a></h4><p>預設情況下，Kotlin 和 Java 中普通型別參數的空值性是未定義的。在 Java 中，您可以使用空值性註解指定它。讓我們註解 <code>Base</code> 類別的型別參數：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p>當繼承自 <code>Base</code> 時，Kotlin 期望一個非空型別引數或型別參數。 因此，以下 Kotlin 程式碼會產生警告：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Derived</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// warning: K has undefined nullability</span></span></code></pre></div><p>您可以透過指定上限 <code>K : Any</code> 來修正它。</p><p>Kotlin 也支援 Java 型別參數界限上的空值性註解。讓我們為 <code>Base</code> 新增界限：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BaseWithBound</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p>Kotlin 將其翻譯如下：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BaseWithBound</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p>因此，將可空型別作為型別引數或型別參數傳遞會產生警告。</p><p>註解型別引數和型別參數適用於 Java 8 或更高版本。此功能要求空值性註解支援 <code>TYPE_USE</code> 目標（<code>org.jetbrains.annotations</code> 在版本 15 及更高版本中支援此目標）。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>如果空值性註解除了 <code>TYPE_USE</code> 目標之外，還支援適用於型別的其他目標，則 <code>TYPE_USE</code> 具有優先權。例如，如果 <code>@Nullable</code> 同時具有 <code>TYPE_USE</code> 和 <code>METHOD</code> 目標，則 Java 方法簽章 <code>@Nullable String[] f()</code> 在 Kotlin 中變為 <code>fun f(): Array&lt;String?&gt;!</code>。</p></div><h3 id="jsr-305-支援" tabindex="-1">JSR-305 支援 <a class="header-anchor" href="#jsr-305-支援" aria-label="Permalink to &quot;JSR-305 支援&quot;">​</a></h3><p><a href="https://jcp.org/en/jsr/detail?id=305" target="_blank" rel="noreferrer">JSR-305</a> 中定義的 <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/Nonnull.html" target="_blank" rel="noreferrer"><code>@Nonnull</code></a> 註解支援用於表示 Java 類型的空值性。</p><p>如果 <code>@Nonnull(when = ...)</code> 值為 <code>When.ALWAYS</code>，則被註解的類型被視為不可空；<code>When.MAYBE</code> 和 <code>When.NEVER</code> 表示可空類型；而 <code>When.UNKNOWN</code> 強制類型為<a href="#null-safety-and-platform-types">平台類型</a>。</p><p>函式庫可以針對 JSR-305 註解進行編譯，但函式庫消費者無需將註解 artifact（例如 <code>jsr305.jar</code>）作為編譯依賴。Kotlin 編譯器可以在 classpath 上沒有註解的情況下，從函式庫讀取 JSR-305 註解。</p><p>也支援 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/jsr-305-custom-nullability-qualifiers.md" target="_blank" rel="noreferrer">自訂空值性限定詞 (KEEP-79)</a>（見下方）。</p><h4 id="類型限定詞暱稱" tabindex="-1">類型限定詞暱稱 <a class="header-anchor" href="#類型限定詞暱稱" aria-label="Permalink to &quot;類型限定詞暱稱&quot;">​</a></h4><p>如果註解類型同時被 <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/meta/TypeQualifierNickname.html" target="_blank" rel="noreferrer"><code>@TypeQualifierNickname</code></a> 和 JSR-305 <code>@Nonnull</code>（或其另一個暱稱，例如 <code>@CheckForNull</code>）註解，則該註解類型本身用於檢索精確的空值性，並具有與該空值性註解相同的意義：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierNickname</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">when</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> When.ALWAYS)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Retention</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RetentionPolicy.RUNTIME)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> MyNonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierNickname</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CheckForNull</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a nickname to another type qualifier nickname</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Retention</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RetentionPolicy.RUNTIME)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> MyNullable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">MyNullable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">MyNonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // in Kotlin (strict mode): \`fun foo(x: String): String?\`</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(List&lt;@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">MyNonnull</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // in Kotlin (strict mode): \`fun bar(x: List&lt;String&gt;!): String!\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="類型限定詞預設值" tabindex="-1">類型限定詞預設值 <a class="header-anchor" href="#類型限定詞預設值" aria-label="Permalink to &quot;類型限定詞預設值&quot;">​</a></h4><p><a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/meta/TypeQualifierDefault.html" target="_blank" rel="noreferrer"><code>@TypeQualifierDefault</code></a> 允許引入註解，當應用時，這些註解在被註解元素的範圍內定義預設空值性。</p><p>此類註解類型本身應同時被 <code>@Nonnull</code>（或其暱稱）和 <code>@TypeQualifierDefault(...)</code> 註解，並帶有一個或多個 <code>ElementType</code> 值：</p><ul><li><code>ElementType.METHOD</code> 用於方法的回傳型別</li><li><code>ElementType.PARAMETER</code> 用於值參數</li><li><code>ElementType.FIELD</code> 用於欄位</li><li><code>ElementType.TYPE_USE</code> 用於任何型別，包括型別引數、型別參數的上限和萬用字元型別</li></ul><p>當型別本身未被空值性註解註解時，將使用預設空值性，且預設值由最內層包含元素（該元素帶有與型別使用匹配的 <code>ElementType</code> 的類型限定詞預設註解）確定。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ElementType.METHOD, ElementType.PARAMETER})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NonNullApi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">when</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> When.MAYBE)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE_USE})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NullableApi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NullableApi</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fun foo(x: String?): String?</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNullApi</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // overriding default from the interface</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nullable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fun bar(x: String, y: String?): String</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // The List&lt;String&gt; type argument is seen as nullable because of \`@NullableApi\`</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // having the \`TYPE_USE\` element type:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">baz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fun baz(List&lt;String?&gt;?): String?</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // The type of \`x\` parameter remains platform because there&#39;s an explicit</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // UNKNOWN-marked nullability annotation:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">qux</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">when</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> When.UNKNOWN) String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fun baz(x: String!): String?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>本範例中的類型僅在啟用嚴格模式時才生效；否則，平台類型保持不變。 請參閱 <a href="#undermigration-annotation"><code>@UnderMigration</code> 註解</a> 和 <a href="#compiler-configuration">編譯器配置</a> 部分。</p></div><p>也支援套件級別的預設空值性：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// FILE: test/package-info.java</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NonNullApi</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // declaring all types in package &#39;test&#39; as non-nullable by default</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test;</span></span></code></pre></div><h4 id="undermigration-註解" tabindex="-1">@UnderMigration 註解 <a class="header-anchor" href="#undermigration-註解" aria-label="Permalink to &quot;@UnderMigration 註解&quot;">​</a></h4><p><code>@UnderMigration</code> 註解（在單獨的 artifact <code>kotlin-annotations-jvm</code> 中提供）可供函式庫維護者用於定義空值性類型限定詞的遷移狀態。</p><p><code>@UnderMigration(status = ...)</code> 中的狀態值指定編譯器如何處理 Kotlin 中被註解類型的不當使用（例如，將被 <code>@MyNullable</code> 註解的類型值用作非空）：</p><ul><li><code>MigrationStatus.STRICT</code> 使註解像任何普通空值性註解一樣工作，即報告不當使用的錯誤並影響被註解宣告中在 Kotlin 中所見的類型</li><li><code>MigrationStatus.WARN</code>：不當使用報告為編譯警告而非錯誤，但被註解宣告中的類型保持平台類型</li><li><code>MigrationStatus.IGNORE</code> 使編譯器完全忽略空值性註解</li></ul><p>函式庫維護者可以將 <code>@UnderMigration</code> 狀態新增到類型限定詞暱稱和類型限定詞預設值：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">when</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> When.ALWAYS)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ElementType.METHOD, ElementType.PARAMETER})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UnderMigration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">status</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MigrationStatus.WARN)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NonNullApi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// The types in the class are non-nullable, but only warnings are reported</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// because \`@NonNullApi\` is annotated \`@UnderMigration(status = MigrationStatus.WARN)\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NonNullApi</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>空值性註解的遷移狀態不會被其類型限定詞暱稱繼承，但會應用於其在預設類型限定詞中的使用。</p></div><p>如果預設類型限定詞使用類型限定詞暱稱並且它們都是 <code>@UnderMigration</code>，則使用預設類型限定詞的狀態。</p><h4 id="編譯器配置" tabindex="-1">編譯器配置 <a class="header-anchor" href="#編譯器配置" aria-label="Permalink to &quot;編譯器配置&quot;">​</a></h4><p>JSR-305 檢查可以透過新增 <code>-Xjsr305</code> 編譯器標誌並帶有以下選項（及其組合）進行配置：</p><ul><li><p><code>-Xjsr305={strict|warn|ignore}</code> 設定非 <code>@UnderMigration</code> 註解的行為。自訂空值性限定詞，尤其是 <code>@TypeQualifierDefault</code>，已廣泛分佈於許多知名函式庫中，使用者在更新到包含 JSR-305 支援的 Kotlin 版本時可能需要平穩遷移。自 Kotlin 1.1.60 以來，此標誌僅影響非 <code>@UnderMigration</code> 註解。</p></li><li><p><code>-Xjsr305=under-migration:{strict|warn|ignore}</code> 覆寫 <code>@UnderMigration</code> 註解的行為。 使用者對於函式庫的遷移狀態可能有不同的看法： 他們可能希望在官方遷移狀態為 <code>WARN</code> 時出現錯誤，反之亦然， 他們可能希望推遲某些錯誤報告，直到他們完成遷移。</p></li><li><p><code>-Xjsr305=@&lt;fq.name&gt;:{strict|warn|ignore}</code> 覆寫單一註解的行為，其中 <code>&lt;fq.name&gt;</code> 是註解的完全合格類別名稱。可能針對不同的註解出現多次。這對於管理特定函式庫的遷移狀態很有用。</p></li></ul><p><code>strict</code>、<code>warn</code> 和 <code>ignore</code> 值與 <code>MigrationStatus</code> 的意義相同， 並且只有 <code>strict</code> 模式會影響被註解宣告中在 Kotlin 中所見的類型。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>注意：內建的 JSR-305 註解 <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/Nonnull.html" target="_blank" rel="noreferrer"><code>@Nonnull</code></a>、 <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/3.0.1/javax/annotation/Nullable.html" target="_blank" rel="noreferrer"><code>@Nullable</code></a> 和 <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/CheckForNull.html" target="_blank" rel="noreferrer"><code>@CheckForNull</code></a> 始終啟用，並且 無論編譯器是否使用 <code>-Xjsr305</code> 標誌配置，它們都會影響被註解宣告的類型。</p></div><p>例如，將 <code>-Xjsr305=ignore -Xjsr305=under-migration:ignore -Xjsr305=@org.library.MyNullable:warn</code> 新增到 編譯器參數中，會使編譯器對 <code>@org.library.MyNullable</code> 註解類型的不當使用產生警告，並忽略所有其他 JSR-305 註解。</p><p>預設行為與 <code>-Xjsr305=warn</code> 相同。<code>strict</code> 值應被視為實驗性（未來可能會新增更多檢查）。</p><h2 id="映射類型" tabindex="-1">映射類型 <a class="header-anchor" href="#映射類型" aria-label="Permalink to &quot;映射類型&quot;">​</a></h2><p>Kotlin 會特別處理某些 Java 類型。這些類型不會「原樣」從 Java 載入，而是<em>映射</em>到對應的 Kotlin 類型。 映射僅在編譯時重要，執行時表示保持不變。 Java 的原始類型會映射到對應的 Kotlin 類型（考慮到<a href="#null-safety-and-platform-types">平台類型</a>）：</p><table tabindex="0"><thead><tr><th><strong>Java 類型</strong></th><th><strong>Kotlin 類型</strong></th></tr></thead><tbody><tr><td><code>byte</code></td><td><code>kotlin.Byte</code></td></tr><tr><td><code>short</code></td><td><code>kotlin.Short</code></td></tr><tr><td><code>int</code></td><td><code>kotlin.Int</code></td></tr><tr><td><code>long</code></td><td><code>kotlin.Long</code></td></tr><tr><td><code>char</code></td><td><code>kotlin.Char</code></td></tr><tr><td><code>float</code></td><td><code>kotlin.Float</code></td></tr><tr><td><code>double</code></td><td><code>kotlin.Double</code></td></tr><tr><td><code>boolean</code></td><td><code>kotlin.Boolean</code></td></tr></tbody></table><p>一些非原始的內建類別也會被映射：</p><table tabindex="0"><thead><tr><th><strong>Java 類型</strong></th><th><strong>Kotlin 類型</strong></th></tr></thead><tbody><tr><td><code>java.lang.Object</code></td><td><code>kotlin.Any!</code></td></tr><tr><td><code>java.lang.Cloneable</code></td><td><code>kotlin.Cloneable!</code></td></tr><tr><td><code>java.lang.Comparable</code></td><td><code>kotlin.Comparable!</code></td></tr><tr><td><code>java.lang.Enum</code></td><td><code>kotlin.Enum!</code></td></tr><tr><td><code>java.lang.annotation.Annotation</code></td><td><code>kotlin.Annotation!</code></td></tr><tr><td><code>java.lang.CharSequence</code></td><td><code>kotlin.CharSequence!</code></td></tr><tr><td><code>java.lang.String</code></td><td><code>kotlin.String!</code></td></tr><tr><td><code>java.lang.Number</code></td><td><code>kotlin.Number!</code></td></tr><tr><td><code>java.lang.Throwable</code></td><td><code>kotlin.Throwable!</code></td></tr></tbody></table><p>Java 的封裝原始類型會映射到可空的 Kotlin 類型：</p><table tabindex="0"><thead><tr><th><strong>Java 類型</strong></th><th><strong>Kotlin 類型</strong></th></tr></thead><tbody><tr><td><code>java.lang.Byte</code></td><td><code>kotlin.Byte?</code></td></tr><tr><td><code>java.lang.Short</code></td><td><code>kotlin.Short?</code></td></tr><tr><td><code>java.lang.Integer</code></td><td><code>kotlin.Int?</code></td></tr><tr><td><code>java.lang.Long</code></td><td><code>kotlin.Long?</code></td></tr><tr><td><code>java.lang.Character</code></td><td><code>kotlin.Char?</code></td></tr><tr><td><code>java.lang.Float</code></td><td><code>kotlin.Float?</code></td></tr><tr><td><code>java.lang.Double</code></td><td><code>kotlin.Double?</code></td></tr><tr><td><code>java.lang.Boolean</code></td><td><code>kotlin.Boolean?</code></td></tr></tbody></table><p>請注意，作為型別參數使用的封裝原始類型會映射到平台類型： 例如，<code>List&lt;java.lang.Integer&gt;</code> 在 Kotlin 中變為 <code>List&lt;Int!&gt;</code>。</p><p>集合類型在 Kotlin 中可以是唯讀或可變的，因此 Java 的集合映射如下 （此表格中的所有 Kotlin 類型都位於 <code>kotlin.collections</code> 套件中）：</p><table tabindex="0"><thead><tr><th><strong>Java 類型</strong></th><th><strong>Kotlin 唯讀類型</strong></th><th><strong>Kotlin 可變類型</strong></th><th><strong>載入的平台類型</strong></th></tr></thead><tbody><tr><td><code>Iterator&lt;T&gt;</code></td><td><code>Iterator&lt;T&gt;</code></td><td><code>MutableIterator&lt;T&gt;</code></td><td><code>(Mutable)Iterator&lt;T&gt;!</code></td></tr><tr><td><code>Iterable&lt;T&gt;</code></td><td><code>Iterable&lt;T&gt;</code></td><td><code>MutableIterable&lt;T&gt;</code></td><td><code>(Mutable)Iterable&lt;T&gt;!</code></td></tr><tr><td><code>Collection&lt;T&gt;</code></td><td><code>Collection&lt;T&gt;</code></td><td><code>MutableCollection&lt;T&gt;</code></td><td><code>(Mutable)Collection&lt;T&gt;!</code></td></tr><tr><td><code>Set&lt;T&gt;</code></td><td><code>Set&lt;T&gt;</code></td><td><code>MutableSet&lt;T&gt;</code></td><td><code>(Mutable)Set&lt;T&gt;!</code></td></tr><tr><td><code>List&lt;T&gt;</code></td><td><code>List&lt;T&gt;</code></td><td><code>MutableList&lt;T&gt;</code></td><td><code>(Mutable)List&lt;T&gt;!</code></td></tr><tr><td><code>ListIterator&lt;T&gt;</code></td><td><code>ListIterator&lt;T&gt;</code></td><td><code>MutableListIterator&lt;T&gt;</code></td><td><code>(Mutable)ListIterator&lt;T&gt;!</code></td></tr><tr><td><code>Map&lt;K, V&gt;</code></td><td><code>Map&lt;K, V&gt;</code></td><td><code>MutableMap&lt;K, V&gt;</code></td><td><code>(Mutable)Map&lt;K, V&gt;!</code></td></tr><tr><td><code>Map.Entry&lt;K, V&gt;</code></td><td><code>Map.Entry&lt;K, V&gt;</code></td><td><code>MutableMap.MutableEntry&lt;K,V&gt;</code></td><td><code>(Mutable)Map.(Mutable)Entry&lt;K, V&gt;!</code></td></tr></tbody></table><p>Java 的陣列映射如下<a href="#java-arrays">下方</a>所述：</p><table tabindex="0"><thead><tr><th><strong>Java 類型</strong></th><th><strong>Kotlin 類型</strong></th></tr></thead><tbody><tr><td><code>int[]</code></td><td><code>kotlin.IntArray!</code></td></tr><tr><td><code>String[]</code></td><td><code>kotlin.Array&lt;(out) String!&gt;!</code></td></tr></tbody></table><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>這些 Java 類型的靜態成員無法直接在 Kotlin 類型的<a href="/zh-Hant/kotlin/object-declarations#companion-objects">伴隨物件</a>上存取。若要呼叫它們，請使用 Java 類型的完全合格名稱，例如 <code>java.lang.Integer.toHexString(foo)</code>。</p></div><h2 id="kotlin-中的-java-泛型" tabindex="-1">Kotlin 中的 Java 泛型 <a class="header-anchor" href="#kotlin-中的-java-泛型" aria-label="Permalink to &quot;Kotlin 中的 Java 泛型&quot;">​</a></h2><p>Kotlin 的泛型與 Java 的有些許不同（參閱<a href="/zh-Hant/kotlin/generics">泛型</a>）。 當將 Java 類型匯入 Kotlin 時，會進行以下轉換：</p><ul><li><p>Java 的萬用字元會轉換為型別投射：</p><ul><li><code>Foo&lt;? extends Bar&gt;</code> 變成 <code>Foo&lt;out Bar!&gt;!</code></li><li><code>Foo&lt;? super Bar&gt;</code> 變成 <code>Foo&lt;in Bar!&gt;!</code></li></ul></li><li><p>Java 的原始類型會轉換為星號投射：</p><ul><li><code>List</code> 變成 <code>List&lt;*&gt;!</code>，即 <code>List&lt;out Any?&gt;!</code></li></ul></li></ul><p>如同 Java 泛型，Kotlin 的泛型在執行時也不會保留：物件不攜帶傳遞給其建構子的實際型別引數資訊。例如，<code>ArrayList&lt;Integer&gt;()</code> 與 <code>ArrayList&lt;Character&gt;()</code> 無法區分。 這使得進行考慮泛型的 <code>is</code> 檢查變得不可能。 Kotlin 只允許對星號投射的泛型類型進行 <code>is</code> 檢查：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Error: cannot check if it is really a List of Ints</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// but</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;*&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK: no guarantees about the contents of the list</span></span></code></pre></div><h2 id="java-陣列" tabindex="-1">Java 陣列 <a class="header-anchor" href="#java-陣列" aria-label="Permalink to &quot;Java 陣列&quot;">​</a></h2><p>Kotlin 中的陣列是不可變的，這與 Java 不同。這表示 Kotlin 不會讓您將 <code>Array&lt;String&gt;</code> 指派給 <code>Array&lt;Any&gt;</code>，這可以防止可能的執行時失敗。將子類別的陣列作為父類別的陣列傳遞給 Kotlin 方法也是被禁止的，但對於 Java 方法，這可以透過形式為 <code>Array&lt;(out) String&gt;!</code> 的<a href="#null-safety-and-platform-types">平台類型</a>來允許。</p><p>陣列在 Java 平台上與原始資料類型一起使用，以避免封裝/解封裝操作的成本。 由於 Kotlin 隱藏了這些實作細節，因此需要變通方法來與 Java 程式碼介面。 對於每種原始陣列類型（<code>IntArray</code>、<code>DoubleArray</code>、<code>CharArray</code> 等）都有專門的類別來處理此情況。 它們與 <code>Array</code> 類別無關，並編譯成 Java 的原始陣列以實現最大效能。</p><p>假設有一個 Java 方法接受一個 <code>int</code> 索引陣列：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JavaArrayExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeIndices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">indices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // code here...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>要在 Kotlin 中傳遞原始值陣列，您可以這樣做：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> javaObj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JavaArrayExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> intArrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">javaObj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeIndices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// passes int[] to method</span></span></code></pre></div><p>在編譯為 JVM 位元組碼時，編譯器會優化對陣列的存取，因此不會引入任何額外開銷：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">array[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // no actual calls to get() and set() generated</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// no iterator created</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>即使您透過索引導航，也不會引入任何額外開銷：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.indices) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// no iterator created</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    array[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>最後，<code>in</code> 檢查也沒有額外開銷：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.indices) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// same as (i &gt;= 0 &amp;&amp; i &lt; array.size)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array[i])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="java-變長參數" tabindex="-1">Java 變長參數 <a class="header-anchor" href="#java-變長參數" aria-label="Permalink to &quot;Java 變長參數&quot;">​</a></h2><p>Java 類別有時會使用帶有可變參數 (varargs) 的索引方法宣告：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JavaArrayExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeIndicesVarArg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">... </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">indices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // code here...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在這種情況下，您需要使用展開運算子 <code>*</code> 來傳遞 <code>IntArray</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> javaObj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JavaArrayExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> intArrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">javaObj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeIndicesVarArg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">array)</span></span></code></pre></div><h2 id="運算子" tabindex="-1">運算子 <a class="header-anchor" href="#運算子" aria-label="Permalink to &quot;運算子&quot;">​</a></h2><p>由於 Java 無法標記那些適用於運算子語法的方法，Kotlin 允許使用任何具有正確名稱和簽章的 Java 方法作為運算子多載和其他慣例（例如 <code>invoke()</code> 等）。 不允許使用中綴呼叫語法呼叫 Java 方法。</p><h2 id="已檢查例外" tabindex="-1">已檢查例外 <a class="header-anchor" href="#已檢查例外" aria-label="Permalink to &quot;已檢查例外&quot;">​</a></h2><p>在 Kotlin 中，所有<a href="/zh-Hant/kotlin/exceptions">例外都是未檢查的</a>，這表示編譯器不會強制您捕捉任何例外。 因此，當您呼叫宣告了已檢查例外的 Java 方法時，Kotlin 不會強制您做任何事情：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(list: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;*&gt;, to: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Appendable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        to.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Java would require us to catch IOException here</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="物件方法" tabindex="-1">物件方法 <a class="header-anchor" href="#物件方法" aria-label="Permalink to &quot;物件方法&quot;">​</a></h2><p>當 Java 類型匯入 Kotlin 時，所有 <code>java.lang.Object</code> 類型的參考都會轉換為 <code>Any</code>。 由於 <code>Any</code> 不是平台特定的，它只宣告 <code>toString()</code>、<code>hashCode()</code> 和 <code>equals()</code> 作為其成員， 因此為了使 <code>java.lang.Object</code> 的其他成員可用，Kotlin 使用了<a href="/zh-Hant/kotlin/extensions">擴充函數</a>。</p><h3 id="wait-notify" tabindex="-1">wait()/notify() <a class="header-anchor" href="#wait-notify" aria-label="Permalink to &quot;wait()/notify()&quot;">​</a></h3><p><code>wait()</code> 和 <code>notify()</code> 方法在 <code>Any</code> 類型的參考上不可用。通常不鼓勵使用它們，而偏好使用 <code>java.util.concurrent</code>。如果您確實需要呼叫這些方法，可以轉換為 <code>java.lang.Object</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.lang.Object).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h3 id="getclass" tabindex="-1">getClass() <a class="header-anchor" href="#getclass" aria-label="Permalink to &quot;getClass()&quot;">​</a></h3><p>要擷取物件的 Java 類別，請在<a href="/zh-Hant/kotlin/reflection#class-references">類別參考</a>上使用 <code>java</code> 擴充屬性：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fooClass </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.java</span></span></code></pre></div><p>上面的程式碼使用<a href="/zh-Hant/kotlin/reflection#bound-class-references">綁定類別參考</a>。您也可以使用 <code>javaClass</code> 擴充屬性：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fooClass </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo.javaClass</span></span></code></pre></div><p>請勿將 <code>ClassName.javaClass</code> 用於此目的，因為它指的是 <code>ClassName</code> 的伴隨物件類別， 這與 <code>ClassName.Companion::class.java</code> 相同，而非 <code>ClassName::class.java</code>。</p><p>對於每個原始類型，有兩個不同的 Java 類別，Kotlin 提供了兩種獲取方式。例如，<code>Int::class.java</code> 將回傳代表原始類型本身的類別實例， 對應於 Java 中的 <code>Integer.TYPE</code>。要獲取對應封裝器類型的類別，請使用 <code>Int::class.javaObjectType</code>，這等同於 Java 的 <code>Integer.class</code>。</p><p>其他支援的案例包括獲取 Kotlin 屬性的 Java getter/setter 方法或支援欄位，Java 欄位的 <code>KProperty</code>，Java 方法或建構子的 <code>KFunction</code>，反之亦然。</p><h2 id="sam-轉換" tabindex="-1">SAM 轉換 <a class="header-anchor" href="#sam-轉換" aria-label="Permalink to &quot;SAM 轉換&quot;">​</a></h2><p>Kotlin 支援 Java 和 <a href="/zh-Hant/kotlin/fun-interfaces">Kotlin 介面</a>的 SAM 轉換。 對 Java 的這種支援意味著 Kotlin 函數字面值可以自動轉換為單一非預設方法的 Java 介面實作，只要介面方法的參數類型與 Kotlin 函數的參數類型匹配。</p><p>您可以將其用於建立 SAM 介面實例：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> runnable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This runs in a runnable&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span></code></pre></div><p>...以及在方法呼叫中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ThreadPoolExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Java signature: void execute(Runnable command)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">executor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This runs in a thread pool&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span></code></pre></div><p>如果 Java 類別有多個接受函數式介面的方法，您可以透過使用轉接器函數來選擇需要呼叫的方法，該函數將 lambda 轉換為特定的 SAM 類型。這些轉接器函數也會在需要時由編譯器生成：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">executor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This runs in a thread pool&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) })</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>SAM 轉換僅適用於介面，不適用於抽象類別，即使這些抽象類別也只有一個抽象方法。</p></div><h2 id="在-kotlin-中使用-jni" tabindex="-1">在 Kotlin 中使用 JNI <a class="header-anchor" href="#在-kotlin-中使用-jni" aria-label="Permalink to &quot;在 Kotlin 中使用 JNI&quot;">​</a></h2><p>要宣告一個在原生 (C 或 C++) 程式碼中實作的函數，您需要使用 <code>external</code> 修飾符標記它：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Double</span></span></code></pre></div><p>其餘程序與 Java 中完全相同。</p><p>您也可以將屬性 getter 和 setter 標記為 <code>external</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myProperty: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> get</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> set</span></span></code></pre></div><p>在幕後，這將建立兩個函數 <code>getMyProperty</code> 和 <code>setMyProperty</code>，兩者都標記為 <code>external</code>。</p><h2 id="在-kotlin-中使用-lombok-生成的宣告" tabindex="-1">在 Kotlin 中使用 Lombok 生成的宣告 <a class="header-anchor" href="#在-kotlin-中使用-lombok-生成的宣告" aria-label="Permalink to &quot;在 Kotlin 中使用 Lombok 生成的宣告&quot;">​</a></h2><p>您可以在 Kotlin 程式碼中使用 Java 的 Lombok 生成宣告。 如果您需要在同一個混合 Java/Kotlin 模組中生成並使用這些宣告， 您可以從 <a href="/zh-Hant/kotlin/lombok">Lombok 編譯器外掛頁面</a>了解如何執行此操作。 如果您從另一個模組呼叫此類宣告，則無需使用此外掛來編譯該模組。</p>`,158))])}const A=k(r,[["render",E]]);export{v as __pageData,A as default};
