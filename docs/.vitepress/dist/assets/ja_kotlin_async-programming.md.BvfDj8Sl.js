import{_ as i,c as a,o as n,ag as e}from"./chunks/framework.Bksy39di.js";const o=JSON.parse('{"title":"非同期プログラミング手法","description":"","frontmatter":{},"headers":[],"relativePath":"ja/kotlin/async-programming.md","filePath":"ja/kotlin/async-programming.md","lastUpdated":1754307826000}'),t={name:"ja/kotlin/async-programming.md"};function p(l,s,h,k,r,E){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="非同期プログラミング手法" tabindex="-1">非同期プログラミング手法 <a class="header-anchor" href="#非同期プログラミング手法" aria-label="Permalink to &quot;非同期プログラミング手法&quot;">​</a></h1><p>何十年もの間、私たちは開発者として、アプリケーションがブロックされるのを防ぐ方法という問題に直面してきました。デスクトップ、モバイル、あるいはサーバーサイドアプリケーションを開発している場合でも、ユーザーを待たせたり、さらに悪いことにアプリケーションのスケーリングを妨げるボトルネックを引き起こしたりするのを避けたいと考えます。</p><p>この問題を解決するために、これまでに多くの方法が考案されてきました。</p><ul><li><a href="#threading">スレッド</a></li><li><a href="#callbacks">コールバック</a></li><li><a href="#futures-promises-and-others">Future、Promise、その他</a></li><li><a href="#reactive-extensions">Reactive Extensions</a></li><li><a href="#coroutines">コルーチン</a></li></ul><p>コルーチンがどのようなものかを説明する前に、他の解決策のいくつかについて簡単に確認しておきましょう。</p><h2 id="スレッド" tabindex="-1">スレッド <a class="header-anchor" href="#スレッド" aria-label="Permalink to &quot;スレッド&quot;">​</a></h2><p>スレッドは、アプリケーションがブロックされるのを回避するための、おそらく最もよく知られたアプローチです。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> postItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> token </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> preparePost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> post </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> submitPost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(token, item)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    processPost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(post)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> preparePost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Token</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // makes a request and consequently blocks the main thread</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> token</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>上記のコードで <code>preparePost</code> が長時間実行されるプロセスであり、その結果ユーザーインターフェースがブロックされると仮定しましょう。この場合、それを別のスレッドで起動することができます。これにより、UIがブロックされるのを回避できます。これは非常に一般的な手法ですが、一連の欠点があります。</p><ul><li>スレッドはコストが高い。スレッドはコストのかかるコンテキストスイッチを必要とします。</li><li>スレッドは無限ではない。起動できるスレッドの数は、基盤となるオペレーティングシステムによって制限されます。サーバーサイドアプリケーションでは、これが主要なボトルネックになる可能性があります。</li><li>スレッドは常に利用できるわけではない。JavaScriptなどの一部のプラットフォームは、スレッドをサポートしていません。</li><li>スレッドは簡単ではない。スレッドのデバッグや競合状態の回避は、マルチスレッドプログラミングで私たちが悩まされる一般的な問題です。</li></ul><h2 id="コールバック" tabindex="-1">コールバック <a class="header-anchor" href="#コールバック" aria-label="Permalink to &quot;コールバック&quot;">​</a></h2><p>コールバックでは、ある関数を別の関数のパラメーターとして渡し、プロセスが完了したときにその関数が呼び出されるようにするという考え方です。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> postItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    preparePostAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { token </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        submitPostAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(token, item) { post </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            processPost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(post)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> preparePostAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Token</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // make request and return immediately </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // arrange callback to be invoked later</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>これは原則として、はるかに洗練された解決策のように感じられますが、またしてもいくつかの問題があります。</p><ul><li>ネストされたコールバックの難しさ。通常、コールバックとして使用される関数は、しばしば独自のコールバックを必要とすることになります。これにより、一連のネストされたコールバックが発生し、理解不能なコードにつながります。このパターンは、これらの深くネストされたコールバックによるインデントが三角形の形になることから、しばしば「コールバック地獄」または<a href="https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)" target="_blank" rel="noreferrer">破滅のピラミッド</a>と呼ばれます。</li><li>エラーハンドリングが複雑。ネストされたモデルは、エラーハンドリングとその伝播を多少複雑にします。</li></ul><p>コールバックはJavaScriptのようなイベントループアーキテクチャでは非常に一般的ですが、そこでも、一般的に人々はPromiseやReactive Extensionsのような他のアプローチを使う方向へと移行しています。</p><h2 id="future、promise、その他" tabindex="-1">Future、Promise、その他 <a class="header-anchor" href="#future、promise、その他" aria-label="Permalink to &quot;Future、Promise、その他&quot;">​</a></h2><p>FutureまたはPromise（言語やプラットフォームによっては他の用語が使われることもあります）の背後にある考え方は、呼び出しを行うと、ある時点で呼び出しが<code>Promise</code>オブジェクトを返すことが<strong>約束</strong>され、そのオブジェクトに対して操作を実行できるというものです。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> postItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    preparePostAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">thenCompose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { token </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            submitPostAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(token, item)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">thenAccept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { post </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            processPost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(post)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> preparePostAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Token</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // makes request and returns a promise that is completed later</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> promise </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>このアプローチは、プログラミングの方法に一連の変更を要求します。具体的には、次の点が挙げられます。</p><ul><li>異なるプログラミングモデル。コールバックと同様に、プログラミングモデルはトップダウンの命令型アプローチから、チェイン呼び出しによる構成型モデルへと移行します。ループや例外処理などの従来のプログラム構造は、通常このモデルでは有効ではありません。</li><li>異なるAPI。通常、<code>thenCompose</code>や<code>thenAccept</code>のような全く新しいAPIを学ぶ必要があり、これらはプラットフォームによって異なることもあります。</li><li>特定の戻り値の型。戻り値の型は、必要とする実際のデータから離れて、代わりに検査される必要がある新しい型<code>Promise</code>を返します。</li><li>エラーハンドリングが複雑になる可能性がある。エラーの伝播とチェイン化は、常に単純ではありません。</li></ul><h2 id="reactive-extensions" tabindex="-1">Reactive Extensions <a class="header-anchor" href="#reactive-extensions" aria-label="Permalink to &quot;Reactive Extensions&quot;">​</a></h2><p>Reactive Extensions (Rx) は、<a href="https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)" target="_blank" rel="noreferrer">Erik Meijer</a>によってC#に導入されました。Rxは確かに.NETプラットフォームで使われていましたが、NetflixがJavaに移植し、RxJavaと名付けるまで主流にはなりませんでした。それ以来、JavaScript (RxJS) を含む様々なプラットフォーム向けに多数の移植版が提供されています。</p><p>Rxの背景にある考え方は、<code>observable streams</code>と呼ばれるものへと移行することです。これにより、データがストリーム（無限の量のデータ）として考えられ、これらのストリームを監視できるようになります。実用的な観点から見ると、Rxは単に<a href="https://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="noreferrer">Observer パターン</a>に、データに対する操作を可能にする一連の拡張を加えたものです。</p><p>アプローチとしてはFutureに非常に似ていますが、Futureが離散的な要素を返すのに対し、Rxはストリームを返すと考えることができます。しかし、以前のものと同様に、これもプログラミングモデルについて全く新しい考え方を導入しており、有名なフレーズで表現されています。</p><pre><code>「すべてはストリームであり、監視可能である」
</code></pre><p>これは、問題に取り組む異なる方法を意味し、同期コードを書く際に慣れているものとはかなり大きな変化を伴います。Futureと比較して一つの利点は、非常に多くのプラットフォームに移植されているため、C#、Java、JavaScript、その他Rxが利用可能などの言語を使用しても、一般的に一貫したAPI体験を見つけることができるという点です。</p><p>さらに、Rxはエラーハンドリングに対し、いくらかより良いアプローチを導入しています。</p><h2 id="コルーチン" tabindex="-1">コルーチン <a class="header-anchor" href="#コルーチン" aria-label="Permalink to &quot;コルーチン&quot;">​</a></h2><p>Kotlinの非同期コードを扱うアプローチはコルーチンを使用することです。これはサスペンド可能な計算という考え方、つまり関数がある時点で実行を中断し、後で再開できるという考え方です。</p><p>しかし、コルーチンの利点の1つは、開発者にとってはノンブロッキングコードを書くことが、実質的にブロッキングコードを書くことと同じであるという点です。プログラミングモデル自体は実際には変わりません。</p><p>たとえば、次のコードを見てみましょう。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> postItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> token </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> preparePost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> post </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> submitPost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(token, item)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        processPost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(post)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> preparePost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Token</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // makes a request and suspends the coroutine</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> suspendCoroutine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>このコードは、メインスレッドをブロックすることなく、長時間実行される操作を起動します。<code>preparePost</code>は<code>サスペンド可能関数</code>と呼ばれるものであり、その前に<code>suspend</code>キーワードがついています。これが意味することは、前述のように、関数が実行され、実行を一時停止し、ある時点で再開するということです。</p><ul><li>関数シグネチャは全く同じままです。唯一の違いは<code>suspend</code>が追加されていることです。ただし、戻り値の型は、返したい型になります。</li><li>コードは引き続き、同期コードを書くかのように、トップダウンで書かれており、コルーチンを本質的に開始させる<code>launch</code>という関数を使用する以外の特別な構文は必要ありません（他のチュートリアルで解説されています）。</li><li>プログラミングモデルとAPIは同じままです。ループ、例外処理などを引き続き使用でき、全く新しいAPIセットを学ぶ必要はありません。</li><li>プラットフォーム非依存です。JVM、JavaScript、またはその他のプラットフォームをターゲットにしているかどうかにかかわらず、私たちが書くコードは同じです。内部では、コンパイラが各プラットフォームへの適応を処理します。</li></ul><p>コルーチンは新しい概念ではありませんし、Kotlinによって発明されたものでもありません。何十年も前から存在し、Goのような他のプログラミング言語では人気があります。ただし重要な点は、Kotlinでの実装方法であり、その機能のほとんどはライブラリに委譲されていることです。実際、<code>suspend</code>キーワード以外に、言語にキーワードは追加されていません。これは、<code>async</code>と<code>await</code>が構文の一部であるC#のような言語とは多少異なります。Kotlinでは、これらは単なるライブラリ関数です。</p><p>詳細については、<a href="/ja/kotlin/coroutines-overview">コルーチンリファレンス</a>を参照してください。</p>`,37)]))}const c=i(t,[["render",p]]);export{o as __pageData,c as default};
