import{_ as p,C as i,c as h,o as k,G as a,ag as r,w as o,a as d}from"./chunks/framework.Bksy39di.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ko/ktor/server-routing.md","filePath":"ko/ktor/server-routing.md","lastUpdated":1755457140000}'),c={name:"ko/ktor/server-routing.md"};function E(g,s,u,y,F,C){const n=i("TopicTitle"),e=i("show-structure"),t=i("primary-label"),l=i("link-summary");return k(),h("div",null,[a(n,{labelRef:"server-plugin",title:"라우팅"}),a(e,{for:"chapter",depth:"2"}),a(t,{ref:"server-plugin"},null,512),a(l,null,{default:o(()=>s[0]||(s[0]=[d(" 라우팅은 서버 애플리케이션에서 들어오는 요청을 처리하는 핵심 플러그인입니다. ")])),_:1}),s[1]||(s[1]=r(`<p>라우팅은 서버 애플리케이션에서 들어오는 요청을 처리하기 위한 Ktor의 핵심 <a href="./server-plugins">플러그인</a>입니다. 클라이언트가 특정 URL(예: <code>/hello</code>)로 요청을 보내면, 라우팅 메커니즘을 통해 이 요청을 어떻게 처리할지 정의할 수 있습니다.</p><h2 id="install_plugin" tabindex="-1">라우팅 설치 <a class="header-anchor" href="#install_plugin" aria-label="Permalink to &quot;라우팅 설치 {id=&quot;install_plugin&quot;}&quot;">​</a></h2><p>라우팅 플러그인은 다음과 같이 설치할 수 있습니다:</p><div class="language-Kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io.ktor.server.routing.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RoutingRoot) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>라우팅 플러그인은 모든 애플리케이션에서 매우 흔하게 사용되므로, 라우팅을 더 간단하게 설치할 수 있는 편리한 <code>routing</code> 함수가 있습니다. 아래 코드 스니펫에서 <code>install(RoutingRoot)</code>는 <code>routing</code> 함수로 대체됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io.ktor.server.routing.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="define_route" tabindex="-1">라우트 핸들러 정의 <a class="header-anchor" href="#define_route" aria-label="Permalink to &quot;라우트 핸들러 정의 {id=&quot;define_route&quot;}&quot;">​</a></h2><p>라우팅 플러그인을 <a href="#install_plugin">설치</a>한 후, <code>routing</code> 내에서 <a href="https://api.ktor.io/ktor-server/ktor-server-core/io.ktor.server.routing/route.html" target="_blank" rel="noreferrer">route</a> 함수를 호출하여 라우트를 정의할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io.ktor.server.routing.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io.ktor.http.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io.ktor.server.response.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    route</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, HttpMethod.Get) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        handle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            call.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">respondText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Ktor는 라우트 핸들러 정의를 훨씬 더 쉽고 간결하게 만들어주는 일련의 함수들을 제공합니다. 예를 들어, 이전 코드를 이제 URL과 요청을 처리할 코드만 필요한 <a href="https://api.ktor.io/ktor-server/ktor-server-core/io.ktor.server.routing/get.html" target="_blank" rel="noreferrer">get</a> 함수로 대체할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io.ktor.server.routing.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io.ktor.server.response.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        call.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">respondText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>유사하게, Ktor는 <code>put</code>, <code>post</code>, <code>head</code> 등 다른 모든 HTTP 동사(verb)에 대한 함수를 제공합니다.</p><p>요약하자면, 라우트를 정의하기 위해 다음 설정을 지정해야 합니다:</p><ul><li><p><strong>HTTP 동사(Verb)</strong></p><p><code>GET</code>, <code>POST</code>, <code>PUT</code> 등 HTTP 동사를 선택합니다. 가장 편리한 방법은 <code>get</code>, <code>post</code>, <code>put</code> 등 전용 동사 함수를 사용하는 것입니다.</p></li><li><p><strong>경로 패턴</strong></p><p>URL 경로를 <a href="#match_url">일치</a>시키는 데 사용되는 경로 패턴을 지정합니다. 예를 들어, <code>/hello</code>, <code>/customer/{id}</code>와 같습니다. <code>get</code>/<code>post</code>/등 함수에 경로 패턴을 바로 전달할 수 있으며, <a href="#multiple_routes">라우트 핸들러</a>를 그룹화하고 <a href="#nested_routes">중첩 라우트</a>를 정의하기 위해 <code>route</code> 함수를 사용할 수도 있습니다.</p></li><li><p><strong>핸들러</strong></p><p><a href="./server-requests">요청</a>과 <a href="./server-responses">응답</a>을 처리하는 방법을 지정합니다. 핸들러 내에서 <code>ApplicationCall</code>에 접근하여, 클라이언트 요청을 처리하고 응답을 보낼 수 있습니다.</p></li></ul><h2 id="match_url" tabindex="-1">경로 패턴 지정 <a class="header-anchor" href="#match_url" aria-label="Permalink to &quot;경로 패턴 지정 {id=&quot;match_url&quot;}&quot;">​</a></h2><p><a href="#define_route">라우팅</a> 함수(<code>route</code>, <code>get</code>, <code>post</code> 등)에 전달되는 경로 패턴은 URL의 <em>경로</em> 구성 요소를 일치시키는 데 사용됩니다. 경로는 슬래시(<code>/</code>) 문자로 구분된 일련의 경로 세그먼트를 포함할 수 있습니다.</p><blockquote><p>참고: Ktor는 후행 슬래시(trailing slash)가 있는 경로와 없는 경로를 구분합니다. <code>IgnoreTrailingSlash</code> 플러그인을 <a href="./server-plugins#install">설치</a>하여 이 동작을 변경할 수 있습니다.</p></blockquote><p>다음은 몇 가지 경로 예시입니다:</p><ul><li><code>/hello</code><br> 단일 경로 세그먼트를 포함하는 경로입니다.</li><li><code>/order/shipment</code><br> 여러 경로 세그먼트를 포함하는 경로입니다. 이러한 경로는 <a href="#define_route">route/get/등</a> 함수에 그대로 전달하거나 여러 <code>route</code> 함수를 <a href="#multiple_routes">중첩</a>하여 하위 라우트를 구성할 수 있습니다.</li><li><code>/user/{login}</code><br><code>login</code> <a href="#path_parameter">경로 파라미터</a>가 있는 경로로, 해당 값은 라우트 핸들러 내에서 접근할 수 있습니다.</li><li><code>/user/*</code><br><a href="#wildcard">와일드카드 문자</a>가 있는 경로로, 모든 경로 세그먼트와 일치합니다.</li><li><code>/user/{...}</code><br><a href="#tailcard">테일카드</a>가 있는 경로로, URL 경로의 나머지 전부와 일치합니다.</li><li><code>/user/{param...}</code><br><a href="#path_parameter_tailcard">테일카드를 포함한 경로 파라미터</a>를 포함하는 경로입니다.</li><li><code>Regex(&quot;/.+/hello&quot;)</code><br><a href="#regular_expression">정규 표현식</a>을 포함하는 경로로, <code>/hello</code>의 마지막 발생까지의 경로 세그먼트와 일치합니다.</li></ul><h3 id="wildcard" tabindex="-1">와일드카드 (Wildcard) <a class="header-anchor" href="#wildcard" aria-label="Permalink to &quot;와일드카드 (Wildcard) {id=&quot;wildcard&quot;}&quot;">​</a></h3><p><em>와일드카드</em> (<code>*</code>)는 모든 경로 세그먼트와 일치하며 생략될 수 없습니다. 예를 들어, <code>/user/*</code>는 <code>/user/john</code>과 일치하지만, <code>/user</code>와는 일치하지 않습니다.</p><h3 id="tailcard" tabindex="-1">테일카드 (Tailcard) <a class="header-anchor" href="#tailcard" aria-label="Permalink to &quot;테일카드 (Tailcard) {id=&quot;tailcard&quot;}&quot;">​</a></h3><p><em>테일카드</em> (<code>{...}</code>)는 URL 경로의 나머지 전부와 일치하며, 여러 경로 세그먼트를 포함할 수 있고, 비어 있을 수도 있습니다. 예를 들어, <code>/user/{...}</code>는 <code>/user/john/settings</code>뿐만 아니라 <code>/user</code>와도 일치합니다.</p><h3 id="path_parameter" tabindex="-1">경로 파라미터 (Path Parameter) <a class="header-anchor" href="#path_parameter" aria-label="Permalink to &quot;경로 파라미터 (Path Parameter) {id=&quot;path_parameter&quot;}&quot;">​</a></h3><p><em>경로 파라미터</em> (<code>{param}</code>)는 경로 세그먼트와 일치하고 <code>param</code>이라는 이름의 파라미터로 캡처합니다. 이 경로 세그먼트는 필수이지만, 물음표를 추가하여 <code>{param?}</code> 선택 사항으로 만들 수 있습니다. 예를 들어:</p><ul><li><code>/user/{login}</code>은 <code>/user/john</code>과 일치하지만, <code>/user</code>와는 일치하지 않습니다.</li><li><code>/user/{login?}</code>은 <code>/user/john</code>뿐만 아니라 <code>/user</code>와도 일치합니다.<div class="note custom-block"><p class="custom-block-title">NOTE</p><p>참고: 선택적 경로 파라미터 <code>{param?}</code>는 경로의 끝에만 사용할 수 있습니다.</p></div></li></ul><p>라우트 핸들러 내에서 파라미터 값에 접근하려면 <code>call.parameters</code> 속성을 사용합니다. 예를 들어, 아래 코드 스니펫에서 <code>/user/admin</code> 경로에 대해 <code>call.parameters[&quot;login&quot;]</code>은 _admin_을 반환합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/user/{login}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (call.parameters[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;login&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;admin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>요청에 쿼리 문자열이 포함된 경우, <code>call.parameters</code>에는 이 쿼리 문자열의 파라미터도 포함됩니다. 핸들러 내에서 쿼리 문자열과 해당 파라미터에 접근하는 방법을 알아보려면 <a href="./server-requests#query_parameters">쿼리 파라미터</a>를 참조하세요.</p></blockquote><h3 id="path_parameter_tailcard" tabindex="-1">테일카드를 포함한 경로 파라미터 (Path Parameter with Tailcard) <a class="header-anchor" href="#path_parameter_tailcard" aria-label="Permalink to &quot;테일카드를 포함한 경로 파라미터 (Path Parameter with Tailcard) {id=&quot;path_parameter_tailcard&quot;}&quot;">​</a></h3><p>테일카드를 포함한 경로 파라미터(<code>{param...}</code>)는 URL 경로의 나머지 전부와 일치하며 각 경로 세그먼트에 대한 여러 값을 <code>param</code>을 키로 사용하여 파라미터에 넣습니다. 예를 들어, <code>/user/{param...}</code>는 <code>/user/john/settings</code>와 일치합니다. 라우트 핸들러 내에서 경로 세그먼트 값에 접근하려면 <code>call.parameters.getAll(&quot;param&quot;)</code>을 사용합니다. 위 예시의 경우, <code>getAll</code> 함수는 _john_과 <em>settings</em> 값을 포함하는 배열을 반환합니다.</p><h3 id="regular_expression" tabindex="-1">정규 표현식 (Regular Expression) <a class="header-anchor" href="#regular_expression" aria-label="Permalink to &quot;정규 표현식 (Regular Expression) {id=&quot;regular_expression&quot;}&quot;">​</a></h3><p>정규 표현식은 모든 라우트 핸들러 정의 함수에서 사용할 수 있습니다: <code>route</code>, <code>get</code>, <code>post</code> 등입니다.</p><blockquote><p>정규 표현식에 대해 더 자세히 알아보려면 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/" target="_blank" rel="noreferrer">Kotlin 문서</a>를 참조하세요.</p></blockquote><p><code>/hello</code>로 끝나는 모든 경로와 일치하는 라우트를 작성해 보겠습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io.ktor.server.routing.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io.ktor.server.response.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Regex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;.+/hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        call.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">respondText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 라우트 정의를 통해, <code>/hello</code>로 끝나는 경로에 대한 모든 들어오는 요청(예를 들어 <code>/foo/hello</code>, <code>/bar/baz/hello</code> 등)은 일치하게 됩니다.</p><h4 id="핸들러에서-경로-부분-접근" tabindex="-1">핸들러에서 경로 부분 접근 <a class="header-anchor" href="#핸들러에서-경로-부분-접근" aria-label="Permalink to &quot;핸들러에서 경로 부분 접근&quot;">​</a></h4><p>정규 표현식에서, 이름 있는 그룹(named groups)은 패턴과 일치하는 문자열의 특정 부분을 캡처하고 이름을 할당하는 방법입니다. <code>(?&lt;name&gt;pattern)</code> 문법은 이름 있는 그룹을 정의하는 데 사용되며, 여기서 <code>name</code>은 그룹의 이름이고 <code>pattern</code>은 그룹과 일치하는 정규 표현식 패턴입니다.</p><p>라우트 함수에서 이름 있는 그룹을 정의함으로써 경로의 일부를 캡처할 수 있으며, 그런 다음 핸들러 함수에서 <code>call.parameters</code> 객체를 사용하여 캡처된 파라미터에 접근할 수 있습니다.</p><p>예를 들어, 정수 식별자가 포함된 경로 뒤에 <code>/hello</code>가 오는 요청과 일치하는 라우트를 정의할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io.ktor.server.routing.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io.ktor.server.response.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Regex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;(?&lt;id&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">+)/hello&quot;&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> call.parameters[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        call.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">respondText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>아래 코드에서, <code>(?&lt;id&gt;\\d+)</code> 이름 있는 그룹은 요청된 경로에서 정수 식별자 <code>id</code>를 캡처하는 데 사용되며, <code>call.parameters</code> 속성은 핸들러 함수에서 캡처된 <code>id</code> 파라미터에 접근하는 데 사용됩니다.</p><p>이름 없는 그룹은 정규 표현식 라우트 핸들러 내에서 접근할 수 없지만, 경로를 일치시키는 데 사용할 수 있습니다. 예를 들어, <code>hello/world</code> 경로는 일치하지만 <code>hello/World</code>는 일치하지 않습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io.ktor.server.routing.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io.ktor.server.response.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Regex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello/([a-z]+)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        call.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">respondText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>또한, 전체 경로 세그먼트는 정규 표현식에 의해 소비되어야 합니다. 예를 들어, 경로 패턴 <code>get(Regex(&quot;[a-z]+&quot;))</code>는 <code>&quot;hello1&quot;</code> 경로와 일치하지 않지만 <code>hello/1</code> 경로의 <code>hello</code> 부분과 일치하고 <code>/1</code>을 다음 라우트를 위해 남겨둡니다.</p><h2 id="multiple_routes" tabindex="-1">여러 라우트 핸들러 정의 <a class="header-anchor" href="#multiple_routes" aria-label="Permalink to &quot;여러 라우트 핸들러 정의 {id=&quot;multiple_routes&quot;}&quot;">​</a></h2><h3 id="group_by_verb" tabindex="-1">동사 함수별로 라우트 그룹화 <a class="header-anchor" href="#group_by_verb" aria-label="Permalink to &quot;동사 함수별로 라우트 그룹화 {id=&quot;group_by_verb&quot;}&quot;">​</a></h3><p>여러 라우트 핸들러를 정의하고 싶다면 (물론 모든 애플리케이션에서 이러한 경우입니다), <code>routing</code> 함수에 추가하기만 하면 됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/customer/{id}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    post</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/customer&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/order&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/order/{id}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 경우, 각 라우트는 자체 함수를 가지며 특정 엔드포인트와 HTTP 동사에 응답합니다.</p><h3 id="group_by_path" tabindex="-1">경로별로 라우트 그룹화 <a class="header-anchor" href="#group_by_path" aria-label="Permalink to &quot;경로별로 라우트 그룹화 {id=&quot;group_by_path&quot;}&quot;">​</a></h3><p>대안적인 방법은 경로별로 그룹화하는 것으로, <code>route</code> 함수를 사용하여 경로를 정의한 다음 해당 경로에 대한 동사를 중첩 함수로 배치합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    route</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/customer&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        post</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    route</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/order&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/{id}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="nested_routes" tabindex="-1">중첩 라우트 <a class="header-anchor" href="#nested_routes" aria-label="Permalink to &quot;중첩 라우트 {id=&quot;nested_routes&quot;}&quot;">​</a></h3><p>그룹화 방식에 관계없이, Ktor는 <code>route</code> 함수의 파라미터로 하위 라우트를 가질 수 있도록 허용합니다. 이는 다른 리소스의 논리적 자식인 리소스를 정의하는 데 유용할 수 있습니다. 다음 예시는 <code>/order/shipment</code>에 대한 <code>GET</code> 및 <code>POST</code> 요청에 응답하는 방법을 보여줍니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    route</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/order&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        route</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/shipment&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            post</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>따라서 각 <code>route</code> 호출은 별도의 경로 세그먼트를 생성합니다.</p><h2 id="route_extension_function" tabindex="-1">라우트 확장 함수 <a class="header-anchor" href="#route_extension_function" aria-label="Permalink to &quot;라우트 확장 함수 {id=&quot;route_extension_function&quot;}&quot;">​</a></h2><p>일반적인 패턴은 <code>Route</code> 타입에 대한 확장 함수를 사용하여 실제 라우트를 정의하는 것입니다. 이를 통해 동사(verb)에 쉽게 접근하고 모든 라우트가 단일 라우팅 함수에 있는 복잡함을 없앨 수 있습니다. 이 패턴은 라우트를 그룹화하는 방식과 관계없이 적용할 수 있습니다. 따라서 첫 번째 예시는 더 깔끔한 방식으로 표현될 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">routing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    listOrdersRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    getOrderRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    totalizeOrderRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Route</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listOrdersRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/order&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Route</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrderRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/order/{id}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Route</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">totalizeOrderRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/order/{id}/total&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 접근 방식을 보여주는 전체 예시는 <a href="https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/legacy-interactive-website" target="_blank" rel="noreferrer">legacy-interactive-website</a>를 참조하세요.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>애플리케이션의 유지 보수성을 고려하여 확장하려면, 특정 <a href="./server-application-structure">구조화 패턴</a>을 따르는 것이 좋습니다.</p></div><h2 id="trace_routes" tabindex="-1">라우트 추적 <a class="header-anchor" href="#trace_routes" aria-label="Permalink to &quot;라우트 추적 {id=&quot;trace_routes&quot;}&quot;">​</a></h2><p><a href="./server-logging">로깅</a>이 구성된 경우, Ktor는 일부 라우트가 실행되지 않는 이유를 파악하는 데 도움이 되는 라우트 추적(route tracing)을 활성화합니다. 예를 들어, 애플리케이션을 <a href="./server-run">실행</a>하고 지정된 엔드포인트로 요청을 보내면, 애플리케이션의 출력은 다음과 같을 수 있습니다:</p><div class="language-Console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TRACE Application - Trace for [missing-page]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">/, segment:0 -&gt; SUCCESS @ /</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  /, segment:0 -&gt; SUCCESS @ /</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    /(method:GET), segment:0 -&gt; FAILURE &quot;Not all segments matched&quot; @ /(method:GET)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Matched routes:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  No results</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Route resolve result:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  FAILURE &quot;No matched subtrees found&quot; @ /</span></span></code></pre></div><blockquote><p><a href="./server-native">네이티브 서버</a>에서 라우트 추적을 활성화하려면, 애플리케이션을 <a href="./server-run">실행</a>할 때 <code>KTOR_LOG_LEVEL</code> 환경 변수에 <em>TRACE</em> 값을 전달하세요.</p></blockquote>`,67))])}const q=p(c,[["render",E]]);export{b as __pageData,q as default};
