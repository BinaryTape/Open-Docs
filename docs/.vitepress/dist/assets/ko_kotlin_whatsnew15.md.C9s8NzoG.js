import{_ as r,C as k,c as o,o as d,ag as e,G as t,w as n,j as i,a}from"./chunks/framework.Bksy39di.js";const f=JSON.parse('{"title":"Kotlin 1.5.0의 새로운 기능","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/whatsnew15.md","filePath":"ko/kotlin/whatsnew15.md","lastUpdated":1754307826000}'),c={name:"ko/kotlin/whatsnew15.md"};function g(E,s,y,u,F,b){const l=k("YouTubeVideo"),h=k("tab"),p=k("tabs");return d(),o("div",null,[s[4]||(s[4]=e(`<h1 id="kotlin-1-5-0의-새로운-기능" tabindex="-1">Kotlin 1.5.0의 새로운 기능 <a class="header-anchor" href="#kotlin-1-5-0의-새로운-기능" aria-label="Permalink to &quot;Kotlin 1.5.0의 새로운 기능&quot;">​</a></h1><p><em><a href="/ko/kotlin/releases#release-details">출시일: 2021년 5월 5일</a></em></p><p>Kotlin 1.5.0은 새로운 언어 기능, 안정적인 IR 기반 JVM 컴파일러 백엔드, 성능 개선, 그리고 실험적 기능 안정화 및 오래된 기능 사용 중단과 같은 발전적인 변화를 도입합니다.</p><p>변경 사항에 대한 개요는 <a href="https://blog.jetbrains.com/kotlin/2021/04/kotlin-1-5-0-released/" target="_blank" rel="noreferrer">릴리스 블로그 게시물</a>에서도 확인할 수 있습니다.</p><h2 id="언어-기능" tabindex="-1">언어 기능 <a class="header-anchor" href="#언어-기능" aria-label="Permalink to &quot;언어 기능&quot;">​</a></h2><p>Kotlin 1.5.0은 <a href="/ko/kotlin/whatsnew1430#language-features">1.4.30 미리 보기</a>에서 소개되었던 새로운 언어 기능의 안정화 버전을 제공합니다:</p><ul><li><a href="#jvm-records-support">JVM 레코드 지원</a></li><li><a href="#sealed-interfaces">Sealed 인터페이스</a> 및 <a href="#package-wide-sealed-class-hierarchies">sealed 클래스 개선</a></li><li><a href="#inline-classes">Inline 클래스</a></li></ul><p>이러한 기능에 대한 자세한 설명은 <a href="https://blog.jetbrains.com/kotlin/2021/02/new-language-features-preview-in-kotlin-1-4-30/" target="_blank" rel="noreferrer">이 블로그 게시물</a>과 Kotlin 문서의 해당 페이지에서 확인할 수 있습니다.</p><h3 id="jvm-레코드-지원" tabindex="-1">JVM 레코드 지원 <a class="header-anchor" href="#jvm-레코드-지원" aria-label="Permalink to &quot;JVM 레코드 지원&quot;">​</a></h3><p>자바는 빠르게 발전하고 있으며, 코틀린이 자바와 상호 운용성을 유지하도록 보장하기 위해 최신 기능 중 하나인 <a href="https://openjdk.java.net/jeps/395" target="_blank" rel="noreferrer">레코드 클래스</a>에 대한 지원을 도입했습니다.</p><p>코틀린의 JVM 레코드 지원에는 양방향 상호 운용성이 포함됩니다:</p><ul><li>코틀린 코드에서 자바 레코드 클래스를 속성을 가진 일반 클래스처럼 사용할 수 있습니다.</li><li>코틀린 클래스를 자바 코드에서 레코드로 사용하려면, <code>data</code> 클래스로 만들고 <code>@JvmRecord</code> 어노테이션을 붙이세요.</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmRecord</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><a href="/ko/kotlin/jvm-records">코틀린에서 JVM 레코드 사용에 대해 자세히 알아보기</a>.</p>`,14)),t(l,{src:"https://www.youtube.com/v/iyEWXyuuseU",title:"Kotlin 1.5.0의 JVM 레코드 지원"}),s[5]||(s[5]=e(`<h3 id="sealed-인터페이스" tabindex="-1">Sealed 인터페이스 <a class="header-anchor" href="#sealed-인터페이스" aria-label="Permalink to &quot;Sealed 인터페이스&quot;">​</a></h3><p>이제 코틀린 인터페이스에 <code>sealed</code> 한정자를 사용할 수 있습니다. 이는 클래스에 작동하는 방식과 동일하게 인터페이스에도 작동합니다: sealed 인터페이스의 모든 구현은 컴파일 시점에 알려집니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Polygon</span></span></code></pre></div><p>예를 들어, 이 사실을 활용하여 모든 경우를 다루는 <code>when</code> 표현식을 작성할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> draw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(polygon: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Polygon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (polygon) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Rectangle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Triangle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // else는 필요하지 않습니다 - 가능한 모든 구현이 포함됩니다</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>또한 sealed 인터페이스는 클래스가 하나 이상의 sealed 인터페이스를 직접 상속할 수 있으므로, 더 유연한 제한된 클래스 계층 구조를 가능하게 합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FilledRectangle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Polygon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Fillable</span></span></code></pre></div><p><a href="/ko/kotlin/sealed-classes">sealed 인터페이스에 대해 자세히 알아보기</a>.</p>`,8)),t(l,{src:"https://www.youtube.com/v/d_Mor21W_60",title:"Sealed 인터페이스 및 Sealed 클래스 개선"}),s[6]||(s[6]=e(`<h3 id="패키지-전체의-sealed-클래스-계층-구조" tabindex="-1">패키지 전체의 sealed 클래스 계층 구조 <a class="header-anchor" href="#패키지-전체의-sealed-클래스-계층-구조" aria-label="Permalink to &quot;패키지 전체의 sealed 클래스 계층 구조&quot;">​</a></h3><p>이제 sealed 클래스는 동일한 컴파일 단위 및 동일한 패키지의 모든 파일에 서브클래스를 가질 수 있습니다. 이전에는 모든 서브클래스가 동일한 파일에 있어야 했습니다.</p><p>직접적인 서브클래스는 최상위이거나 다른 이름이 지정된 클래스, 이름이 지정된 인터페이스 또는 이름이 지정된 객체 내부에 중첩될 수 있습니다.</p><p>sealed 클래스의 서브클래스는 적절하게 한정된 이름을 가져야 합니다 – 로컬 또는 익명 객체일 수 없습니다.</p><p><a href="/ko/kotlin/sealed-classes#inheritance">sealed 클래스 계층 구조에 대해 자세히 알아보기</a>.</p><h3 id="inline-클래스" tabindex="-1">Inline 클래스 <a class="header-anchor" href="#inline-클래스" aria-label="Permalink to &quot;Inline 클래스&quot;">​</a></h3><p>Inline 클래스는 값만 포함하는 <a href="https://github.com/Kotlin/KEEP/blob/master/notes/value-classes.md" target="_blank" rel="noreferrer">값 기반</a> 클래스의 하위 집합입니다. 메모리 할당으로 인한 추가 오버헤드 없이 특정 타입의 값을 위한 래퍼로 사용할 수 있습니다.</p><p>Inline 클래스는 클래스 이름 앞에 <code>value</code> 한정자를 사용하여 선언할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Password</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>JVM 백엔드는 특별한 <code>@JvmInline</code> 어노테이션도 필요로 합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmInline</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Password</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><code>inline</code> 한정자는 이제 경고와 함께 사용 중단(deprecated)되었습니다.</p><p><a href="/ko/kotlin/inline-classes">inline 클래스에 대해 자세히 알아보기</a>.</p>`,13)),t(l,{src:"https://www.youtube.com/v/LpqvtgibbsQ",title:"Inline 클래스에서 Value 클래스로"}),s[7]||(s[7]=e('<h2 id="kotlin-jvm" tabindex="-1">Kotlin/JVM <a class="header-anchor" href="#kotlin-jvm" aria-label="Permalink to &quot;Kotlin/JVM&quot;">​</a></h2><p>Kotlin/JVM은 내부 및 사용자 관련 측면에서 여러 개선 사항을 받았습니다. 그중 가장 주목할 만한 사항은 다음과 같습니다:</p><ul><li><a href="#stable-jvm-ir-backend">안정적인 JVM IR 백엔드</a></li><li><a href="#new-default-jvm-target-1-8">새로운 기본 JVM 대상: 1.8</a></li><li><a href="#sam-adapters-via-invokedynamic">invokedynamic을 통한 SAM 어댑터</a></li><li><a href="#lambdas-via-invokedynamic">invokedynamic을 통한 람다</a></li><li><a href="#deprecation-of-jvmdefault-and-old-xjvm-default-modes">@JvmDefault 및 이전 Xjvm-default 모드 사용 중단</a></li><li><a href="#improvements-to-handling-nullability-annotations">Nullability 어노테이션 처리 개선</a></li></ul><h3 id="안정적인-jvm-ir-백엔드" tabindex="-1">안정적인 JVM IR 백엔드 <a class="header-anchor" href="#안정적인-jvm-ir-백엔드" aria-label="Permalink to &quot;안정적인 JVM IR 백엔드&quot;">​</a></h3><p>Kotlin/JVM 컴파일러용 <a href="/ko/kotlin/whatsnew14#new-jvm-ir-backend">IR 기반 백엔드</a>가 이제 <a href="/ko/kotlin/components-stability">안정화</a>되었으며 기본적으로 활성화됩니다.</p><p><a href="/ko/kotlin/whatsnew14">Kotlin 1.4.0</a>부터 IR 기반 백엔드의 초기 버전은 미리 보기로 제공되었으며, 이제 언어 버전 <code>1.5</code>의 기본값이 되었습니다. 이전 백엔드는 이전 언어 버전에서 여전히 기본적으로 사용됩니다.</p><p>IR 백엔드의 이점과 향후 개발에 대한 자세한 내용은 <a href="https://blog.jetbrains.com/kotlin/2021/02/the-jvm-backend-is-in-beta-let-s-make-it-stable-together/" target="_blank" rel="noreferrer">이 블로그 게시물</a>에서 확인할 수 있습니다.</p><p>Kotlin 1.5.0에서 이전 백엔드를 사용해야 하는 경우, 프로젝트의 설정 파일에 다음 줄을 추가할 수 있습니다:</p><ul><li>Gradle에서:</li></ul>',9)),t(p,{group:"build-script"},{default:n(()=>[t(h,{title:"Kotlin","group-key":"kotlin"},{default:n(()=>s[0]||(s[0]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"tasks."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"withType"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"org"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"jetbrains"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"gradle"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"dsl"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"KotlinJvmCompile"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"> {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"  kotlinOptions.useOldBackend "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," true")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),t(h,{title:"Groovy","group-key":"groovy"},{default:n(()=>s[1]||(s[1]=[i("div",{class:"language-groovy vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"groovy"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"tasks"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"withType("),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"org.jetbrains.kotlin.gradle.dsl.KotlinJvmCompile"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," kotlinOptions"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"useOldBackend "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," true")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),s[8]||(s[8]=e(`<ul><li>Maven에서:</li></ul><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">configuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;-Xuse-old-backend&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">configuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="새로운-기본-jvm-대상-1-8" tabindex="-1">새로운 기본 JVM 대상: 1.8 <a class="header-anchor" href="#새로운-기본-jvm-대상-1-8" aria-label="Permalink to &quot;새로운 기본 JVM 대상: 1.8&quot;">​</a></h3><p>Kotlin/JVM 컴파일의 기본 대상 버전은 이제 <code>1.8</code>입니다. <code>1.6</code> 대상은 사용 중단되었습니다.</p><p>JVM 1.6용 빌드가 필요한 경우, 여전히 이 대상으로 전환할 수 있습니다. 방법 알아보기:</p><ul><li><a href="/ko/kotlin/gradle-compiler-options#attributes-specific-to-jvm">Gradle에서</a></li><li><a href="/ko/kotlin/maven#attributes-specific-to-jvm">Maven에서</a></li><li><a href="/ko/kotlin/compiler-reference#jvm-target-version">명령줄 컴파일러에서</a></li></ul><h3 id="invokedynamic을-통한-sam-어댑터" tabindex="-1">invokedynamic을 통한 SAM 어댑터 <a class="header-anchor" href="#invokedynamic을-통한-sam-어댑터" aria-label="Permalink to &quot;invokedynamic을 통한 SAM 어댑터&quot;">​</a></h3><p>Kotlin 1.5.0은 이제 SAM(Single Abstract Method) 변환 컴파일을 위해 동적 호출(<code>invokedynamic</code>)을 사용합니다:</p><ul><li>SAM 타입이 <a href="/ko/kotlin/java-interop#sam-conversions">자바 인터페이스</a>인 경우 모든 표현식에서</li><li>SAM 타입이 <a href="/ko/kotlin/fun-interfaces#sam-conversions">코틀린 함수형 인터페이스</a>인 경우 람다에서</li></ul><p>새로운 구현은 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html#metafactory-java.lang.invoke.MethodHandles.Lookup-java.lang.String-java.lang.invoke.MethodType-java.lang.invoke.MethodType-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-" target="_blank" rel="noreferrer"><code>LambdaMetafactory.metafactory()</code></a>를 사용하며, 컴파일 중에 보조 래퍼 클래스가 더 이상 생성되지 않습니다. 이는 애플리케이션 JAR의 크기를 줄여 JVM 시작 성능을 향상시킵니다.</p><p>익명 클래스 생성에 기반한 이전 구현 방식으로 되돌리려면, 컴파일러 옵션 <code>-Xsam-conversions=class</code>를 추가하세요.</p><p><a href="/ko/kotlin/gradle-compiler-options">Gradle</a>, <a href="/ko/kotlin/maven#specify-compiler-options">Maven</a>, 및 <a href="/ko/kotlin/compiler-reference#compiler-options">명령줄 컴파일러</a>에서 컴파일러 옵션을 추가하는 방법을 알아보세요.</p><h3 id="invokedynamic을-통한-람다" tabindex="-1">invokedynamic을 통한 람다 <a class="header-anchor" href="#invokedynamic을-통한-람다" aria-label="Permalink to &quot;invokedynamic을 통한 람다&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>일반 Kotlin 람다를 invokedynamic으로 컴파일하는 기능은 <a href="/ko/kotlin/components-stability">실험적</a>입니다. 언제든지 중단되거나 변경될 수 있습니다. 옵트인(자세한 내용은 아래 참조)이 필요하며, 평가 목적으로만 사용해야 합니다. <a href="https://youtrack.jetbrains.com/issue/KT-45375" target="_blank" rel="noreferrer">YouTrack</a>에 피드백을 주시면 감사하겠습니다.</p></div><p>Kotlin 1.5.0은 일반 코틀린 람다(함수형 인터페이스 인스턴스로 변환되지 않은)를 동적 호출(<code>invokedynamic</code>)로 컴파일하는 실험적 지원을 도입합니다. 이 구현은 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html#metafactory-java.lang.invoke.MethodHandles.Lookup-java.lang.String-java.lang.invoke.MethodType-java.lang.invoke.MethodType-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-" target="_blank" rel="noreferrer"><code>LambdaMetafactory.metafactory()</code></a>를 사용하여 더 가벼운 바이너리를 생성하며, 이는 런타임에 필요한 클래스를 효과적으로 생성합니다. 현재, 일반 람다 컴파일과 비교하여 세 가지 제한 사항이 있습니다:</p><ul><li>invokedynamic으로 컴파일된 람다는 직렬화할 수 없습니다.</li><li>이러한 람다에 <code>toString()</code>을 호출하면 가독성이 떨어지는 문자열 표현이 생성됩니다.</li><li>실험적인 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect.jvm/reflect.html" target="_blank" rel="noreferrer"><code>reflect</code></a> API는 <code>LambdaMetafactory</code>로 생성된 람다를 지원하지 않습니다.</li></ul><p>이 기능을 사용해 보려면 <code>-Xlambdas=indy</code> 컴파일러 옵션을 추가하세요. 이 <a href="https://youtrack.jetbrains.com/issue/KT-45375" target="_blank" rel="noreferrer">YouTrack 티켓</a>을 사용하여 피드백을 공유해 주시면 감사하겠습니다.</p><p><a href="/ko/kotlin/gradle-compiler-options">Gradle</a>, <a href="/ko/kotlin/maven#specify-compiler-options">Maven</a>, 및 <a href="/ko/kotlin/compiler-reference#compiler-options">명령줄 컴파일러</a>에서 컴파일러 옵션을 추가하는 방법을 알아보세요.</p><h3 id="jvmdefault-및-이전-xjvm-default-모드-사용-중단" tabindex="-1">@JvmDefault 및 이전 Xjvm-default 모드 사용 중단 <a class="header-anchor" href="#jvmdefault-및-이전-xjvm-default-모드-사용-중단" aria-label="Permalink to &quot;@JvmDefault 및 이전 Xjvm-default 모드 사용 중단&quot;">​</a></h3><p>Kotlin 1.4.0 이전에는 <code>@JvmDefault</code> 어노테이션과 <code>-Xjvm-default=enable</code> 및 <code>-Xjvm-default=compatibility</code> 모드가 있었습니다. 이들은 Kotlin 인터페이스의 특정 비추상 멤버에 대한 JVM 기본 메서드를 생성하는 역할을 했습니다.</p><p>Kotlin 1.4.0에서 우리는 전체 프로젝트에 대한 기본 메서드 생성을 켜는 <a href="https://blog.jetbrains.com/kotlin/2020/07/kotlin-1-4-m3-generating-default-methods-in-interfaces/" target="_blank" rel="noreferrer">새로운 <code>Xjvm-default</code> 모드</a>를 도입했습니다.</p><p>Kotlin 1.5.0에서는 <code>@JvmDefault</code>와 이전 Xjvm-default 모드(<code>-Xjvm-default=enable</code> 및 <code>-Xjvm-default=compatibility</code>)를 사용 중단합니다.</p><p><a href="/ko/kotlin/java-to-kotlin-interop#default-methods-in-interfaces">자바 상호 운용성의 기본 메서드에 대해 자세히 알아보기</a>.</p><h3 id="nullability-어노테이션-처리-개선" tabindex="-1">Nullability 어노테이션 처리 개선 <a class="header-anchor" href="#nullability-어노테이션-처리-개선" aria-label="Permalink to &quot;Nullability 어노테이션 처리 개선&quot;">​</a></h3><p>코틀린은 <a href="/ko/kotlin/java-interop#nullability-annotations">nullability 어노테이션</a>을 통해 자바의 타입 nullability 정보를 처리하는 것을 지원합니다. Kotlin 1.5.0은 이 기능에 대한 여러 개선 사항을 도입합니다:</p><ul><li>의존성으로 사용되는 컴파일된 자바 라이브러리에서 타입 인수에 대한 nullability 어노테이션을 읽습니다.</li><li>다음 항목에 대해 <code>TYPE_USE</code> 대상을 가진 nullability 어노테이션을 지원합니다: <ul><li>배열</li><li>가변 인자(Varargs)</li><li>필드</li><li>타입 파라미터 및 그 경계(bounds)</li><li>기본 클래스 및 인터페이스의 타입 인수</li></ul></li><li>nullability 어노테이션이 타입에 적용 가능한 여러 대상을 가지고 있고, 이 대상 중 하나가 <code>TYPE_USE</code>인 경우, <code>TYPE_USE</code>가 선호됩니다. 예를 들어, <code>@Nullable</code>이 <code>TYPE_USE</code>와 <code>METHOD</code>를 모두 대상으로 지원하는 경우, 메서드 시그니처 <code>@Nullable String[] f()</code>는 <code>fun f(): Array&lt;String?&gt;!</code>이 됩니다.</li></ul><p>새롭게 지원되는 이러한 경우에 대해, 코틀린에서 자바를 호출할 때 잘못된 타입 nullability를 사용하면 경고가 발생합니다. 이러한 경우에 대한 엄격 모드(오류 보고 포함)를 활성화하려면 <code>-Xtype-enhancement-improvements-strict-mode</code> 컴파일러 옵션을 사용하세요.</p><p><a href="/ko/kotlin/java-interop#null-safety-and-platform-types">null 안전성 및 플랫폼 타입에 대해 자세히 알아보기</a>.</p><h2 id="kotlin-native" tabindex="-1">Kotlin/Native <a class="header-anchor" href="#kotlin-native" aria-label="Permalink to &quot;Kotlin/Native&quot;">​</a></h2><p>Kotlin/Native가 이제 더 나은 성능과 안정성을 제공합니다. 주목할 만한 변경 사항은 다음과 같습니다:</p><ul><li><a href="#performance-improvements">성능 개선</a></li><li><a href="#deactivation-of-the-memory-leak-checker">메모리 누수 검사기 비활성화</a></li></ul><h3 id="성능-개선" tabindex="-1">성능 개선 <a class="header-anchor" href="#성능-개선" aria-label="Permalink to &quot;성능 개선&quot;">​</a></h3><p>1.5.0에서 Kotlin/Native는 컴파일과 실행 속도를 모두 향상시키는 일련의 성능 개선 사항을 받았습니다.</p><p><a href="https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-3-70-released/#kotlin-native" target="_blank" rel="noreferrer">컴파일러 캐시</a>는 이제 <code>linuxX64</code>(Linux 호스트에서만) 및 <code>iosArm64</code> 대상의 디버그 모드에서 지원됩니다. 컴파일러 캐시를 활성화하면 첫 컴파일을 제외하고 대부분의 디버그 컴파일이 훨씬 빠르게 완료됩니다. 측정 결과, 테스트 프로젝트에서 약 200%의 속도 향상이 나타났습니다.</p><p>새로운 대상에 컴파일러 캐시를 사용하려면, 프로젝트의 <code>gradle.properties</code>에 다음 줄을 추가하여 옵트인하세요:</p><ul><li><code>linuxX64</code>용: <code>kotlin.native.cacheKind.linuxX64=static</code></li><li><code>iosArm64</code>용: <code>kotlin.native.cacheKind.iosArm64=static</code></li></ul><p>컴파일러 캐시를 활성화한 후 문제가 발생하는 경우, 이슈 트래커인 <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack</a>에 보고해 주세요.</p><p>다른 개선 사항은 Kotlin/Native 코드 실행 속도를 높입니다:</p><ul><li>사소한 속성 접근자는 인라인 처리됩니다.</li><li>문자열 리터럴에 대한 <code>trimIndent()</code>는 컴파일 중에 평가됩니다.</li></ul><h3 id="메모리-누수-검사기-비활성화" tabindex="-1">메모리 누수 검사기 비활성화 <a class="header-anchor" href="#메모리-누수-검사기-비활성화" aria-label="Permalink to &quot;메모리 누수 검사기 비활성화&quot;">​</a></h3><p>내장된 Kotlin/Native 메모리 누수 검사기가 기본적으로 비활성화되었습니다.</p><p>이 검사기는 원래 내부 사용을 위해 설계되었으며, 모든 경우의 누수를 찾는 것이 아니라 제한된 수의 경우에만 누수를 찾을 수 있습니다. 또한 나중에 애플리케이션 충돌을 유발할 수 있는 문제가 있는 것으로 밝혀졌습니다. 따라서 메모리 누수 검사기를 끄기로 결정했습니다.</p><p>메모리 누수 검사기는 여전히 특정 경우, 예를 들어 단위 테스트에 유용할 수 있습니다. 이러한 경우를 위해 다음 코드 줄을 추가하여 활성화할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Platform.isMemoryLeakCheckerActive </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span></code></pre></div><p>애플리케이션 런타임에 검사기를 활성화하는 것은 권장되지 않습니다.</p><h2 id="kotlin-js" tabindex="-1">Kotlin/JS <a class="header-anchor" href="#kotlin-js" aria-label="Permalink to &quot;Kotlin/JS&quot;">​</a></h2><p>Kotlin/JS는 1.5.0에서 발전적인 변화를 받고 있습니다. 우리는 <a href="/ko/kotlin/js-ir-compiler">JS IR 컴파일러 백엔드</a>를 안정화시키고 다른 업데이트를 제공하기 위한 작업을 계속하고 있습니다:</p><ul><li><a href="#upgrade-to-webpack-5">webpack 5 버전으로 업그레이드</a></li><li><a href="#frameworks-and-libraries-for-the-ir-compiler">IR 컴파일러를 위한 프레임워크 및 라이브러리</a></li></ul><h3 id="webpack-5로-업그레이드" tabindex="-1">webpack 5로 업그레이드 <a class="header-anchor" href="#webpack-5로-업그레이드" aria-label="Permalink to &quot;webpack 5로 업그레이드&quot;">​</a></h3><p>Kotlin/JS Gradle 플러그인은 이제 webpack 4 대신 브라우저 대상에 webpack 5를 사용합니다. 이는 호환되지 않는 변경 사항을 가져오는 주요 webpack 업그레이드입니다. 사용자 지정 webpack 설정을 사용하는 경우, <a href="https://webpack.js.org/blog/2020-10-10-webpack-5-release/" target="_blank" rel="noreferrer">webpack 5 릴리스 노트</a>를 확인하세요.</p><p><a href="/ko/kotlin/js-project-setup#webpack-bundling">webpack을 사용하여 Kotlin/JS 프로젝트 번들링에 대해 자세히 알아보기</a>.</p><h3 id="ir-컴파일러를-위한-프레임워크-및-라이브러리" tabindex="-1">IR 컴파일러를 위한 프레임워크 및 라이브러리 <a class="header-anchor" href="#ir-컴파일러를-위한-프레임워크-및-라이브러리" aria-label="Permalink to &quot;IR 컴파일러를 위한 프레임워크 및 라이브러리&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>Kotlin/JS IR 컴파일러는 <a href="/ko/kotlin/components-stability">알파</a> 버전입니다. 향후 호환되지 않게 변경될 수 있으며 수동 마이그레이션이 필요할 수 있습니다. <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a>에 피드백을 주시면 감사하겠습니다.</p></div><p>Kotlin/JS 컴파일러용 IR 기반 백엔드 작업과 더불어, 라이브러리 개발자들이 <code>both</code> 모드로 프로젝트를 빌드하도록 권장하고 돕고 있습니다. 이는 두 가지 Kotlin/JS 컴파일러 모두를 위한 아티팩트를 생성할 수 있어 새로운 컴파일러의 생태계를 성장시키는 데 기여합니다.</p><p>많은 잘 알려진 프레임워크와 라이브러리가 이미 IR 백엔드에서 사용할 수 있습니다: <a href="https://kvision.io/" target="_blank" rel="noreferrer">KVision</a>, <a href="https://www.fritz2.dev/" target="_blank" rel="noreferrer">fritz2</a>, <a href="https://github.com/nacular/doodle" target="_blank" rel="noreferrer">doodle</a> 등이 있습니다. 프로젝트에서 이를 사용하고 있다면, 이미 IR 백엔드로 빌드하고 그 이점을 경험할 수 있습니다.</p><p>자신만의 라이브러리를 작성하고 있다면, 클라이언트도 새로운 컴파일러와 함께 사용할 수 있도록 <a href="/ko/kotlin/js-ir-compiler#authoring-libraries-for-the-ir-compiler-with-backwards-compatibility">‘both’ 모드로 컴파일</a>하세요.</p><h2 id="kotlin-multiplatform" tabindex="-1">Kotlin Multiplatform <a class="header-anchor" href="#kotlin-multiplatform" aria-label="Permalink to &quot;Kotlin Multiplatform&quot;">​</a></h2><p>Kotlin 1.5.0에서는 <a href="#simplified-test-dependencies-usage-in-multiplatform-projects">각 플랫폼에 대한 테스트 의존성을 선택하는 과정이 간소화</a>되었으며, 이제 Gradle 플러그인이 자동으로 처리합니다.</p><p><a href="#new-api-for-getting-a-char-category-now-available-in-multiplatform-code">문자 카테고리를 가져오는 새로운 API</a>가 이제 멀티플랫폼 프로젝트에서 사용할 수 있습니다.</p><h2 id="표준-라이브러리" tabindex="-1">표준 라이브러리 <a class="header-anchor" href="#표준-라이브러리" aria-label="Permalink to &quot;표준 라이브러리&quot;">​</a></h2><p>표준 라이브러리는 실험적 부분의 안정화부터 새로운 기능 추가에 이르기까지 다양한 변경 및 개선 사항을 받았습니다:</p><ul><li><a href="#stable-unsigned-integer-types">안정적인 부호 없는 정수 타입</a></li><li><a href="#stable-locale-agnostic-api-for-upper-lowercasing-text">대/소문자 변환을 위한 안정적인 로케일 독립적 API</a></li><li><a href="#stable-char-to-integer-conversion-api">안정적인 문자-정수 변환 API</a></li><li><a href="#stable-path-api">안정적인 Path API</a></li><li><a href="#floored-division-and-the-mod-operator">내림 나눗셈 및 나머지 연산자</a></li><li><a href="#duration-api-changes">Duration API 변경 사항</a></li><li><a href="#new-api-for-getting-a-char-category-now-available-in-multiplatform-code">문자 카테고리를 가져오는 새로운 API, 이제 멀티플랫폼 코드에서 사용 가능</a></li><li><a href="#new-collections-function-firstnotnullof">새로운 컬렉션 함수 firstNotNullOf()</a></li><li><a href="#strict-version-of-string-toboolean">String?.toBoolean()의 엄격 버전</a></li></ul><p>표준 라이브러리 변경 사항에 대한 자세한 내용은 <a href="https://blog.jetbrains.com/kotlin/2021/04/kotlin-1-5-0-rc-released/" target="_blank" rel="noreferrer">이 블로그 게시물</a>에서 확인할 수 있습니다.</p>`,63)),t(l,{src:"https://www.youtube.com/v/MyTkiT2I6-8",title:"새로운 표준 라이브러리 기능"}),s[9]||(s[9]=e(`<h3 id="안정적인-부호-없는-정수-타입" tabindex="-1">안정적인 부호 없는 정수 타입 <a class="header-anchor" href="#안정적인-부호-없는-정수-타입" aria-label="Permalink to &quot;안정적인 부호 없는 정수 타입&quot;">​</a></h3><p><code>UInt</code>, <code>ULong</code>, <code>UByte</code>, <code>UShort</code> 부호 없는 정수 타입이 이제 <a href="/ko/kotlin/components-stability">안정화</a>되었습니다. 이러한 타입에 대한 연산, 범위, 그리고 진행(progression)도 마찬가지입니다. 부호 없는 배열과 그에 대한 연산은 베타 상태로 남아 있습니다.</p><p><a href="/ko/kotlin/unsigned-integer-types">부호 없는 정수 타입에 대해 자세히 알아보기</a>.</p><h3 id="대-소문자-변환을-위한-안정적인-로케일-독립적-api" tabindex="-1">대/소문자 변환을 위한 안정적인 로케일 독립적 API <a class="header-anchor" href="#대-소문자-변환을-위한-안정적인-로케일-독립적-api" aria-label="Permalink to &quot;대/소문자 변환을 위한 안정적인 로케일 독립적 API&quot;">​</a></h3><p>이번 릴리스에서는 대/소문자 텍스트 변환을 위한 새로운 로케일 독립적 API를 제공합니다. 이는 로케일 민감성이 있는 <code>toLowerCase()</code>, <code>toUpperCase()</code>, <code>capitalize()</code>, <code>decapitalize()</code> API 함수에 대한 대안을 제공합니다. 새로운 API는 다른 로케일 설정으로 인한 오류를 방지하는 데 도움이 됩니다.</p><p>Kotlin 1.5.0은 다음의 완전히 <a href="/ko/kotlin/components-stability">안정적인</a> 대안을 제공합니다:</p><ul><li><p><code>String</code> 함수용:</p><table tabindex="0"><thead><tr><th><strong>이전 버전</strong></th><th><strong>1.5.0 대안</strong></th></tr></thead><tbody><tr><td><code>String.toUpperCase()</code></td><td><code>String.uppercase()</code></td></tr><tr><td><code>String.toLowerCase()</code></td><td><code>String.lowercase()</code></td></tr><tr><td><code>String.capitalize()</code></td><td><code>String.replaceFirstChar { it.uppercase() }</code></td></tr><tr><td><code>String.decapitalize()</code></td><td><code>String.replaceFirstChar { it.lowercase() }</code></td></tr></tbody></table></li><li><p><code>Char</code> 함수용:</p><table tabindex="0"><thead><tr><th><strong>이전 버전</strong></th><th><strong>1.5.0 대안</strong></th></tr></thead><tbody><tr><td><code>Char.toUpperCase()</code></td><td><code>Char.uppercaseChar(): Char</code><br><code>Char.uppercase(): String</code></td></tr><tr><td><code>Char.toLowerCase()</code></td><td><code>Char.lowercaseChar(): Char</code><br><code>Char.lowercase(): String</code></td></tr><tr><td><code>Char.toTitleCase()</code></td><td><code>Char.titlecaseChar(): Char</code><br><code>Char.titlecase(): String</code></td></tr></tbody></table></li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Kotlin/JVM의 경우, 명시적인 <code>Locale</code> 파라미터를 가진 오버로드된 <code>uppercase()</code>, <code>lowercase()</code>, <code>titlecase()</code> 함수도 있습니다.</p></div><p>이전 API 함수는 사용 중단(deprecated)으로 표시되었으며 향후 릴리스에서 제거될 예정입니다.</p><p>텍스트 처리 함수의 전체 변경 목록은 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/locale-agnostic-case-conversions.md" target="_blank" rel="noreferrer">KEEP</a>에서 확인하세요.</p><h3 id="안정적인-문자-정수-변환-api" tabindex="-1">안정적인 문자-정수 변환 API <a class="header-anchor" href="#안정적인-문자-정수-변환-api" aria-label="Permalink to &quot;안정적인 문자-정수 변환 API&quot;">​</a></h3><p>Kotlin 1.5.0부터 새로운 문자-코드 및 문자-숫자 변환 함수가 <a href="/ko/kotlin/components-stability">안정화</a>되었습니다. 이 함수들은 유사한 문자열-Int 변환과 혼동되는 경우가 많았던 현재 API 함수들을 대체합니다.</p><p>새로운 API는 이러한 명칭 혼동을 없애고, 코드 동작을 더 투명하고 명확하게 만듭니다.</p><p>이번 릴리스에서는 명확하게 명명된 다음 함수 집합으로 나뉜 <code>Char</code> 변환을 도입합니다:</p><ul><li><code>Char</code>의 정수 코드를 가져오고 주어진 코드에서 <code>Char</code>를 구성하는 함수:</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(code: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Char</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(code: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UShort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Char</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Char.code: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span></span></code></pre></div><ul><li><code>Char</code>를 나타내는 숫자의 값으로 변환하는 함수:</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">digitToInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radix: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">digitToIntOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radix: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?</span></span></code></pre></div><ul><li><code>Int</code>의 확장 함수로, 나타내는 음이 아닌 한 자리 숫자를 해당 <code>Char</code> 표현으로 변환합니다:</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">digitToChar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radix: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Char</span></span></code></pre></div><p><code>Number.toChar()</code>의 구현( <code>Int.toChar()</code> 제외)을 포함한 이전 변환 API와 <code>Char.toInt()</code>와 같은 숫자 타입으로의 변환을 위한 <code>Char</code> 확장 함수는 이제 사용 중단되었습니다.</p><p><a href="https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/char-int-conversions.md" target="_blank" rel="noreferrer">KEEP에서 문자-정수 변환 API에 대해 자세히 알아보기</a>.</p><h3 id="내림-나눗셈-및-나머지-연산자" tabindex="-1">내림 나눗셈 및 나머지 연산자 <a class="header-anchor" href="#내림-나눗셈-및-나머지-연산자" aria-label="Permalink to &quot;내림 나눗셈 및 나머지 연산자&quot;">​</a></h3><p>표준 라이브러리에 모듈러 산술을 위한 새로운 연산이 추가되었습니다:</p><ul><li><code>floorDiv()</code>는 <a href="https://en.wikipedia.org/wiki/Floor_and_ceiling_functions" target="_blank" rel="noreferrer">내림 나눗셈</a>의 결과를 반환합니다. 이는 정수 타입에서 사용할 수 있습니다.</li><li><code>mod()</code>는 내림 나눗셈의 나머지(<em>모듈러스</em>)를 반환합니다. 이는 모든 숫자 타입에서 사용할 수 있습니다.</li></ul><p>이러한 연산은 기존 <a href="/ko/kotlin/numbers#operations-on-numbers">정수 나눗셈</a> 및 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/rem.html" target="_blank" rel="noreferrer">rem()</a> 함수(또는 <code>%</code> 연산자)와 매우 유사하게 보이지만, 음수에서 다르게 작동합니다:</p><ul><li><code>a.floorDiv(b)</code>는 <code>floorDiv</code>가 결과를 내림(더 작은 정수 방향으로)하는 반면, 일반 <code>/</code>는 결과를 0에 더 가까운 정수로 자른다는 점에서 일반 <code>/</code>와 다릅니다.</li><li><code>a.mod(b)</code>는 <code>a</code>와 <code>a.floorDiv(b) * b</code>의 차이입니다. 결과는 0이거나 <code>b</code>와 같은 부호를 가집니다. 반면 <code>a % b</code>는 다른 부호를 가질 수 있습니다.</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;내림 나눗셈 -5/3: \${(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floorDiv</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;나머지: \${(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mod</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;절삭 나눗셈 -5/3: \${</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;나머지: \${</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> %</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="duration-api-변경-사항" tabindex="-1">Duration API 변경 사항 <a class="header-anchor" href="#duration-api-변경-사항" aria-label="Permalink to &quot;Duration API 변경 사항&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>Duration API는 <a href="/ko/kotlin/components-stability">실험적</a>입니다. 언제든지 중단되거나 변경될 수 있습니다. 평가 목적으로만 사용하세요. <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a>에 피드백을 주시면 감사하겠습니다.</p></div><p>다양한 시간 단위로 지속 시간을 나타내기 위한 실험적인 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/" target="_blank" rel="noreferrer">Duration</a> 클래스가 있습니다. 1.5.0에서 Duration API는 다음 변경 사항을 받았습니다:</p><ul><li>내부 값 표현이 이제 <code>Double</code> 대신 <code>Long</code>을 사용하여 더 나은 정밀도를 제공합니다.</li><li><code>Long</code>으로 특정 시간 단위로 변환하기 위한 새로운 API가 있습니다. 이는 <code>Double</code> 값을 사용하여 작동하며 이제 사용 중단된 이전 API를 대체합니다. 예를 들어, <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/in-whole-minutes.html" target="_blank" rel="noreferrer"><code>Duration.inWholeMinutes</code></a>는 <code>Long</code>으로 표현된 지속 시간 값을 반환하며 <code>Duration.inMinutes</code>를 대체합니다.</li><li>숫자로부터 <code>Duration</code>을 구성하기 위한 새로운 동반(companion) 함수가 있습니다. 예를 들어, <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/seconds.html" target="_blank" rel="noreferrer"><code>Duration.seconds(Int)</code></a>는 정수 초를 나타내는 <code>Duration</code> 객체를 생성합니다. <code>Int.seconds</code>와 같은 이전 확장 속성은 이제 사용 중단되었습니다.</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.time.Duration</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.time.ExperimentalTime</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@ExperimentalTime</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> duration </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Duration.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">milliseconds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">120000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\${duration.inWholeMinutes}분은 \${duration.inWholeSeconds}초입니다&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="문자-카테고리를-가져오는-새로운-api-이제-멀티플랫폼-코드에서-사용-가능" tabindex="-1">문자 카테고리를 가져오는 새로운 API, 이제 멀티플랫폼 코드에서 사용 가능 <a class="header-anchor" href="#문자-카테고리를-가져오는-새로운-api-이제-멀티플랫폼-코드에서-사용-가능" aria-label="Permalink to &quot;문자 카테고리를 가져오는 새로운 API, 이제 멀티플랫폼 코드에서 사용 가능&quot;">​</a></h3><p>Kotlin 1.5.0은 멀티플랫폼 프로젝트에서 유니코드에 따른 문자 카테고리를 가져오는 새로운 API를 도입합니다. 여러 함수가 이제 모든 플랫폼과 공통 코드에서 사용할 수 있습니다.</p><p>문자가 글자 또는 숫자인지 확인하는 함수:</p><ul><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-digit.html" target="_blank" rel="noreferrer"><code>Char.isDigit()</code></a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-letter.html" target="_blank" rel="noreferrer"><code>Char.isLetter()</code></a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-letter-or-digit.html" target="_blank" rel="noreferrer"><code>Char.isLetterOrDigit()</code></a></li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chars </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;+&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (letterOrDigitList, notLetterOrDigitList) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chars.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isLetterOrDigit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(letterOrDigitList) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [a, 1]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(notLetterOrDigitList) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [+]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>문자의 대소문자(case)를 확인하는 함수:</p><ul><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-lower-case.html" target="_blank" rel="noreferrer"><code>Char.isLowerCase()</code></a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-upper-case.html" target="_blank" rel="noreferrer"><code>Char.isUpperCase()</code></a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-title-case.html" target="_blank" rel="noreferrer"><code>Char.isTitleCase()</code></a></li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chars </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ǅ&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ǈ&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ǋ&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ǲ&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;+&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (titleCases, notTitleCases) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chars.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isTitleCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(titleCases) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [ǅ, ǈ, ǋ, ǲ]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(notTitleCases) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [1, A, a, +]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>다른 함수:</p><ul><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-defined.html" target="_blank" rel="noreferrer"><code>Char.isDefined()</code></a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-i-s-o-control.html" target="_blank" rel="noreferrer"><code>Char.isISOControl()</code></a></li></ul><p>유니코드에 따른 문자의 일반 카테고리를 나타내는 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/category.html" target="_blank" rel="noreferrer"><code>Char.category</code></a> 속성과 그 반환 타입 열거형 클래스인 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-char-category/" target="_blank" rel="noreferrer"><code>CharCategory</code></a>도 이제 멀티플랫폼 프로젝트에서 사용할 수 있습니다.</p><p><a href="/ko/kotlin/characters">문자에 대해 자세히 알아보기</a>.</p><h3 id="새로운-컬렉션-함수-firstnotnullof" tabindex="-1">새로운 컬렉션 함수 firstNotNullOf() <a class="header-anchor" href="#새로운-컬렉션-함수-firstnotnullof" aria-label="Permalink to &quot;새로운 컬렉션 함수 firstNotNullOf()&quot;">​</a></h3><p>새로운 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/first-not-null-of.html" target="_blank" rel="noreferrer"><code>firstNotNullOf()</code></a> 및 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/first-not-null-of-or-null.html" target="_blank" rel="noreferrer"><code>firstNotNullOfOrNull()</code></a> 함수는 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map-not-null.html" target="_blank" rel="noreferrer"><code>mapNotNull()</code></a>과 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/first.html" target="_blank" rel="noreferrer"><code>first()</code></a> 또는 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/first-or-null.html" target="_blank" rel="noreferrer"><code>firstOrNull()</code></a>을 결합합니다. 이 함수들은 사용자 정의 셀렉터 함수로 원본 컬렉션을 매핑하고 첫 번째 null이 아닌 값을 반환합니다. 그러한 값이 없으면 <code>firstNotNullOf()</code>는 예외를 발생시키고, <code>firstNotNullOfOrNull()</code>은 null을 반환합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Kotlin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.5&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">firstNotNullOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toDoubleOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">firstNotNullOfOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toIntOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="string-toboolean-의-엄격-버전" tabindex="-1">String?.toBoolean()의 엄격 버전 <a class="header-anchor" href="#string-toboolean-의-엄격-버전" aria-label="Permalink to &quot;String?.toBoolean()의 엄격 버전&quot;">​</a></h3><p>두 가지 새로운 함수는 기존 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-boolean.html" target="_blank" rel="noreferrer">String?.toBoolean()</a>의 대소문자 구분 엄격 버전을 도입합니다:</p><ul><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-boolean-strict.html" target="_blank" rel="noreferrer"><code>String.toBooleanStrict()</code></a>는 리터럴 <code>true</code> 및 <code>false</code>를 제외한 모든 입력에 대해 예외를 발생시킵니다.</li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-boolean-strict-or-null.html" target="_blank" rel="noreferrer"><code>String.toBooleanStrictOrNull()</code></a>은 리터럴 <code>true</code> 및 <code>false</code>를 제외한 모든 입력에 대해 null을 반환합니다.</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;true&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toBooleanStrict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toBooleanStrictOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // println(&quot;1&quot;.toBooleanStrict())</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 예외 발생</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="kotlin-test-라이브러리" tabindex="-1">kotlin-test 라이브러리 <a class="header-anchor" href="#kotlin-test-라이브러리" aria-label="Permalink to &quot;kotlin-test 라이브러리&quot;">​</a></h2><p><a href="https://kotlinlang.org/api/latest/kotlin.test/" target="_blank" rel="noreferrer">kotlin-test</a> 라이브러리는 몇 가지 새로운 기능을 도입합니다:</p><ul><li><a href="#simplified-test-dependencies-usage-in-multiplatform-projects">멀티플랫폼 프로젝트에서 테스트 의존성 사용 간소화</a></li><li><a href="#automatic-selection-of-a-testing-framework-for-kotlin-jvm-source-sets">Kotlin/JVM 소스 세트에 대한 테스트 프레임워크 자동 선택</a></li><li><a href="#assertion-function-updates">단언(Assertion) 함수 업데이트</a></li></ul><h3 id="멀티플랫폼-프로젝트에서-테스트-의존성-사용-간소화" tabindex="-1">멀티플랫폼 프로젝트에서 테스트 의존성 사용 간소화 <a class="header-anchor" href="#멀티플랫폼-프로젝트에서-테스트-의존성-사용-간소화" aria-label="Permalink to &quot;멀티플랫폼 프로젝트에서 테스트 의존성 사용 간소화&quot;">​</a></h3><p>이제 <code>kotlin-test</code> 의존성을 사용하여 <code>commonTest</code> 소스 세트에 테스트 의존성을 추가할 수 있으며, Gradle 플러그인이 각 테스트 소스 세트에 대한 해당 플랫폼 의존성을 추론합니다:</p><ul><li>JVM 소스 세트용 <code>kotlin-test-junit</code>, <a href="#automatic-selection-of-a-testing-framework-for-kotlin-jvm-source-sets">Kotlin/JVM 소스 세트에 대한 테스트 프레임워크 자동 선택</a> 참조</li><li>Kotlin/JS 소스 세트용 <code>kotlin-test-js</code></li><li>공통 소스 세트용 <code>kotlin-test-common</code> 및 <code>kotlin-test-annotations-common</code></li><li>Kotlin/Native 소스 세트에는 추가 아티팩트 없음</li></ul><p>또한, 모든 공유 또는 플랫폼별 소스 세트에서 <code>kotlin-test</code> 의존성을 사용할 수 있습니다.</p><p>명시적 의존성이 있는 기존 kotlin-test 설정은 Gradle과 Maven 모두에서 계속 작동합니다.</p><p><a href="/ko/kotlin/gradle-configure-project#set-dependencies-on-test-libraries">테스트 라이브러리에 의존성 설정</a>에 대해 자세히 알아보세요.</p><h3 id="kotlin-jvm-소스-세트에-대한-테스트-프레임워크-자동-선택" tabindex="-1">Kotlin/JVM 소스 세트에 대한 테스트 프레임워크 자동 선택 <a class="header-anchor" href="#kotlin-jvm-소스-세트에-대한-테스트-프레임워크-자동-선택" aria-label="Permalink to &quot;Kotlin/JVM 소스 세트에 대한 테스트 프레임워크 자동 선택&quot;">​</a></h3><p>Gradle 플러그인은 이제 테스트 프레임워크에 대한 의존성을 자동으로 선택하고 추가합니다. 공통 소스 세트에 <code>kotlin-test</code> 의존성을 추가하기만 하면 됩니다.</p><p>Gradle은 기본적으로 JUnit 4를 사용합니다. 따라서 <code>kotlin(&quot;test&quot;)</code> 의존성은 JUnit 4용 변형, 즉 <code>kotlin-test-junit</code>으로 확인됩니다:</p>`,64)),t(p,{group:"build-script"},{default:n(()=>[t(h,{title:"Kotlin","group-key":"kotlin"},{default:n(()=>s[2]||(s[2]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    sourceSets"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"        val"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," commonTest "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"by"),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," getting"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"            dependencies"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"                implementation"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"test"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")) "),i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"// 이 의존성은 JUnit 4에 대한")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"                                               // 전이적 의존성을 가져옵니다")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),t(h,{title:"Groovy","group-key":"groovy"},{default:n(()=>s[3]||(s[3]=[i("div",{class:"language-groovy vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"groovy"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"kotlin {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    sourceSets {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        commonTest {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            dependencies {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"                implementation kotlin("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"test"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") "),i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"// 이 의존성은 JUnit 4에 대한")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"                                              // 전이적 의존성을 가져옵니다")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),s[10]||(s[10]=e(`<p>테스트 태스크에서 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/testing/Test.html#useJUnitPlatform" target="_blank" rel="noreferrer"><code>useJUnitPlatform()</code></a> 또는 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/testing/Test.html#useTestNG" target="_blank" rel="noreferrer"><code>useTestNG()</code></a>를 호출하여 JUnit 5 또는 TestNG를 선택할 수 있습니다:</p><div class="language-groovy vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">groovy</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tasks {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    test {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // TestNG 지원 활성화</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        useTestNG()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 또는</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // JUnit Platform(일명 JUnit 5) 지원 활성화</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        useJUnitPlatform()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>프로젝트의 <code>gradle.properties</code>에 <code>kotlin.test.infer.jvm.variant=false</code> 줄을 추가하여 자동 테스트 프레임워크 선택을 비활성화할 수 있습니다.</p><p><a href="/ko/kotlin/gradle-configure-project#set-dependencies-on-test-libraries">테스트 라이브러리에 의존성 설정</a>에 대해 자세히 알아보세요.</p><h3 id="단언-assertion-함수-업데이트" tabindex="-1">단언(Assertion) 함수 업데이트 <a class="header-anchor" href="#단언-assertion-함수-업데이트" aria-label="Permalink to &quot;단언(Assertion) 함수 업데이트&quot;">​</a></h3><p>이번 릴리스에서는 새로운 단언 함수를 도입하고 기존 함수를 개선합니다.</p><p><code>kotlin-test</code> 라이브러리는 이제 다음과 같은 기능을 제공합니다:</p><ul><li><p><strong>값의 타입 확인</strong></p><p>새로운 <code>assertIs&lt;T&gt;</code>와 <code>assertIsNot&lt;T&gt;</code>를 사용하여 값의 타입을 확인할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;test&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assertIs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(s)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 단언 실패 시 s의 실제 타입을 언급하는 AssertionError를 던집니다</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // assertIs의 계약(contract) 때문에 이제 s.length를 출력할 수 있습니다</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\${s.length}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>타입 이레이저(type erasure) 때문에, 이 단언 함수는 다음 예시에서 <code>value</code>가 <code>List</code> 타입인지 여부만 확인하며, 특정 <code>String</code> 요소 타입의 리스트인지 여부는 확인하지 않습니다: <code>assertIs&lt;List&lt;String&gt;&gt;(value)</code>.</p></li><li><p><strong>배열, 시퀀스 및 임의의 이터러블에 대한 컨테이너 내용 비교</strong></p><p><a href="/ko/kotlin/equality#structural-equality">구조적 동등성</a>을 구현하지 않는 다른 컬렉션의 내용을 비교하기 위한 새로운 오버로드된 <code>assertContentEquals()</code> 함수 집합이 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> expectedArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> actualArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { it </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assertContentEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(expectedArray, actualArray)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong><code>Double</code> 및 <code>Float</code> 숫자에 대한 <code>assertEquals()</code> 및 <code>assertNotEquals()</code>의 새로운 오버로드</strong></p><p>새로운 <code>assertEquals()</code> 함수 오버로드는 두 <code>Double</code> 또는 <code>Float</code> 숫자를 절대 정밀도로 비교할 수 있게 합니다. 정밀도 값은 함수의 세 번째 파라미터로 지정됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> @Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(PI)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 정밀도 파라미터</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tolerance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.000001</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assertEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x, tolerance)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>컬렉션 및 요소의 내용 확인을 위한 새로운 함수</strong></p><p>이제 <code>assertContains()</code> 함수를 사용하여 컬렉션이나 요소가 어떤 것을 포함하는지 확인할 수 있습니다. <code>IntRange</code>, <code>String</code> 등과 같이 <code>contains()</code> 연산자를 가진 Kotlin 컬렉션 및 요소와 함께 사용할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sampleList </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sample&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sample2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sampleString </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;sample&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assertContains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sampleList, sampleString)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 컬렉션의 요소</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assertContains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sampleString, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;amp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 문자열의 부분 문자열</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong><code>assertTrue()</code>, <code>assertFalse()</code>, <code>expect()</code> 함수가 이제 인라인입니다</strong></p><p>이제 이 함수들을 인라인 함수로 사용할 수 있으므로 람다 표현식 내에서 <a href="/ko/kotlin/composing-suspending-functions">suspend 함수</a>를 호출할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deferred </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Kotlin is nice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assertTrue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Kotlin 부분 문자열이 존재해야 합니다&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        deferred.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Kotlin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><h2 id="kotlinx-라이브러리" tabindex="-1">kotlinx 라이브러리 <a class="header-anchor" href="#kotlinx-라이브러리" aria-label="Permalink to &quot;kotlinx 라이브러리&quot;">​</a></h2><p>Kotlin 1.5.0과 함께 kotlinx 라이브러리의 새로운 버전이 릴리스됩니다:</p><ul><li><code>kotlinx.coroutines</code> <a href="#coroutines-1-5-0-rc">1.5.0-RC</a></li><li><code>kotlinx.serialization</code> <a href="#serialization-1-2-1">1.2.1</a></li><li><code>kotlinx-datetime</code> <a href="#datetime-0-2-0">0.2.0</a></li></ul><h3 id="coroutines-1-5-0-rc" tabindex="-1">Coroutines 1.5.0-RC <a class="header-anchor" href="#coroutines-1-5-0-rc" aria-label="Permalink to &quot;Coroutines 1.5.0-RC&quot;">​</a></h3><p><code>kotlinx.coroutines</code> <a href="https://github.com/Kotlin/kotlinx.coroutines/releases/tag/1.5.0-RC" target="_blank" rel="noreferrer">1.5.0-RC</a>에는 다음이 포함됩니다:</p><ul><li><a href="/ko/kotlin/channels">새로운 channels API</a></li><li>안정적인 <a href="/ko/kotlin/async-programming#reactive-extensions">반응형 통합</a></li><li>그리고 더 많은 기능</li></ul><p>Kotlin 1.5.0부터 <a href="/ko/kotlin/whatsnew14#exclusion-of-the-deprecated-experimental-coroutines">실험적인 코루틴</a>은 비활성화되며 <code>-Xcoroutines=experimental</code> 플래그는 더 이상 지원되지 않습니다.</p><p><a href="https://github.com/Kotlin/kotlinx.coroutines/releases/tag/1.5.0-RC" target="_blank" rel="noreferrer">변경 로그</a> 및 <a href="https://blog.jetbrains.com/kotlin/2021/05/kotlin-coroutines-1-5-0-released/" target="_blank" rel="noreferrer"><code>kotlinx.coroutines</code> 1.5.0 릴리스 블로그 게시물</a>에서 자세히 알아보세요.</p>`,16)),t(l,{src:"https://www.youtube.com/v/EVLnWOcR0is",title:"kotlinx.coroutines 1.5.0"}),s[11]||(s[11]=e('<h3 id="serialization-1-2-1" tabindex="-1">Serialization 1.2.1 <a class="header-anchor" href="#serialization-1-2-1" aria-label="Permalink to &quot;Serialization 1.2.1&quot;">​</a></h3><p><code>kotlinx.serialization</code> <a href="https://github.com/Kotlin/kotlinx.serialization/releases/tag/v1.2.1" target="_blank" rel="noreferrer">1.2.1</a>에는 다음이 포함됩니다:</p><ul><li>JSON 직렬화 성능 개선</li><li>JSON 직렬화에서 여러 이름 지원</li><li><code>@Serializable</code> 클래스에서 .proto 스키마 생성 실험적 지원</li><li>그리고 더 많은 기능</li></ul><p><a href="https://github.com/Kotlin/kotlinx.serialization/releases/tag/v1.2.1" target="_blank" rel="noreferrer">변경 로그</a> 및 <a href="https://blog.jetbrains.com/kotlin/2021/05/kotlinx-serialization-1-2-released/" target="_blank" rel="noreferrer"><code>kotlinx.serialization</code> 1.2.1 릴리스 블로그 게시물</a>에서 자세히 알아보세요.</p>',4)),t(l,{src:"https://www.youtube.com/v/698I_AH8h6s",title:"kotlinx.serialization 1.2.1"}),s[12]||(s[12]=e('<h3 id="datetime-0-2-0" tabindex="-1">dateTime 0.2.0 <a class="header-anchor" href="#datetime-0-2-0" aria-label="Permalink to &quot;dateTime 0.2.0&quot;">​</a></h3><p><code>kotlinx-datetime</code> <a href="https://github.com/Kotlin/kotlinx-datetime/releases/tag/v0.2.0" target="_blank" rel="noreferrer">0.2.0</a>에는 다음이 포함됩니다:</p><ul><li><code>@Serializable</code> Datetime 객체</li><li><code>DateTimePeriod</code> 및 <code>DatePeriod</code>의 정규화된 API</li><li>그리고 더 많은 기능</li></ul><p><a href="https://github.com/Kotlin/kotlinx-datetime/releases/tag/v0.2.0" target="_blank" rel="noreferrer">변경 로그</a> 및 <a href="https://blog.jetbrains.com/kotlin/2021/05/kotlinx-datetime-0-2-0-is-out/" target="_blank" rel="noreferrer"><code>kotlinx-datetime</code> 0.2.0 릴리스 블로그 게시물</a>에서 자세히 알아보세요.</p><h2 id="kotlin-1-5-0으로-마이그레이션" tabindex="-1">Kotlin 1.5.0으로 마이그레이션 <a class="header-anchor" href="#kotlin-1-5-0으로-마이그레이션" aria-label="Permalink to &quot;Kotlin 1.5.0으로 마이그레이션&quot;">​</a></h2><p>IntelliJ IDEA와 Android Studio는 Kotlin 플러그인 1.5.0이 사용 가능해지면 업데이트를 제안할 것입니다.</p><p>기존 프로젝트를 Kotlin 1.5.0으로 마이그레이션하려면, Kotlin 버전을 <code>1.5.0</code>으로 변경하고 Gradle 또는 Maven 프로젝트를 다시 가져오기(re-import)만 하면 됩니다. <a href="/ko/kotlin/releases#update-to-a-new-kotlin-version">Kotlin 1.5.0으로 업데이트하는 방법 알아보기</a>.</p><p>Kotlin 1.5.0으로 새 프로젝트를 시작하려면, Kotlin 플러그인을 업데이트하고 <strong>File</strong> | <strong>New</strong> | <strong>Project</strong>에서 프로젝트 마법사를 실행하세요.</p><p>새로운 명령줄 컴파일러는 <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.5.0" target="_blank" rel="noreferrer">GitHub 릴리스 페이지</a>에서 다운로드할 수 있습니다.</p><p>Kotlin 1.5.0은 <a href="/ko/kotlin/kotlin-evolution-principles#language-and-tooling-releases">기능 릴리스</a>이므로 언어에 호환되지 않는 변경 사항을 가져올 수 있습니다. 이러한 변경 사항의 자세한 목록은 <a href="/ko/kotlin/compatibility-guide-15">Kotlin 1.5 호환성 가이드</a>에서 확인할 수 있습니다.</p>',10))])}const v=r(c,[["render",g]]);export{f as __pageData,v as default};
