import{_ as s,c as i,o as e,ag as n}from"./chunks/framework.Bksy39di.js";const k=JSON.parse('{"title":"文件化 Kotlin 程式碼：KDoc","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/kotlin-doc.md","filePath":"zh-Hant/kotlin/kotlin-doc.md","lastUpdated":1754307826000}'),t={name:"zh-Hant/kotlin/kotlin-doc.md"};function l(p,a,h,o,r,d){return e(),i("div",null,a[0]||(a[0]=[n(`<h1 id="文件化-kotlin-程式碼-kdoc" tabindex="-1">文件化 Kotlin 程式碼：KDoc <a class="header-anchor" href="#文件化-kotlin-程式碼-kdoc" aria-label="Permalink to &quot;文件化 Kotlin 程式碼：KDoc&quot;">​</a></h1><p>用於文件化 Kotlin 程式碼的語言（等同於 Java 的 Javadoc）稱為 <strong>KDoc</strong>。本質上，KDoc 結合了 Javadoc 的區塊標籤語法（並擴展以支援 Kotlin 特定的建構）與 Markdown 的 行內標記功能。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Kotlin 的文件引擎：Dokka，能夠理解 KDoc 並可用於產生各種格式的文件。 如需更多資訊，請閱讀我們的 <a href="/zh-Hant/kotlin/dokka-introduction">Dokka 文件</a>。</p></div><h2 id="kdoc-語法" tabindex="-1">KDoc 語法 <a class="header-anchor" href="#kdoc-語法" aria-label="Permalink to &quot;KDoc 語法&quot;">​</a></h2><p>如同 Javadoc，KDoc 註解以 <code>/**</code> 開頭並以 <code>*/</code> 結尾。註解的每一行都可以星號開頭，此星號不被視為註解內容的一部分。</p><p>依照慣例，文件文字的第一段（直到第一個空白行為止的文字區塊）是元素的摘要說明，後續文字則是詳細說明。</p><p>每個區塊標籤都從新的一行開始，並以 <code>@</code> 字元開頭。</p><p>以下是使用 KDoc 文件化類別的範例：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 一群 *成員*。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 此類別沒有實用邏輯；它只是一個文件範例。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> T</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 此群組中成員的類型。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@property</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> name</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 此群組的名稱。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@constructor</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 建立一個空的群組。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Group</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 將一個 [member] 加入此群組。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@return</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 群組的新大小。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(member: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="區塊標籤" tabindex="-1">區塊標籤 <a class="header-anchor" href="#區塊標籤" aria-label="Permalink to &quot;區塊標籤&quot;">​</a></h3><p>KDoc 目前支援以下區塊標籤：</p><h3 id="param-name" tabindex="-1">@param <em>name</em> <a class="header-anchor" href="#param-name" aria-label="Permalink to &quot;@param _name_&quot;">​</a></h3><p>文件化函式的值參數，或類別、屬性或函式的類型參數。 為了更好地將參數名稱與說明分開，如果您願意，可以將參數名稱括在方括號中。因此，以下兩種語法是等效的：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@param name 說明。</span></span>
<span class="line"><span>@param[name] 說明。</span></span></code></pre></div><h3 id="return" tabindex="-1">@return <a class="header-anchor" href="#return" aria-label="Permalink to &quot;@return&quot;">​</a></h3><p>文件化函式的回傳值。</p><h3 id="constructor" tabindex="-1">@constructor <a class="header-anchor" href="#constructor" aria-label="Permalink to &quot;@constructor&quot;">​</a></h3><p>文件化類別的主要建構函式。</p><h3 id="receiver" tabindex="-1">@receiver <a class="header-anchor" href="#receiver" aria-label="Permalink to &quot;@receiver&quot;">​</a></h3><p>文件化擴充函式的接收者。</p><h3 id="property-name" tabindex="-1">@property <em>name</em> <a class="header-anchor" href="#property-name" aria-label="Permalink to &quot;@property _name_&quot;">​</a></h3><p>文件化具有指定名稱的類別屬性。此標籤可用於文件化在主要建構函式中宣告的屬性，在這種情況下，將文件註解直接放在屬性定義之前會顯得尷尬。</p><h3 id="throws-class、-exception-class" tabindex="-1">@throws <em>class</em>、@exception <em>class</em> <a class="header-anchor" href="#throws-class、-exception-class" aria-label="Permalink to &quot;@throws _class_、@exception _class_&quot;">​</a></h3><p>文件化方法可能拋出的例外。由於 Kotlin 沒有檢查型例外 (checked exceptions)，因此也不期望所有可能的例外都經過文件化，但您仍可以在此標籤為類別使用者提供有用資訊時使用它。</p><h3 id="sample-identifier" tabindex="-1">@sample <em>identifier</em> <a class="header-anchor" href="#sample-identifier" aria-label="Permalink to &quot;@sample _identifier_&quot;">​</a></h3><p>將指定限定名稱的函式主體嵌入目前元素的文件中，以展示該元素的使用範例。</p><h3 id="see-identifier" tabindex="-1">@see <em>identifier</em> <a class="header-anchor" href="#see-identifier" aria-label="Permalink to &quot;@see _identifier_&quot;">​</a></h3><p>在文件的「<strong>另請參閱</strong>」區塊中新增一個指向指定類別或方法的連結。</p><h3 id="author" tabindex="-1">@author <a class="header-anchor" href="#author" aria-label="Permalink to &quot;@author&quot;">​</a></h3><p>指定被文件化元素的作者。</p><h3 id="since" tabindex="-1">@since <a class="header-anchor" href="#since" aria-label="Permalink to &quot;@since&quot;">​</a></h3><p>指定引入被文件化元素的軟體版本。</p><h3 id="suppress" tabindex="-1">@suppress <a class="header-anchor" href="#suppress" aria-label="Permalink to &quot;@suppress&quot;">​</a></h3><p>將元素從產生的文件中排除。可用於不屬於模組官方 API 但仍須對外部可見的元素。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>KDoc 不支援 <code>@deprecated</code> 標籤。請改用 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin/-deprecated/" target="_blank" rel="noreferrer"><code>@Deprecated</code></a> 註解。</p></div><h2 id="行內標記" tabindex="-1">行內標記 <a class="header-anchor" href="#行內標記" aria-label="Permalink to &quot;行內標記&quot;">​</a></h2><p>對於行內標記，KDoc 使用常規的 <a href="https://daringfireball.net/projects/markdown/syntax" target="_blank" rel="noreferrer">Markdown</a> 語法，並擴展以支援連結到程式碼中其他元素的簡寫語法。</p><h3 id="連結到元素" tabindex="-1">連結到元素 <a class="header-anchor" href="#連結到元素" aria-label="Permalink to &quot;連結到元素&quot;">​</a></h3><p>要連結到另一個元素（類別、方法、屬性或參數），只需將其名稱放在方括號中：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>為此目的使用方法 [foo]。</span></span></code></pre></div><p>如果您想為連結指定自訂標籤，請在元素連結前方的另一組方括號中新增：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>為此目的使用 [此方法][foo]。</span></span></code></pre></div><p>您也可以在元素連結中使用限定名稱。請注意，與 Javadoc 不同，限定名稱始終使用點字符來分隔組件，即使在方法名稱之前也是如此：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>使用 [kotlin.reflect.KClass.properties] 來列舉類別的屬性。</span></span></code></pre></div><p>元素連結中的名稱解析規則，與該名稱在被文件化的元素內部使用時的規則相同。 特別是，這意味著如果您已將名稱匯入目前的檔案，則在 KDoc 註解中使用它時不需要完全限定它。</p><p>請注意，KDoc 沒有任何語法來解析連結中的多載成員。由於 Kotlin 的文件產生工具將函式所有多載的文件放在同一頁上，因此識別特定多載函式對於連結的運作並非必需。</p><h3 id="外部連結" tabindex="-1">外部連結 <a class="header-anchor" href="#外部連結" aria-label="Permalink to &quot;外部連結&quot;">​</a></h3><p>要新增外部連結，請使用典型的 Markdown 語法：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>有關 KDoc 語法的更多資訊，請參閱 [KDoc](&lt;example-URL&gt;)。</span></span></code></pre></div><h2 id="接下來" tabindex="-1">接下來？ <a class="header-anchor" href="#接下來" aria-label="Permalink to &quot;接下來？&quot;">​</a></h2><p>學習如何使用 Kotlin 的文件產生工具：<a href="/zh-Hant/kotlin/dokka-introduction">Dokka</a>。</p>`,51)]))}const u=s(t,[["render",l]]);export{k as __pageData,u as default};
