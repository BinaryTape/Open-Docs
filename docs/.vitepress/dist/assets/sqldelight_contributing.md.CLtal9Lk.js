import{_ as a,c as s,o as n,ag as t}from"./chunks/framework.Bksy39di.js";const u=JSON.parse('{"title":"贡献","description":"","frontmatter":{},"headers":[],"relativePath":"sqldelight/contributing.md","filePath":"sqldelight/contributing.md","lastUpdated":1748443437000}'),l={name:"sqldelight/contributing.md"};function p(i,e,o,r,c,d){return n(),s("div",null,e[0]||(e[0]=[t(`<h1 id="贡献" tabindex="-1">贡献 <a class="header-anchor" href="#贡献" aria-label="Permalink to &quot;贡献&quot;">​</a></h1><p>如果你想为这个项目贡献代码，可以通过 GitHub Fork 仓库并发送 Pull Request 来实现。</p><p>提交代码时，请尽力遵循现有的规范和风格，以尽可能保持代码的可读性。</p><p>在你的代码被项目接受之前，你还必须签署<a href="https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&amp;ndplr=1" target="_blank" rel="noreferrer">个人贡献者许可协议 (CLA)</a>。</p><h2 id="sqldelight" tabindex="-1">SQLDelight <a class="header-anchor" href="#sqldelight" aria-label="Permalink to &quot;SQLDelight&quot;">​</a></h2><p>如果你想开始贡献，请查看下面根据你希望贡献到 SQLDelight 的哪个部分而提供的具体指南。如果你仍然不确定，请在你正在查看的 Issue 中留言，说明你遇到的困难，我们会在那里回复——或者为你正在尝试做的事情创建一个 Issue 并开始讨论。</p><h3 id="ide-插件" tabindex="-1">IDE 插件 <a class="header-anchor" href="#ide-插件" aria-label="Permalink to &quot;IDE 插件&quot;">​</a></h3><p>如果你想修复 Bug 或扩展 IDE，代码更改可能发生于 <code>sqldelight-idea-plugin</code> 模块中。你可以使用 <code>./gradlew runIde</code> 任务测试你的更改，也可以使用 <code>./gradlew runIde --debug-jvm</code> 进行实时调试。</p><p>如果你在 IDE 中遇到 Bug 但无法在示例项目重现，你可以实时调试你的 IDE。为此，你需要第二个 IntelliJ 安装。你可以通过 <a href="https://www.jetbrains.com/toolbox-app/" target="_blank" rel="noreferrer">Toolbox</a> 来实现，滚动到 IDE 列表底部并选择不同版本的 IntelliJ。</p><p>在你希望使用调试器的 IDE 中，检出 SQLDelight 仓库，然后创建一个新的 <code>Remote</code> 运行配置。它将自动填充“Command line arguments for remote JVM”，类似 <code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</code>。复制该值，然后打开你想要调试的 IDE。选择 <code>Help -&gt; Edit Custom VM Options</code>，并将你复制的行粘贴到打开文件的底部。重启你想要调试的 IDE，一旦它启动，打开你创建配置的 IDE，然后使用你创建的远程配置附加调试器。</p><p>有关构建 IDE 插件及其功能的更多信息，请参阅 <a href="https://jetbrains.org/intellij/sdk/docs/reference_guide/custom_language_support.html" target="_blank" rel="noreferrer">Jetbrains 官方文档</a> 或加入 <a href="https://blog.jetbrains.com/platform/2019/10/introducing-jetbrains-platform-slack-for-plugin-developers/" target="_blank" rel="noreferrer">Jetbrains 平台 Slack</a>。</p><h3 id="驱动" tabindex="-1">驱动 <a class="header-anchor" href="#驱动" aria-label="Permalink to &quot;驱动&quot;">​</a></h3><p>如果你有兴趣创建自己的驱动，你可以在 SQLDelight 仓库之外使用 <code>runtime</code> Artifact 来实现。为了测试驱动，你可以依赖于 <code>driver-test</code> 并扩展 <code>DriverTest</code> 和 <code>TransactionTest</code>，以确保它能按 SQLDelight 的预期工作。</p><h4 id="异步驱动" tabindex="-1">异步驱动 <a class="header-anchor" href="#异步驱动" aria-label="Permalink to &quot;异步驱动&quot;">​</a></h4><p>可以通过使用 <code>runtime-async</code> Artifact 来实现进行异步调用的驱动。</p><h3 id="gradle" tabindex="-1">Gradle <a class="header-anchor" href="#gradle" aria-label="Permalink to &quot;Gradle&quot;">​</a></h3><p>如果你遇到 Gradle 问题，请首先在 <code>sqldelight-gradle-plugin/src/test</code> 中创建一个类似于其他文件夹的测试夹具，以重现你的问题。如果你不知道如何修复，请随意直接用这个失败的测试打开一个 PR！测试用例非常受欢迎。集成测试展示了如何设置一个完整的 Gradle 项目，该项目将运行 SQLite/MySQL/PostgreSQL 等，并使用它们各自的运行时环境和 SQLDelight 执行 SQL 查询。如果你在 SQLDelight 中遇到运行时问题，请考虑将测试添加到这些已有的集成测试中。</p><h3 id="编译器" tabindex="-1">编译器 <a class="header-anchor" href="#编译器" aria-label="Permalink to &quot;编译器&quot;">​</a></h3><p>SQLDelight 的编译器有多个层面——如果你只对代码生成 (而非 SQL 解析) 感兴趣，那么你需要在 <code>sqldelight-compiler</code> 模块中进行贡献。如果你对解析器感兴趣，则需要贡献到 <a href="https://github.com/alecstrong/sql-psi" target="_blank" rel="noreferrer">sql-psi</a>。SQLDelight 使用 <a href="https://github.com/square/kotlinpoet" target="_blank" rel="noreferrer">kotlinpoet</a> 来生成 Kotlin 代码，请务必使用它的 API 来引用 Kotlin 类型，以确保导入仍然正常工作。如果你以任何方式修改了代码生成，请在打开 Pull Request 之前运行 <code>./gradlew build</code>，因为它将更新 <code>sqldelight-compiler:integration-tests</code> 中的集成测试。如果你想编写集成测试 (即在运行时环境运行 SQL 查询)，请将测试添加到 <code>sqldelight-compiler:integration-tests</code>。</p><hr><h2 id="sql-psi" tabindex="-1">SQL PSI <a class="header-anchor" href="#sql-psi" aria-label="Permalink to &quot;SQL PSI&quot;">​</a></h2><p>在下一节中，我们将介绍如何贡献到解析器和 PSI 层，但在此之前，你应该阅读一篇关于 <a href="https://www.alecstrong.com/posts/multiple-dialects/" target="_blank" rel="noreferrer">多变体</a> 的博客文章，以了解 <a href="https://github.com/AlecStrong/sql-psi" target="_blank" rel="noreferrer">sql-psi</a> 中各个活动组件。与 SQLDelight 一样，如果你遇到问题但不知道如何贡献修复或需要帮助，请在 GitHub Issue 中留言或创建一个新的 Issue 来开始讨论。</p><p>对于 SQL-PSI 中的任何更改，你都需要在相应的 <code>core/src/test/fixtures_*</code> 文件夹中添加一个测试夹具。<code>fixtures</code> 文件夹 (无后缀) 适用于所有变体。在你的更改合并到 sql-psi 之后，如果 SQLDelight 中也有你需要进行的更改，请检出 SQLDelight 上的 <code>sql-psi-dev</code> 分支，并将你的 PR 指向它。它使用 sql-psi 的快照版本，因此你可以在 sql-psi 更改合并后大约 10 分钟构建你的 SQLDelight 更改。</p><h3 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-label="Permalink to &quot;语法&quot;">​</a></h3><p>如果你要向语法中添加内容，首先决定这是否是你向现有语法添加的新规则，或者你希望从 ANSI SQL (在 <a href="https://github.com/AlecStrong/sql-psi/blob/master/core/src/main/kotlin/com/alecstrong/sql/psi/core/sql.bnf" target="_blank" rel="noreferrer">sql.bnf</a> 中找到) 覆盖的规则。在这两种情况下，你都需要在新语法中定义该规则，但在覆盖 ANSI SQL 规则的情况下，请将其添加到 overrides 列表并为该规则设置 override 属性：</p><div class="language-bnf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bnf</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>overrides ::= my_rule</span></span>
<span class="line"><span></span></span>
<span class="line"><span>my_rule ::= SOME_TOKEN {</span></span>
<span class="line"><span>  override = true</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>你的规则定义应从 ANSI-SQL 规则的精确复制粘贴开始。要引用 ANSI-SQL 中的规则，你需要用 {} 括起来，因此你应该用 {} 括起覆盖规则中的所有外部规则：</p><div class="language-bnf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bnf</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>my_rule ::= internal_rule {external_rule} {</span></span>
<span class="line"><span>  override = true</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>internal_rule ::= SOME_TOKEN</span></span></code></pre></div><p>一个注意事项是，引用 ANSI-SQL 中的 <code>expr</code> 规则应看起来像 <code>&lt;&lt;expr &#39;-1&#39;&gt;&gt;</code>，因为它很特殊，不能被覆盖。</p><p>任何你希望使用的 ANSI SQL 词元 (Token) 也应该手动导入：</p><div class="language-bnf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bnf</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>  parserImports = [</span></span>
<span class="line"><span>    &quot;static com.alecstrong.sql.psi.core.psi.SqlTypes.DELETE&quot;</span></span>
<span class="line"><span>    &quot;static com.alecstrong.sql.psi.core.psi.SqlTypes.FROM&quot;</span></span>
<span class="line"><span>  ]</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>overrides ::= delete</span></span>
<span class="line"><span></span></span>
<span class="line"><span>delete ::= DELETE FROM {table_name} {</span></span>
<span class="line"><span>  override = true</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>变体不能添加自己的词元，但你可以通过用 <code>&quot;&quot;</code> 括起来要求精确文本：</p><div class="language-bnf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bnf</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>my_rule ::= &quot;SOME_TOKEN&quot;</span></span></code></pre></div><p>覆盖规则仍必须生成符合原始规则类型的代码，因此请确保 <code>implement</code> 和 <code>extend</code> 原始规则的现有类型：</p><div class="language-bnf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bnf</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>my_rule ::= internal_rule {external_rule} {</span></span>
<span class="line"><span>  extends = &quot;com.alecstrong.sql.psi.core.psi.impl.SqlMyRuleImpl&quot;</span></span>
<span class="line"><span>  implements = &quot;com.alecstrong.sql.psi.core.psi.SqlMyRule&quot;</span></span>
<span class="line"><span>  overrides = true</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>要查看语法中覆盖规则的示例，请查看 <a href="https://github.com/AlecStrong/sql-psi/pull/163/files" target="_blank" rel="noreferrer">此 PR</a>，它将 <code>RETURNING</code> 语法添加到了 PostgreSQL。</p><h3 id="规则行为" tabindex="-1">规则行为 <a class="header-anchor" href="#规则行为" aria-label="Permalink to &quot;规则行为&quot;">​</a></h3><p>通常，你希望修改 PSI 层的行为 (例如在某些情况下抛出错误，以使编译失败)。为此，让你的规则使用 <code>mixin</code> 而非 <code>extends</code>，<code>mixin</code> 是你编写的包含新逻辑的类：</p><div class="language-bnf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bnf</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>my_rule ::= interal_rule {external_rule} {</span></span>
<span class="line"><span>  mixin = &quot;com.alecstrong.sql.psi.MyRuleMixin&quot;</span></span>
<span class="line"><span>  implements = &quot;com.alecstrong.sql.psi.core.psi.SqlMyRule&quot;</span></span>
<span class="line"><span>  overrides = true</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>然后，在该类中确保它实现了原始的 ANSI SQL 类型和 SQL-PSI 基类 <code>SqlCompositeElementImpl</code>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>class MyRule(</span></span>
<span class="line"><span>  node: ASTNode</span></span>
<span class="line"><span>) : SqlCompositeElementImpl(node),</span></span>
<span class="line"><span>    SqlMyRule {</span></span>
<span class="line"><span>  fun annotate(annotationHolder: SqlAnnotationHolder) {</span></span>
<span class="line"><span>    if (internal_rule.text == &quot;bad_text&quot;) {</span></span>
<span class="line"><span>      annotationHolder.createErrorAnnotation(&quot;Invalid text value&quot;, internal_rule)</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>例如，<a href="https://github.com/AlecStrong/sql-psi/blob/f1137ff82dd0aa77f741a09d88855fbf9b751c00/core/src/main/kotlin/com/alecstrong/sql/psi/core/psi/mixins/DropIndexMixin.kt" target="_blank" rel="noreferrer">DropIndexMixin</a> 验证正在删除的索引是否存在于 Schema 中。</p><hr><p>如果你有关于贡献的未涵盖在此文档中的问题，请随时在 SqlDelight 上开一个 Issue 或开一个 PR，以便我们致力于改进它！</p>`,44)]))}const g=a(l,[["render",p]]);export{u as __pageData,g as default};
