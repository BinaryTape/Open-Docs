import{_ as i,c as o,o as a,ag as t}from"./chunks/framework.Bksy39di.js";const k=JSON.parse('{"title":"iOS 마이그레이션 가이드","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kmp/compose-ios-migration.md","filePath":"ko/kmp/compose-ios-migration.md","lastUpdated":1755516278000}'),s={name:"ko/kmp/compose-ios-migration.md"};function l(c,e,d,n,r,p){return a(),o("div",null,e[0]||(e[0]=[t(`<h1 id="ios-마이그레이션-가이드" tabindex="-1">iOS 마이그레이션 가이드 <a class="header-anchor" href="#ios-마이그레이션-가이드" aria-label="Permalink to &quot;iOS 마이그레이션 가이드&quot;">​</a></h1><p>이 페이지에서는 프로젝트의 Compose Multiplatform 라이브러리를 1.7.0 버전부터 최신 버전으로 업그레이드할 때 iOS 관련 고려 사항을 안내합니다.</p><h2 id="compose-multiplatform-1-6-11에서-1-7-0으로" tabindex="-1">Compose Multiplatform 1.6.11에서 1.7.0으로 <a class="header-anchor" href="#compose-multiplatform-1-6-11에서-1-7-0으로" aria-label="Permalink to &quot;Compose Multiplatform 1.6.11에서 1.7.0으로&quot;">​</a></h2><h3 id="uikitview-및-uikitviewcontroller에서-background-매개변수-제거됨" tabindex="-1">UIKitView 및 UIKitViewController에서 background 매개변수 제거됨 <a class="header-anchor" href="#uikitview-및-uikitviewcontroller에서-background-매개변수-제거됨" aria-label="Permalink to &quot;UIKitView 및 UIKitViewController에서 background 매개변수 제거됨&quot;">​</a></h3><p>지원 중단된(deprecated) <code>UIKitView</code> 및 <code>UIKitViewController</code> API에는 <code>background</code> 매개변수가 있었지만, 새로운 API에는 없습니다. 해당 매개변수는 불필요하다고 판단되어 제거되었습니다.</p><ul><li>새 인스턴스의 인터롭 뷰(interop view) 배경을 설정해야 하는 경우, <code>factory</code> 매개변수를 사용하여 설정할 수 있습니다.</li><li>배경을 업데이트할 수 있어야 하는 경우, 해당 코드를 <code>update</code> 람다에 넣으세요.</li></ul><h3 id="터치-또는-제스처가-예상대로-작동하지-않을-수-있음" tabindex="-1">터치 또는 제스처가 예상대로 작동하지 않을 수 있음 <a class="header-anchor" href="#터치-또는-제스처가-예상대로-작동하지-않을-수-있음" aria-label="Permalink to &quot;터치 또는 제스처가 예상대로 작동하지 않을 수 있음&quot;">​</a></h3><p>새로운 기본 <a href="./compose-ios-touch">터치 동작</a>은 터치가 인터롭 뷰를 위한 것인지 해당 뷰의 Compose 컨테이너를 위한 것인지 판단하기 위해 지연을 사용합니다. 사용자는 인터롭 뷰가 터치를 받기 전에 최소 150ms 동안 움직이지 않고 있어야 합니다.</p><p>Compose Multiplatform이 이전처럼 터치를 처리하도록 하려면, 새로운 실험적인(experimental) <code>UIKitInteropProperties</code> 생성자를 고려해 보세요. 이 생성자에는 <code>interactionMode</code> 매개변수가 있으며, 이를 <code>UIKitInteropInteractionMode.NonCooperative</code>로 설정하여 Compose가 터치를 인터롭 뷰로 직접 전달하도록 만들 수 있습니다.</p><p>이 생성자는 궁극적으로 인터롭 뷰의 상호 작용성(interactability)을 단일 불리언 플래그로 유지하려고 하기 때문에 실험적(experimental)으로 표시되어 있습니다. <code>interactionMode</code> 매개변수에 명시된 동작은 앞으로 자동으로 파생될 가능성이 높습니다.</p><h3 id="accessibilityenabled가-isnativeaccessibilityenabled로-대체되고-기본적으로-비활성화됨" tabindex="-1">accessibilityEnabled가 isNativeAccessibilityEnabled로 대체되고 기본적으로 비활성화됨 <a class="header-anchor" href="#accessibilityenabled가-isnativeaccessibilityenabled로-대체되고-기본적으로-비활성화됨" aria-label="Permalink to &quot;accessibilityEnabled가 isNativeAccessibilityEnabled로 대체되고 기본적으로 비활성화됨&quot;">​</a></h3><p>이전 <code>UIKitView</code> 및 <code>UIKitViewController</code> 생성자의 <code>accessibilityEnabled</code> 매개변수는 <code>UIKitInteropProperties.isNativeAccessibilityEnabled</code> 속성으로 이동 및 이름이 변경되어 사용할 수 있게 되었습니다. 또한 기본적으로 <code>false</code>로 설정됩니다.</p><p><code>isNativeAccessibilityEnabled</code> 속성은 병합된 Compose 서브트리를 네이티브 접근성 해결(native accessibility resolution)로 오염시킵니다. 따라서 웹 뷰(web views)와 같은 인터롭 뷰의 풍부한 접근성 기능이 필요하지 않는 한, <code>true</code>로 설정하는 것은 권장되지 않습니다.</p><p>이 속성과 기본값에 대한 근거는 <a href="https://github.com/JetBrains/compose-multiplatform-core/blob/jb-main/compose/ui/ui/src/uikitMain/kotlin/androidx/compose/ui/viewinterop/UIKitInteropProperties.uikit.kt" target="_blank" rel="noreferrer"><code>UIKitInteropProperties</code> 클래스의 코드 내 문서</a>를 참조하세요.</p><h3 id="onresize-매개변수-제거됨" tabindex="-1">onResize 매개변수 제거됨 <a class="header-anchor" href="#onresize-매개변수-제거됨" aria-label="Permalink to &quot;onResize 매개변수 제거됨&quot;">​</a></h3><p>이전 <code>UIKitView</code> 및 <code>UIKitViewController</code> 생성자의 <code>onResize</code> 매개변수는 <code>rect</code> 인자를 기반으로 사용자 지정 프레임을 설정했지만 Compose 레이아웃 자체에는 영향을 미치지 않아 사용하기 직관적이지 않았습니다. 게다가 <code>onResize</code> 매개변수의 기본 구현은 인터롭 뷰의 프레임을 올바르게 설정하고 뷰를 적절히 클리핑하는 일부 구현 세부 사항을 포함해야 했습니다. </p><p><code>onResize</code> 없이 작업하는 방법:</p><ul><li>인터롭 뷰 프레임 변경에 반응해야 하는 경우 다음을 수행할 수 있습니다. <ul><li>인터롭 <code>UIView</code>의 <a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="noreferrer"><code>layoutSubviews</code></a>를 재정의하거나,</li><li>인터롭 <code>UIViewController</code>의 <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621398-viewdidlayoutsubviews" target="_blank" rel="noreferrer"><code>viewDidLayoutSubviews</code></a>를 재정의하거나,</li><li><code>Modifier</code> 체인에 <code>onGloballyPositioned</code>를 추가합니다.</li></ul></li><li>인터롭 뷰의 프레임을 설정해야 하는 경우 해당 Compose 모디파이어(<code>size</code>, <code>fillMaxSize</code> 등)를 사용하세요.</li></ul><h3 id="일부-onreset-사용-패턴이-무효화됨" tabindex="-1">일부 onReset 사용 패턴이 무효화됨 <a class="header-anchor" href="#일부-onreset-사용-패턴이-무효화됨" aria-label="Permalink to &quot;일부 onReset 사용 패턴이 무효화됨&quot;">​</a></h3><p>null이 아닌 <code>onReset</code> 람다를 <code>remember { UIView() }</code>와 함께 사용하는 것은 올바르지 않습니다.</p><p>다음 코드를 고려해 보세요.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> view </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> remember</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UIView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UIKitView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(factory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { view }, onReset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p><code>UIKitView</code>가 컴포지션에 진입할 때 <code>factory</code> 또는 <code>onReset</code> 둘 중 하나가 호출되며, 둘 다 동시에 호출되지는 않습니다. 따라서 <code>onReset</code>이 null이 아니면, 기억된 <code>view</code>가 화면에 표시되는 뷰와 다를 수 있습니다. 컴포저블(composable)이 컴포지션을 떠나 뷰의 인스턴스를 남겨두면, <code>factory</code>를 사용하여 새 인스턴스를 할당하는 대신 <code>onReset</code>에서 재설정된 후 해당 인스턴스가 재사용될 수 있습니다.</p><p>이러한 실수를 피하려면 생성자에서 <code>onReset</code> 값을 지정하지 마세요. 함수를 방출하는 컨텍스트가 컴포지션에 진입하는 방식에 따라 인터롭 뷰 내부에서 콜백을 수행해야 할 수도 있습니다. 이 경우 <code>update</code>를 사용하여 뷰 내부에 콜백을 저장하는 것을 고려해 보세요.</p>`,24)]))}const u=i(s,[["render",l]]);export{k as __pageData,u as default};
