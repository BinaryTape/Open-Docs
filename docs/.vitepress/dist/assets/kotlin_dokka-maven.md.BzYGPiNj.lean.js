import{_ as d,C as p,c as g,o as r,ag as k,G as l,w as n,j as s,a as i}from"./chunks/framework.Bksy39di.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/dokka-maven.md","filePath":"kotlin/dokka-maven.md","lastUpdated":1754307826000}'),y={name:"kotlin/dokka-maven.md"};function o(c,a,u,D,A,f){const t=p("def"),E=p("list"),e=p("anchor"),h=p("deflist");return r(),g("div",null,[a[40]||(a[40]=k("",37)),l(h,{collapsible:"true"},{default:n(()=>[l(t,{title:"跳过"},{default:n(()=>a[0]||(a[0]=[s("p",null,"是否跳过文档生成。",-1),s("p",null,[i("默认值："),s("code",null,"false")],-1)])),_:1}),l(t,{title:"模块名称"},{default:n(()=>a[1]||(a[1]=[s("p",null,"用于指代项目/模块的显示名称。它用于目录、导航、日志记录等。",-1),s("p",null,[i("默认值："),s("code",null,"{project.artifactId}")],-1)])),_:1}),l(t,{title:"输出目录"},{default:n(()=>a[2]||(a[2]=[s("p",null,"文档的生成目录，不分格式。",-1),s("p",null,[i("默认值："),s("code",null,"{project.basedir}/target/dokka")],-1)])),_:1}),l(t,{title:"警告时失败"},{default:n(()=>a[3]||(a[3]=[s("p",null," 如果 Dokka 发出了警告或错误，是否使文档生成失败。此过程会先等待 所有错误和警告都发出。 ",-1),s("p",null,[i("此设置与 "),s("code",null,"reportUndocumented"),i(" 配合良好。")],-1),s("p",null,[i("默认值："),s("code",null,"false")],-1)])),_:1}),l(t,{title:"抑制明显函数"},{default:n(()=>[a[5]||(a[5]=s("p",null,"是否抑制明显函数。",-1)),a[6]||(a[6]=s("p",null," 如果函数是以下情况，则被认为是明显的：",-1)),l(E,null,{default:n(()=>a[4]||(a[4]=[s("li",null,[i(" 从 "),s("code",null,"kotlin.Any"),i("、"),s("code",null,"Kotlin.Enum"),i("、"),s("code",null,"java.lang.Object"),i(" 或 "),s("code",null,"java.lang.Enum"),i(" 继承的函数，例如 "),s("code",null,"equals"),i("、"),s("code",null,"hashCode"),i("、"),s("code",null,"toString"),i("。 ")],-1),s("li",null,[i(" 合成的（由编译器生成）且没有任何文档的函数，例如 "),s("code",null,"dataClass.componentN"),i(" 或 "),s("code",null,"dataClass.copy"),i("。 ")],-1)])),_:1}),a[7]||(a[7]=s("p",null,[i("默认值："),s("code",null,"true")],-1))]),_:1}),l(t,{title:"抑制继承成员"},{default:n(()=>a[8]||(a[8]=[s("p",null,"是否抑制在给定类中未显式覆盖的继承成员。",-1),s("p",null,[i(" 注意：这可以抑制 "),s("code",null,"equals"),i("/"),s("code",null,"hashCode"),i("/"),s("code",null,"toString"),i(" 等函数， 但不能抑制 "),s("code",null,"dataClass.componentN"),i(" 和 "),s("code",null,"dataClass.copy"),i(" 等合成函数。 为此请使用 "),s("code",null,"suppressObviousFunctions"),i("。 ")],-1),s("p",null,[i("默认值："),s("code",null,"false")],-1)])),_:1}),l(t,{title:"离线模式"},{default:n(()=>a[9]||(a[9]=[s("p",null,"是否通过网络解析远程文件/链接。",-1),s("p",null," 这包括用于生成外部文档链接的 package-list。 例如，使标准库中的类可点击。 ",-1),s("p",null,[i(" 将此设置为 "),s("code",null,"true"),i(" 在某些情况下可以显著加快构建时间， 但也会降低文档质量和用户体验。例如，不 解析来自你的依赖项（包括标准库）的类/成员链接。 ")],-1),s("p",null,[i(" 注意：你可以在本地缓存获取的文件，并将其作为 本地路径提供给 Dokka。请参见 "),s("code",null,"externalDocumentationLinks"),i(" 部分。 ")],-1),s("p",null,[i("默认值："),s("code",null,"false")],-1)])),_:1}),l(t,{title:"源代码目录"},{default:n(()=>a[10]||(a[10]=[s("p",null,[i(" 要分析和文档化的源代码根目录。 可接受的输入是目录和单个 "),s("code",null,".kt"),i(" / "),s("code",null,".java"),i(" 文件。 ")],-1),s("p",null,[i("默认值："),s("code",null,"{project.compileSourceRoots}")],-1)])),_:1}),l(t,{title:"文档化可见性"},{default:n(()=>a[11]||(a[11]=[s("p",null,"应文档化的可见性修饰符集。",-1),s("p",null,[i(" 如果你想文档化 "),s("code",null,"protected"),i("/"),s("code",null,"internal"),i("/"),s("code",null,"private"),i(" 声明， 以及如果你想排除 "),s("code",null,"public"),i(" 声明并仅文档化内部 API，可以使用此选项。 ")],-1),s("p",null,"可以按包进行配置。",-1),s("p",null,[i("默认值："),s("code",null,"PUBLIC")],-1)])),_:1}),l(t,{title:"报告未文档化"},{default:n(()=>a[12]||(a[12]=[s("p",null,[i(" 是否发出关于可见的未文档化声明的警告，即经过 "),s("code",null,"documentedVisibilities"),i(" 和其他过滤器过滤后没有 KDocs 的声明。 ")],-1),s("p",null,[i("此设置与 "),s("code",null,"failOnWarning"),i(" 配合良好。")],-1),s("p",null,"这可以在包级别覆盖。",-1),s("p",null,[i("默认值："),s("code",null,"false")],-1)])),_:1}),l(t,{title:"跳过已弃用"},{default:n(()=>a[13]||(a[13]=[s("p",null,[i("是否文档化使用 "),s("code",null,"@Deprecated"),i(" 注解的声明。")],-1),s("p",null,"这可以在项目/模块级别覆盖。",-1),s("p",null,[i("默认值："),s("code",null,"false")],-1)])),_:1}),l(t,{title:"跳过空包"},{default:n(()=>a[14]||(a[14]=[s("p",null," 是否跳过在应用各种过滤器后不包含任何可见声明的包。 ",-1),s("p",null,[i(" 例如，如果 "),s("code",null,"skipDeprecated"),i(" 设置为 "),s("code",null,"true"),i("，并且你的包只包含 已弃用的声明，则该包被视为空。 ")],-1),s("p",null,[i("默认值："),s("code",null,"true")],-1)])),_:1}),l(t,{title:"抑制文件"},{default:n(()=>a[15]||(a[15]=[s("p",null," 应抑制的目录或单个文件，这意味着来自这些文件的声明 不会被文档化。 ",-1)])),_:1}),l(t,{title:"jdk版本"},{default:n(()=>a[16]||(a[16]=[s("p",null,"为 Java 类型生成外部文档链接时使用的 JDK 版本。",-1),s("p",null,[i(" 例如，如果你在某个 public 声明签名中使用 "),s("code",null,"java.util.UUID"),i("， 并且此选项设置为 "),s("code",null,"8"),i("，Dokka 会为它生成一个外部文档链接 到 "),s("a",{href:"https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html"},"JDK 8 Javadoc"),i("。 ")],-1),s("p",null,"默认值：JDK 8",-1)])),_:1}),l(t,{title:"语言版本"},{default:n(()=>a[17]||(a[17]=[s("p",null,[i(" 用于设置分析和 "),s("a",{href:"https://kotlinlang.org/docs/kotlin-doc.html#sample-identifier"},"@sample"),i(" 环境的 "),s("a",{href:"https://kotlinlang.org/docs/compatibility-modes.html"},"Kotlin 语言版本"),i("。 ")],-1),s("p",null,"默认情况下，使用 Dokka 嵌入式编译器可用的最新语言版本。",-1)])),_:1}),l(t,{title:"API 版本"},{default:n(()=>a[18]||(a[18]=[s("p",null,[i(" 用于设置分析和 "),s("a",{href:"https://kotlinlang.org/docs/kotlin-doc.html#sample-identifier"},"@sample"),i(" 环境的 "),s("a",{href:"https://kotlinlang.org/docs/compatibility-modes.html"},"Kotlin API 版本"),i("。 ")],-1),s("p",null,[i("默认情况下，它从 "),s("code",null,"languageVersion"),i(" 推断。")],-1)])),_:1}),l(t,{title:"无标准库链接"},{default:n(()=>a[19]||(a[19]=[s("p",null," 是否生成指向 Kotlin 标准库 API 参考文档的外部文档链接。 ",-1),s("p",null,[i("注意：当 "),s("code",null,"noStdLibLink"),i(" 设置为 "),s("code",null,"false"),i(" 时，链接"),s("b",null,"会"),i("生成。")],-1),s("p",null,[i("默认值："),s("code",null,"false")],-1)])),_:1}),l(t,{title:"无 JDK 链接"},{default:n(()=>[l(e,{name:"includes"}),a[20]||(a[20]=s("p",null,"是否生成指向 JDK Javadoc 的外部文档链接。",-1)),a[21]||(a[21]=s("p",null,[i("JDK Javadoc 的版本由 "),s("code",null,"jdkVersion"),i(" 选项决定。")],-1)),a[22]||(a[22]=s("p",null,[i("注意：当 "),s("code",null,"noJdkLink"),i(" 设置为 "),s("code",null,"false"),i(" 时，链接"),s("b",null,"会"),i("生成。")],-1)),a[23]||(a[23]=s("p",null,[i("默认值："),s("code",null,"false")],-1))]),_:1}),l(t,{title:"包含"},{default:n(()=>a[24]||(a[24]=[s("p",null,[i(" 包含 "),s("a",{href:"/kotlin/dokka-module-and-package-docs"},"模块和包文档"),i("的 Markdown 文件列表。 ")],-1),s("p",null,"指定文件的内容将被解析并嵌入到文档中作为模块和包的描述。",-1)])),_:1}),l(t,{title:"类路径"},{default:n(()=>a[25]||(a[25]=[s("p",null,"用于分析和交互式示例的类路径。",-1),s("p",null,[i(" 如果来自依赖项的某些类型未自动解析/识别，此选项会很有用。 此选项接受 "),s("code",null,".jar"),i(" 和 "),s("code",null,".klib"),i(" 文件。 ")],-1),s("p",null,[i("默认值："),s("code",null,"{project.compileClasspathElements}")],-1)])),_:1}),l(t,{title:"示例"},{default:n(()=>a[26]||(a[26]=[s("p",null,[i(" 包含通过 "),s("a",{href:"https://kotlinlang.org/docs/kotlin-doc.html#sample-identifier"},"@sample KDoc 标签"),i("引用的示例函数的目录或文件列表。 ")],-1)])),_:1})]),_:1}),a[41]||(a[41]=k("",5)),l(h,{collapsible:"true"},{default:n(()=>[l(t,{title:"路径"},{default:n(()=>a[27]||(a[27]=[s("p",null," 本地源代码目录的路径。路径必须是相对于当前模块根目录的相对路径。 ",-1),s("p",null," 注意：只允许基于 Unix 的路径，Windows 风格的路径将抛出错误。 ",-1)])),_:1}),l(t,{title:"网址"},{default:n(()=>a[28]||(a[28]=[s("p",null," 文档读者可以访问的源代码托管服务的 URL， 例如 GitHub、GitLab、Bitbucket 等。此 URL 用于生成 声明的源代码链接。 ",-1)])),_:1}),l(t,{title:"行号后缀"},{default:n(()=>[a[30]||(a[30]=s("p",null," 用于将源代码行号附加到 URL 的后缀。这有助于读者不仅导航到文件， 而且导航到声明的特定行号。 ",-1)),a[31]||(a[31]=s("p",null,[i(" 数字本身将附加到指定的后缀。例如，如果此选项设置为 "),s("code",null,"#L"),i(" 且行号为 10，则生成的 URL 后缀为 "),s("code",null,"#L10"),i("。 ")],-1)),a[32]||(a[32]=s("p",null," 常用服务使用的后缀：",-1)),l(E,null,{default:n(()=>a[29]||(a[29]=[s("li",null,[i("GitHub："),s("code",null,"#L")],-1),s("li",null,[i("GitLab："),s("code",null,"#L")],-1),s("li",null,[i("Bitbucket："),s("code",null,"#lines-")],-1)])),_:1})]),_:1})]),_:1}),a[42]||(a[42]=k("",5)),l(h,{collapsible:"true"},{default:n(()=>[l(t,{title:"网址"},{default:n(()=>a[33]||(a[33]=[s("p",null,[i("要链接的文档的根 URL。它"),s("b",null,"必须"),i("包含尾部斜杠。")],-1),s("p",null,[i(" Dokka 会尽力自动查找给定 URL 的 "),s("code",null,"package-list"),i("， 并将声明链接在一起。 ")],-1),s("p",null,[i(" 如果自动解析失败或者你想使用本地缓存的文件， 请考虑设置 "),s("code",null,"packageListUrl"),i(" 选项。 ")],-1)])),_:1}),l(t,{title:"包列表网址"},{default:n(()=>a[34]||(a[34]=[s("p",null,[s("code",null,"package-list"),i(" 的确切位置。这是不依赖 Dokka 自动解析的替代方法。 ")],-1),s("p",null," 包列表包含有关文档和项目本身的信息， 例如模块和包名称。 ",-1),s("p",null,"这也可以是本地缓存文件，以避免网络调用。",-1)])),_:1})]),_:1}),a[43]||(a[43]=k("",3)),l(h,{collapsible:"true"},{default:n(()=>[l(t,{title:"匹配正则表达式"},{default:n(()=>a[35]||(a[35]=[s("p",null,"用于匹配包的正则表达式。",-1),s("p",null,[i("默认值："),s("code",null,".*")],-1)])),_:1}),l(t,{title:"抑制"},{default:n(()=>a[36]||(a[36]=[s("p",null,"生成文档时是否应跳过此包。",-1),s("p",null,[i("默认值："),s("code",null,"false")],-1)])),_:1}),l(t,{title:"文档化可见性"},{default:n(()=>a[37]||(a[37]=[s("p",null,"应文档化的可见性修饰符集。",-1),s("p",null,[i(" 如果你想文档化此包内的 "),s("code",null,"protected"),i("/"),s("code",null,"internal"),i("/"),s("code",null,"private"),i(" 声明， 以及如果你想排除 "),s("code",null,"public"),i(" 声明并仅文档化内部 API，可以使用此选项。 ")],-1),s("p",null,[i("默认值："),s("code",null,"PUBLIC")],-1)])),_:1}),l(t,{title:"跳过已弃用"},{default:n(()=>a[38]||(a[38]=[s("p",null,[i("是否文档化使用 "),s("code",null,"@Deprecated"),i(" 注解的声明。")],-1),s("p",null,"这可以在项目/模块级别设置。",-1),s("p",null,[i("默认值："),s("code",null,"false")],-1)])),_:1}),l(t,{title:"报告未文档化"},{default:n(()=>a[39]||(a[39]=[s("p",null,[i(" 是否发出关于可见的未文档化声明的警告，即经过 "),s("code",null,"documentedVisibilities"),i(" 和其他过滤器过滤后没有 KDocs 的声明。 ")],-1),s("p",null,[i("此设置与 "),s("code",null,"failOnWarning"),i(" 配合良好。")],-1),s("p",null,[i("默认值："),s("code",null,"false")],-1)])),_:1})]),_:1}),a[44]||(a[44]=k("",3))])}const v=d(y,[["render",o]]);export{m as __pageData,v as default};
