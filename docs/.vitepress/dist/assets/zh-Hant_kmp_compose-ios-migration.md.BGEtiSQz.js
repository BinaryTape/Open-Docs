import{_ as i,c as o,o as a,ag as t}from"./chunks/framework.Bksy39di.js";const k=JSON.parse('{"title":"iOS 遷移指南","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kmp/compose-ios-migration.md","filePath":"zh-Hant/kmp/compose-ios-migration.md","lastUpdated":1755516278000}'),s={name:"zh-Hant/kmp/compose-ios-migration.md"};function l(c,e,d,n,r,p){return a(),o("div",null,e[0]||(e[0]=[t(`<h1 id="ios-遷移指南" tabindex="-1">iOS 遷移指南 <a class="header-anchor" href="#ios-遷移指南" aria-label="Permalink to &quot;iOS 遷移指南&quot;">​</a></h1><p>本頁將引導您瞭解在專案中將 Compose Multiplatform 函式庫升級到較新版本時（從 1.7.0 開始）需要考慮的 iOS 事項。</p><h2 id="compose-multiplatform-1-6-11-到-1-7-0" tabindex="-1">Compose Multiplatform 1.6.11 到 1.7.0 <a class="header-anchor" href="#compose-multiplatform-1-6-11-到-1-7-0" aria-label="Permalink to &quot;Compose Multiplatform 1.6.11 到 1.7.0&quot;">​</a></h2><h3 id="uikitview-和-uikitviewcontroller-中移除了-background-參數" tabindex="-1">UIKitView 和 UIKitViewController 中移除了 background 參數 <a class="header-anchor" href="#uikitview-和-uikitviewcontroller-中移除了-background-參數" aria-label="Permalink to &quot;UIKitView 和 UIKitViewController 中移除了 background 參數&quot;">​</a></h3><p>已棄用的 <code>UIKitView</code> 和 <code>UIKitViewController</code> API 具有 <code>background</code> 參數，而新的 API 則沒有。該參數被認為是多餘的，因此已移除：</p><ul><li>如果您需要為新的實例設定互通視圖的背景，可以使用 <code>factory</code> 參數來完成。</li><li>如果您需要背景可更新，請將相應的程式碼放入 <code>update</code> lambda 中。</li></ul><h3 id="觸控或手勢可能無法如預期般運作" tabindex="-1">觸控或手勢可能無法如預期般運作 <a class="header-anchor" href="#觸控或手勢可能無法如預期般運作" aria-label="Permalink to &quot;觸控或手勢可能無法如預期般運作&quot;">​</a></h3><p>新的預設 <a href="./compose-ios-touch">觸控行為</a> 使用延遲來判斷觸控是針對互通視圖還是針對該視圖的 Compose 容器：使用者必須保持靜止至少 150 毫秒，互通視圖才會接收到觸控。</p><p>如果您需要 Compose Multiplatform 像以前一樣處理觸控，請考慮使用新的實驗性 <code>UIKitInteropProperties</code> 建構函式。它具有 <code>interactionMode</code> 參數，您可以將其設定為 <code>UIKitInteropInteractionMode.NonCooperative</code>，使 Compose 直接將觸控傳遞給互通視圖。</p><p>此建構函式被標記為實驗性，因為我們最終打算透過單一布林旗標來描述互通視圖的互動性。未來，在 <code>interactionMode</code> 參數中明確描述的行為很可能會被自動推導。</p><h3 id="accessibilityenabled-被-isnativeaccessibilityenabled-取代-並且預設為關閉" tabindex="-1">accessibilityEnabled 被 isNativeAccessibilityEnabled 取代，並且預設為關閉 <a class="header-anchor" href="#accessibilityenabled-被-isnativeaccessibilityenabled-取代-並且預設為關閉" aria-label="Permalink to &quot;accessibilityEnabled 被 isNativeAccessibilityEnabled 取代，並且預設為關閉&quot;">​</a></h3><p>舊版 <code>UIKitView</code> 和 <code>UIKitViewController</code> 建構函式的 <code>accessibilityEnabled</code> 參數已移至並重新命名為 <code>UIKitInteropProperties.isNativeAccessibilityEnabled</code> 屬性。它也預設為 <code>false</code>。</p><p><code>isNativeAccessibilityEnabled</code> 屬性會使合併的 Compose 子樹受到原生輔助功能解析的影響。因此，除非您需要互通視圖（例如網頁視圖）的豐富輔助功能，否則不建議將其設定為 true。</p><p>有關此屬性及其預設值的基本原理，請參閱 <a href="https://github.com/JetBrains/compose-multiplatform-core/blob/jb-main/compose/ui/ui/src/uikitMain/kotlin/androidx/compose/ui/viewinterop/UIKitInteropProperties.uikit.kt" target="_blank" rel="noreferrer">UIKitInteropProperties 類別的程式碼內文件</a>。</p><h3 id="onresize-參數已移除" tabindex="-1">onResize 參數已移除 <a class="header-anchor" href="#onresize-參數已移除" aria-label="Permalink to &quot;onResize 參數已移除&quot;">​</a></h3><p>舊版 <code>UIKitView</code> 和 <code>UIKitViewController</code> 建構函式的 <code>onResize</code> 參數根據 <code>rect</code> 引數設定了自訂框架，但並未影響 Compose 佈局本身，因此使用起來不夠直觀。除此之外，<code>onResize</code> 參數的預設實作需要正確設定互通視圖的框架，並且包含一些關於正確剪裁視圖的實作細節。 </p><p>如何在沒有 <code>onResize</code> 的情況下完成：</p><ul><li>如果您需要回應互通視圖框架的變更，您可以： <ul><li>覆寫互通 <code>UIView</code> 的 <a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="noreferrer"><code>layoutSubviews</code></a>，</li><li>覆寫互通 <code>UIViewController</code> 的 <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621398-viewdidlayoutsubviews" target="_blank" rel="noreferrer"><code>viewDidLayoutSubviews</code></a>，</li><li>或將 <code>onGloballyPositioned</code> 加入 <code>Modifier</code> 鏈中。</li></ul></li><li>如果您需要設定互通視圖的框架，請使用相應的 Compose 修飾符：<code>size</code>、<code>fillMaxSize</code> 等。</li></ul><h3 id="某些-onreset-使用模式已失效" tabindex="-1">某些 onReset 使用模式已失效 <a class="header-anchor" href="#某些-onreset-使用模式已失效" aria-label="Permalink to &quot;某些 onReset 使用模式已失效&quot;">​</a></h3><p>將非空的 <code>onReset</code> lambda 與 <code>remember { UIView() }</code> 一起使用是不正確的。</p><p>請考慮以下程式碼：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> view </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> remember</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UIView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UIKitView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(factory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { view }, onReset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p>當 <code>UIKitView</code> 進入組合時，<code>factory</code> 或 <code>onReset</code> 會被呼叫，但不會同時呼叫。因此，如果 <code>onReset</code> 不是 null，則記住的 <code>view</code> 可能與螢幕上顯示的 <code>view</code> 不同：一個 composable 可以離開組合，並留下一個視圖實例，該實例將在 <code>onReset</code> 中重設後被重複使用，而不是使用 <code>factory</code> 分配一個新的實例。</p><p>為避免此類錯誤，請勿在建構函式中指定 <code>onReset</code> 值。您可能需要根據函式發出它進入組合的上下文，在互通視圖內部執行回呼：在這種情況下，考慮使用 <code>update</code> 將回呼儲存在視圖內部，以處理 <code>onReset</code> 的相關情況。</p>`,24)]))}const u=i(s,[["render",l]]);export{k as __pageData,u as default};
