import{_ as a,c as s,o as e,ag as l}from"./chunks/framework.Bksy39di.js";const k=JSON.parse('{"title":"Koin DSL","description":"","frontmatter":{"title":"Koin DSL"},"headers":[],"relativePath":"ko/koin/reference/koin-core/dsl.md","filePath":"ko/koin/reference/koin-core/dsl.md","lastUpdated":1750001831000}'),o={name:"ko/koin/reference/koin-core/dsl.md"};function n(t,i,d,p,c,h){return e(),s("div",null,i[0]||(i[0]=[l(`<h1 id="koin-dsl" tabindex="-1">Koin DSL <a class="header-anchor" href="#koin-dsl" aria-label="Permalink to &quot;Koin DSL&quot;">​</a></h1><p>Kotlin 언어의 강력함 덕분에 Koin은 어노테이션을 붙이거나 코드를 생성하는 대신 앱을 기술(describe)하는 데 도움이 되는 DSL을 제공합니다. Kotlin DSL을 통해 Koin은 의존성 주입을 준비할 수 있도록 스마트한 함수형 API를 제공합니다.</p><h2 id="애플리케이션-모듈-dsl" tabindex="-1">애플리케이션 &amp; 모듈 DSL <a class="header-anchor" href="#애플리케이션-모듈-dsl" aria-label="Permalink to &quot;애플리케이션 &amp; 모듈 DSL&quot;">​</a></h2><p>Koin은 Koin 애플리케이션의 요소를 기술(describe)할 수 있도록 몇 가지 키워드를 제공합니다.</p><ul><li>애플리케이션 DSL: Koin 컨테이너 구성을 기술합니다.</li><li>모듈 DSL: 주입되어야 할 컴포넌트들을 기술합니다.</li></ul><h2 id="애플리케이션-dsl" tabindex="-1">애플리케이션 DSL <a class="header-anchor" href="#애플리케이션-dsl" aria-label="Permalink to &quot;애플리케이션 DSL&quot;">​</a></h2><p><code>KoinApplication</code> 인스턴스는 Koin 컨테이너 인스턴스 구성입니다. 이를 통해 로깅, 속성 로딩 및 모듈을 구성할 수 있습니다.</p><p>새로운 <code>KoinApplication</code>을 빌드하려면 다음 함수들을 사용합니다.</p><ul><li><code>koinApplication { }</code> - <code>KoinApplication</code> 컨테이너 구성을 생성합니다.</li><li><code>startKoin { }</code> - <code>KoinApplication</code> 컨테이너 구성을 생성하고 <code>GlobalContext</code>에 등록하여 GlobalContext API 사용을 허용합니다.</li></ul><p><code>KoinApplication</code> 인스턴스를 구성하려면 다음 함수들 중 하나를 사용할 수 있습니다.</p><ul><li><code>logger( )</code> - 어떤 레벨과 로거 구현을 사용할지 기술합니다 (기본적으로 <code>EmptyLogger</code>를 사용합니다).</li><li><code>modules( )</code> - 컨테이너에 로드할 Koin 모듈 목록을 설정합니다 (목록 또는 가변 인자(vararg) 목록).</li><li><code>properties()</code> - HashMap 속성을 Koin 컨테이너로 로드합니다.</li><li><code>fileProperties( )</code> - 주어진 파일에서 속성을 Koin 컨테이너로 로드합니다.</li><li><code>environmentProperties( )</code> - OS 환경에서 속성을 Koin 컨테이너로 로드합니다.</li><li><code>createEagerInstances()</code> - 즉시 생성되는(eager) 인스턴스를 생성합니다 (<code>createdAtStart</code>로 표시된 싱글톤 정의).</li></ul><h2 id="koinapplication-인스턴스-전역-global-vs-지역-local" tabindex="-1">KoinApplication 인스턴스: 전역(Global) vs 지역(Local) <a class="header-anchor" href="#koinapplication-인스턴스-전역-global-vs-지역-local" aria-label="Permalink to &quot;KoinApplication 인스턴스: 전역(Global) vs 지역(Local)&quot;">​</a></h2><p>위에서 보듯이, Koin 컨테이너 구성을 <code>koinApplication</code> 또는 <code>startKoin</code> 함수라는 두 가지 방식으로 기술할 수 있습니다.</p><ul><li><code>koinApplication</code>은 Koin 컨테이너 인스턴스를 기술합니다.</li><li><code>startKoin</code>은 Koin 컨테이너 인스턴스를 기술하고 Koin <code>GlobalContext</code>에 등록합니다.</li></ul><p>컨테이너 구성을 <code>GlobalContext</code>에 등록하면 글로벌 API가 이를 직접 사용할 수 있습니다. 모든 <code>KoinComponent</code>는 <code>Koin</code> 인스턴스를 참조합니다. 기본적으로는 <code>GlobalContext</code>의 인스턴스를 사용합니다.</p><p>자세한 내용은 커스텀 Koin 인스턴스에 대한 챕터를 참조하세요.</p><h2 id="koin-시작하기" tabindex="-1">Koin 시작하기 <a class="header-anchor" href="#koin-시작하기" aria-label="Permalink to &quot;Koin 시작하기&quot;">​</a></h2><p>Koin을 시작하는 것은 <code>GlobalContext</code>에서 <code>KoinApplication</code> 인스턴스를 실행하는 것을 의미합니다.</p><p>모듈을 사용하여 Koin 컨테이너를 시작하려면 다음과 같이 <code>startKoin</code> 함수를 사용하면 됩니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Global 컨텍스트에서 KoinApplication 시작</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">startKoin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 사용할 로거 선언</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    logger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 사용할 모듈 선언</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    modules</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coffeeAppModule)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="모듈-dsl" tabindex="-1">모듈 DSL <a class="header-anchor" href="#모듈-dsl" aria-label="Permalink to &quot;모듈 DSL&quot;">​</a></h2><p>Koin 모듈은 애플리케이션에서 주입/결합할 정의들을 모아둡니다. 새로운 모듈을 생성하려면 다음 함수를 사용합니다.</p><ul><li><code>module { // module content }</code> - Koin 모듈을 생성합니다.</li></ul><p>모듈 내부에 내용을 기술(describe)하려면 다음 함수들을 사용할 수 있습니다.</p><ul><li><code>factory { //definition }</code> - 팩토리 빈 정의를 제공합니다.</li><li><code>single { //definition }</code> - 싱글톤 빈 정의를 제공합니다 (<code>bean</code>으로도 별칭 지정됨).</li><li><code>get()</code> - 컴포넌트 의존성을 해결(resolve)합니다 (이름, 스코프 또는 파라미터도 사용할 수 있습니다).</li><li><code>bind()</code> - 주어진 빈 정의에 바인딩할 타입을 추가합니다.</li><li><code>binds()</code> - 주어진 빈 정의에 바인딩할 타입 배열을 추가합니다.</li><li><code>scope { // scope group }</code> - <code>scoped</code> 정의를 위한 논리적 그룹을 정의합니다.</li><li><code>scoped { //definition }</code>- 스코프 내에서만 존재하는 빈 정의를 제공합니다.</li></ul><p>참고: <code>named()</code> 함수는 문자열, 열거형(enum) 또는 타입으로 한정자(qualifier)를 지정할 수 있도록 합니다. 이는 정의에 이름을 부여하는 데 사용됩니다.</p><h3 id="모듈-작성" tabindex="-1">모듈 작성 <a class="header-anchor" href="#모듈-작성" aria-label="Permalink to &quot;모듈 작성&quot;">​</a></h3><p>Koin 모듈은 <em>모든 컴포넌트를 선언하는 공간</em>입니다. <code>module</code> 함수를 사용하여 Koin 모듈을 선언합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myModule </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 여기에 의존성을 선언합니다</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 모듈에서 아래에 설명된 대로 컴포넌트를 선언할 수 있습니다.</p><h3 id="withoptions-dsl-옵션-3-2-버전부터" tabindex="-1">withOptions - DSL 옵션 (3.2 버전부터) <a class="header-anchor" href="#withoptions-dsl-옵션-3-2-버전부터" aria-label="Permalink to &quot;withOptions - DSL 옵션 (3.2 버전부터)&quot;">​</a></h3><p>새로운 <a href="/ko/koin/reference/koin-core/dsl-update">생성자 DSL</a> 정의와 마찬가지로, <code>withOptions</code> 연산자를 사용하여 &quot;일반&quot; 정의에 정의 옵션을 지정할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    single</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ClassA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) } </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        named</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;qualifier&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        createdAtStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 옵션 람다 내에서 다음 옵션들을 지정할 수 있습니다.</p><ul><li><code>named(&quot;a_qualifier&quot;)</code> - 정의에 문자열 한정자(qualifier)를 부여합니다.</li><li><code>named&lt;MyType&gt;()</code> - 정의에 타입 한정자(qualifier)를 부여합니다.</li><li><code>bind&lt;MyInterface&gt;()</code> - 주어진 빈 정의에 바인딩할 타입을 추가합니다.</li><li><code>binds(arrayOf(...))</code> - 주어진 빈 정의에 바인딩할 타입 배열을 추가합니다.</li><li><code>createdAtStart()</code> - Koin 시작 시 싱글톤 인스턴스를 생성합니다.</li></ul>`,35)]))}const g=a(o,[["render",n]]);export{k as __pageData,g as default};
