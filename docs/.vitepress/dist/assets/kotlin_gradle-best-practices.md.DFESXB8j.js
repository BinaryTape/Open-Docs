import{_ as i,C as n,c as o,o as p,ag as r,G as l,j as e,a as s}from"./chunks/framework.Bksy39di.js";const _=JSON.parse('{"title":"Gradle 最佳实践","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/gradle-best-practices.md","filePath":"kotlin/gradle-best-practices.md","lastUpdated":1754307826000}'),d={name:"kotlin/gradle-best-practices.md"};function h(c,a,k,g,u,b){const t=n("TopicTitle");return p(),o("div",null,[a[0]||(a[0]=r(`<h1 id="gradle-最佳实践" tabindex="-1">Gradle 最佳实践 <a class="header-anchor" href="#gradle-最佳实践" aria-label="Permalink to &quot;Gradle 最佳实践&quot;">​</a></h1><p><a href="https://docs.gradle.org/current/userguide/userguide.html" target="_blank" rel="noreferrer">Gradle</a> 是许多 Kotlin 项目用于自动化和管理构建过程的构建系统。</p><p>充分利用 Gradle 至关重要，它能帮助你减少管理和等待构建的时间，将更多时间用于编码。本文将一套最佳实践分为两个主要领域：<strong>组织</strong>和<strong>优化</strong>你的项目。</p><h2 id="组织" tabindex="-1">组织 <a class="header-anchor" href="#组织" aria-label="Permalink to &quot;组织&quot;">​</a></h2><p>本节重点介绍如何构建 Gradle 项目，以提高清晰度、可维护性和可伸缩性。</p><h3 id="使用-kotlin-dsl" tabindex="-1">使用 Kotlin DSL <a class="header-anchor" href="#使用-kotlin-dsl" aria-label="Permalink to &quot;使用 Kotlin DSL&quot;">​</a></h3><p>使用 Kotlin DSL 代替传统的 Groovy DSL。这样可以避免学习另一种语言，并获得严格类型带来的优势。严格类型支持 IDE 提供更好的重构和自动补全支持，从而提高开发效率。</p><p>关于更多信息，请参阅 <a href="https://docs.gradle.org/current/userguide/kotlin_dsl.html" target="_blank" rel="noreferrer">Gradle 的 Kotlin DSL 入门指南</a>。</p><p>关于 Kotlin DSL 成为 Gradle 构建的默认选项，请参阅 Gradle 的<a href="https://blog.gradle.org/kotlin-dsl-is-now-the-default-for-new-gradle-builds" target="_blank" rel="noreferrer">博客</a>。</p><h3 id="使用版本目录" tabindex="-1">使用版本目录 <a class="header-anchor" href="#使用版本目录" aria-label="Permalink to &quot;使用版本目录&quot;">​</a></h3><p>在 <code>libs.versions.toml</code> 文件中使用版本目录来集中管理依赖项。这使你能够在项目之间一致地定义和重用版本、库和插件。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[versions]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kotlinxCoroutines </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;1.10.2&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[libraries]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kotlinxCoroutines </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { module </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;org.jetbrains.kotlinx:kotlinx-coroutines-core&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, version.ref </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;kotlinxCoroutines&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>将以下依赖项添加到你的 <code>build.gradle.kts</code> 文件中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    implementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(libs.kotlinxCoroutines)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>关于 <a href="https://docs.gradle.org/current/userguide/dependency_management_basics.html#version_catalog" target="_blank" rel="noreferrer">依赖项管理基础知识</a>，请参阅 Gradle 的文档。</p>`,15)),l(t,{id:"使用约定插件",level:"3",title:"使用约定插件",labelRef:"advanced"}),a[1]||(a[1]=r('<p>使用约定插件可在多个构建文件之间封装和重用通用构建逻辑。将共享配置移入插件有助于简化构建脚本并使其模块化。</p><p>尽管初始设置可能耗时，但一旦完成，后续维护和添加新的构建逻辑将变得容易。</p><p>关于 <a href="https://docs.gradle.org/current/userguide/custom_plugins.html#sec:convention_plugins" target="_blank" rel="noreferrer">约定插件</a>，请参阅 Gradle 的文档。</p><h2 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to &quot;优化&quot;">​</a></h2><p>本节提供了提升 Gradle 构建性能和效率的策略。</p><h3 id="使用本地构建缓存" tabindex="-1">使用本地构建缓存 <a class="header-anchor" href="#使用本地构建缓存" aria-label="Permalink to &quot;使用本地构建缓存&quot;">​</a></h3><p>使用本地构建缓存，通过重用其他构建产生的输出节省时间。构建缓存可以从你已创建的任何早期构建中检索输出。</p><p>关于 <a href="https://docs.gradle.org/current/userguide/build_cache.html" target="_blank" rel="noreferrer">构建缓存</a>，请参阅 Gradle 的文档。</p><h3 id="使用配置缓存" tabindex="-1">使用配置缓存 <a class="header-anchor" href="#使用配置缓存" aria-label="Permalink to &quot;使用配置缓存&quot;">​</a></h3><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>配置缓存尚不支持所有核心 Gradle 插件。有关最新信息，请参阅 Gradle 的 <a href="https://docs.gradle.org/current/userguide/configuration_cache.html#config_cache:plugins:core" target="_blank" rel="noreferrer">支持插件表</a>。</p></div><p>使用配置缓存可显著提升构建性能，它通过缓存配置阶段的结果并在后续构建中重用该结果。如果 Gradle 检测到构建配置或相关依赖项没有变化，它将跳过配置阶段。</p><p>关于 <a href="https://docs.gradle.org/current/userguide/configuration_cache.html" target="_blank" rel="noreferrer">配置缓存</a>，请参阅 Gradle 的文档。</p><h3 id="缩短多目标平台的构建时间" tabindex="-1">缩短多目标平台的构建时间 <a class="header-anchor" href="#缩短多目标平台的构建时间" aria-label="Permalink to &quot;缩短多目标平台的构建时间&quot;">​</a></h3><p>当你的多平台项目包含多个目标平台时，<code>build</code> 和 <code>assemble</code> 等任务可能会为每个目标平台多次编译相同的代码，从而导致编译时间延长。</p><p>如果你正在积极开发和测试特定平台，请转而运行相应的 <code>linkDebug*</code> 任务。</p><p>关于更多信息，请参见 <a href="/kotlin/native-improving-compilation-time#gradle-configuration">优化编译时间的技巧</a>。</p><h3 id="从-kapt-迁移到-ksp" tabindex="-1">从 kapt 迁移到 KSP <a class="header-anchor" href="#从-kapt-迁移到-ksp" aria-label="Permalink to &quot;从 kapt 迁移到 KSP&quot;">​</a></h3><p>如果你正在使用的库依赖于 <a href="/kotlin/kapt">kapt</a> 编译器插件，请检测是否可以转而使用 <a href="/kotlin/ksp-overview">Kotlin 符号处理 (KSP) API</a>。KSP API 通过减少注解处理时间来提升构建性能。KSP 比 kapt 更快、更高效，因为它直接处理源代码，而无需生成中间 Java 存根。</p><p>关于迁移步骤的指导，请参见 Google 的<a href="https://developer.android.com/build/migrate-to-ksp" target="_blank" rel="noreferrer">迁移指南</a>。</p><p>要详细了解 KSP 与 kapt 的比较，请查阅 <a href="/kotlin/ksp-why-ksp">KSP 的优势</a>。</p>',20)),l(t,{id:"使用模块化",level:"3",title:"使用模块化",labelRef:"advanced"}),a[2]||(a[2]=r(`<div class="note custom-block"><p class="custom-block-title">NOTE</p><p>模块化仅适用于中大型项目。对于基于微服务架构的项目，它不提供优势。</p></div><p>使用模块化项目结构可以提高构建速度并实现更轻松的并行开发。将项目构建为包含一个根项目和一个或多个子项目的结构。如果更改仅影响其中一个子项目，Gradle 将仅重新构建该特定子项目。</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.</span></span>
<span class="line"><span>└── root-project/</span></span>
<span class="line"><span>    ├── settings.gradle.kts</span></span>
<span class="line"><span>    ├── app subproject/</span></span>
<span class="line"><span>    │   └── build.gradle.kts</span></span>
<span class="line"><span>    └── lib subproject/</span></span>
<span class="line"><span>        └── build.gradle.kts</span></span></code></pre></div><p>关于 <a href="https://docs.gradle.org/current/userguide/multi_project_builds.html" target="_blank" rel="noreferrer">使用 Gradle 构建项目</a>，请参阅 Gradle 的文档。</p>`,4)),l(t,{id:"设置-ci-cd",level:"3",title:"设置 CI/CD",labelRef:"advanced"}),a[3]||(a[3]=e("p",null,[s("设置 CI/CD 流程可显著减少构建时间，方法是使用增量构建和缓存依赖项。添加持久化存储或使用远程构建缓存即可获得这些优势。此过程不必耗时，因为像 "),e("a",{href:"https://github.com/features/actions",target:"_blank",rel:"noreferrer"},"GitHub"),s(" 这样的某些提供商几乎提供开箱即用的此项服务。")],-1)),a[4]||(a[4]=e("p",null,[s("请查阅 Gradle 社区手册中关于 "),e("a",{href:"https://cookbook.gradle.org/ci/",target:"_blank",rel:"noreferrer"},"将 Gradle 与持续集成系统结合使用"),s(" 的内容。")],-1)),l(t,{id:"使用远程构建缓存",level:"3",title:"使用远程构建缓存",labelRef:"advanced"}),a[5]||(a[5]=e("p",null,[s("与 "),e("a",{href:"#use-local-build-cache"},"本地构建缓存"),s(" 类似，远程构建缓存通过重用其他构建的输出帮助你节省时间。它不仅可以从上次运行的构建中检索任务输出，还可以从任何人已运行过的任何早期构建中检索。")],-1)),a[6]||(a[6]=e("p",null,"远程构建缓存使用缓存服务器在构建之间共享任务输出。例如，在包含 CI/CD 服务器的开发环境中，服务器上的所有构建都会填充远程缓存。当你检出主分支以开始新特性开发时，可以立即访问增量构建。",-1)),a[7]||(a[7]=e("p",null,"请记住，缓慢的互联网连接可能会导致传输缓存结果比在本地运行任务更慢。",-1)),a[8]||(a[8]=e("p",null,[s("关于 "),e("a",{href:"https://docs.gradle.org/current/userguide/build_cache.html",target:"_blank",rel:"noreferrer"},"构建缓存"),s("，请参阅 Gradle 的文档。")],-1))])}const m=i(d,[["render",h]]);export{_ as __pageData,m as default};
