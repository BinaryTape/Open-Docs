import{_ as k,C as e,c as d,o,ag as h,j as s,G as t,a as i,w as n}from"./chunks/framework.Bksy39di.js";const b=JSON.parse('{"title":"KotlinからのJavaの呼び出し","description":"","frontmatter":{},"headers":[],"relativePath":"ja/kotlin/java-interop.md","filePath":"ja/kotlin/java-interop.md","lastUpdated":1754307826000}'),r={name:"ja/kotlin/java-interop.md"};function E(c,a,g,y,u,F){const l=e("tab"),p=e("tabs");return o(),d("div",null,[a[2]||(a[2]=h(`<h1 id="kotlinからのjavaの呼び出し" tabindex="-1">KotlinからのJavaの呼び出し <a class="header-anchor" href="#kotlinからのjavaの呼び出し" aria-label="Permalink to &quot;KotlinからのJavaの呼び出し&quot;">​</a></h1><p>KotlinはJavaとの相互運用性を考慮して設計されています。既存のJavaコードはKotlinから自然な形で呼び出すことができ、KotlinコードもJavaからスムーズに使用できます。このセクションでは、KotlinからJavaコードを呼び出す際の詳細について説明します。</p><p>ほぼすべてのJavaコードは問題なく使用できます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> java.util.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> demo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(source: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // &#39;for&#39;-loops work for Java collections:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Operator conventions work as well:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">source.size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        list[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source[i] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// get and set are called</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="ゲッターとセッター" tabindex="-1">ゲッターとセッター <a class="header-anchor" href="#ゲッターとセッター" aria-label="Permalink to &quot;ゲッターとセッター&quot;">​</a></h2><p>Javaのゲッターとセッターの規約（<code>get</code>で始まる引数なしのメソッド、<code>set</code>で始まる単一引数のメソッド）に従うメソッドは、Kotlinではプロパティとして表現されます。このようなプロパティは<em>合成プロパティ</em>（<em>synthetic properties</em>）とも呼ばれます。<code>Boolean</code>アクセサメソッド（ゲッターの名前が<code>is</code>で始まり、セッターの名前が<code>set</code>で始まるもの）は、ゲッターメソッドと同じ名前を持つプロパティとして表現されます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> java.util.Calendar</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> calendarDemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> calendar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Calendar.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (calendar.firstDayOfWeek </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Calendar.SUNDAY) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// call getFirstDayOfWeek()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        calendar.firstDayOfWeek </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Calendar.MONDAY </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// call setFirstDayOfWeek()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">calendar.isLenient) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// call isLenient()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        calendar.isLenient </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // call setLenient()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>上記の<code>calendar.firstDayOfWeek</code>は、合成プロパティの一例です。</p><p>なお、Javaクラスがセッターしか持たない場合、Kotlinはセット専用プロパティをサポートしないため、Kotlinではプロパティとして表示されません。</p><h2 id="java合成プロパティ参照" tabindex="-1">Java合成プロパティ参照 <a class="header-anchor" href="#java合成プロパティ参照" aria-label="Permalink to &quot;Java合成プロパティ参照&quot;">​</a></h2><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>この機能は<a href="/ja/kotlin/components-stability#stability-levels-explained">実験的（Experimental）</a>です。いつでも廃止または変更される可能性があります。 評価目的でのみ使用することをお勧めします。</p></div><p>Kotlin 1.8.20以降、Java合成プロパティへの参照を作成できるようになりました。以下のJavaコードを考えてみましょう。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String name;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getAge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Kotlinでは常に<code>person.age</code>と書くことができ、<code>age</code>は合成プロパティです。これに加えて、<code>Person::age</code>や<code>person::age</code>への参照も作成できるようになりました。<code>name</code>についても同様です。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> persons </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Jack&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Sofie&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Peter&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    persons</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // Call a reference to Java synthetic property:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sortedBy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Person::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // Call Java getter via the Kotlin property syntax:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person.name) }</span></span></code></pre></div>`,15)),a[3]||(a[3]=s("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"java合成プロパティ参照を有効にする方法",tabindex:"-1"},[i("Java合成プロパティ参照を有効にする方法 "),s("a",{class:"header-anchor",href:"#java合成プロパティ参照を有効にする方法","aria-label":'Permalink to "Java合成プロパティ参照を有効にする方法 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),a[4]||(a[4]=s("p",null,[i("この機能を有効にするには、"),s("code",null,"-language-version 2.1"),i("コンパイラオプションを設定します。Gradleプロジェクトでは、"),s("code",null,"build.gradle(.kts)"),i("に以下を追加することで設定できます。")],-1)),t(p,{group:"build-script"},{default:n(()=>[t(l,{title:"Kotlin","group-key":"kotlin"},{default:n(()=>a[0]||(a[0]=[s("div",{class:"language-kotlin vp-adaptive-theme"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"kotlin"),s("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"tasks")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    ."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"withType"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"org"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"jetbrains"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"gradle"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"tasks"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"KotlinCompilationTask"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<*>>()")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    ."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"configureEach"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        compilerOptions")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            .languageVersion")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            ."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"set"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"                org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_2_1")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            )")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")])])])],-1)])),_:1}),t(l,{title:"Groovy","group-key":"groovy"},{default:n(()=>a[1]||(a[1]=[s("div",{class:"language-groovy vp-adaptive-theme"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"groovy"),s("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"tasks")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    .withType("),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"org.jetbrains.kotlin.gradle.tasks.KotlinCompilationTask."),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"class)")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    .configureEach {")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        compilerOptions"),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"languageVersion")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"            ="),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}}," org.jetbrains.kotlin.gradle.dsl.KotlinVersion."),s("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"KOTLIN_2_1")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),a[5]||(a[5]=h(`<div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Kotlin 1.9.0より前では、この機能を有効にするには<code>-language-version 1.9</code>コンパイラオプションを設定する必要がありました。</p></div><h2 id="voidを返すメソッド" tabindex="-1"><code>void</code>を返すメソッド <a class="header-anchor" href="#voidを返すメソッド" aria-label="Permalink to &quot;\`void\`を返すメソッド&quot;">​</a></h2><p>Javaメソッドが<code>void</code>を返す場合、Kotlinから呼び出すと<code>Unit</code>を返します。 もしその戻り値が何らかの形で使用されたとしても、値自体は事前にわかっているため（<code>Unit</code>であるため）、Kotlinコンパイラによって呼び出し元で割り当てられます。</p><h2 id="kotlinのキーワードであるjava識別子のエスケープ" tabindex="-1">KotlinのキーワードであるJava識別子のエスケープ <a class="header-anchor" href="#kotlinのキーワードであるjava識別子のエスケープ" aria-label="Permalink to &quot;KotlinのキーワードであるJava識別子のエスケープ&quot;">​</a></h2><p>Kotlinの一部のキーワードは、Javaでは有効な識別子です。例えば、<code>in</code>、<code>object</code>、<code>is</code>などです。 JavaライブラリがKotlinのキーワードをメソッド名に使用している場合でも、バッククォート（\`）文字でエスケープすることでメソッドを呼び出すことができます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">\`is\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bar)</span></span></code></pre></div><h2 id="null安全性とプラットフォーム型" tabindex="-1">Null安全性とプラットフォーム型 <a class="header-anchor" href="#null安全性とプラットフォーム型" aria-label="Permalink to &quot;Null安全性とプラットフォーム型&quot;">​</a></h2><p>Javaのすべての参照は<code>null</code>になる可能性があるため、Javaから来るオブジェクトに対してKotlinの厳格なNull安全性の要件を適用するのは現実的ではありません。 Javaの宣言の型はKotlinでは特定の方法で扱われ、<em>プラットフォーム型</em>と呼ばれます。これらの型に対してはNullチェックが緩和され、安全性保証はJavaと同じになります（詳細は<a href="#mapped-types">以下</a>を参照）。</p><p>以下の例を考えてみましょう。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// non-null (constructor result)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Item&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list.size </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// non-null (primitive int)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// platform type inferred (ordinary Java object)</span></span></code></pre></div><p>プラットフォーム型の変数に対してメソッドを呼び出す場合、Kotlinはコンパイル時にNull許容性エラーを発行しませんが、Nullポインター例外またはKotlinがNullの伝播を防ぐために生成するアサーションによって、実行時に呼び出しが失敗する可能性があります。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">item.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">substring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// allowed, throws an exception if item == null</span></span></code></pre></div><p>プラットフォーム型は<em>表記不可能</em>（non-denotable）であり、言語で明示的に記述することはできません。 プラットフォーム値がKotlin変数に割り当てられる場合、型推論に頼るか（上記の例の<code>item</code>のように、変数は推論されたプラットフォーム型になります）、または期待する型を選択できます（Null許容型と非Null許容型の両方が許可されます）。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nullable: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// allowed, always works</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> notNull: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// allowed, may fail at runtime</span></span></code></pre></div><p>非Null許容型を選択した場合、コンパイラは代入時にアサーションを出力します。これにより、Kotlinの非Null許容変数がNullを保持することを防ぎます。アサーションは、プラットフォーム値を非Null値を期待するKotlin関数に渡す場合や、その他の場合にも出力されます。 全体として、ジェネリクスによっては完全に排除できない場合もありますが、コンパイラはプログラム全体にNullが伝播しないように最善を尽くします。</p><h3 id="プラットフォーム型の表記法" tabindex="-1">プラットフォーム型の表記法 <a class="header-anchor" href="#プラットフォーム型の表記法" aria-label="Permalink to &quot;プラットフォーム型の表記法&quot;">​</a></h3><p>前述のとおり、プラットフォーム型はプログラム中で明示的に言及できないため、言語にはそれらを記述するための構文がありません。 しかし、コンパイラやIDEは（エラーメッセージやパラメータ情報などで）それらを表示する必要がある場合があるため、ニーモニック表記が存在します。</p><ul><li><code>T!</code> は「<code>T</code>または<code>T?</code>」を意味します。</li><li><code>(Mutable)Collection&lt;T&gt;!</code> は「<code>T</code>のJavaコレクション。可変または不変、Null許容または非Null許容」を意味します。</li><li><code>Array&lt;(out) T&gt;!</code> は「<code>T</code>（または<code>T</code>のサブタイプ）のJava配列。Null許容または非Null許容」を意味します。</li></ul><h3 id="null許容性アノテーション" tabindex="-1">Null許容性アノテーション <a class="header-anchor" href="#null許容性アノテーション" aria-label="Permalink to &quot;Null許容性アノテーション&quot;">​</a></h3><p>Null許容性アノテーションを持つJava型は、プラットフォーム型としてではなく、実際のNull許容または非Null許容Kotlin型として表現されます。コンパイラは、いくつかの種類のNull許容性アノテーションをサポートしています。</p><ul><li><a href="https://www.jetbrains.com/idea/help/nullable-and-notnull-annotations.html" target="_blank" rel="noreferrer">JetBrains</a> (<code>org.jetbrains.annotations</code>パッケージの<code>@Nullable</code>および<code>@NotNull</code>)</li><li><a href="https://jspecify.dev/" target="_blank" rel="noreferrer">JSpecify</a> (<code>org.jspecify.annotations</code>)</li><li>Android (<code>com.android.annotations</code>および<code>android.support.annotations</code>)</li><li>JSR-305 (<code>javax.annotation</code>、詳細は以下を参照)</li><li>FindBugs (<code>edu.umd.cs.findbugs.annotations</code>)</li><li>Eclipse (<code>org.eclipse.jdt.annotation</code>)</li><li>Lombok (<code>lombok.NonNull</code>)</li><li>RxJava 3 (<code>io.reactivex.rxjava3.annotations</code>)</li></ul><p>特定の種類のNull許容性アノテーションからの情報に基づいて、コンパイラがNull許容性の不一致を報告するかどうかを指定できます。コンパイラオプション<code>-Xnullability-annotations=@&lt;package-name&gt;:&lt;report-level&gt;</code>を使用します。引数には、完全修飾されたNull許容性アノテーションパッケージと、以下のいずれかのレポートレベルを指定します。</p><ul><li><code>ignore</code>: Null許容性の不一致を無視します。</li><li><code>warn</code>: 警告を報告します。</li><li><code>strict</code>: エラーを報告します。</li></ul><p>サポートされているNull許容性アノテーションの完全なリストは、<a href="https://github.com/JetBrains/kotlin/blob/master/core/compiler.common.jvm/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt" target="_blank" rel="noreferrer">Kotlinコンパイラのソースコード</a>で確認できます。</p><h3 id="型引数と型パラメータのアノテーション" tabindex="-1">型引数と型パラメータのアノテーション <a class="header-anchor" href="#型引数と型パラメータのアノテーション" aria-label="Permalink to &quot;型引数と型パラメータのアノテーション&quot;">​</a></h3><p>総称型（generic types）の型引数と型パラメータにもNull許容性情報を指定するアノテーションを付けることができます。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>このセクションのすべての例では、<code>org.jetbrains.annotations</code>パッケージのJetBrains Null許容性アノテーションを使用しています。</p></div><h4 id="型引数" tabindex="-1">型引数 <a class="header-anchor" href="#型引数" aria-label="Permalink to &quot;型引数&quot;">​</a></h4><p>Javaの宣言に付けられたこれらのアノテーションを考えてみましょう。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Set</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Collection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elements) { ... }</span></span></code></pre></div><p>これらはKotlinで以下のシグネチャになります。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mutable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Collection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) : (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mutable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span></code></pre></div><p>型引数から<code>@NotNull</code>アノテーションが欠落している場合、代わりにプラットフォーム型が得られます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mutable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Collection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">!&gt;) : (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mutable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">!&gt; { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span></code></pre></div><p>Kotlinは、基底クラスやインターフェースの型引数に関するNull許容性アノテーションも考慮します。例えば、以下に示すシグネチャを持つ2つのJavaクラスがあるとします。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Derived</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nullable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p>Kotlinコードでは、<code>Base&lt;String&gt;</code>が想定される場所で<code>Derived</code>のインスタンスを渡すと、警告が生成されます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> takeBaseOfNotNullStrings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    takeBaseOfNotNullStrings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Derived</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// warning: nullability mismatch</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>Derived</code>の上限は<code>Base&lt;String?&gt;</code>に設定されており、これは<code>Base&lt;String&gt;</code>とは異なります。</p><p><a href="#java-generics-in-kotlin">KotlinにおけるJavaジェネリクス</a>の詳細をご覧ください。</p><h4 id="型パラメータ" tabindex="-1">型パラメータ <a class="header-anchor" href="#型パラメータ" aria-label="Permalink to &quot;型パラメータ&quot;">​</a></h4><p>デフォルトでは、KotlinとJavaの両方におけるプレーンな型パラメータのNull許容性は未定義です。Javaでは、Null許容性アノテーションを使用してそれを指定できます。<code>Base</code>クラスの型パラメータにアノテーションを付けてみましょう。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p><code>Base</code>から継承する場合、Kotlinは非Null許容の型引数または型パラメータを期待します。 したがって、以下のKotlinコードは警告を生成します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Derived</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// warning: K has undefined nullability</span></span></code></pre></div><p><code>K : Any</code>という上限を指定することで、これを修正できます。</p><p>Kotlinは、Javaの型パラメータの上限に対するNull許容性アノテーションもサポートしています。<code>Base</code>に上限を追加してみましょう。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BaseWithBound</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p>Kotlinはこれを以下のように変換します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BaseWithBound</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p>そのため、Null許容型を型引数または型パラメータとして渡すと警告が生成されます。</p><p>型引数と型パラメータのアノテーションは、Java 8以降のターゲットで動作します。この機能は、Null許容性アノテーションが<code>TYPE_USE</code>ターゲットをサポートしている必要があります（<code>org.jetbrains.annotations</code>はバージョン15以降でこれをサポートしています）。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Null許容性アノテーションが<code>TYPE_USE</code>ターゲットに加えて型に適用可能な他のターゲットをサポートしている場合、<code>TYPE_USE</code>が優先されます。例えば、<code>@Nullable</code>が<code>TYPE_USE</code>と<code>METHOD</code>の両方のターゲットを持つ場合、Javaのメソッドシグネチャ<code>@Nullable String[] f()</code>はKotlinで<code>fun f(): Array&lt;String?&gt;!</code>になります。</p></div><h3 id="jsr-305サポート" tabindex="-1">JSR-305サポート <a class="header-anchor" href="#jsr-305サポート" aria-label="Permalink to &quot;JSR-305サポート&quot;">​</a></h3><p><a href="https://jcp.org/en/jsr/detail?id=305" target="_blank" rel="noreferrer">JSR-305</a>で定義されている<a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/Nonnull.html" target="_blank" rel="noreferrer"><code>@Nonnull</code></a>アノテーションは、Java型のNull許容性を示すためにサポートされています。</p><p><code>@Nonnull(when = ...)</code>の値が<code>When.ALWAYS</code>の場合、アノテーションが付けられた型は非Null許容として扱われます。<code>When.MAYBE</code>と<code>When.NEVER</code>はNull許容型を示し、<code>When.UNKNOWN</code>は型を<a href="#null-safety-and-platform-types">プラットフォーム型</a>に強制します。</p><p>ライブラリはJSR-305アノテーションに対してコンパイルできますが、アノテーションアーティファクト（例：<code>jsr305.jar</code>）をライブラリ利用者のコンパイル依存関係にする必要はありません。Kotlinコンパイラは、クラスパスにアノテーションが存在しなくても、ライブラリからJSR-305アノテーションを読み取ることができます。</p><p><a href="https://github.com/Kotlin/KEEP/blob/master/proposals/jsr-305-custom-nullability-qualifiers.md" target="_blank" rel="noreferrer">カスタムNull許容性修飾子 (KEEP-79)</a>もサポートされています（以下参照）。</p><h4 id="型修飾子ニックネーム" tabindex="-1">型修飾子ニックネーム <a class="header-anchor" href="#型修飾子ニックネーム" aria-label="Permalink to &quot;型修飾子ニックネーム&quot;">​</a></h4><p>アノテーション型が<a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/meta/TypeQualifierNickname.html" target="_blank" rel="noreferrer"><code>@TypeQualifierNickname</code></a>とJSR-305の<code>@Nonnull</code>（または<code>@CheckForNull</code>などの別のニックネーム）の両方でアノテーションされている場合、そのアノテーション型自体が正確なNull許容性を取得するために使用され、そのNull許容性アノテーションと同じ意味を持ちます。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierNickname</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">when</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> When.ALWAYS)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Retention</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RetentionPolicy.RUNTIME)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> MyNonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierNickname</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CheckForNull</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a nickname to another type qualifier nickname</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Retention</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RetentionPolicy.RUNTIME)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> MyNullable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">MyNullable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">MyNonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // in Kotlin (strict mode): \`fun foo(x: String): String?\`</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(List&lt;@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">MyNonnull</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // in Kotlin (strict mode): \`fun bar(x: List&lt;String&gt;!): String!\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="型修飾子デフォルト" tabindex="-1">型修飾子デフォルト <a class="header-anchor" href="#型修飾子デフォルト" aria-label="Permalink to &quot;型修飾子デフォルト&quot;">​</a></h4><p><a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/meta/TypeQualifierDefault.html" target="_blank" rel="noreferrer"><code>@TypeQualifierDefault</code></a>は、適用されると、アノテーションされた要素のスコープ内でデフォルトのNull許容性を定義するアノテーションを導入することができます。</p><p>このようなアノテーション型は、それ自体が<code>@Nonnull</code>（またはそのニックネーム）と<code>@TypeQualifierDefault(...)</code>の両方で、1つ以上の<code>ElementType</code>値と共にアノテーションされている必要があります。</p><ul><li><code>ElementType.METHOD</code>: メソッドの戻り値の型</li><li><code>ElementType.PARAMETER</code>: 値パラメータ</li><li><code>ElementType.FIELD</code>: フィールド</li><li><code>ElementType.TYPE_USE</code>: 型引数、型パラメータの上限、ワイルドカード型を含む任意の型</li></ul><p>デフォルトのNull許容性は、型自体にNull許容性アノテーションが付けられていない場合に使用され、デフォルトは、型使用法に一致する<code>ElementType</code>を持つ型修飾子デフォルトアノテーションでアノテーションされた最も内側の囲む要素によって決定されます。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ElementType.METHOD, ElementType.PARAMETER})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NonNullApi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">when</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> When.MAYBE)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE_USE})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NullableApi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NullableApi</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fun foo(x: String?): String?</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNullApi</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // overriding default from the interface</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nullable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fun bar(x: String, y: String?): String</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // The List&lt;String&gt; type argument is seen as nullable because of \`@NullableApi\`</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // having the \`TYPE_USE\` element type:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">baz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fun baz(List&lt;String?&gt;?): String?</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // The type of \`x\` parameter remains platform because there&#39;s an explicit</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // UNKNOWN-marked nullability annotation:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">qux</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">when</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> When.UNKNOWN) String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fun baz(x: String!): String?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>この例の型は、strictモードが有効な場合にのみ適用されます。それ以外の場合、プラットフォーム型はそのまま残ります。 <a href="#undermigration-annotation"><code>@UnderMigration</code>アノテーション</a>と<a href="#compiler-configuration">コンパイラ設定</a>のセクションを参照してください。</p></div><p>パッケージレベルのデフォルトNull許容性もサポートされています。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// FILE: test/package-info.java</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NonNullApi</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // declaring all types in package &#39;test&#39; as non-nullable by default</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test;</span></span></code></pre></div><h4 id="undermigrationアノテーション" tabindex="-1"><code>@UnderMigration</code>アノテーション <a class="header-anchor" href="#undermigrationアノテーション" aria-label="Permalink to &quot;\`@UnderMigration\`アノテーション&quot;">​</a></h4><p><code>@UnderMigration</code>アノテーション（<code>kotlin-annotations-jvm</code>という別個のアーティファクトで提供）は、ライブラリのメンテナーがNull許容性型修飾子の移行ステータスを定義するために使用できます。</p><p><code>@UnderMigration(status = ...)</code>のステータス値は、アノテーション付き型のKotlinでの不適切な使用（例：<code>@MyNullable</code>アノテーション付き型値を非Nullとして使用する）をコンパイラがどのように扱うかを指定します。</p><ul><li><code>MigrationStatus.STRICT</code>: アノテーションを通常のNull許容性アノテーションとして機能させ、不適切な使用に対してエラーを報告し、アノテーション付き宣言内の型にKotlinで認識されるように影響を与えます。</li><li><code>MigrationStatus.WARN</code>: 不適切な使用はエラーではなくコンパイル警告として報告されますが、アノテーション付き宣言内の型はプラットフォーム型として残ります。</li><li><code>MigrationStatus.IGNORE</code>: コンパイラがNull許容性アノテーションを完全に無視します。</li></ul><p>ライブラリのメンテナーは、型修飾子のニックネームと型修飾子のデフォルトの両方に<code>@UnderMigration</code>ステータスを追加できます。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">when</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> When.ALWAYS)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ElementType.METHOD, ElementType.PARAMETER})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UnderMigration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">status</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MigrationStatus.WARN)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NonNullApi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// The types in the class are non-nullable, but only warnings are reported</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// because \`@NonNullApi\` is annotated \`@UnderMigration(status = MigrationStatus.WARN)\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NonNullApi</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Null許容性アノテーションの移行ステータスは、その型修飾子ニックネームには継承されませんが、デフォルトの型修飾子での使用には適用されます。</p></div><p>デフォルトの型修飾子が型修飾子のニックネームを使用し、それらが両方とも<code>@UnderMigration</code>である場合、デフォルトの型修飾子からのステータスが使用されます。</p><h4 id="コンパイラ設定" tabindex="-1">コンパイラ設定 <a class="header-anchor" href="#コンパイラ設定" aria-label="Permalink to &quot;コンパイラ設定&quot;">​</a></h4><p>JSR-305のチェックは、以下のオプション（およびその組み合わせ）とともに<code>-Xjsr305</code>コンパイラフラグを追加することで設定できます。</p><ul><li><p><code>-Xjsr305={strict|warn|ignore}</code>: <code>@UnderMigration</code>アノテーションではないアノテーションの動作を設定します。 カスタムNull許容性修飾子、特に<code>@TypeQualifierDefault</code>は、すでに多くの著名なライブラリに普及しており、ユーザーはJSR-305サポートを含むKotlinバージョンに更新する際にスムーズに移行する必要があるかもしれません。Kotlin 1.1.60以降、このフラグは<code>@UnderMigration</code>アノテーションではないものにのみ影響します。</p></li><li><p><code>-Xjsr305=under-migration:{strict|warn|ignore}</code>: <code>@UnderMigration</code>アノテーションの動作を上書きします。 ユーザーはライブラリの移行ステータスについて異なる見解を持つかもしれません。公式の移行ステータスが<code>WARN</code>であるにもかかわらずエラーを発生させたい場合や、その逆の場合、または一部のエラー報告を移行が完了するまで延期したい場合があります。</p></li><li><p><code>-Xjsr305=@&lt;fq.name&gt;:{strict|warn|ignore}</code>: 単一のアノテーションの動作を上書きします。<code>&lt;fq.name&gt;</code>はアノテーションの完全修飾クラス名です。異なるアノテーションに対して複数回出現する場合があります。これは特定のライブラリの移行状態を管理するのに役立ちます。</p></li></ul><p><code>strict</code>、<code>warn</code>、<code>ignore</code>の値は<code>MigrationStatus</code>と同じ意味を持ち、<code>strict</code>モードのみがアノテーション付き宣言内の型にKotlinで認識されるように影響します。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>注：組み込みのJSR-305アノテーション<a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/Nonnull.html" target="_blank" rel="noreferrer"><code>@Nonnull</code></a>、 <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/3.0.1/javax/annotation/Nullable.html" target="_blank" rel="noreferrer"><code>@Nullable</code></a>、 <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/CheckForNull.html" target="_blank" rel="noreferrer"><code>@CheckForNull</code></a>は常に有効であり、 <code>-Xjsr305</code>フラグによるコンパイラ設定に関わらず、Kotlinにおけるアノテーション付き宣言の型に影響を与えます。</p></div><p>例えば、コンパイラ引数に<code>-Xjsr305=ignore -Xjsr305=under-migration:ignore -Xjsr305=@org.library.MyNullable:warn</code>を追加すると、コンパイラは<code>@org.library.MyNullable</code>でアノテーションされた型の不適切な使用に対して警告を生成し、他のすべてのJSR-305アノテーションを無視します。</p><p>デフォルトの動作は<code>-Xjsr305=warn</code>と同じです。<code>strict</code>の値は実験的と見なすべきです（将来的により多くのチェックが追加される可能性があります）。</p><h2 id="マップされる型" tabindex="-1">マップされる型 <a class="header-anchor" href="#マップされる型" aria-label="Permalink to &quot;マップされる型&quot;">​</a></h2><p>Kotlinは、特定のJava型を特別に扱います。これらの型はJavaから「そのまま」ロードされるのではなく、対応するKotlin型に<em>マップ</em>されます。マッピングはコンパイル時にのみ重要であり、実行時の表現は変更されません。 Javaのプリミティブ型は、対応するKotlin型にマップされます（<a href="#null-safety-and-platform-types">プラットフォーム型</a>を考慮して）。</p><table tabindex="0"><thead><tr><th><strong>Java型</strong></th><th><strong>Kotlin型</strong></th></tr></thead><tbody><tr><td><code>byte</code></td><td><code>kotlin.Byte</code></td></tr><tr><td><code>short</code></td><td><code>kotlin.Short</code></td></tr><tr><td><code>int</code></td><td><code>kotlin.Int</code></td></tr><tr><td><code>long</code></td><td><code>kotlin.Long</code></td></tr><tr><td><code>char</code></td><td><code>kotlin.Char</code></td></tr><tr><td><code>float</code></td><td><code>kotlin.Float</code></td></tr><tr><td><code>double</code></td><td><code>kotlin.Double</code></td></tr><tr><td><code>boolean</code></td><td><code>kotlin.Boolean</code></td></tr></tbody></table><p>一部の非プリミティブな組み込みクラスもマップされます。</p><table tabindex="0"><thead><tr><th><strong>Java型</strong></th><th><strong>Kotlin型</strong></th></tr></thead><tbody><tr><td><code>java.lang.Object</code></td><td><code>kotlin.Any!</code></td></tr><tr><td><code>java.lang.Cloneable</code></td><td><code>kotlin.Cloneable!</code></td></tr><tr><td><code>java.lang.Comparable</code></td><td><code>kotlin.Comparable!</code></td></tr><tr><td><code>java.lang.Enum</code></td><td><code>kotlin.Enum!</code></td></tr><tr><td><code>java.lang.annotation.Annotation</code></td><td><code>kotlin.Annotation!</code></td></tr><tr><td><code>java.lang.CharSequence</code></td><td><code>kotlin.CharSequence!</code></td></tr><tr><td><code>java.lang.String</code></td><td><code>kotlin.String!</code></td></tr><tr><td><code>java.lang.Number</code></td><td><code>kotlin.Number!</code></td></tr><tr><td><code>java.lang.Throwable</code></td><td><code>kotlin.Throwable!</code></td></tr></tbody></table><p>Javaのボックス化されたプリミティブ型は、Null許容Kotlin型にマップされます。</p><table tabindex="0"><thead><tr><th><strong>Java型</strong></th><th><strong>Kotlin型</strong></th></tr></thead><tbody><tr><td><code>java.lang.Byte</code></td><td><code>kotlin.Byte?</code></td></tr><tr><td><code>java.lang.Short</code></td><td><code>kotlin.Short?</code></td></tr><tr><td><code>java.lang.Integer</code></td><td><code>kotlin.Int?</code></td></tr><tr><td><code>java.lang.Long</code></td><td><code>kotlin.Long?</code></td></tr><tr><td><code>java.lang.Character</code></td><td><code>kotlin.Char?</code></td></tr><tr><td><code>java.lang.Float</code></td><td><code>kotlin.Float?</code></td></tr><tr><td><code>java.lang.Double</code></td><td><code>kotlin.Double?</code></td></tr><tr><td><code>java.lang.Boolean</code></td><td><code>kotlin.Boolean?</code></td></tr></tbody></table><p>型パラメータとして使用されるボックス化されたプリミティブ型は、プラットフォーム型にマップされることに注意してください。 例えば、<code>List&lt;java.lang.Integer&gt;</code>はKotlinでは<code>List&lt;Int!&gt;</code>になります。</p><p>コレクション型はKotlinでは読み取り専用または可変になる場合があるため、Javaのコレクションは次のようにマップされます（この表のすべてのKotlin型は<code>kotlin.collections</code>パッケージにあります）。</p><table tabindex="0"><thead><tr><th><strong>Java型</strong></th><th><strong>Kotlin読み取り専用型</strong></th><th><strong>Kotlin可変型</strong></th><th><strong>ロードされるプラットフォーム型</strong></th></tr></thead><tbody><tr><td><code>Iterator&lt;T&gt;</code></td><td><code>Iterator&lt;T&gt;</code></td><td><code>MutableIterator&lt;T&gt;</code></td><td><code>(Mutable)Iterator&lt;T&gt;!</code></td></tr><tr><td><code>Iterable&lt;T&gt;</code></td><td><code>Iterable&lt;T&gt;</code></td><td><code>MutableIterable&lt;T&gt;</code></td><td><code>(Mutable)Iterable&lt;T&gt;!</code></td></tr><tr><td><code>Collection&lt;T&gt;</code></td><td><code>Collection&lt;T&gt;</code></td><td><code>MutableCollection&lt;T&gt;</code></td><td><code>(Mutable)Collection&lt;T&gt;!</code></td></tr><tr><td><code>Set&lt;T&gt;</code></td><td><code>Set&lt;T&gt;</code></td><td><code>MutableSet&lt;T&gt;</code></td><td><code>(Mutable)Set&lt;T&gt;!</code></td></tr><tr><td><code>List&lt;T&gt;</code></td><td><code>List&lt;T&gt;</code></td><td><code>MutableList&lt;T&gt;</code></td><td><code>(Mutable)List&lt;T&gt;!</code></td></tr><tr><td><code>ListIterator&lt;T&gt;</code></td><td><code>ListIterator&lt;T&gt;</code></td><td><code>MutableListIterator&lt;T&gt;</code></td><td><code>(Mutable)ListIterator&lt;T&gt;!</code></td></tr><tr><td><code>Map&lt;K, V&gt;</code></td><td><code>Map&lt;K, V&gt;</code></td><td><code>MutableMap&lt;K, V&gt;</code></td><td><code>(Mutable)Map&lt;K, V&gt;!</code></td></tr><tr><td><code>Map.Entry&lt;K, V&gt;</code></td><td><code>Map.Entry&lt;K, V&gt;</code></td><td><code>MutableMap.MutableEntry&lt;K,V&gt;</code></td><td><code>(Mutable)Map.(Mutable)Entry&lt;K, V&gt;!</code></td></tr></tbody></table><p>Javaの配列は、<a href="#java-arrays">以下</a>で述べられているようにマップされます。</p><table tabindex="0"><thead><tr><th><strong>Java型</strong></th><th><strong>Kotlin型</strong></th></tr></thead><tbody><tr><td><code>int[]</code></td><td><code>kotlin.IntArray!</code></td></tr><tr><td><code>String[]</code></td><td><code>kotlin.Array&lt;(out) String!&gt;!</code></td></tr></tbody></table><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>これらのJava型の静的メンバーは、Kotlin型の<a href="/ja/kotlin/object-declarations#companion-objects">コンパニオンオブジェクト</a>では直接アクセスできません。それらを呼び出すには、<code>java.lang.Integer.toHexString(foo)</code>のように、Java型の完全修飾名を使用します。</p></div><h2 id="kotlinにおけるjavaジェネリクス" tabindex="-1">KotlinにおけるJavaジェネリクス <a class="header-anchor" href="#kotlinにおけるjavaジェネリクス" aria-label="Permalink to &quot;KotlinにおけるJavaジェネリクス&quot;">​</a></h2><p>KotlinのジェネリクスはJavaのジェネリクスとは少し異なります（<a href="/ja/kotlin/generics">ジェネリクス</a>を参照）。 Java型をKotlinにインポートする際、以下の変換が行われます。</p><ul><li><p>Javaのワイルドカードは型プロジェクションに変換されます。</p><ul><li><code>Foo&lt;? extends Bar&gt;</code> は <code>Foo&lt;out Bar!&gt;!</code> になります。</li><li><code>Foo&lt;? super Bar&gt;</code> は <code>Foo&lt;in Bar!&gt;!</code> になります。</li></ul></li><li><p>Javaの生の型（raw types）はスタープロジェクションに変換されます。</p><ul><li><code>List</code> は <code>List&lt;*&gt;!</code>、つまり <code>List&lt;out Any?&gt;!</code> になります。</li></ul></li></ul><p>Javaと同様に、Kotlinのジェネリクスは実行時には保持されません。オブジェクトはコンストラクタに渡された実際の型引数に関する情報を持ちません。例えば、<code>ArrayList&lt;Integer&gt;()</code>と<code>ArrayList&lt;Character&gt;()</code>は区別できません。 このため、ジェネリクスを考慮した<code>is</code>チェックを実行することは不可能です。 Kotlinでは、スタープロジェクションされた総称型に対してのみ<code>is</code>チェックが可能です。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Error: cannot check if it is really a List of Ints</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// but</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;*&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK: no guarantees about the contents of the list</span></span></code></pre></div><h2 id="java配列" tabindex="-1">Java配列 <a class="header-anchor" href="#java配列" aria-label="Permalink to &quot;Java配列&quot;">​</a></h2><p>Kotlinの配列は不変であり、Javaとは異なります。これは、Kotlinが<code>Array&lt;String&gt;</code>を<code>Array&lt;Any&gt;</code>に割り当てることを許可しないことを意味し、これにより起こりうる実行時エラーを防ぎます。サブクラスの配列をスーパークラスの配列としてKotlinメソッドに渡すことも禁止されていますが、Javaメソッドの場合は<code>Array&lt;(out) String&gt;!</code>のような<a href="#null-safety-and-platform-types">プラットフォーム型</a>を介して許可されます。</p><p>配列は、ボクシング/アンボクシング操作のコストを避けるために、Javaプラットフォームでプリミティブデータ型と共に使用されます。 Kotlinはこれらの実装の詳細を隠蔽するため、Javaコードとインターフェースするには回避策が必要です。 このケースを処理するために、すべてのプリミティブ配列型（<code>IntArray</code>、<code>DoubleArray</code>、<code>CharArray</code>など）に特化したクラスがあります。 これらは<code>Array</code>クラスとは関連しておらず、最高のパフォーマンスのためにJavaのプリミティブ配列にコンパイルされます。</p><p>インデックスの<code>int</code>配列を受け入れるJavaメソッドがあるとします。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JavaArrayExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeIndices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">indices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // code here...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>プリミティブ値の配列を渡すには、Kotlinで次のようにします。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> javaObj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JavaArrayExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> intArrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">javaObj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeIndices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// passes int[] to method</span></span></code></pre></div><p>JVMバイトコードにコンパイルされる際、コンパイラは配列へのアクセスを最適化し、オーバーヘッドが発生しないようにします。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">array[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // no actual calls to get() and set() generated</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// no iterator created</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>インデックスでナビゲートする場合でも、オーバーヘッドは発生しません。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.indices) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// no iterator created</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    array[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>最後に、<code>in</code>チェックにもオーバーヘッドはありません。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.indices) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// same as (i &gt;= 0 &amp;&amp; i &lt; array.size)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array[i])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="javaの可変長引数-varargs" tabindex="-1">Javaの可変長引数（varargs） <a class="header-anchor" href="#javaの可変長引数-varargs" aria-label="Permalink to &quot;Javaの可変長引数（varargs）&quot;">​</a></h2><p>Javaクラスでは、インデックスに対して可変数の引数（varargs）を持つメソッド宣言が使用されることがあります。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JavaArrayExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeIndicesVarArg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">... </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">indices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // code here...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>この場合、<code>IntArray</code>を渡すにはスプレッド演算子<code>*</code>を使用する必要があります。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> javaObj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JavaArrayExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> intArrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">javaObj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeIndicesVarArg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">array)</span></span></code></pre></div><h2 id="演算子" tabindex="-1">演算子 <a class="header-anchor" href="#演算子" aria-label="Permalink to &quot;演算子&quot;">​</a></h2><p>Javaには演算子構文を使用することが理にかなっているメソッドをマークする方法がないため、Kotlinでは適切な名前とシグネチャを持つ任意のJavaメソッドを演算子オーバーロードやその他の規約（<code>invoke()</code>など）として使用できます。中置呼び出し構文を使用してJavaメソッドを呼び出すことは許可されていません。</p><h2 id="チェック例外" tabindex="-1">チェック例外 <a class="header-anchor" href="#チェック例外" aria-label="Permalink to &quot;チェック例外&quot;">​</a></h2><p>Kotlinでは、すべての<a href="/ja/kotlin/exceptions">例外はアンチェック</a>です。つまり、コンパイラはそれらをキャッチすることを強制しません。 そのため、チェック例外を宣言するJavaメソッドを呼び出す場合でも、Kotlinは何も強制しません。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(list: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;*&gt;, to: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Appendable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        to.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Java would require us to catch IOException here</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="objectクラスのメソッド" tabindex="-1"><code>Object</code>クラスのメソッド <a class="header-anchor" href="#objectクラスのメソッド" aria-label="Permalink to &quot;\`Object\`クラスのメソッド&quot;">​</a></h2><p>Java型がKotlinにインポートされると、<code>java.lang.Object</code>型のすべての参照は<code>Any</code>に変換されます。 <code>Any</code>はプラットフォーム固有ではないため、メンバーとして<code>toString()</code>、<code>hashCode()</code>、<code>equals()</code>のみを宣言します。 したがって、<code>java.lang.Object</code>の他のメンバーを利用可能にするために、Kotlinは<a href="/ja/kotlin/extensions">拡張関数</a>を使用します。</p><h3 id="wait-notify" tabindex="-1"><code>wait()</code>/<code>notify()</code> <a class="header-anchor" href="#wait-notify" aria-label="Permalink to &quot;\`wait()\`/\`notify()\`&quot;">​</a></h3><p><code>wait()</code>および<code>notify()</code>メソッドは<code>Any</code>型の参照では利用できません。これらの使用は一般的に<code>java.util.concurrent</code>を優先して推奨されていません。どうしてもこれらのメソッドを呼び出す必要がある場合は、<code>java.lang.Object</code>にキャストできます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.lang.Object).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h3 id="getclass" tabindex="-1"><code>getClass()</code> <a class="header-anchor" href="#getclass" aria-label="Permalink to &quot;\`getClass()\`&quot;">​</a></h3><p>オブジェクトのJavaクラスを取得するには、<a href="/ja/kotlin/reflection#class-references">クラス参照</a>の<code>java</code>拡張プロパティを使用します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fooClass </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.java</span></span></code></pre></div><p>上記のコードは<a href="/ja/kotlin/reflection#bound-class-references">バウンドクラスリファレンス</a>を使用しています。<code>javaClass</code>拡張プロパティを使用することもできます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fooClass </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo.javaClass</span></span></code></pre></div><h3 id="clone" tabindex="-1"><code>clone()</code> <a class="header-anchor" href="#clone" aria-label="Permalink to &quot;\`clone()\`&quot;">​</a></h3><p><code>clone()</code>をオーバーライドするには、クラスが<code>kotlin.Cloneable</code>を継承する必要があります。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Cloneable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> clone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.oracle.com/technetwork/java/effectivejava-136174.html" target="_blank" rel="noreferrer">『Effective Java 第3版』</a>の項目13「<code>clone</code>を慎重にオーバーライドする」も忘れないでください。</p><h3 id="finalize" tabindex="-1"><code>finalize()</code> <a class="header-anchor" href="#finalize" aria-label="Permalink to &quot;\`finalize()\`&quot;">​</a></h3><p><code>finalize()</code>をオーバーライドするには、<code>override</code>キーワードを使用せずに単純に宣言するだけです。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    protected</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> finalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // finalization logic</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Javaのルールによると、<code>finalize()</code>は<code>private</code>であってはなりません。</p><h2 id="javaクラスからの継承" tabindex="-1">Javaクラスからの継承 <a class="header-anchor" href="#javaクラスからの継承" aria-label="Permalink to &quot;Javaクラスからの継承&quot;">​</a></h2><p>Kotlinのクラスは、最大1つのJavaクラス（および任意の数のJavaインターフェース）をスーパークラスとすることができます。</p><h2 id="静的メンバーへのアクセス" tabindex="-1">静的メンバーへのアクセス <a class="header-anchor" href="#静的メンバーへのアクセス" aria-label="Permalink to &quot;静的メンバーへのアクセス&quot;">​</a></h2><p>Javaクラスの静的メンバーは、これらのクラスの「コンパニオンオブジェクト」を形成します。このような「コンパニオンオブジェクト」を値として渡すことはできませんが、メンバーには明示的にアクセスできます。例えば、次のようになります。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Character.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isLetter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a)) { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span></code></pre></div><p><a href="#mapped-types">マップされる型</a>であるJava型の静的メンバーにアクセスするには、<code>java.lang.Integer.bitCount(foo)</code>のように、Java型の完全修飾名を使用します。</p><h2 id="javaリフレクション" tabindex="-1">Javaリフレクション <a class="header-anchor" href="#javaリフレクション" aria-label="Permalink to &quot;Javaリフレクション&quot;">​</a></h2><p>JavaリフレクションはKotlinクラスで動作し、その逆も同様です。前述のとおり、<code>instance::class.java</code>、<code>ClassName::class.java</code>、または<code>instance.javaClass</code>を使用して<code>java.lang.Class</code>を介してJavaリフレクションに入ることができます。 <code>ClassName.javaClass</code>をこの目的で使用しないでください。これは<code>ClassName</code>のコンパニオンオブジェクトクラスを参照し、<code>ClassName.Companion::class.java</code>と同じであり、<code>ClassName::class.java</code>とは異なります。</p><p>各プリミティブ型には2つの異なるJavaクラスがあり、Kotlinは両方を取得する方法を提供します。例えば、<code>Int::class.java</code>はプリミティブ型自体を表すクラスインスタンスを返します。これはJavaの<code>Integer.TYPE</code>に相当します。対応するラッパー型のクラスを取得するには、Javaの<code>Integer.class</code>と同等の<code>Int::class.javaObjectType</code>を使用します。</p><p>その他のサポートされるケースには、KotlinプロパティのJavaゲッター/セッターメソッドまたはバッキングフィールドの取得、Javaフィールドの<code>KProperty</code>の取得、<code>KFunction</code>のJavaメソッドまたはコンストラクタの取得、およびその逆が含まれます。</p><h2 id="sam変換" tabindex="-1">SAM変換 <a class="header-anchor" href="#sam変換" aria-label="Permalink to &quot;SAM変換&quot;">​</a></h2><p>KotlinはJavaと<a href="/ja/kotlin/fun-interfaces">Kotlinインターフェース</a>の両方でSAM変換をサポートしています。 Javaに対するこのサポートは、Kotlinの関数リテラルが、単一の非デフォルトメソッドを持つJavaインターフェースの実装に自動的に変換できることを意味します。ただし、インターフェースメソッドのパラメータ型がKotlin関数のパラメータ型と一致する必要があります。</p><p>これを使用してSAMインターフェースのインスタンスを作成できます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> runnable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This runs in a runnable&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span></code></pre></div><p>…そしてメソッド呼び出しで。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ThreadPoolExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Java signature: void execute(Runnable command)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">executor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This runs in a thread pool&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span></code></pre></div><p>Javaクラスが複数の関数インターフェースを取るメソッドを持っている場合、ラムダを特定のSAM型に変換するアダプター関数を使用することで、呼び出す必要があるメソッドを選択できます。これらのアダプター関数も必要に応じてコンパイラによって生成されます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">executor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This runs in a thread pool&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) })</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>SAM変換はインターフェースにのみ機能し、抽象クラスには機能しません。抽象クラスが単一の抽象メソッドしか持たない場合でも同様です。</p></div><h2 id="kotlinでのjniの使用" tabindex="-1">KotlinでのJNIの使用 <a class="header-anchor" href="#kotlinでのjniの使用" aria-label="Permalink to &quot;KotlinでのJNIの使用&quot;">​</a></h2><p>ネイティブ（CまたはC++）コードで実装された関数を宣言するには、<code>external</code>修飾子でマークする必要があります。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Double</span></span></code></pre></div><p>残りの手順はJavaとまったく同じです。</p><p>プロパティのゲッターとセッターも<code>external</code>としてマークできます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myProperty: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> get</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> set</span></span></code></pre></div><p>内部的には、これにより<code>getMyProperty</code>と<code>setMyProperty</code>という2つの関数が作成され、どちらも<code>external</code>としてマークされます。</p><h2 id="kotlinでlombokによって生成された宣言を使用する" tabindex="-1">KotlinでLombokによって生成された宣言を使用する <a class="header-anchor" href="#kotlinでlombokによって生成された宣言を使用する" aria-label="Permalink to &quot;KotlinでLombokによって生成された宣言を使用する&quot;">​</a></h2><p>JavaのLombokによって生成された宣言をKotlinコードで使用できます。 同じJava/Kotlin混在モジュールでこれらの宣言を生成して使用する必要がある場合は、<a href="/ja/kotlin/lombok">Lombokコンパイラプラグインのページ</a>でその方法を学ぶことができます。 別のモジュールからそのような宣言を呼び出す場合、そのモジュールをコンパイルするためにこのプラグインを使用する必要はありません。</p>`,173))])}const A=k(r,[["render",E]]);export{b as __pageData,A as default};
