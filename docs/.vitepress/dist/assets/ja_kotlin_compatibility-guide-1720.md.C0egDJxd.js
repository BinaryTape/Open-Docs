import{_ as t,c as o,o as a,ag as r}from"./chunks/framework.Bksy39di.js";const h=JSON.parse('{"title":"Kotlin 1.7.20 の互換性ガイド","description":"","frontmatter":{},"headers":[],"relativePath":"ja/kotlin/compatibility-guide-1720.md","filePath":"ja/kotlin/compatibility-guide-1720.md","lastUpdated":1754307826000}'),n={name:"ja/kotlin/compatibility-guide-1720.md"};function i(l,e,s,p,c,u){return a(),o("div",null,e[0]||(e[0]=[r('<h1 id="kotlin-1-7-20-の互換性ガイド" tabindex="-1">Kotlin 1.7.20 の互換性ガイド <a class="header-anchor" href="#kotlin-1-7-20-の互換性ガイド" aria-label="Permalink to &quot;Kotlin 1.7.20 の互換性ガイド&quot;">​</a></h1><p><em><a href="/ja/kotlin/kotlin-evolution-principles">言語の現代性を保つ (Keeping the Language Modern)</a></em> および <em><a href="/ja/kotlin/kotlin-evolution-principles">快適な更新 (Comfortable Updates)</a></em> は、Kotlin言語設計の基本原則です。前者は、言語の進化を妨げる構文は削除されるべきであると述べており、後者は、この削除はコード移行を可能な限り円滑にするために、事前に十分に伝達されるべきであると述べています。</p><p>通常、互換性のない変更はフィーチャーリリースでのみ発生しますが、今回はKotlin 1.7での変更によって生じた問題の広がりを抑えるため、インクリメンタルリリースでそのような変更を2つ導入する必要があるためです。</p><p>このドキュメントはそれらを要約し、Kotlin 1.7.0および1.7.10からKotlin 1.7.20への移行の参照情報を提供します。</p><h2 id="基本的な用語" tabindex="-1">基本的な用語 <a class="header-anchor" href="#基本的な用語" aria-label="Permalink to &quot;基本的な用語&quot;">​</a></h2><p>本ドキュメントでは、いくつかの種類の互換性について説明します。</p><ul><li><em>ソース互換性</em>: ソース非互換な変更とは、以前は問題なく（エラーや警告なしで）コンパイルされていたコードが、もはやコンパイルできなくなる変更を指します。</li><li><em>バイナリ互換性</em>: 2つのバイナリ成果物がバイナリ互換であるとは、それらを入れ替えてもローディングエラーやリンクエラーが発生しない場合を指します。</li><li><em>動作互換性</em>: 変更が動作非互換であるとは、同じプログラムがその変更を適用する前後で異なる動作を示す場合を指します。</li></ul><p>これらの定義は純粋なKotlinコードにのみ適用されることに留意してください。他の言語の視点（例：Java）から見たKotlinコードの互換性は、本ドキュメントの範囲外です。</p><h2 id="言語" tabindex="-1">言語 <a class="header-anchor" href="#言語" aria-label="Permalink to &quot;言語&quot;">​</a></h2><h3 id="適切な制約処理を修正するためのロールバック試行" tabindex="-1">適切な制約処理を修正するためのロールバック試行 <a class="header-anchor" href="#適切な制約処理を修正するためのロールバック試行" aria-label="Permalink to &quot;適切な制約処理を修正するためのロールバック試行&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-53813" target="_blank" rel="noreferrer">KT-53813</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>非互換な変更の種類</strong>: ソース</p><p><strong>概要</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-52668" target="_blank" rel="noreferrer">KT-52668</a>で説明されている変更を実装した後、1.7.0で発生した型推論の制約処理における問題の修正試行をロールバックします。この試行は1.7.10で行われましたが、それが今度は新たな問題を引き起こしました。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>1.7.20: 1.7.0の動作にロールバック</li></ul></blockquote><h3 id="複数のラムダと解決処理との問題のある相互作用を避けるため、一部のビルダー推論ケースを禁止" tabindex="-1">複数のラムダと解決処理との問題のある相互作用を避けるため、一部のビルダー推論ケースを禁止 <a class="header-anchor" href="#複数のラムダと解決処理との問題のある相互作用を避けるため、一部のビルダー推論ケースを禁止" aria-label="Permalink to &quot;複数のラムダと解決処理との問題のある相互作用を避けるため、一部のビルダー推論ケースを禁止&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-53797" target="_blank" rel="noreferrer">KT-53797</a></p><p><strong>コンポーネント</strong>: コア言語</p><p><strong>非互換な変更の種類</strong>: ソース</p><p><strong>概要</strong>: Kotlin 1.7では、無制限ビルダー推論と呼ばれる機能が導入され、<code>@BuilderInference</code>アノテーションが付けられていないパラメータに渡されたラムダでさえ、ビルダー推論の恩恵を受けられるようになりました。しかし、関数呼び出しで複数のそのようなラムダが発生した場合、いくつかの問題を引き起こす可能性がありました。</p><p>Kotlin 1.7.20では、対応するパラメータに<code>@BuilderInference</code>アノテーションが付けられていないラムダ関数が複数あり、そのラムダ内の型の推論を完了するためにビルダー推論の使用が必要な場合、エラーが報告されます。</p><p><strong>非推奨サイクル</strong>:</p><ul><li>1.7.20: そのようなラムダ関数でエラーを報告します。 <code>-XXLanguage:+NoBuilderInferenceWithoutAnnotationRestriction</code> を使用すると、一時的に1.7.20より前の動作に戻すことができます。</li></ul></blockquote>',13)]))}const g=t(n,[["render",i]]);export{h as __pageData,g as default};
