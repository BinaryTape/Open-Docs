import{_ as a}from"./chunks/ksp-class-diagram.ClaR6pZl.js";import{_ as n,c as t,o as l,j as e,ag as p,a as s}from"./chunks/framework.Bksy39di.js";const f=JSON.parse('{"title":"KSP 如何为 Kotlin 代码建模","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/ksp-additional-details.md","filePath":"kotlin/ksp-additional-details.md","lastUpdated":1754307826000}'),o={name:"kotlin/ksp-additional-details.md"};function r(c,i,d,k,h,g){return l(),t("div",null,i[0]||(i[0]=[e("h1",{id:"ksp-如何为-kotlin-代码建模",tabindex:"-1"},[s("KSP 如何为 Kotlin 代码建模 "),e("a",{class:"header-anchor",href:"#ksp-如何为-kotlin-代码建模","aria-label":'Permalink to "KSP 如何为 Kotlin 代码建模"'},"​")],-1),e("p",null,[s("你可以在 "),e("a",{href:"https://github.com/google/ksp/tree/main/api/src/main/kotlin/com/google/devtools/ksp",target:"_blank",rel:"noreferrer"},"KSP GitHub 版本库"),s("中找到 API 定义。 该图表概述了 Kotlin 在 KSP 中是如何被"),e("a",{href:"https://github.com/google/ksp/tree/main/api/src/main/kotlin/com/google/devtools/ksp/symbol/",target:"_blank",rel:"noreferrer"},"建模"),s("的：")],-1),e("p",null,[e("img",{src:a,alt:"类图",thumbnail:"true",width:"800","thumbnail-same-file":"true"})],-1),p(`<div class="note custom-block"><p class="custom-block-title">NOTE</p><p><a href="https://kotlinlang.org/docs/images/ksp-class-diagram.svg" target="_blank" rel="noreferrer">关于全尺寸图表请参见此处</a>。</p></div><h2 id="类型与解析" tabindex="-1">类型与解析 <a class="header-anchor" href="#类型与解析" aria-label="Permalink to &quot;类型与解析&quot;">​</a></h2><p>解析占据了底层 API 实现的大部分开销。因此，类型引用被设计为由处理器显式地（除少数例外）解析。当引用一个_类型_（例如 <code>KSFunctionDeclaration.returnType</code> 或 <code>KSAnnotation.annotationType</code>）时，它始终是一个 <code>KSTypeReference</code>，它是一个带有注解和修饰符的 <code>KSReferenceElement</code>。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> KSFunctionDeclaration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> returnType: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSTypeReference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> KSTypeReference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSAnnotated</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSModifierListOwner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> type: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSReferenceElement</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>一个 <code>KSTypeReference</code> 可以被解析为 <code>KSType</code>，它引用了 Kotlin 类型系统中的一个类型。</p><p><code>KSTypeReference</code> 有一个 <code>KSReferenceElement</code>，它为 Kotlin 的程序结构建模：即，引用是如何编写的。它对应于 Kotlin 语法中的 <a href="https://kotlinlang.org/docs/reference/grammar.html#type" target="_blank" rel="noreferrer"><code>type</code></a> 元素。</p><p><code>KSReferenceElement</code> 可以是 <code>KSClassifierReference</code> 或 <code>KSCallableReference</code>，它们包含大量有用信息，而无需解析。例如，<code>KSClassifierReference</code> 有 <code>referencedName</code>，而 <code>KSCallableReference</code> 有 <code>receiverType</code>、<code>functionArguments</code> 和 <code>returnType</code>。</p><p>如果需要 <code>KSTypeReference</code> 引用的原始声明，通常可以通过解析为 <code>KSType</code> 并通过 <code>KSType.declaration</code> 访问来找到。将类型被提及之处与其类定义之处关联起来，示例如下：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ksType: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSType</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ksTypeReference.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ksDeclaration: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KSDeclaration</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ksType.declaration</span></span></code></pre></div><p>类型解析开销大，因此采用显式形式。从解析中获取的一些信息已在 <code>KSReferenceElement</code> 中可用。例如，<code>KSClassifierReference.referencedName</code> 可以过滤掉许多不相关的元素。只有当你需要从 <code>KSDeclaration</code> 或 <code>KSType</code> 中获取特定信息时，才应该解析类型。</p><p>指向函数类型的 <code>KSTypeReference</code> 大部分信息都在其元素中。 尽管它可以被解析为 <code>Function0</code>、<code>Function1</code> 等系列，但这些解析不会比 <code>KSCallableReference</code> 带来更多信息。解析函数类型引用的一个用例是处理函数原型的标识。</p>`,11)]))}const m=n(o,[["render",r]]);export{f as __pageData,m as default};
