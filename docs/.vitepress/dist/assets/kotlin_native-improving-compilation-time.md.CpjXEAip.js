import{_ as d,C as o,c as n,o as c,j as a,G as t,ag as s,a as r}from"./chunks/framework.Bksy39di.js";const _=JSON.parse('{"title":"提高编译时间的建议","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/native-improving-compilation-time.md","filePath":"kotlin/native-improving-compilation-time.md","lastUpdated":1754307826000}'),p={name:"kotlin/native-improving-compilation-time.md"};function h(u,e,m,b,k,g){const l=o("show-structure"),i=o("TopicTitle");return c(),n("div",null,[e[0]||(e[0]=a("h1",{id:"提高编译时间的建议",tabindex:"-1"},[r("提高编译时间的建议 "),a("a",{class:"header-anchor",href:"#提高编译时间的建议","aria-label":'Permalink to "提高编译时间的建议"'},"​")],-1)),t(l,{depth:"1"}),e[1]||(e[1]=s('<p>Kotlin/Native 编译器持续接收更新，以提升其性能。借助于最新的 Kotlin/Native 编译器和正确配置的构建环境，你可以显著提升采用 Kotlin/Native 目标平台的项目的编译时间。</p><p>请继续阅读我们提供的建议，了解如何加速 Kotlin/Native 编译过程。</p><h2 id="一般建议" tabindex="-1">一般建议 <a class="header-anchor" href="#一般建议" aria-label="Permalink to &quot;一般建议&quot;">​</a></h2><h3 id="使用最新版本的-kotlin" tabindex="-1">使用最新版本的 Kotlin <a class="header-anchor" href="#使用最新版本的-kotlin" aria-label="Permalink to &quot;使用最新版本的 Kotlin&quot;">​</a></h3><p>这样你总能获得最新的性能改进。最新的 Kotlin 版本是 2.2.10。</p><h3 id="避免创建大型类" tabindex="-1">避免创建大型类 <a class="header-anchor" href="#避免创建大型类" aria-label="Permalink to &quot;避免创建大型类&quot;">​</a></h3><p>尽量避免创建编译和执行加载耗时较长的巨型类。</p><h3 id="在构建之间保留已下载和缓存的组件" tabindex="-1">在构建之间保留已下载和缓存的组件 <a class="header-anchor" href="#在构建之间保留已下载和缓存的组件" aria-label="Permalink to &quot;在构建之间保留已下载和缓存的组件&quot;">​</a></h3><p>编译项目时，Kotlin/Native 会下载所需组件并缓存部分工作成果到 <code>$USER_HOME/.konan</code> 目录。编译器会利用此目录进行后续编译，从而缩短编译完成时间。</p><p>在容器（例如 Docker）中或使用持续集成系统进行构建时，编译器可能需要在每次构建时从头创建 <code>~/.konan</code> 目录。为避免此步骤，请配置你的环境，以在构建之间保留 <code>~/.konan</code>。例如，可以使用 <code>kotlin.data.dir</code> Gradle 属性重新定义其位置。</p><p>另外，你也可以通过 <code>cinterop</code> 和 <code>konanc</code> 工具，使用 <code>-Xkonan-data-dir</code> 编译器选项配置目录的自定义路径。</p><h2 id="gradle-配置" tabindex="-1">Gradle 配置 <a class="header-anchor" href="#gradle-配置" aria-label="Permalink to &quot;Gradle 配置&quot;">​</a></h2><p>由于需要下载依赖项、构建缓存以及执行额外步骤，Gradle 的首次编译通常比后续编译耗时更长。你应该至少构建两次项目，才能准确读取实际编译时间。</p><p>以下是关于配置 Gradle 以获得更好编译性能的一些建议。</p><h3 id="增加-gradle-堆大小" tabindex="-1">增加 Gradle 堆大小 <a class="header-anchor" href="#增加-gradle-堆大小" aria-label="Permalink to &quot;增加 Gradle 堆大小&quot;">​</a></h3><p>要增加 <a href="https://docs.gradle.org/current/userguide/performance.html#adjust_the_daemons_heap_size" target="_blank" rel="noreferrer">Gradle 堆大小</a>，请将 <code>org.gradle.jvmargs=-Xmx3g</code> 添加到你的 <code>gradle.properties</code> 文件中。</p><p>如果你使用<a href="https://docs.gradle.org/current/userguide/performance.html#parallel_execution" target="_blank" rel="noreferrer">并行构建</a>，你可能需要使用 <code>org.gradle.workers.max</code> 属性或 <code>--max-workers</code> 命令行选项选择合适的工作进程数量。默认值是 CPU 处理器数量。</p><h3 id="仅构建必要的二进制文件" tabindex="-1">仅构建必要的二进制文件 <a class="header-anchor" href="#仅构建必要的二进制文件" aria-label="Permalink to &quot;仅构建必要的二进制文件&quot;">​</a></h3><p>除非你确实需要，否则不要运行构建整个项目的 Gradle 任务，例如 <code>build</code> 或 <code>assemble</code>。这些任务会多次构建相同的代码，从而增加编译时间。在典型情况下，例如从 IntelliJ IDEA 运行测试或从 Xcode 启动应用，Kotlin 工具链会避免执行不必要的任务。</p><p>如果你有非典型情况或构建配置，可能需要自行选择任务：</p><ul><li><p><code>linkDebug*</code>。为了在开发过程中运行代码，你通常只需要一个二进制文件，因此运行相应的 <code>linkDebug*</code> 任务就足够了。</p></li><li><p><code>embedAndSignAppleFrameworkForXcode</code>。由于 iOS 模拟器和设备具有不同的处理器架构，将 Kotlin/Native 二进制文件作为通用 (fat) framework 分发是一种常见方法。</p><p>然而，在本地开发期间，仅为你正在使用的平台构建 <code>.framework</code> 文件会更快。要构建平台特有的 framework，请使用 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-direct-integration.html#connect-the-framework-to-your-project" target="_blank" rel="noreferrer">embedAndSignAppleFrameworkForXcode</a> 任务。</p></li></ul><h3 id="仅为必要的目标平台构建" tabindex="-1">仅为必要的目标平台构建 <a class="header-anchor" href="#仅为必要的目标平台构建" aria-label="Permalink to &quot;仅为必要的目标平台构建&quot;">​</a></h3><p>与上述建议类似，不要一次性为所有原生平台构建二进制文件。例如，编译 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-build-native-binaries.html#build-xcframeworks" target="_blank" rel="noreferrer">XCFramework</a>（使用 <code>*XCFramework</code> 任务）会为所有目标平台构建相同的代码，这比为单个目标平台构建耗时按比例更长。</p><p>如果你的设置确实需要 XCFrameworks，可以减少目标平台数量。例如，如果你不在基于 Intel 的 Mac 上运行此项目，则不需要 <code>iosX64</code>。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>二进制文件是使用 <code>linkDebug*$Target</code> 和 <code>linkRelease*$Target</code> Gradle 任务为不同目标平台构建的。 你可以在构建日志中或通过使用 <code>--scan</code> 选项运行 Gradle 构建来在 <a href="https://docs.gradle.org/current/userguide/build_scans.html" target="_blank" rel="noreferrer">Gradle 构建扫描</a> 中查找已执行的任务。</p></div><h3 id="不要构建不必要的发布二进制文件" tabindex="-1">不要构建不必要的发布二进制文件 <a class="header-anchor" href="#不要构建不必要的发布二进制文件" aria-label="Permalink to &quot;不要构建不必要的发布二进制文件&quot;">​</a></h3><p>Kotlin/Native 支持两种构建模式：<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-build-native-binaries.html#declare-binaries" target="_blank" rel="noreferrer">调试和发布</a>。发布模式经过高度优化，这会耗费大量时间：发布二进制文件的编译时间比调试二进制文件长一个数量级。</p><p>除了实际发布之外，所有这些优化在典型开发周期中可能是不必要的。如果在开发过程中使用了名称中包含 <code>Release</code> 的任务，请考虑将其替换为 <code>Debug</code>。类似地，你可以运行 <code>assembleSharedDebugXCFramework</code>，而不是运行 <code>assembleXCFramework</code>。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>发布二进制文件是使用 <code>linkRelease*</code> Gradle 任务构建的。你可以在构建日志中或通过使用 <code>--scan</code> 选项运行 Gradle 构建来在 <a href="https://docs.gradle.org/current/userguide/build_scans.html" target="_blank" rel="noreferrer">Gradle 构建扫描</a> 中检查它们。</p></div><h3 id="不要禁用-gradle-守护进程" tabindex="-1">不要禁用 Gradle 守护进程 <a class="header-anchor" href="#不要禁用-gradle-守护进程" aria-label="Permalink to &quot;不要禁用 Gradle 守护进程&quot;">​</a></h3><p>除非有充分理由，否则不要禁用 <a href="https://docs.gradle.org/current/userguide/gradle_daemon.html" target="_blank" rel="noreferrer">Gradle 守护进程</a>。默认情况下，<a href="https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-3-70-released/#kotlin-native" target="_blank" rel="noreferrer">Kotlin/Native 会从 Gradle 守护进程运行</a>。启用后，会使用相同的 JVM 进程，每次编译时无需对其进行预热。</p><h3 id="不要使用传递性导出" tabindex="-1">不要使用传递性导出 <a class="header-anchor" href="#不要使用传递性导出" aria-label="Permalink to &quot;不要使用传递性导出&quot;">​</a></h3><p>使用 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-build-native-binaries.html#export-dependencies-to-binaries" target="_blank" rel="noreferrer"><code>transitiveExport = true</code></a> 在许多情况下会禁用无用代码消除，因此编译器必须处理大量未使用的代码。这会增加编译时间。相反，请明确使用 <code>export</code> 方法导出所需的项目和依赖项。</p><h3 id="不要过度导出模块" tabindex="-1">不要过度导出模块 <a class="header-anchor" href="#不要过度导出模块" aria-label="Permalink to &quot;不要过度导出模块&quot;">​</a></h3><p>尽量避免不必要的<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-build-native-binaries.html#export-dependencies-to-binaries" target="_blank" rel="noreferrer">模块导出</a>。每个导出的模块都会对编译时间与二进制文件大小产生负面影响。</p><h3 id="使用-gradle-构建缓存" tabindex="-1">使用 Gradle 构建缓存 <a class="header-anchor" href="#使用-gradle-构建缓存" aria-label="Permalink to &quot;使用 Gradle 构建缓存&quot;">​</a></h3><p>启用 Gradle <a href="https://docs.gradle.org/current/userguide/build_cache.html" target="_blank" rel="noreferrer">构建缓存</a> 特性：</p><ul><li><strong>本地构建缓存</strong>。对于本地缓存，请将 <code>org.gradle.caching=true</code> 添加到你的 <code>gradle.properties</code> 文件中，或在命令行中使用 <code>--build-cache</code> 选项运行构建。</li><li><strong>远程构建缓存</strong>。了解如何为持续集成环境<a href="https://docs.gradle.org/current/userguide/build_cache.html#sec:build_cache_configure_remote" target="_blank" rel="noreferrer">配置远程构建缓存</a>。</li></ul><h3 id="使用-gradle-配置缓存" tabindex="-1">使用 Gradle 配置缓存 <a class="header-anchor" href="#使用-gradle-配置缓存" aria-label="Permalink to &quot;使用 Gradle 配置缓存&quot;">​</a></h3><p>要使用 Gradle <a href="https://docs.gradle.org/current/userguide/configuration_cache.html" target="_blank" rel="noreferrer">配置缓存</a>，请将 <code>org.gradle.configuration-cache=true</code> 添加到你的 <code>gradle.properties</code> 文件中。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>配置缓存还允许并行运行 <code>link*</code> 任务，这可能会严重加载机器，尤其是在 CPU 核心数量很多的情况下。此问题将在 <a href="https://youtrack.jetbrains.com/issue/KT-70915" target="_blank" rel="noreferrer">KT-70915</a> 中修复。</p></div><h3 id="启用以前禁用的特性" tabindex="-1">启用以前禁用的特性 <a class="header-anchor" href="#启用以前禁用的特性" aria-label="Permalink to &quot;启用以前禁用的特性&quot;">​</a></h3><p>有一些 Kotlin/Native 属性会禁用 Gradle 守护进程和编译器缓存：</p><ul><li><code>kotlin.native.disableCompilerDaemon=true</code></li><li><code>kotlin.native.cacheKind=none</code></li><li><code>kotlin.native.cacheKind.$target=none</code>，其中 <code>$target</code> 是 Kotlin/Native 编译目标，例如 <code>iosSimulatorArm64</code>。</li></ul><p>如果你之前遇到这些特性导致的问题，并将这些行添加到你的 <code>gradle.properties</code> 文件或 Gradle 实参中，请删除它们并检查构建是否成功完成。这些属性可能是在解决已修复的问题时添加的。</p><h3 id="尝试-klib-构件的增量编译" tabindex="-1">尝试 klib 构件的增量编译 <a class="header-anchor" href="#尝试-klib-构件的增量编译" aria-label="Permalink to &quot;尝试 klib 构件的增量编译&quot;">​</a></h3><p>通过增量编译，如果项目模块生成的 <code>klib</code> 构件只有一部分发生变化，那么只有 <code>klib</code> 的一部分会被进一步重新编译成二进制文件。</p><p>此特性为<a href="/kotlin/components-stability#stability-levels-explained">实验性的</a>。要启用它，请将 <code>kotlin.incremental.native=true</code> 选项添加到你的 <code>gradle.properties</code> 文件中。如果遇到任何问题，请在 <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack 中创建问题</a>。</p><h2 id="windows-配置" tabindex="-1">Windows 配置 <a class="header-anchor" href="#windows-配置" aria-label="Permalink to &quot;Windows 配置&quot;">​</a></h2><p>Windows 安全中心可能会减慢 Kotlin/Native 编译器。你可以通过将默认位于 <code>%\\USERPROFILE%</code> 的 <code>.konan</code> 目录添加到 Windows 安全中心排除项来避免这种情况。了解如何<a href="https://support.microsoft.com/en-us/windows/add-an-exclusion-to-windows-security-811816c0-4dfd-af4a-47e4-c301afe13b26" target="_blank" rel="noreferrer">将排除项添加到 Windows 安全中心</a>。</p>',50)),t(i,{id:"llvm-配置",level:"2",title:"LLVM 配置",labelRef:"advanced"}),e[2]||(e[2]=a("p",null,[r("如果上述建议未能帮助你提升编译时间，请考虑"),a("a",{href:"/kotlin/native-llvm-passes"},"自定义 LLVM 后端"),r("。")],-1))])}const v=d(p,[["render",h]]);export{_ as __pageData,v as default};
