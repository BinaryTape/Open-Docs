import{_ as t,c as a,o,ag as r}from"./chunks/framework.Bksy39di.js";const m=JSON.parse('{"title":"Kotlin 1.7.20 相容性指南","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/compatibility-guide-1720.md","filePath":"zh-Hant/kotlin/compatibility-guide-1720.md","lastUpdated":1754307826000}'),n={name:"zh-Hant/kotlin/compatibility-guide-1720.md"};function i(l,e,s,c,p,u){return o(),a("div",null,e[0]||(e[0]=[r('<h1 id="kotlin-1-7-20-相容性指南" tabindex="-1">Kotlin 1.7.20 相容性指南 <a class="header-anchor" href="#kotlin-1-7-20-相容性指南" aria-label="Permalink to &quot;Kotlin 1.7.20 相容性指南&quot;">​</a></h1><p><em><a href="/zh-Hant/kotlin/kotlin-evolution-principles">保持語言現代化</a></em> 和 <em><a href="/zh-Hant/kotlin/kotlin-evolution-principles">舒適的更新</a></em> 是 Kotlin 語言設計中的基本原則。前者指出阻礙語言演進的建構應被移除，而後者則說明此類移除應事先充分溝通，以使程式碼遷移盡可能順暢。</p><p>通常，不相容變更僅發生在功能發佈版本中，但本次我們必須在一個增量發佈版本中引入兩項此類變更，以限制 Kotlin 1.7 中變更所引入問題的蔓延。</p><p>本文總結了這些變更，為從 Kotlin 1.7.0 和 1.7.10 遷移到 Kotlin 1.7.20 提供了參考。</p><h2 id="基本術語" tabindex="-1">基本術語 <a class="header-anchor" href="#基本術語" aria-label="Permalink to &quot;基本術語&quot;">​</a></h2><p>本文中我們介紹了幾種相容性類型：</p><ul><li><em>source</em>：原始碼不相容變更會使原本能正常編譯（沒有錯誤或警告）的程式碼不再能編譯</li><li><em>binary</em>：如果互換兩個二進位產物不會導致載入或連結錯誤，則稱它們是二進位相容的</li><li><em>behavioral</em>：如果相同的程式在應用變更前後表現出不同的行為，則稱該變更是行為不相容的</li></ul><p>請記住，這些定義僅針對純 Kotlin 程式碼。從其他語言（例如 Java）的角度來看 Kotlin 程式碼的相容性不在本文的範圍之內。</p><h2 id="語言" tabindex="-1">語言 <a class="header-anchor" href="#語言" aria-label="Permalink to &quot;語言&quot;">​</a></h2><h3 id="回溯嘗試以修正正確的約束處理" tabindex="-1">回溯嘗試以修正正確的約束處理 <a class="header-anchor" href="#回溯嘗試以修正正確的約束處理" aria-label="Permalink to &quot;回溯嘗試以修正正確的約束處理&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.jetbrains.com/issue/KT-53813" target="_blank" rel="noreferrer">KT-53813</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: 回溯一項修正型別推斷約束處理中問題的嘗試，該問題在實作 <a href="https://youtrack.jetbrains.com/issue/KT-52668" target="_blank" rel="noreferrer">KT-52668</a> 中描述的變更後於 1.7.0 版本中出現。該嘗試於 1.7.10 版本中進行，但它反過來引入了新的問題。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.20: 回溯至 1.7.0 的行為</li></ul></blockquote><h3 id="禁止某些建構器推斷案例以避免與多個-lambda-和解析產生問題的交互" tabindex="-1">禁止某些建構器推斷案例以避免與多個 Lambda 和解析產生問題的交互 <a class="header-anchor" href="#禁止某些建構器推斷案例以避免與多個-lambda-和解析產生問題的交互" aria-label="Permalink to &quot;禁止某些建構器推斷案例以避免與多個 Lambda 和解析產生問題的交互&quot;">​</a></h3><blockquote><p><strong>Issue</strong>: <a href="https://youtrack.com/issue/KT-53797" target="_blank" rel="noreferrer">KT-53797</a></p><p><strong>Component</strong>: Core language</p><p><strong>Incompatible change type</strong>: source</p><p><strong>Short summary</strong>: Kotlin 1.7 引入了一項名為「無限制建構器推斷 (unrestricted builder inference)」的功能，使得即使傳遞給未以 <code>@BuilderInference</code> 註解之參數的 Lambda 也能從建構器推斷中受益。然而，如果函數調用中出現多於一個此類 Lambda，則可能導致多個問題。Kotlin 1.7.20 將報告錯誤，如果有多個 Lambda 函數的相應參數未以 <code>@BuilderInference</code> 註解，並且需要使用建構器推斷來完成 Lambda 中的型別推斷。</p><p><strong>Deprecation cycle</strong>:</p><ul><li>1.7.20: 在此類 Lambda 函數上報告錯誤，可以使用 <code>-XXLanguage:+NoBuilderInferenceWithoutAnnotationRestriction</code> 來暫時恢復到 1.7.20 之前的行為</li></ul></blockquote>',13)]))}const h=t(n,[["render",i]]);export{m as __pageData,h as default};
