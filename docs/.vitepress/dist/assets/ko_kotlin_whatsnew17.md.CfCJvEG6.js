import{_ as h,C as a,c as p,o as k,j as s,G as n,ag as t,a as r,w as o}from"./chunks/framework.Bksy39di.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/whatsnew17.md","filePath":"ko/kotlin/whatsnew17.md","lastUpdated":1754307826000}'),d={name:"ko/kotlin/whatsnew17.md"};function c(E,i,g,y,u,F){const l=a("tldr"),e=a("YouTubeVideo");return k(),p("div",null,[i[1]||(i[1]=s("h1",{id:"kotlin-1-7-0의-새로운-기능",tabindex:"-1"},[r("Kotlin 1.7.0의 새로운 기능 "),s("a",{class:"header-anchor",href:"#kotlin-1-7-0의-새로운-기능","aria-label":'Permalink to "Kotlin 1.7.0의 새로운 기능"'},"​")],-1)),n(l,null,{default:o(()=>i[0]||(i[0]=[s("p",null,"Kotlin 1.7.0용 IDE 지원은 IntelliJ IDEA 2021.2, 2021.3 및 2022.1에서 사용할 수 있습니다.",-1)])),_:1}),i[2]||(i[2]=t('<p><em><a href="/ko/kotlin/releases#release-details">릴리스됨: 2022년 6월 9일</a></em></p><p>Kotlin 1.7.0이 릴리스되었습니다. 이 버전에서는 새로운 Kotlin/JVM K2 컴파일러의 알파 버전을 공개하고, 언어 기능을 안정화하며, JVM, JS, Native 플랫폼에 대한 성능 개선을 제공합니다.</p><p>다음은 이번 버전의 주요 업데이트 목록입니다.</p><ul><li><a href="#new-kotlin-k2-compiler-for-the-jvm-in-alpha">새로운 Kotlin K2 컴파일러가 현재 알파 버전으로 출시되었습니다</a>. 심각한 성능 개선을 제공합니다. JVM에서만 사용할 수 있으며, kapt를 포함한 어떤 컴파일러 플러그인도 이와 함께 작동하지 않습니다.</li><li><a href="#a-new-approach-to-incremental-compilation">Gradle에서 점진적 컴파일에 대한 새로운 접근 방식</a>. 이제 종속된 비-Kotlin 모듈 내의 변경 사항에 대해서도 점진적 컴파일이 지원되며 Gradle과 호환됩니다.</li><li><a href="#stable-opt-in-requirements">옵트인 요구 사항 어노테이션</a>, <a href="#stable-definitely-non-nullable-types">명확히 null을 허용하지 않는 타입</a>, <a href="#stable-builder-inference">빌더 추론</a>이 안정화되었습니다.</li><li><a href="#underscore-operator-for-type-arguments">타입 인자에 대한 언더스코어 연산자가 추가되었습니다</a>. 다른 타입이 지정되었을 때 인자의 타입을 자동으로 추론하는 데 사용할 수 있습니다.</li><li><a href="#allow-implementation-by-delegation-to-an-inlined-value-of-an-inline-class">이번 릴리스에서는 인라인 클래스의 인라인된 값에 대한 위임을 통한 구현을 허용합니다</a>. 이제 대부분의 경우 메모리를 할당하지 않는 경량 래퍼를 생성할 수 있습니다.</li></ul><p>이 비디오에서 변경 사항에 대한 간략한 개요를 확인할 수도 있습니다.</p>',5)),n(e,{src:"https://www.youtube.com/v/54WEfLKtCGk",title:"What's new in Kotlin 1.7.0"}),i[3]||(i[3]=t(`<h2 id="jvm용-새로운-kotlin-k2-컴파일러-알파-버전" tabindex="-1">JVM용 새로운 Kotlin K2 컴파일러(알파 버전) <a class="header-anchor" href="#jvm용-새로운-kotlin-k2-컴파일러-알파-버전" aria-label="Permalink to &quot;JVM용 새로운 Kotlin K2 컴파일러(알파 버전)&quot;">​</a></h2><p>이번 Kotlin 릴리스는 새로운 Kotlin K2 컴파일러의 <strong>알파</strong> 버전을 소개합니다. 새로운 컴파일러는 새로운 언어 기능 개발 속도를 높이고, Kotlin이 지원하는 모든 플랫폼을 통합하며, 성능 개선을 가져오고, 컴파일러 확장을 위한 API를 제공하는 것을 목표로 합니다.</p><p>새로운 컴파일러와 그 장점에 대한 자세한 설명은 이미 게시되었습니다.</p><ul><li><a href="https://www.youtube.com/watch?v=iTdJJq_LyoY" target="_blank" rel="noreferrer">새로운 Kotlin 컴파일러를 향한 여정 (The Road to the New Kotlin Compiler)</a></li><li><a href="https://www.youtube.com/watch?v=db19VFLZqJM" target="_blank" rel="noreferrer">K2 컴파일러: 탑다운 뷰 (K2 Compiler: a Top-Down View)</a></li></ul><p>새로운 K2 컴파일러의 알파 버전은 주로 성능 개선에 중점을 두었으며 JVM 프로젝트에서만 작동한다는 점을 강조하는 것이 중요합니다. Kotlin/JS, Kotlin/Native 또는 다른 멀티플랫폼 프로젝트를 지원하지 않으며, <a href="/ko/kotlin/kapt">kapt</a>를 포함한 어떤 컴파일러 플러그인도 함께 작동하지 않습니다.</p><p>저희 벤치마크는 내부 프로젝트에서 뛰어난 결과를 보여줍니다.</p><table tabindex="0"><thead><tr><th>프로젝트</th><th>현재 Kotlin 컴파일러 성능</th><th>새로운 K2 Kotlin 컴파일러 성능</th><th>성능 향상</th></tr></thead><tbody><tr><td>Kotlin</td><td>2.2 KLOC/s</td><td>4.8 KLOC/s</td><td>~ x2.2</td></tr><tr><td>YouTrack</td><td>1.8 KLOC/s</td><td>4.2 KLOC/s</td><td>~ x2.3</td></tr><tr><td>IntelliJ IDEA</td><td>1.8 KLOC/s</td><td>3.9 KLOC/s</td><td>~ x2.2</td></tr><tr><td>Space</td><td>1.2 KLOC/s</td><td>2.8 KLOC/s</td><td>~ x2.3</td></tr></tbody></table><blockquote><p>KLOC/s 성능 수치는 컴파일러가 초당 처리하는 코드의 천 단위 라인 수를 의미합니다.</p><p style=""></p></blockquote><p>JVM 프로젝트에서 성능 향상을 확인하고 이전 컴파일러의 결과와 비교할 수 있습니다. Kotlin K2 컴파일러를 활성화하려면 다음 컴파일러 옵션을 사용하십시오.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-Xuse-k2</span></span></code></pre></div><p>또한 K2 컴파일러에는 <a href="https://youtrack.jetbrains.com/issues/KT?q=tag:%20FIR-preview-qa%20%23Resolved" target="_blank" rel="noreferrer">여러 버그 수정 사항이 포함되어 있습니다</a>. 이 목록에서 <strong>State: Open</strong> 상태인 문제도 K2에서는 실제로 수정되었으니 참고하십시오.</p><p>다음 Kotlin 릴리스에서는 K2 컴파일러의 안정성을 개선하고 더 많은 기능을 제공할 예정이니, 계속 지켜봐 주십시오!</p><p>Kotlin K2 컴파일러에서 성능 문제가 발생하는 경우 <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">이슈 트래커에 보고해 주십시오</a>.</p><h2 id="언어" tabindex="-1">언어 <a class="header-anchor" href="#언어" aria-label="Permalink to &quot;언어&quot;">​</a></h2><p>Kotlin 1.7.0은 위임을 통한 구현(implementation by delegation) 지원과 타입 인자를 위한 새로운 언더스코어 연산자를 도입합니다. 또한 이전 릴리스에서 프리뷰로 소개되었던 여러 언어 기능을 안정화합니다.</p><ul><li><a href="#allow-implementation-by-delegation-to-an-inlined-value-of-an-inline-class">인라인 클래스의 인라인된 값에 대한 위임을 통한 구현</a></li><li><a href="#underscore-operator-for-type-arguments">타입 인자를 위한 언더스코어 연산자</a></li><li><a href="#stable-builder-inference">안정적인 빌더 추론</a></li><li><a href="#stable-opt-in-requirements">안정적인 옵트인 요구 사항</a></li><li><a href="#stable-definitely-non-nullable-types">안정적인 명확히 null을 허용하지 않는 타입</a></li></ul><h3 id="인라인-클래스의-인라인된-값에-위임을-통한-구현-허용" tabindex="-1">인라인 클래스의 인라인된 값에 위임을 통한 구현 허용 <a class="header-anchor" href="#인라인-클래스의-인라인된-값에-위임을-통한-구현-허용" aria-label="Permalink to &quot;인라인 클래스의 인라인된 값에 위임을 통한 구현 허용&quot;">​</a></h3><p>값이나 클래스 인스턴스를 위한 경량 래퍼를 생성하려면 모든 인터페이스 메서드를 직접 구현해야 합니다. 위임을 통한 구현(Implementation by delegation)은 이 문제를 해결하지만, 1.7.0 이전에는 인라인 클래스와 함께 작동하지 않았습니다. 이 제한이 제거되어 이제 대부분의 경우 메모리를 할당하지 않는 경량 래퍼를 생성할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;foo&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmInline</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BarWrapper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bar: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Bar</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bar</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BarWrapper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {})</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bw.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="타입-인자를-위한-언더스코어-연산자" tabindex="-1">타입 인자를 위한 언더스코어 연산자 <a class="header-anchor" href="#타입-인자를-위한-언더스코어-연산자" aria-label="Permalink to &quot;타입 인자를 위한 언더스코어 연산자&quot;">​</a></h3><p>Kotlin 1.7.0은 타입 인자를 위한 언더스코어 연산자 <code>_</code>를 도입합니다. 다른 타입이 지정되었을 때 타입 인자를 자동으로 추론하는 데 사용할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeImplementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SomeClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Test&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OtherImplementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SomeClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">object</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Runner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reified</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SomeClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> S::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.java.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getDeclaredConstructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // SomeImplementation이 SomeClass&lt;String&gt;에서 파생되었으므로 T는 String으로 추론됩니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Runner.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SomeImplementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // OtherImplementation이 SomeClass&lt;Int&gt;에서 파생되었으므로 T는 Int로 추론됩니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Runner.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OtherImplementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>변수 목록의 어느 위치에서든 언더스코어 연산자를 사용하여 타입 인자를 추론할 수 있습니다.</p></div><h3 id="안정적인-빌더-추론" tabindex="-1">안정적인 빌더 추론 <a class="header-anchor" href="#안정적인-빌더-추론" aria-label="Permalink to &quot;안정적인 빌더 추론&quot;">​</a></h3><p>빌더 추론(Builder inference)은 제네릭 빌더 함수를 호출할 때 유용한 특별한 타입 추론 방식입니다. 람다 인자 내의 다른 호출에 대한 타입 정보를 사용하여 호출의 타입 인자를 컴파일러가 추론하도록 돕습니다.</p><p>1.7.0부터 빌더 추론은 일반적인 타입 추론이 타입에 대한 충분한 정보를 얻을 수 없을 때, 즉 <a href="/ko/kotlin/whatsnew16#changes-to-builder-inference">1.6.0에 도입된</a> <code>-Xenable-builder-inference</code> 컴파일러 옵션을 지정하지 않아도 자동으로 활성화됩니다.</p><p><a href="/ko/kotlin/using-builders-with-builder-inference">커스텀 제네릭 빌더 작성 방법</a>에 대해 자세히 알아보세요.</p><h3 id="안정적인-옵트인-요구-사항" tabindex="-1">안정적인 옵트인 요구 사항 <a class="header-anchor" href="#안정적인-옵트인-요구-사항" aria-label="Permalink to &quot;안정적인 옵트인 요구 사항&quot;">​</a></h3><p><a href="/ko/kotlin/opt-in-requirements">옵트인 요구 사항(Opt-in requirements)</a>은 이제 <a href="/ko/kotlin/components-stability">Stable</a>이며 추가적인 컴파일러 구성이 필요하지 않습니다.</p><p>1.7.0 이전에는 옵트인 기능 자체에 경고를 피하기 위해 <code>-opt-in=kotlin.RequiresOptIn</code> 인자가 필요했습니다. 이제는 더 이상 필요하지 않지만, 다른 어노테이션이나 <a href="/ko/kotlin/opt-in-requirements#opt-in-a-module">모듈</a>에 옵트인하기 위해 <code>-opt-in</code> 컴파일러 인자를 계속 사용할 수 있습니다.</p><h3 id="안정적인-명확히-null을-허용하지-않는-타입" tabindex="-1">안정적인 명확히 null을 허용하지 않는 타입 <a class="header-anchor" href="#안정적인-명확히-null을-허용하지-않는-타입" aria-label="Permalink to &quot;안정적인 명확히 null을 허용하지 않는 타입&quot;">​</a></h3><p>Kotlin 1.7.0에서는 명확히 null을 허용하지 않는 타입(definitely non-nullable types)이 <a href="/ko/kotlin/components-stability">Stable</a>로 승격되었습니다. 이는 제네릭 Java 클래스 및 인터페이스를 확장할 때 더 나은 상호 운용성을 제공합니다.</p><p>새로운 구문 <code>T &amp; Any</code>를 사용하여 사용 위치에서 제네릭 타입 파라미터를 명확히 null을 허용하지 않는 것으로 표시할 수 있습니다. 이 구문 형식은 <a href="https://en.wikipedia.org/wiki/Intersection_type" target="_blank" rel="noreferrer">교차 타입(intersection types)</a> 표기법에서 유래했으며, 이제 <code>&amp;</code>의 왼쪽에 nullable 상위 바운드가 있는 타입 파라미터와 오른쪽에 non-nullable <code>Any</code>로 제한됩니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">elvisLike</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, y: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp; Any): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp; Any </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x ?: y</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // OK</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    elvisLike</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).length</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Error: &#39;null&#39; cannot be a value of a non-null type</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    elvisLike</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).length</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // OK</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    elvisLike</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).length</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Error: &#39;null&#39; cannot be a value of a non-null type</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    elvisLike</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).length</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>명확히 null을 허용하지 않는 타입에 대해 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/definitely-non-nullable-types.md" target="_blank" rel="noreferrer">이 KEEP</a>에서 자세히 알아보세요.</p><h2 id="kotlin-jvm" tabindex="-1">Kotlin/JVM <a class="header-anchor" href="#kotlin-jvm" aria-label="Permalink to &quot;Kotlin/JVM&quot;">​</a></h2><p>이번 릴리스는 Kotlin/JVM 컴파일러의 성능 개선과 새로운 컴파일러 옵션을 제공합니다. 또한 함수형 인터페이스 생성자에 대한 호출 가능한 참조(callable references)가 Stable이 되었습니다. 1.7.0부터 Kotlin/JVM 컴파일의 기본 타겟 버전은 <code>1.8</code>입니다.</p><ul><li><a href="#compiler-performance-optimizations">컴파일러 성능 최적화</a></li><li><a href="#new-compiler-option-xjdk-release">새로운 컴파일러 옵션 <code>-Xjdk-release</code></a></li><li><a href="#stable-callable-references-to-functional-interface-constructors">함수형 인터페이스 생성자에 대한 안정적인 호출 가능한 참조</a></li><li><a href="#removed-jvm-target-version-1-6">JVM 타겟 버전 1.6 제거</a></li></ul><h3 id="컴파일러-성능-최적화" tabindex="-1">컴파일러 성능 최적화 <a class="header-anchor" href="#컴파일러-성능-최적화" aria-label="Permalink to &quot;컴파일러 성능 최적화&quot;">​</a></h3><p>Kotlin 1.7.0은 Kotlin/JVM 컴파일러의 성능 개선을 도입합니다. 저희 벤치마크에 따르면 Kotlin 1.6.0에 비해 컴파일 시간이 <a href="https://youtrack.jetbrains.com/issue/KT-48233/Switching-to-JVM-IR-backend-increases-compilation-time-by-more-t#focus=Comments-27-6114542.0-0" target="_blank" rel="noreferrer">평균 10% 단축</a>되었습니다. 예를 들어, <a href="https://youtrack.jetbrains.com/issue/KT-51416/Compilation-of-kotlinx-html-DSL-should-still-be-faster" target="_blank" rel="noreferrer">kotlinx.html을 사용하는 프로젝트</a>와 같이 인라인 함수를 많이 사용하는 프로젝트는 바이트코드 후처리 개선 덕분에 더 빠르게 컴파일될 것입니다.</p><h3 id="새로운-컴파일러-옵션-xjdk-release" tabindex="-1">새로운 컴파일러 옵션: -Xjdk-release <a class="header-anchor" href="#새로운-컴파일러-옵션-xjdk-release" aria-label="Permalink to &quot;새로운 컴파일러 옵션: -Xjdk-release&quot;">​</a></h3><p>Kotlin 1.7.0은 새로운 컴파일러 옵션 <code>-Xjdk-release</code>를 제공합니다. 이 옵션은 <a href="http://openjdk.java.net/jeps/247" target="_blank" rel="noreferrer">javac의 커맨드라인 <code>--release</code> 옵션</a>과 유사합니다. <code>-Xjdk-release</code> 옵션은 타겟 바이트코드 버전을 제어하고, 클래스패스에 있는 JDK의 API를 지정된 Java 버전으로 제한합니다. 예를 들어, <code>kotlinc -Xjdk-release=1.8</code>은 종속성에 있는 JDK 버전이 9 이상이라도 <code>java.lang.Module</code>을 참조할 수 없도록 합니다.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>이 옵션은 각 JDK 배포판에 대해 <a href="https://youtrack.jetbrains.com/issue/KT-29974" target="_blank" rel="noreferrer">효과가 보장되지 않습니다</a>.</p></div><p><a href="https://youtrack.jetbrains.com/issue/KT-29974/Add-a-compiler-option-Xjdk-release-similar-to-javac-s-release-to" target="_blank" rel="noreferrer">이 YouTrack 티켓</a>에 피드백을 남겨주십시오.</p><h3 id="함수형-인터페이스-생성자에-대한-안정적인-호출-가능한-참조" tabindex="-1">함수형 인터페이스 생성자에 대한 안정적인 호출 가능한 참조 <a class="header-anchor" href="#함수형-인터페이스-생성자에-대한-안정적인-호출-가능한-참조" aria-label="Permalink to &quot;함수형 인터페이스 생성자에 대한 안정적인 호출 가능한 참조&quot;">​</a></h3><p>함수형 인터페이스 생성자에 대한 <a href="/ko/kotlin/reflection#callable-references">호출 가능한 참조(Callable references)</a>는 이제 <a href="/ko/kotlin/components-stability">Stable</a>입니다. 호출 가능한 참조를 사용하여 생성자 함수가 있는 인터페이스에서 함수형 인터페이스로 <a href="/ko/kotlin/fun-interfaces#migration-from-an-interface-with-constructor-function-to-a-functional-interface">마이그레이션하는 방법</a>을 알아보십시오.</p><p>발견한 모든 문제는 <a href="https://youtrack.jetbrains.com/newissue?project=kt" target="_blank" rel="noreferrer">YouTrack</a>에 보고해 주십시오.</p><h3 id="jvm-타겟-버전-1-6-제거" tabindex="-1">JVM 타겟 버전 1.6 제거 <a class="header-anchor" href="#jvm-타겟-버전-1-6-제거" aria-label="Permalink to &quot;JVM 타겟 버전 1.6 제거&quot;">​</a></h3><p>Kotlin/JVM 컴파일의 기본 타겟 버전은 <code>1.8</code>입니다. <code>1.6</code> 타겟은 제거되었습니다.</p><p>JVM 타겟 1.8 이상으로 마이그레이션하십시오. 다음 환경에서 JVM 타겟 버전을 업데이트하는 방법을 알아보세요.</p><ul><li><a href="/ko/kotlin/gradle-compiler-options#attributes-specific-to-jvm">Gradle</a></li><li><a href="/ko/kotlin/maven#attributes-specific-to-jvm">Maven</a></li><li><a href="/ko/kotlin/compiler-reference#jvm-target-version">커맨드라인 컴파일러</a></li></ul><h2 id="kotlin-native" tabindex="-1">Kotlin/Native <a class="header-anchor" href="#kotlin-native" aria-label="Permalink to &quot;Kotlin/Native&quot;">​</a></h2><p>Kotlin 1.7.0에는 Objective-C 및 Swift 상호 운용성에 대한 변경 사항이 포함되어 있으며, 이전 릴리스에서 도입된 기능을 안정화합니다. 또한 새로운 메모리 관리자에 대한 성능 개선 및 기타 업데이트를 제공합니다.</p><ul><li><a href="#performance-improvements-for-the-new-memory-manager">새로운 메모리 관리자 성능 개선</a></li><li><a href="#unified-compiler-plugin-abi-with-jvm-and-js-ir-backends">JVM 및 JS IR 백엔드와 통합된 컴파일러 플러그인 ABI</a></li><li><a href="#support-for-standalone-android-executables">독립형 Android 실행 파일 지원</a></li><li><a href="#interop-with-swift-async-await-returning-void-instead-of-kotlinunit">Swift async/await와의 상호 운용성: KotlinUnit 대신 Void 반환</a></li><li><a href="#prohibited-undeclared-exceptions-through-objective-c-bridges">Objective-C 브리지를 통한 선언되지 않은 예외 금지</a></li><li><a href="#improved-cocoapods-integration">향상된 CocoaPods 통합</a></li><li><a href="#overriding-the-kotlin-native-compiler-download-url">Kotlin/Native 컴파일러 다운로드 URL 재정의</a></li></ul><h3 id="새로운-메모리-관리자-성능-개선" tabindex="-1">새로운 메모리 관리자 성능 개선 <a class="header-anchor" href="#새로운-메모리-관리자-성능-개선" aria-label="Permalink to &quot;새로운 메모리 관리자 성능 개선&quot;">​</a></h3><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>새로운 Kotlin/Native 메모리 관리자는 <a href="/ko/kotlin/components-stability">알파 버전</a>입니다. 향후 호환되지 않게 변경될 수 있으며 수동 마이그레이션이 필요할 수 있습니다. <a href="https://youtrack.jetbrains.com/issue/KT-48525" target="_blank" rel="noreferrer">YouTrack</a>에 피드백을 주시면 감사하겠습니다.</p></div><p>새로운 메모리 관리자는 아직 알파 버전이지만, <a href="/ko/kotlin/components-stability">Stable</a>로 향하는 길에 있습니다. 이번 릴리스에서는 새로운 메모리 관리자에 대한 상당한 성능 개선, 특히 가비지 컬렉션(GC)에서 이루어졌습니다. 특히 <a href="/ko/kotlin/whatsnew1620">1.6.20에 도입된</a> 스윕 단계의 동시 구현이 이제 기본적으로 활성화됩니다. 이는 애플리케이션이 GC를 위해 일시 중지되는 시간을 줄이는 데 도움이 됩니다. 새로운 GC 스케줄러는 특히 더 큰 힙에서 GC 빈도를 더 잘 선택합니다.</p><p>또한, 디버그 바이너리를 특별히 최적화하여 메모리 관리자의 구현 코드에서 적절한 최적화 수준과 링크 타임 최적화가 사용되도록 했습니다. 이는 벤치마크에서 디버그 바이너리의 실행 시간을 약 30% 개선하는 데 도움이 되었습니다.</p><p>프로젝트에서 새로운 메모리 관리자를 사용해 보고 어떻게 작동하는지 확인한 후 <a href="https://youtrack.com/issue/KT-48525" target="_blank" rel="noreferrer">YouTrack</a>에 피드백을 공유해 주십시오.</p><h3 id="jvm-및-js-ir-백엔드와-통합된-컴파일러-플러그인-abi" tabindex="-1">JVM 및 JS IR 백엔드와 통합된 컴파일러 플러그인 ABI <a class="header-anchor" href="#jvm-및-js-ir-백엔드와-통합된-컴파일러-플러그인-abi" aria-label="Permalink to &quot;JVM 및 JS IR 백엔드와 통합된 컴파일러 플러그인 ABI&quot;">​</a></h3><p>Kotlin 1.7.0부터 Kotlin Multiplatform Gradle 플러그인은 기본적으로 Kotlin/Native용 임베더블 컴파일러 JAR를 사용합니다. 이 <a href="/ko/kotlin/whatsnew16#unified-compiler-plugin-abi-with-jvm-and-js-ir-backends">기능은 1.6.0에 실험적으로 발표되었으며</a>, 이제 Stable이며 사용할 준비가 되었습니다.</p><p>이 개선 사항은 라이브러리 작성자에게 매우 유용하며, 컴파일러 플러그인 개발 경험을 향상시킵니다. 이 릴리스 이전에는 Kotlin/Native용 별도 아티팩트를 제공해야 했지만, 이제는 Native 및 다른 지원되는 플랫폼에 동일한 컴파일러 플러그인 아티팩트를 사용할 수 있습니다.</p><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>이 기능은 플러그인 개발자가 기존 플러그인에 대한 마이그레이션 단계를 수행해야 할 수도 있습니다. <a href="https://youtrack.jetbrains.com/issue/KT-48595" target="_blank" rel="noreferrer">이 YouTrack 이슈</a>에서 플러그인 업데이트를 준비하는 방법을 알아보세요.</p></div><h3 id="독립형-android-실행-파일-지원" tabindex="-1">독립형 Android 실행 파일 지원 <a class="header-anchor" href="#독립형-android-실행-파일-지원" aria-label="Permalink to &quot;독립형 Android 실행 파일 지원&quot;">​</a></h3><p>Kotlin 1.7.0은 Android Native 타겟용 표준 실행 파일을 생성하는 것을 완전히 지원합니다. 이 기능은 <a href="/ko/kotlin/whatsnew1620#support-for-standalone-android-executables">1.6.20에 도입되었으며</a>, 이제 기본적으로 활성화됩니다.</p><p>Kotlin/Native가 공유 라이브러리를 생성하던 이전 동작으로 되돌리려면 다음 설정을 사용하십시오.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">binaryOptions[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;androidProgramType&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;nativeActivity&quot;</span></span></code></pre></div><h3 id="swift-async-await와의-상호-운용성-kotlinunit-대신-void-반환" tabindex="-1">Swift async/await와의 상호 운용성: KotlinUnit 대신 Void 반환 <a class="header-anchor" href="#swift-async-await와의-상호-운용성-kotlinunit-대신-void-반환" aria-label="Permalink to &quot;Swift async/await와의 상호 운용성: KotlinUnit 대신 Void 반환&quot;">​</a></h3><p>Kotlin <code>suspend</code> 함수는 이제 Swift에서 <code>KotlinUnit</code> 타입 대신 <code>Void</code> 타입을 반환합니다. 이는 Swift의 <code>async</code>/<code>await</code>와의 상호 운용성 개선의 결과입니다. 이 기능은 <a href="/ko/kotlin/whatsnew1620#interop-with-swift-async-await-returning-void-instead-of-kotlinunit">1.6.20에 도입되었으며</a>, 이번 릴리스에서는 이 동작이 기본적으로 활성화됩니다.</p><p>더 이상 <code>kotlin.native.binary.unitSuspendFunctionObjCExport=proper</code> 속성을 사용하여 이러한 함수에 대한 올바른 타입을 반환할 필요가 없습니다.</p><h3 id="objective-c-브리지를-통한-선언되지-않은-예외-금지" tabindex="-1">Objective-C 브리지를 통한 선언되지 않은 예외 금지 <a class="header-anchor" href="#objective-c-브리지를-통한-선언되지-않은-예외-금지" aria-label="Permalink to &quot;Objective-C 브리지를 통한 선언되지 않은 예외 금지&quot;">​</a></h3><p>Kotlin 코드를 Swift/Objective-C 코드에서 호출하거나(또는 그 반대) 이 코드가 예외를 던지는 경우, 예외가 발생한 코드에서 처리되어야 합니다. 단, 적절한 변환(예: <code>@Throws</code> 어노테이션 사용)을 통해 언어 간에 예외 전달을 명시적으로 허용한 경우는 제외합니다.</p><p>이전에는 Kotlin에 선언되지 않은 예외가 일부 경우 한 언어에서 다른 언어로 &quot;누출&quot;될 수 있는 의도치 않은 동작이 있었습니다. Kotlin 1.7.0은 해당 문제를 수정했으며, 이제 그러한 경우는 프로그램 종료로 이어집니다.</p><p>따라서 예를 들어 Kotlin에 <code>{ throw Exception() }</code> 람다가 있고 이를 Swift에서 호출하는 경우, Kotlin 1.7.0에서는 예외가 Swift 코드에 도달하는 즉시 종료됩니다. 이전 Kotlin 버전에서는 그러한 예외가 Swift 코드로 누출될 수 있었습니다.</p><p><code>@Throws</code> 어노테이션은 이전과 동일하게 작동합니다.</p><h3 id="향상된-cocoapods-통합" tabindex="-1">향상된 CocoaPods 통합 <a class="header-anchor" href="#향상된-cocoapods-통합" aria-label="Permalink to &quot;향상된 CocoaPods 통합&quot;">​</a></h3><p>Kotlin 1.7.0부터 프로젝트에 CocoaPods를 통합하려면 더 이상 <code>cocoapods-generate</code> 플러그인을 설치할 필요가 없습니다.</p><p>이전에는 Kotlin Multiplatform Mobile 프로젝트에서 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-ios-dependencies.html#with-cocoapods" target="_blank" rel="noreferrer">iOS 종속성</a>을 처리하는 등 CocoaPods를 사용하려면 CocoaPods 종속성 관리자와 <code>cocoapods-generate</code> 플러그인을 모두 설치해야 했습니다.</p><p>이제 CocoaPods 통합 설정이 더 쉬워졌으며, Ruby 3 이상에서 <code>cocoapods-generate</code>가 설치되지 않던 문제를 해결했습니다. 이제 Apple M1에서 더 잘 작동하는 최신 Ruby 버전도 지원됩니다.</p><p><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-overview.html#set-up-an-environment-to-work-with-cocoapods" target="_blank" rel="noreferrer">초기 CocoaPods 통합 설정 방법</a>을 참조하십시오.</p><h3 id="kotlin-native-컴파일러-다운로드-url-재정의" tabindex="-1">Kotlin/Native 컴파일러 다운로드 URL 재정의 <a class="header-anchor" href="#kotlin-native-컴파일러-다운로드-url-재정의" aria-label="Permalink to &quot;Kotlin/Native 컴파일러 다운로드 URL 재정의&quot;">​</a></h3><p>Kotlin 1.7.0부터 Kotlin/Native 컴파일러의 다운로드 URL을 사용자 지정할 수 있습니다. 이는 CI에서 외부 링크가 금지된 경우에 유용합니다.</p><p>기본 기본 URL <code>https://download.jetbrains.com/kotlin/native/builds</code>를 재정의하려면 다음 Gradle 속성을 사용하십시오.</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.distribution.baseDownloadUrl=https://example.com</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>다운로더는 실제 컴파일러 배포판을 다운로드하도록 이 기본 URL에 네이티브 버전과 타겟 OS를 추가합니다.</p></div><h2 id="kotlin-js" tabindex="-1">Kotlin/JS <a class="header-anchor" href="#kotlin-js" aria-label="Permalink to &quot;Kotlin/JS&quot;">​</a></h2><p>Kotlin/JS는 <a href="/ko/kotlin/js-ir-compiler">JS IR 컴파일러 백엔드</a>에 대한 추가 개선 사항과 개발 경험을 향상시킬 수 있는 다른 업데이트를 제공합니다.</p><ul><li><a href="#performance-improvements-for-the-new-ir-backend">새로운 IR 백엔드 성능 개선</a></li><li><a href="#minification-for-member-names-when-using-ir">IR 사용 시 멤버 이름 최소화(Minification)</a></li><li><a href="#support-for-older-browsers-via-polyfills-in-the-ir-backend">IR 백엔드에서 폴리필을 통한 이전 브라우저 지원</a></li><li><a href="#dynamically-load-javascript-modules-from-js-expressions">JS 표현식에서 JavaScript 모듈 동적 로드</a></li><li><a href="#specify-environment-variables-for-javascript-test-runners">JavaScript 테스트 러너용 환경 변수 지정</a></li></ul><h3 id="새로운-ir-백엔드-성능-개선" tabindex="-1">새로운 IR 백엔드 성능 개선 <a class="header-anchor" href="#새로운-ir-백엔드-성능-개선" aria-label="Permalink to &quot;새로운 IR 백엔드 성능 개선&quot;">​</a></h3><p>이번 릴리스에는 개발 경험을 향상시킬 주요 업데이트가 있습니다.</p><ul><li>Kotlin/JS의 점진적 컴파일 성능이 크게 향상되었습니다. JS 프로젝트를 빌드하는 데 시간이 덜 걸립니다. 점진적 리빌드는 이제 많은 경우 레거시 백엔드와 거의 동등한 수준이 되어야 합니다.</li><li>Kotlin/JS 최종 번들의 공간이 덜 필요합니다. 최종 아티팩트 크기를 크게 줄였기 때문입니다. 일부 대형 프로젝트의 경우 프로덕션 번들 크기가 레거시 백엔드에 비해 최대 20% 감소한 것으로 측정되었습니다.</li><li>인터페이스에 대한 타입 검사가 몇 배 더 향상되었습니다.</li><li>Kotlin이 더 고품질의 JS 코드를 생성합니다.</li></ul><h3 id="ir-사용-시-멤버-이름-최소화-minification" tabindex="-1">IR 사용 시 멤버 이름 최소화(Minification) <a class="header-anchor" href="#ir-사용-시-멤버-이름-최소화-minification" aria-label="Permalink to &quot;IR 사용 시 멤버 이름 최소화(Minification)&quot;">​</a></h3><p>Kotlin/JS IR 컴파일러는 이제 Kotlin 클래스와 함수의 관계에 대한 내부 정보를 사용하여 더 효율적인 최소화(minification)를 적용하여 함수, 속성 및 클래스의 이름을 단축합니다. 이는 결과 번들된 애플리케이션의 크기를 줄입니다.</p><p>이러한 유형의 최소화는 프로덕션 모드에서 Kotlin/JS 애플리케이션을 빌드할 때 자동으로 적용되며 기본적으로 활성화되어 있습니다. 멤버 이름 최소화를 비활성화하려면 <code>-Xir-minimized-member-names</code> 컴파일러 플래그를 사용하십시오.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(IR) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        compilations.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            compileKotlinTask.kotlinOptions.freeCompilerArgs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xir-minimized-member-names=false&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="ir-백엔드에서-폴리필을-통한-이전-브라우저-지원" tabindex="-1">IR 백엔드에서 폴리필을 통한 이전 브라우저 지원 <a class="header-anchor" href="#ir-백엔드에서-폴리필을-통한-이전-브라우저-지원" aria-label="Permalink to &quot;IR 백엔드에서 폴리필을 통한 이전 브라우저 지원&quot;">​</a></h3><p>Kotlin/JS용 IR 컴파일러 백엔드는 이제 레거시 백엔드와 동일한 폴리필을 포함합니다. 이를 통해 새로운 컴파일러로 컴파일된 코드가 Kotlin 표준 라이브러리에서 사용하는 모든 ES2015 메서드를 지원하지 않는 이전 브라우저에서 실행될 수 있습니다. 프로젝트에서 실제로 사용되는 폴리필만 최종 번들에 포함되어 번들 크기에 미치는 잠재적 영향을 최소화합니다.</p><p>이 기능은 IR 컴파일러를 사용할 때 기본적으로 활성화되어 있으며, 별도로 구성할 필요가 없습니다.</p><h3 id="js-표현식에서-javascript-모듈-동적-로드" tabindex="-1">JS 표현식에서 JavaScript 모듈 동적 로드 <a class="header-anchor" href="#js-표현식에서-javascript-모듈-동적-로드" aria-label="Permalink to &quot;JS 표현식에서 JavaScript 모듈 동적 로드&quot;">​</a></h3><p>JavaScript 모듈을 사용할 때 대부분의 애플리케이션은 정적 임포트를 사용하며, 이는 <a href="/ko/kotlin/js-modules">JavaScript 모듈 통합</a>에서 다룹니다. 그러나 Kotlin/JS는 애플리케이션에서 런타임에 JavaScript 모듈을 동적으로 로드하는 메커니즘이 부족했습니다.</p><p>Kotlin 1.7.0부터 JavaScript의 <code>import</code> 문이 <code>js</code> 블록에서 지원되어 런타임에 패키지를 애플리케이션으로 동적으로 가져올 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myPackage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;import(&#39;my-package&#39;)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="javascript-테스트-러너용-환경-변수-지정" tabindex="-1">JavaScript 테스트 러너용 환경 변수 지정 <a class="header-anchor" href="#javascript-테스트-러너용-환경-변수-지정" aria-label="Permalink to &quot;JavaScript 테스트 러너용 환경 변수 지정&quot;">​</a></h3><p>Node.js 패키지 해상도를 조정하거나 Node.js 테스트에 외부 정보를 전달하기 위해 이제 JavaScript 테스트 러너에서 사용하는 환경 변수를 지정할 수 있습니다. 환경 변수를 정의하려면 빌드 스크립트의 <code>testTask</code> 블록 내에서 키-값 쌍과 함께 <code>environment()</code> 함수를 사용하십시오.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        nodejs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            testTask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                environment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;key&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="표준-라이브러리" tabindex="-1">표준 라이브러리 <a class="header-anchor" href="#표준-라이브러리" aria-label="Permalink to &quot;표준 라이브러리&quot;">​</a></h2><p>Kotlin 1.7.0에서는 표준 라이브러리에 다양한 변경 사항과 개선 사항이 적용되었습니다. 새로운 기능을 도입하고, 실험적인 기능을 안정화하며, Native, JS, JVM에서 명명된 캡처 그룹(named capturing groups) 지원을 통합합니다.</p><ul><li><a href="#min-and-max-collection-functions-return-as-non-nullable">min() 및 max() 컬렉션 함수가 null을 허용하지 않는 형태로 반환</a></li><li><a href="#regular-expression-matching-at-specific-indices">특정 인덱스에서의 정규 표현식 매칭</a></li><li><a href="#extended-support-for-previous-language-and-api-versions">이전 언어 및 API 버전 확장 지원</a></li><li><a href="#access-to-annotations-via-reflection">리플렉션을 통한 어노테이션 접근</a></li><li><a href="#stable-deep-recursive-functions">안정적인 깊은 재귀 함수</a></li><li><a href="#time-marks-based-on-inline-classes-for-default-time-source">기본 타임 소스에 대한 인라인 클래스 기반 타임 마크</a></li><li><a href="#new-experimental-extension-functions-for-java-optionals">Java Optional을 위한 새로운 실험적인 확장 함수</a></li><li><a href="#support-for-named-capturing-groups-in-js-and-native">JS 및 Native에서 명명된 캡처 그룹 지원</a></li></ul><h3 id="min-및-max-컬렉션-함수가-null을-허용하지-않는-형태로-반환" tabindex="-1">min() 및 max() 컬렉션 함수가 null을 허용하지 않는 형태로 반환 <a class="header-anchor" href="#min-및-max-컬렉션-함수가-null을-허용하지-않는-형태로-반환" aria-label="Permalink to &quot;min() 및 max() 컬렉션 함수가 null을 허용하지 않는 형태로 반환&quot;">​</a></h3><p><a href="/ko/kotlin/whatsnew14">Kotlin 1.4.0</a>에서 <code>min()</code> 및 <code>max()</code> 컬렉션 함수의 이름을 <code>minOrNull()</code> 및 <code>maxOrNull()</code>로 변경했습니다. 이 새로운 이름은 수신 컬렉션이 비어 있을 경우 null을 반환하는 동작을 더 잘 반영합니다. 또한 Kotlin 컬렉션 API 전체에서 사용되는 명명 규칙과 함수의 동작을 일치시키는 데 도움이 되었습니다.</p><p><code>minBy()</code>, <code>maxBy()</code>, <code>minWith()</code>, <code>maxWith()</code>도 마찬가지였으며, 모두 Kotlin 1.4.0에서 *OrNull() 동의어를 얻었습니다. 이 변경의 영향을 받은 이전 함수들은 점진적으로 지원 중단되었습니다.</p><p>Kotlin 1.7.0은 원래 함수 이름을 다시 도입하지만, null을 허용하지 않는 반환 타입을 가집니다. 새로운 <code>min()</code>, <code>max()</code>, <code>minBy()</code>, <code>maxBy()</code>, <code>minWith()</code>, <code>maxWith()</code> 함수는 이제 컬렉션 요소를 엄격하게 반환하거나 예외를 던집니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(numbers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">maxOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;null&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(numbers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;Exception in... Collection is empty.&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="특정-인덱스에서의-정규-표현식-매칭" tabindex="-1">특정 인덱스에서의 정규 표현식 매칭 <a class="header-anchor" href="#특정-인덱스에서의-정규-표현식-매칭" aria-label="Permalink to &quot;특정 인덱스에서의 정규 표현식 매칭&quot;">​</a></h3><p><a href="/ko/kotlin/whatsnew1530#matching-with-regex-at-a-particular-position">1.5.30에 도입된</a> <code>Regex.matchAt()</code> 및 <code>Regex.matchesAt()</code> 함수는 이제 Stable입니다. 이 함수들은 <code>String</code> 또는 <code>CharSequence</code> 내의 특정 위치에서 정규 표현식이 정확히 일치하는지 확인하는 방법을 제공합니다.</p><p><code>matchesAt()</code>은 일치 여부를 확인하고 boolean 결과를 반환합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> releaseText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Kotlin 1.7.0 is on its way!&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 정규 표현식: 한 자리 숫자, 점, 한 자리 숫자, 점, 한 자리 이상 숫자</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> versionRegex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">d[.]</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">d[.]</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">d+&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toRegex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(versionRegex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchesAt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(releaseText, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;false&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(versionRegex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchesAt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(releaseText, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;true&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>matchAt()</code>은 일치하는 경우 일치 항목을 반환하고, 그렇지 않으면 <code>null</code>을 반환합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> releaseText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Kotlin 1.7.0 is on its way!&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> versionRegex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">d[.]</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">d[.]</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">d+&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toRegex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(versionRegex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchAt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(releaseText, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;null&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(versionRegex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchAt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(releaseText, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)?.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;1.7.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://youtrack.jetbrains.com/issue/KT-34021" target="_blank" rel="noreferrer">이 YouTrack 이슈</a>에 대한 피드백에 감사드립니다.</p><h3 id="이전-언어-및-api-버전-확장-지원" tabindex="-1">이전 언어 및 API 버전 확장 지원 <a class="header-anchor" href="#이전-언어-및-api-버전-확장-지원" aria-label="Permalink to &quot;이전 언어 및 API 버전 확장 지원&quot;">​</a></h3><p>광범위한 이전 Kotlin 버전에서 소비될 수 있는 라이브러리를 개발하는 라이브러리 작성자를 지원하고, 주요 Kotlin 릴리스의 증가하는 빈도에 대처하기 위해 이전 언어 및 API 버전에 대한 지원을 확장했습니다.</p><p>Kotlin 1.7.0부터는 이전 언어 및 API 버전을 두 개가 아닌 세 개를 지원합니다. 즉, Kotlin 1.7.0은 Kotlin 버전 1.4.0까지의 라이브러리 개발을 지원합니다. 하위 호환성에 대한 자세한 내용은 <a href="/ko/kotlin/compatibility-modes">호환성 모드</a>를 참조하십시오.</p><h3 id="리플렉션을-통한-어노테이션-접근" tabindex="-1">리플렉션을 통한 어노테이션 접근 <a class="header-anchor" href="#리플렉션을-통한-어노테이션-접근" aria-label="Permalink to &quot;리플렉션을 통한 어노테이션 접근&quot;">​</a></h3><p><a href="/ko/kotlin/whatsnew16#repeatable-annotations-with-runtime-retention-for-1-8-jvm-target">1.6.0에 처음 도입된</a> <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect.full/find-annotations.html" target="_blank" rel="noreferrer"><code>KAnnotatedElement.findAnnotations()</code></a> 확장 함수는 이제 <a href="/ko/kotlin/components-stability">Stable</a>입니다. 이 <a href="/ko/kotlin/reflection">리플렉션</a> 함수는 개별적으로 적용되었거나 반복된 어노테이션을 포함하여 요소에 있는 지정된 타입의 모든 어노테이션을 반환합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Repeatable</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">annotation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;First Tag&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Second Tag&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> taggedFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;I&#39;m a tagged function!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">taggedFunction</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KAnnotatedElement</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foo.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">findAnnotations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [@Tag(name=First Tag), @Tag(name=Second Tag)]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="안정적인-깊은-재귀-함수" tabindex="-1">안정적인 깊은 재귀 함수 <a class="header-anchor" href="#안정적인-깊은-재귀-함수" aria-label="Permalink to &quot;안정적인 깊은 재귀 함수&quot;">​</a></h3><p>깊은 재귀 함수는 <a href="https://blog.jetbrains.com/kotlin/2020/07/kotlin-1-4-rc-debugging-coroutines/#Defining_deep_recursive_functions_using_coroutines" target="_blank" rel="noreferrer">Kotlin 1.4.0</a>부터 실험적인 기능으로 제공되었으며, Kotlin 1.7.0에서 이제 <a href="/ko/kotlin/components-stability">Stable</a>입니다. <code>DeepRecursiveFunction</code>을 사용하면 실제 호출 스택 대신 힙에 스택을 유지하는 함수를 정의할 수 있습니다. 이를 통해 매우 깊은 재귀 계산을 실행할 수 있습니다. 깊은 재귀 함수를 호출하려면 <code>invoke</code>합니다.</p><p>이 예제에서는 깊은 재귀 함수를 사용하여 이진 트리의 깊이를 재귀적으로 계산합니다. 이 샘플 함수는 재귀적으로 100,000번 호출되지만 <code>StackOverflowError</code>는 발생하지 않습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Tree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Tree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Tree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> calculateDepth </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DeepRecursiveFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Tree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; { t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> else</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> maxOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        callRecursive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t.left),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        callRecursive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t.right)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 깊이가 100,000인 트리를 생성합니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deepTree </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> generateSequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Tree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) { prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        Tree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(prev, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">take</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">last</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">calculateDepth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(deepTree)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 100000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>재귀 깊이가 1000번 호출을 초과하는 코드에서는 깊은 재귀 함수를 사용하는 것을 고려하십시오.</p><h3 id="기본-타임-소스에-대한-인라인-클래스-기반-타임-마크" tabindex="-1">기본 타임 소스에 대한 인라인 클래스 기반 타임 마크 <a class="header-anchor" href="#기본-타임-소스에-대한-인라인-클래스-기반-타임-마크" aria-label="Permalink to &quot;기본 타임 소스에 대한 인라인 클래스 기반 타임 마크&quot;">​</a></h3><p>Kotlin 1.7.0은 <code>TimeSource.Monotonic</code>이 반환하는 타임 마크를 인라인 값 클래스로 변경하여 시간 측정 기능의 성능을 향상시킵니다. 이는 <code>markNow()</code>, <code>elapsedNow()</code>, <code>measureTime()</code>, <code>measureTimedValue()</code>와 같은 함수를 호출할 때 <code>TimeMark</code> 인스턴스에 대한 래퍼 클래스를 할당하지 않는다는 것을 의미합니다. 특히 핫 패스의 일부인 코드 조각을 측정할 때, 이는 측정의 성능 영향을 최소화하는 데 도움이 될 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalTime::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mark </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TimeSource.Monotonic.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">markNow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 반환된 \`TimeMark\`는 인라인 클래스입니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elapsedDuration </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mark.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">elapsedNow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>이 최적화는 <code>TimeMark</code>가 얻어진 타임 소스가 정적으로 <code>TimeSource.Monotonic</code>으로 알려진 경우에만 사용할 수 있습니다.</p></div><h3 id="java-optional을-위한-새로운-실험적인-확장-함수" tabindex="-1">Java Optional을 위한 새로운 실험적인 확장 함수 <a class="header-anchor" href="#java-optional을-위한-새로운-실험적인-확장-함수" aria-label="Permalink to &quot;Java Optional을 위한 새로운 실험적인 확장 함수&quot;">​</a></h3><p>Kotlin 1.7.0은 Java의 <code>Optional</code> 클래스 작업을 단순화하는 새로운 편의 함수들을 제공합니다. 이 새로운 함수들은 JVM에서 Optional 객체를 언래핑(unwrap)하고 변환하는 데 사용될 수 있으며, Java API 작업의 간결성을 높이는 데 도움이 됩니다.</p><p><code>getOrNull()</code>, <code>getOrDefault()</code>, <code>getOrElse()</code> 확장 함수는 <code>Optional</code>이 존재할 경우 값을 가져올 수 있게 합니다. 그렇지 않으면 각각 <code>null</code>, 기본 값, 또는 함수가 반환하는 값을 얻게 됩니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> presentOptional </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Optional.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;I&#39;m here!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(presentOptional.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;I&#39;m here!&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> absentOptional </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Optional.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">empty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(absentOptional.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// null</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(absentOptional.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Nobody here!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;Nobody here!&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(absentOptional.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrElse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Optional was absent!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Default value!&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;Optional was absent!&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;Default value!&quot;</span></span></code></pre></div><p><code>toList()</code>, <code>toSet()</code>, <code>asSequence()</code> 확장 함수는 존재하는 <code>Optional</code>의 값을 리스트, 세트 또는 시퀀스로 변환하거나, 그렇지 않으면 빈 컬렉션을 반환합니다. <code>toCollection()</code> 확장 함수는 <code>Optional</code> 값을 이미 존재하는 대상 컬렉션에 추가합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> presentOptional </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Optional.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;I&#39;m here!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> absentOptional </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Optional.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">empty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(presentOptional.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;,&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> absentOptional.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [&quot;I&#39;m here!&quot;], []</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(presentOptional.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;,&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> absentOptional.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [&quot;I&#39;m here!&quot;], []</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myCollection </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mutableListOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">absentOptional.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toCollection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myCollection)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myCollection)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">presentOptional.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toCollection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myCollection)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myCollection)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [&quot;I&#39;m here!&quot;]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(presentOptional, absentOptional).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">flatMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asSequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(list)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [&quot;I&#39;m here!&quot;]</span></span></code></pre></div><p>이러한 확장 함수는 Kotlin 1.7.0에서 실험적으로 도입되었습니다. <code>Optional</code> 확장에 대한 자세한 내용은 <a href="https://github.com/Kotlin/KEEP/pull/291" target="_blank" rel="noreferrer">이 KEEP</a>에서 확인할 수 있습니다. 언제나처럼, <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">Kotlin 이슈 트래커</a>에 피드백을 환영합니다.</p><h3 id="js-및-native에서-명명된-캡처-그룹-지원" tabindex="-1">JS 및 Native에서 명명된 캡처 그룹 지원 <a class="header-anchor" href="#js-및-native에서-명명된-캡처-그룹-지원" aria-label="Permalink to &quot;JS 및 Native에서 명명된 캡처 그룹 지원&quot;">​</a></h3><p>Kotlin 1.7.0부터는 명명된 캡처 그룹(named capturing groups)이 JVM뿐만 아니라 JS 및 Native 플랫폼에서도 지원됩니다.</p><p>캡처 그룹에 이름을 부여하려면 정규 표현식에서 (<code>?&lt;name&gt;group</code>) 구문을 사용하십시오. 그룹에 의해 일치된 텍스트를 얻으려면 새로 도입된 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/get.html" target="_blank" rel="noreferrer"><code>MatchGroupCollection.get()</code></a> 함수를 호출하고 그룹 이름을 전달하십시오.</p><h4 id="이름으로-일치된-그룹-값-검색" tabindex="-1">이름으로 일치된 그룹 값 검색 <a class="header-anchor" href="#이름으로-일치된-그룹-값-검색" aria-label="Permalink to &quot;이름으로 일치된 그룹 값 검색&quot;">​</a></h4><p>도시 좌표를 매칭하는 이 예제를 고려해 보십시오. 정규 표현식과 일치하는 그룹 컬렉션을 얻으려면 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-match-result/groups.html" target="_blank" rel="noreferrer"><code>groups</code></a>를 사용하십시오. 그룹의 내용을 번호(인덱스)와 <code>value</code>를 사용한 이름으로 검색하는 것을 비교하십시오.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> regex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">b(?&lt;city&gt;[A-Za-z</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">s]+),</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">s(?&lt;state&gt;[A-Z]{2}):</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">s(?&lt;areaCode&gt;[0-9]{3})</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">b&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toRegex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Coordinates: Austin, TX: 123&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> match </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> regex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(match.groups[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;city&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]?.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;Austin&quot; — 이름으로</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(match.groups[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]?.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;TX&quot; — 번호로</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="명명된-역참조-backreferencing" tabindex="-1">명명된 역참조(backreferencing) <a class="header-anchor" href="#명명된-역참조-backreferencing" aria-label="Permalink to &quot;명명된 역참조(backreferencing)&quot;">​</a></h4><p>이제 그룹을 역참조할 때 그룹 이름을 사용할 수도 있습니다. 역참조는 이전에 캡처 그룹에 의해 일치된 동일한 텍스트를 일치시킵니다. 이를 위해 정규 표현식에서 <code>\\k&lt;name&gt;</code> 구문을 사용하십시오.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> backRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> regex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;(?&lt;title&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">w+), yes </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">k&lt;title&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toRegex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> match </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> regex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Do you copy? Sir, yes Sir!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(match.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;Sir, yes Sir&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(match.groups[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;title&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]?.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;Sir&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="대체-표현식의-명명된-그룹" tabindex="-1">대체 표현식의 명명된 그룹 <a class="header-anchor" href="#대체-표현식의-명명된-그룹" aria-label="Permalink to &quot;대체 표현식의 명명된 그룹&quot;">​</a></h4><p>명명된 그룹 참조는 대체 표현식과 함께 사용될 수 있습니다. 입력의 지정된 정규 표현식의 모든 발생을 대체 표현식으로 대체하는 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/replace.html" target="_blank" rel="noreferrer"><code>replace()</code></a> 함수와 첫 번째 일치만 교환하는 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/replace-first.html" target="_blank" rel="noreferrer"><code>replaceFirst()</code></a> 함수를 고려해 보십시오.</p><p>대체 문자열에서 <code>\${name}</code>의 발생은 지정된 이름의 캡처된 그룹에 해당하는 서브시퀀스로 대체됩니다. 그룹 참조에서 이름과 인덱스로 대체하는 것을 비교할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dateReplace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dateRegex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Regex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;(?&lt;dd&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">d{2})-(?&lt;mm&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">d{2})-(?&lt;yyyy&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">d{4})&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Date of birth: 27-04-2022&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dateRegex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">{yyyy}-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">{mm}-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">{dd}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;Date of birth: 2022-04-27&quot; — 이름으로</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dateRegex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">3-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">2-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;Date of birth: 2022-04-27&quot; — 번호로</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="gradle" tabindex="-1">Gradle <a class="header-anchor" href="#gradle" aria-label="Permalink to &quot;Gradle&quot;">​</a></h2><p>이번 릴리스는 새로운 빌드 보고서, Gradle 플러그인 변형 지원, kapt의 새로운 통계 등 다양한 기능을 제공합니다.</p><ul><li><a href="#a-new-approach-to-incremental-compilation">점진적 컴파일에 대한 새로운 접근 방식</a></li><li><a href="#build-reports-for-kotlin-compiler-tasks">컴파일러 성능 추적을 위한 새로운 빌드 보고서</a></li><li><a href="#bumping-minimum-supported-versions">Gradle 및 Android Gradle 플러그인의 최소 지원 버전 변경</a></li><li><a href="#support-for-gradle-plugin-variants">Gradle 플러그인 변형 지원</a></li><li><a href="#updates-in-the-kotlin-gradle-plugin-api">Kotlin Gradle 플러그인 API의 업데이트</a></li><li><a href="#the-sam-with-receiver-plugin-is-available-via-the-plugins-api">plugins API를 통한 sam-with-receiver 플러그인 사용 가능</a></li><li><a href="#changes-in-compile-tasks">컴파일 태스크의 변경 사항</a></li><li><a href="#statistics-of-generated-files-by-each-annotation-processor-in-kapt">kapt에서 각 어노테이션 프로세서에 의해 생성된 파일의 새로운 통계</a></li><li><a href="#deprecation-of-the-kotlin-compiler-execution-strategy-system-property">kotlin.compiler.execution.strategy 시스템 속성 지원 중단</a></li><li><a href="#removal-of-deprecated-options-methods-and-plugins">지원 중단된 옵션, 메서드 및 플러그인 제거</a></li></ul><h3 id="점진적-컴파일에-대한-새로운-접근-방식" tabindex="-1">점진적 컴파일에 대한 새로운 접근 방식 <a class="header-anchor" href="#점진적-컴파일에-대한-새로운-접근-방식" aria-label="Permalink to &quot;점진적 컴파일에 대한 새로운 접근 방식&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>점진적 컴파일의 새로운 접근 방식은 <a href="/ko/kotlin/components-stability">실험적(Experimental) 기능</a>입니다. 언제든지 변경되거나 제거될 수 있습니다. 옵트인(Opt-in)이 필요합니다(자세한 내용은 아래 참조). 평가 목적으로만 사용하시길 권장하며, <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a>에 피드백을 주시면 감사하겠습니다.</p></div><p>Kotlin 1.7.0에서는 모듈 간 변경 사항에 대한 점진적 컴파일을 재작업했습니다. 이제 종속된 비-Kotlin 모듈 내의 변경 사항에 대해서도 점진적 컴파일이 지원되며, <a href="https://docs.gradle.org/current/userguide/build_cache.html" target="_blank" rel="noreferrer">Gradle 빌드 캐시</a>와 호환됩니다. 컴파일 회피(compilation avoidance)에 대한 지원도 향상되었습니다.</p><p>빌드 캐시를 사용하거나 비-Kotlin Gradle 모듈에서 자주 변경하는 경우 새로운 접근 방식의 가장 큰 이점을 보게 될 것으로 예상합니다. <code>kotlin-gradle-plugin</code> 모듈의 Kotlin 프로젝트에 대한 저희 테스트에서는 캐시 적중 후 변경 사항에 대해 80% 이상의 개선을 보여줍니다.</p><p>이 새로운 접근 방식을 사용해 보려면 <code>gradle.properties</code>에 다음 옵션을 설정하십시오.</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.incremental.useClasspathSnapshot=true</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>점진적 컴파일의 새로운 접근 방식은 현재 Gradle 빌드 시스템의 JVM 백엔드에서만 사용할 수 있습니다.</p></div><p><a href="https://blog.jetbrains.com/kotlin/2022/07/a-new-approach-to-incremental-compilation-in-kotlin/" target="_blank" rel="noreferrer">이 블로그 게시물</a>에서 점진적 컴파일의 새로운 접근 방식이 내부적으로 어떻게 구현되었는지 알아보세요.</p><p>저희의 계획은 이 기술을 안정화하고 다른 백엔드(예: JS) 및 빌드 시스템에 대한 지원을 추가하는 것입니다. 이 컴파일 스키마에서 발생하는 모든 문제나 이상한 동작에 대해 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a>에 보고해 주시면 감사하겠습니다. 감사합니다!</p><p>Kotlin 팀은 <a href="https://github.com/gavra0" target="_blank" rel="noreferrer">Ivan Gavrilovic</a>, <a href="https://github.com/hungvietnguyen" target="_blank" rel="noreferrer">Hung Nguyen</a>, <a href="https://github.com/melix" target="_blank" rel="noreferrer">Cédric Champeau</a> 및 다른 외부 기여자들의 도움에 매우 감사드립니다.</p><h3 id="kotlin-컴파일러-태스크를-위한-빌드-보고서" tabindex="-1">Kotlin 컴파일러 태스크를 위한 빌드 보고서 <a class="header-anchor" href="#kotlin-컴파일러-태스크를-위한-빌드-보고서" aria-label="Permalink to &quot;Kotlin 컴파일러 태스크를 위한 빌드 보고서&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>Kotlin 빌드 보고서는 <a href="/ko/kotlin/components-stability">실험적(Experimental) 기능</a>입니다. 언제든지 변경되거나 제거될 수 있습니다. 옵트인(Opt-in)이 필요합니다(자세한 내용은 아래 참조). 평가 목적으로만 사용하십시오. <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a>에 피드백을 주시면 감사하겠습니다.</p></div><p>Kotlin 1.7.0은 컴파일러 성능을 추적하는 데 도움이 되는 빌드 보고서를 도입합니다. 보고서에는 다양한 컴파일 단계의 지속 시간과 컴파일이 점진적일 수 없었던 이유가 포함됩니다.</p><p>빌드 보고서는 다음과 같은 컴파일러 태스크 문제를 조사할 때 유용합니다.</p><ul><li>Gradle 빌드가 너무 오래 걸리고 성능 저하의 근본 원인을 파악하고 싶을 때.</li><li>동일한 프로젝트의 컴파일 시간이 다를 때(때로는 몇 초, 때로는 몇 분).</li></ul><p>빌드 보고서를 활성화하려면 <code>gradle.properties</code>에 빌드 보고서 출력 저장 위치를 선언하십시오.</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.build.report.output=file</span></span></code></pre></div><p>다음 값(및 조합)을 사용할 수 있습니다.</p><ul><li><p><code>file</code>은 빌드 보고서를 로컬 파일에 저장합니다.</p></li><li><p><code>build_scan</code>은 <a href="https://scans.gradle.com/" target="_blank" rel="noreferrer">빌드 스캔</a>의 <code>custom values</code> 섹션에 빌드 보고서를 저장합니다.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Gradle Enterprise 플러그인은 사용자 정의 값의 수와 길이를 제한합니다. 대규모 프로젝트에서는 일부 값이 손실될 수 있습니다.</p></div></li><li><p><code>http</code>는 HTTP(S)를 사용하여 빌드 보고서를 POST합니다. POST 메서드는 JSON 형식으로 메트릭을 보냅니다. 데이터는 버전마다 변경될 수 있습니다. 전송된 데이터의 현재 버전은 <a href="https://github.com/JetBrains/kotlin/blob/master/libraries/tools/kotlin-gradle-plugin/src/common/kotlin/org/jetbrains/kotlin/gradle/report/data/GradleCompileStatisticsData.kt" target="_blank" rel="noreferrer">Kotlin 저장소</a>에서 확인할 수 있습니다.</p></li></ul><p>오래 실행되는 컴파일에 대한 빌드 보고서 분석이 해결하는 데 도움이 될 수 있는 두 가지 일반적인 경우가 있습니다.</p><ul><li>빌드가 점진적이지 않았습니다. 원인을 분석하고 근본적인 문제를 해결하십시오.</li><li>빌드는 점진적이었지만 너무 오래 걸렸습니다. 소스 파일을 재구성해 보십시오. 즉, 큰 파일을 분할하고, 별도의 클래스를 다른 파일에 저장하고, 큰 클래스를 리팩터링하고, 최상위 함수를 다른 파일에 선언하는 등입니다.</li></ul><p><a href="https://blog.jetbrains.com/kotlin/2022/06/introducing-kotlin-build-reports/" target="_blank" rel="noreferrer">이 블로그 게시물</a>에서 새로운 빌드 보고서에 대해 자세히 알아보세요.</p><p>인프라에서 빌드 보고서를 사용해 보는 것을 환영합니다. 피드백이 있거나, 문제가 발생하거나, 개선 사항을 제안하고 싶다면 주저하지 말고 <a href="https://youtrack.jetbrains.com/newIssue" target="_blank" rel="noreferrer">이슈 트래커</a>에 보고해 주십시오. 감사합니다!</p><h3 id="최소-지원-버전-올리기" tabindex="-1">최소 지원 버전 올리기 <a class="header-anchor" href="#최소-지원-버전-올리기" aria-label="Permalink to &quot;최소 지원 버전 올리기&quot;">​</a></h3><p>Kotlin 1.7.0부터 최소 지원 Gradle 버전은 6.7.1입니다. <a href="#support-for-gradle-plugin-variants">Gradle 플러그인 변형</a>과 새로운 Gradle API를 지원하기 위해 <a href="https://youtrack.jetbrains.com/issue/KT-49733/Bump-minimal-supported-Gradle-version-to-6-7-1" target="_blank" rel="noreferrer">버전을 올려야 했습니다</a>. 앞으로는 Gradle 플러그인 변형 기능 덕분에 최소 지원 버전을 자주 올릴 필요가 없을 것입니다.</p><p>또한, 최소 지원 Android Gradle 플러그인 버전은 이제 3.6.4입니다.</p><h3 id="gradle-플러그인-변형-지원" tabindex="-1">Gradle 플러그인 변형 지원 <a class="header-anchor" href="#gradle-플러그인-변형-지원" aria-label="Permalink to &quot;Gradle 플러그인 변형 지원&quot;">​</a></h3><p>Gradle 7.0은 Gradle 플러그인 작성자를 위한 새로운 기능인 <a href="https://docs.gradle.org/7.0/userguide/implementing_gradle_plugins.html#plugin-with-variants" target="_blank" rel="noreferrer">플러그인 변형</a>을 도입했습니다. 이 기능은 Gradle 버전 7.1 미만과의 호환성을 유지하면서 새로운 Gradle 기능에 대한 지원을 더 쉽게 추가할 수 있도록 합니다. <a href="https://docs.gradle.org/current/userguide/variant_model.html" target="_blank" rel="noreferrer">Gradle의 변형 선택</a>에 대해 자세히 알아보십시오.</p><p>Gradle 플러그인 변형을 통해 다양한 Gradle 버전에 대해 다양한 Kotlin Gradle 플러그인 변형을 제공할 수 있습니다. 목표는 가장 오래된 지원 Gradle 버전에 해당하는 <code>main</code> 변형에서 기본 Kotlin 컴파일을 지원하는 것입니다. 각 변형은 해당 릴리스의 Gradle 기능에 대한 구현을 가질 것입니다. 최신 변형은 가장 넓은 Gradle 기능 세트를 지원할 것입니다. 이 접근 방식을 통해 제한된 기능으로 이전 Gradle 버전에 대한 지원을 확장할 수 있습니다.</p><p>현재 Kotlin Gradle 플러그인의 변형은 두 가지뿐입니다.</p><ul><li>Gradle 버전 6.7.1–6.9.3용 <code>main</code></li><li>Gradle 버전 7.0 이상용 <code>gradle70</code></li></ul><p>향후 Kotlin 릴리스에서는 더 많은 변형을 추가할 수 있습니다.</p><p>빌드에서 사용하는 변형을 확인하려면 <a href="https://docs.gradle.org/current/userguide/logging.html#sec:choosing_a_log_level" target="_blank" rel="noreferrer"><code>--info</code> 로그 레벨</a>을 활성화하고 출력에서 <code>Using Kotlin Gradle plugin</code>으로 시작하는 문자열(예: <code>Using Kotlin Gradle plugin main variant</code>)을 찾으십시오.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Gradle의 변형 선택과 관련된 몇 가지 알려진 문제에 대한 해결 방법은 다음과 같습니다. * <a href="https://github.com/gradle/gradle/issues/20545" target="_blank" rel="noreferrer">pluginManagement의 ResolutionStrategy가 멀티 변형 플러그인에서 작동하지 않음</a> * <a href="https://github.com/gradle/gradle/issues/20847" target="_blank" rel="noreferrer"><code>buildSrc</code> 공통 종속성으로 플러그인을 추가할 때 플러그인 변형이 무시됨</a></p></div><p><a href="https://youtrack.jetbrains.com/issue/KT-49227/Support-Gradle-plugins-variants" target="_blank" rel="noreferrer">이 YouTrack 티켓</a>에 피드백을 남겨주십시오.</p><h3 id="kotlin-gradle-플러그인-api의-업데이트" tabindex="-1">Kotlin Gradle 플러그인 API의 업데이트 <a class="header-anchor" href="#kotlin-gradle-플러그인-api의-업데이트" aria-label="Permalink to &quot;Kotlin Gradle 플러그인 API의 업데이트&quot;">​</a></h3><p>Kotlin Gradle 플러그인 API 아티팩트에 여러 개선 사항이 적용되었습니다.</p><ul><li><p>사용자가 구성할 수 있는 입력을 가진 Kotlin/JVM 및 Kotlin/kapt 태스크를 위한 새로운 인터페이스가 있습니다.</p></li><li><p>모든 Kotlin 플러그인이 상속하는 새로운 <code>KotlinBasePlugin</code> 인터페이스가 있습니다. 이 인터페이스는 Kotlin Gradle 플러그인(JVM, JS, Multiplatform, Native 및 기타 플랫폼)이 적용될 때마다 일부 구성 작업을 트리거하려는 경우에 사용합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">project.plugins.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">org</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jetbrains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gradle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">plugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KotlinBasePlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 여기에 작업을 구성합니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>KotlinBasePlugin</code>에 대한 피드백은 <a href="https://youtrack.jetbrains.com/issue/KT-48008/Consider-offering-a-KotlinBasePlugin" target="_blank" rel="noreferrer">이 YouTrack 티켓</a>에 남겨주십시오.</p></li><li><p>Android Gradle 플러그인이 자체적으로 Kotlin 컴파일을 구성할 수 있도록 기반을 마련했습니다. 즉, 빌드에 Kotlin Android Gradle 플러그인을 추가할 필요가 없습니다. <a href="https://developer.android.com/studio/releases/gradle-plugin" target="_blank" rel="noreferrer">Android Gradle Plugin 릴리스 공지</a>를 확인하여 추가된 지원에 대해 알아보고 사용해 보십시오!</p></li></ul><h3 id="plugins-api를-통한-sam-with-receiver-플러그인-사용-가능" tabindex="-1">plugins API를 통한 sam-with-receiver 플러그인 사용 가능 <a class="header-anchor" href="#plugins-api를-통한-sam-with-receiver-플러그인-사용-가능" aria-label="Permalink to &quot;plugins API를 통한 sam-with-receiver 플러그인 사용 가능&quot;">​</a></h3><p><a href="/ko/kotlin/sam-with-receiver-plugin">sam-with-receiver 컴파일러 플러그인</a>은 이제 <a href="https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block" target="_blank" rel="noreferrer">Gradle plugins DSL</a>을 통해 사용할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">plugins</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org.jetbrains.kotlin.plugin.sam.with.receiver&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) version </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$kotlin_version</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="컴파일-태스크의-변경-사항" tabindex="-1">컴파일 태스크의 변경 사항 <a class="header-anchor" href="#컴파일-태스크의-변경-사항" aria-label="Permalink to &quot;컴파일 태스크의 변경 사항&quot;">​</a></h3><p>이번 릴리스에서 컴파일 태스크에 많은 변경 사항이 있었습니다.</p><ul><li>Kotlin 컴파일 태스크는 더 이상 Gradle <code>AbstractCompile</code> 태스크를 상속하지 않습니다. 이제 <code>DefaultTask</code>만 상속합니다.</li><li><code>AbstractCompile</code> 태스크에는 <code>sourceCompatibility</code> 및 <code>targetCompatibility</code> 입력이 있습니다. <code>AbstractCompile</code> 태스크가 더 이상 상속되지 않으므로 이러한 입력은 Kotlin 사용자 스크립트에서 더 이상 사용할 수 없습니다.</li><li><code>SourceTask.stableSources</code> 입력은 더 이상 사용할 수 없으며, <code>sources</code> 입력을 사용해야 합니다. <code>setSource(...)</code> 메서드는 여전히 사용할 수 있습니다.</li><li>모든 컴파일 태스크는 이제 컴파일에 필요한 라이브러리 목록에 <code>libraries</code> 입력을 사용합니다. <code>KotlinCompile</code> 태스크는 여전히 지원 중단된 Kotlin 속성 <code>classpath</code>를 가지고 있으며, 이는 향후 릴리스에서 제거될 예정입니다.</li><li>컴파일 태스크는 여전히 <code>PatternFilterable</code> 인터페이스를 구현하며, 이는 Kotlin 소스의 필터링을 허용합니다. <code>sourceFilesExtensions</code> 입력은 <code>PatternFilterable</code> 메서드를 사용하는 것을 선호하여 제거되었습니다.</li><li>지원 중단된 <code>Gradle destinationDir: File</code> 출력은 <code>destinationDirectory: DirectoryProperty</code> 출력으로 대체되었습니다.</li><li>Kotlin/Native <code>AbstractNativeCompile</code> 태스크는 이제 <code>AbstractKotlinCompileTool</code> 기본 클래스를 상속합니다. 이는 Kotlin/Native 빌드 도구를 다른 모든 도구에 통합하기 위한 초기 단계입니다.</li></ul><p><a href="https://youtrack.jetbrains.com/issue/KT-32805" target="_blank" rel="noreferrer">이 YouTrack 티켓</a>에 피드백을 남겨주십시오.</p><h3 id="kapt에서-각-어노테이션-프로세서에-의해-생성된-파일의-새로운-통계" tabindex="-1">kapt에서 각 어노테이션 프로세서에 의해 생성된 파일의 새로운 통계 <a class="header-anchor" href="#kapt에서-각-어노테이션-프로세서에-의해-생성된-파일의-새로운-통계" aria-label="Permalink to &quot;kapt에서 각 어노테이션 프로세서에 의해 생성된 파일의 새로운 통계&quot;">​</a></h3><p><code>kotlin-kapt</code> Gradle 플러그인은 이미 <a href="https://github.com/JetBrains/kotlin/pull/4280" target="_blank" rel="noreferrer">각 프로세서에 대한 성능 통계를 보고</a>합니다. Kotlin 1.7.0부터는 각 어노테이션 프로세서에 의해 생성된 파일 수에 대한 통계도 보고할 수 있습니다.</p><p>이는 빌드의 일부로 사용되지 않는 어노테이션 프로세서가 있는지 추적하는 데 유용합니다. 생성된 보고서를 사용하여 불필요한 어노테이션 프로세서를 트리거하는 모듈을 찾아 업데이트하여 이를 방지할 수 있습니다.</p><p>두 단계로 통계를 활성화하십시오.</p><ul><li><p><code>build.gradle.kts</code>에서 <code>showProcessorStats</code> 플래그를 <code>true</code>로 설정하십시오.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kapt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    showProcessorStats </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><code>gradle.properties</code>에서 <code>kapt.verbose</code> Gradle 속성을 <code>true</code>로 설정하십시오.</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kapt.verbose=true</span></span></code></pre></div></li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p><a href="/ko/kotlin/kapt#use-in-cli">커맨드 라인 옵션 <code>verbose</code></a>를 통해서도 상세 출력을 활성화할 수 있습니다.</p></div><p>통계는 <code>info</code> 레벨로 로그에 나타납니다. <code>Annotation processor stats:</code> 줄 뒤에 각 어노테이션 프로세서의 실행 시간에 대한 통계가 표시됩니다. 이 줄 뒤에는 <code>Generated files report:</code> 줄이 나오고 각 어노테이션 프로세서에 의해 생성된 파일 수에 대한 통계가 표시됩니다. 예:</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[INFO] Annotation processor stats:</span></span>
<span class="line"><span>[INFO] org.mapstruct.ap.MappingProcessor: total: 290 ms, init: 1 ms, 3 round(s): 289 ms, 0 ms, 0 ms</span></span>
<span class="line"><span>[INFO] Generated files report:</span></span>
<span class="line"><span>[INFO] org.mapstruct.ap.MappingProcessor: total sources: 2, sources per round: 2, 0, 0</span></span></code></pre></div><p><a href="https://youtrack.jetbrains.com/issue/KT-51132/KAPT-Support-reporting-the-number-of-generated-files-by-each-ann" target="_blank" rel="noreferrer">이 YouTrack 티켓</a>에 피드백을 남겨주십시오.</p><h3 id="kotlin-compiler-execution-strategy-시스템-속성-지원-중단" tabindex="-1">kotlin.compiler.execution.strategy 시스템 속성 지원 중단 <a class="header-anchor" href="#kotlin-compiler-execution-strategy-시스템-속성-지원-중단" aria-label="Permalink to &quot;kotlin.compiler.execution.strategy 시스템 속성 지원 중단&quot;">​</a></h3><p>Kotlin 1.6.20은 <a href="/ko/kotlin/whatsnew1620#properties-for-defining-kotlin-compiler-execution-strategy">Kotlin 컴파일러 실행 전략을 정의하기 위한 새로운 속성</a>을 도입했습니다. Kotlin 1.7.0에서는 이전 시스템 속성 <code>kotlin.compiler.execution.strategy</code>에 대한 지원 중단 주기가 시작되었으며, 새로운 속성들이 이를 대체합니다.</p><p><code>kotlin.compiler.execution.strategy</code> 시스템 속성을 사용하면 경고 메시지가 표시됩니다. 이 속성은 향후 릴리스에서 삭제될 예정입니다. 이전 동작을 유지하려면 시스템 속성을 동일한 이름의 Gradle 속성으로 교체하십시오. 예를 들어, <code>gradle.properties</code>에서 다음과 같이 할 수 있습니다.</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.compiler.execution.strategy=out-of-process</span></span></code></pre></div><p>컴파일 태스크 속성 <code>compilerExecutionStrategy</code>도 사용할 수 있습니다. <a href="/ko/kotlin/gradle-compilation-and-caches#defining-kotlin-compiler-execution-strategy">Gradle 페이지</a>에서 이에 대해 자세히 알아보십시오.</p><h3 id="지원-중단된-옵션-메서드-및-플러그인-제거" tabindex="-1">지원 중단된 옵션, 메서드 및 플러그인 제거 <a class="header-anchor" href="#지원-중단된-옵션-메서드-및-플러그인-제거" aria-label="Permalink to &quot;지원 중단된 옵션, 메서드 및 플러그인 제거&quot;">​</a></h3><h4 id="useexperimentalannotation-메서드-제거" tabindex="-1">useExperimentalAnnotation 메서드 제거 <a class="header-anchor" href="#useexperimentalannotation-메서드-제거" aria-label="Permalink to &quot;useExperimentalAnnotation 메서드 제거&quot;">​</a></h4><p>Kotlin 1.7.0에서는 <code>useExperimentalAnnotation</code> Gradle 메서드에 대한 지원 중단 주기를 완료했습니다. 대신 모듈에서 API를 사용하기 위해 옵트인하려면 <code>optIn()</code>을 사용하십시오.</p><p>예를 들어 Gradle 모듈이 멀티플랫폼인 경우:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sourceSets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        languageSettings.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">optIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org.mylibrary.OptInAnnotation&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Kotlin의 <a href="/ko/kotlin/opt-in-requirements">옵트인 요구 사항</a>에 대해 자세히 알아보십시오.</p><h4 id="지원-중단된-컴파일러-옵션-제거" tabindex="-1">지원 중단된 컴파일러 옵션 제거 <a class="header-anchor" href="#지원-중단된-컴파일러-옵션-제거" aria-label="Permalink to &quot;지원 중단된 컴파일러 옵션 제거&quot;">​</a></h4><p>여러 컴파일러 옵션에 대한 지원 중단 주기를 완료했습니다.</p><ul><li><code>kotlinOptions.jdkHome</code> 컴파일러 옵션은 1.5.30에서 지원 중단되었으며 현재 릴리스에서 제거되었습니다. 이 옵션을 포함하는 Gradle 빌드는 이제 실패합니다. Kotlin 1.5.30부터 지원되는 <a href="/ko/kotlin/whatsnew1530#support-for-java-toolchains">Java 툴체인</a>을 사용하는 것을 권장합니다.</li><li>지원 중단된 <code>noStdlib</code> 컴파일러 옵션도 제거되었습니다. Gradle 플러그인은 Kotlin 표준 라이브러리가 있는지 여부를 제어하기 위해 <code>kotlin.stdlib.default.dependency=true</code> 속성을 사용합니다.</li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>컴파일러 인자 <code>-jdkHome</code> 및 <code>-no-stdlib</code>는 여전히 사용할 수 있습니다.</p></div><h4 id="지원-중단된-플러그인-제거" tabindex="-1">지원 중단된 플러그인 제거 <a class="header-anchor" href="#지원-중단된-플러그인-제거" aria-label="Permalink to &quot;지원 중단된 플러그인 제거&quot;">​</a></h4><p>Kotlin 1.4.0에서 <code>kotlin2js</code> 및 <code>kotlin-dce-plugin</code> 플러그인은 지원 중단되었으며, 이 릴리스에서 제거되었습니다. <code>kotlin2js</code> 대신 새로운 <code>org.jetbrains.kotlin.js</code> 플러그인을 사용하십시오. 데드 코드 제거(DCE)는 Kotlin/JS Gradle 플러그인이 올바르게 구성된 경우 작동합니다.</p><p>Kotlin 1.6.0에서는 <code>KotlinGradleSubplugin</code> 클래스의 지원 중단 수준을 <code>ERROR</code>로 변경했습니다. 개발자들은 이 클래스를 컴파일러 플러그인 작성을 위해 사용했습니다. 이 릴리스에서는 <a href="https://youtrack.jetbrains.com/issue/KT-48831/" target="_blank" rel="noreferrer">이 클래스가 제거되었습니다</a>. 대신 <code>KotlinCompilerPluginSupportPlugin</code> 클래스를 사용하십시오.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>가장 좋은 방법은 프로젝트 전체에서 Kotlin 플러그인을 1.7.0 이상 버전으로 사용하는 것입니다.</p></div><h4 id="지원-중단된-코루틴-dsl-옵션-및-속성-제거" tabindex="-1">지원 중단된 코루틴 DSL 옵션 및 속성 제거 <a class="header-anchor" href="#지원-중단된-코루틴-dsl-옵션-및-속성-제거" aria-label="Permalink to &quot;지원 중단된 코루틴 DSL 옵션 및 속성 제거&quot;">​</a></h4><p>지원 중단된 <code>kotlin.experimental.coroutines</code> Gradle DSL 옵션과 <code>gradle.properties</code>에서 사용되던 <code>kotlin.coroutines</code> 속성을 제거했습니다. 이제 <a href="/ko/kotlin/coroutines-basics#extract-function-refactoring">일시 중단 함수(suspending functions)</a>를 사용하거나 빌드 스크립트에 <a href="/ko/kotlin/gradle-configure-project#set-a-dependency-on-a-kotlinx-library"><code>kotlinx.coroutines</code> 종속성</a>을 추가하기만 하면 됩니다.</p><p><a href="/ko/kotlin/coroutines-guide">코루틴 가이드</a>에서 코루틴에 대해 자세히 알아보세요.</p><h4 id="툴체인-확장-메서드의-타입-캐스트-제거" tabindex="-1">툴체인 확장 메서드의 타입 캐스트 제거 <a class="header-anchor" href="#툴체인-확장-메서드의-타입-캐스트-제거" aria-label="Permalink to &quot;툴체인 확장 메서드의 타입 캐스트 제거&quot;">​</a></h4><p>Kotlin 1.7.0 이전에는 Kotlin DSL로 Gradle 툴체인을 구성할 때 <code>JavaToolchainSpec</code> 클래스로 타입 캐스트를 수행해야 했습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvmToolchain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> JavaToolchainSpec).languageVersion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(JavaLanguageVersion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MAJOR_JDK_VERSION</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이제 <code>(this as JavaToolchainSpec)</code> 부분을 생략할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvmToolchain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        languageVersion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(JavaLanguageVersion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MAJOR_JDK_VERSION</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="kotlin-1-7-0으로-마이그레이션" tabindex="-1">Kotlin 1.7.0으로 마이그레이션 <a class="header-anchor" href="#kotlin-1-7-0으로-마이그레이션" aria-label="Permalink to &quot;Kotlin 1.7.0으로 마이그레이션&quot;">​</a></h2><h3 id="kotlin-1-7-0-설치" tabindex="-1">Kotlin 1.7.0 설치 <a class="header-anchor" href="#kotlin-1-7-0-설치" aria-label="Permalink to &quot;Kotlin 1.7.0 설치&quot;">​</a></h3><p>IntelliJ IDEA 2022.1 및 Android Studio Chipmunk (212)는 Kotlin 플러그인을 1.7.0으로 자동으로 업데이트하도록 제안합니다.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>IntelliJ IDEA 2022.2, Android Studio Dolphin (213) 또는 Android Studio Electric Eel (221)의 경우, Kotlin 플러그인 1.7.0은 향후 IntelliJ IDEA 및 Android Studio 업데이트와 함께 제공될 예정입니다.</p></div><p>새로운 커맨드라인 컴파일러는 <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.7.0" target="_blank" rel="noreferrer">GitHub 릴리스 페이지</a>에서 다운로드할 수 있습니다.</p><h3 id="기존-프로젝트-마이그레이션-또는-kotlin-1-7-0으로-새-프로젝트-시작" tabindex="-1">기존 프로젝트 마이그레이션 또는 Kotlin 1.7.0으로 새 프로젝트 시작 <a class="header-anchor" href="#기존-프로젝트-마이그레이션-또는-kotlin-1-7-0으로-새-프로젝트-시작" aria-label="Permalink to &quot;기존 프로젝트 마이그레이션 또는 Kotlin 1.7.0으로 새 프로젝트 시작&quot;">​</a></h3><ul><li><p>기존 프로젝트를 Kotlin 1.7.0으로 마이그레이션하려면 Kotlin 버전을 <code>1.7.0</code>으로 변경하고 Gradle 또는 Maven 프로젝트를 다시 임포트하십시오. <a href="/ko/kotlin/releases#update-to-a-new-kotlin-version">Kotlin 1.7.0으로 업데이트하는 방법</a>을 알아보세요.</p></li><li><p>Kotlin 1.7.0으로 새 프로젝트를 시작하려면 Kotlin 플러그인을 업데이트하고 <strong>File</strong> | <strong>New</strong> | <strong>Project</strong>에서 프로젝트 마법사를 실행하십시오.</p></li></ul><h3 id="kotlin-1-7-0-호환성-가이드" tabindex="-1">Kotlin 1.7.0 호환성 가이드 <a class="header-anchor" href="#kotlin-1-7-0-호환성-가이드" aria-label="Permalink to &quot;Kotlin 1.7.0 호환성 가이드&quot;">​</a></h3><p>Kotlin 1.7.0은 <a href="/ko/kotlin/kotlin-evolution-principles#language-and-tooling-releases">기능 릴리스</a>이므로, 이전 버전의 언어로 작성된 코드와 호환되지 않는 변경 사항을 가져올 수 있습니다. 그러한 변경 사항에 대한 자세한 목록은 <a href="/ko/kotlin/compatibility-guide-17">Kotlin 1.7.0 호환성 가이드</a>에서 확인할 수 있습니다.</p>`,248))])}const C=h(d,[["render",c]]);export{m as __pageData,C as default};
