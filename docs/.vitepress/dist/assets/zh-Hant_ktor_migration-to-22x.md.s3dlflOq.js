import{_ as o,C as i,c as s,o as n,j as a,G as r,ag as l,a as c}from"./chunks/framework.Bksy39di.js";const q=JSON.parse('{"title":"從 2.0.x 遷移到 2.2.x","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/ktor/migration-to-22x.md","filePath":"zh-Hant/ktor/migration-to-22x.md","lastUpdated":1755457140000}'),d={name:"zh-Hant/ktor/migration-to-22x.md"};function h(p,e,u,k,g,m){const t=i("show-structure");return n(),s("div",null,[e[0]||(e[0]=a("h1",{id:"從-2-0-x-遷移到-2-2-x",tabindex:"-1"},[c("從 2.0.x 遷移到 2.2.x "),a("a",{class:"header-anchor",href:"#從-2-0-x-遷移到-2-2-x","aria-label":'Permalink to "從 2.0.x 遷移到 2.2.x"'},"​")],-1)),r(t,{for:"chapter",depth:"2"}),e[1]||(e[1]=l(`<p>本指南提供了如何將您的 Ktor 應用程式從 2.0.x 版本遷移到 2.2.x 的說明。</p><blockquote><p>標記為 <code>WARNING</code> 廢棄等級的 API 將會持續運作直到 3.0.0 版本發行。 您可以在 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-deprecated/" target="_blank" rel="noreferrer">Deprecated</a> 中了解更多關於廢棄等級的資訊。</p></blockquote><h2 id="server" tabindex="-1">Ktor 伺服器 <a class="header-anchor" href="#server" aria-label="Permalink to &quot;Ktor 伺服器 {id=&quot;server&quot;}&quot;">​</a></h2><h3 id="cookies" tabindex="-1">Cookie <a class="header-anchor" href="#cookies" aria-label="Permalink to &quot;Cookie {id=&quot;cookies&quot;}&quot;">​</a></h3><p>從 v2.2.0 起，以下與配置 <a href="./server-responses#cookies">回應 Cookie</a> 相關的 API 成員有所變動：</p><ul><li>傳遞給 <code>append</code> 函數的 <code>maxAge</code> 參數類型從 <code>Int</code> 變更為 <code>Long</code>。</li><li><code>appendExpired</code> 函數已廢棄。請改用帶有 <code>expires</code> 參數的 <code>append</code> 函數。</li></ul><h3 id="request-address-info" tabindex="-1">請求位址資訊 <a class="header-anchor" href="#request-address-info" aria-label="Permalink to &quot;請求位址資訊 {id=&quot;request-address-info&quot;}&quot;">​</a></h3><p>從 2.2.0 版本開始，用於取得發出請求的主機名稱/埠的 <code>RequestConnectionPoint.host</code> 和 <code>RequestConnectionPoint.port</code> 屬性已廢棄。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> originHost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> call.request.origin.host</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> originPort </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> call.request.origin.port</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>請改用 <code>RequestConnectionPoint.serverHost</code> 和 <code>RequestConnectionPoint.serverPort</code>。我們也新增了 <code>localHost</code>/<code>localPort</code> 屬性，它們會回傳收到請求的主機名稱/埠。您可以在 <a href="./server-forward-headers#original-request-information">原始請求資訊</a> 中了解更多資訊。</p><h3 id="merge-configs" tabindex="-1">合併配置 <a class="header-anchor" href="#merge-configs" aria-label="Permalink to &quot;合併配置 {id=&quot;merge-configs&quot;}&quot;">​</a></h3><p>在 v2.2.0 之前，<code>List&lt;ApplicationConfig&gt;.merge()</code> 函數用於合併應用程式配置。 如果兩個配置具有相同的鍵，則產生的配置將採用第一個配置中的值。 透過此版本，引入了以下 API 以改進此行為：</p><ul><li><code>public fun ApplicationConfig.withFallback(other: ApplicationConfig): ApplicationConfig</code>：此函數的工作方式與 <code>merge()</code> 相同，並從第一個配置中取值。</li><li><code>public fun ApplicationConfig.mergeWith(other: ApplicationConfig): ApplicationConfig</code>：產生的配置將採用第二個配置中的值。</li></ul><h2 id="client" tabindex="-1">Ktor 用戶端 <a class="header-anchor" href="#client" aria-label="Permalink to &quot;Ktor 用戶端 {id=&quot;client&quot;}&quot;">​</a></h2><h3 id="persistent-storage" tabindex="-1">快取：持久儲存 <a class="header-anchor" href="#persistent-storage" aria-label="Permalink to &quot;快取：持久儲存 {id=&quot;persistent-storage&quot;}&quot;">​</a></h3><p>從 v2.2.0 起，以下與回應 <a href="./client-caching">快取</a> 相關的 API 已廢棄：</p><ul><li><code>HttpCacheStorage</code> 類別已被 <code>CacheStorage</code> 介面取代，該介面可用於為所需平台實作持久儲存。</li><li><code>publicStorage</code>/<code>privateStorage</code> 屬性已被接受 <code>CacheStorage</code> 實例的對應函數取代。</li></ul><h3 id="custom-plugins" tabindex="-1">自訂外掛 <a class="header-anchor" href="#custom-plugins" aria-label="Permalink to &quot;自訂外掛 {id=&quot;custom-plugins&quot;}&quot;">​</a></h3><p>從 2.2.0 版本發行開始，Ktor 提供了一個用於建立自訂用戶端外掛的新 API。 若要了解更多資訊，請參閱 <a href="./client-custom-plugins">自訂用戶端外掛</a>。</p><h2 id="new-mm" tabindex="-1">新記憶體模型 <a class="header-anchor" href="#new-mm" aria-label="Permalink to &quot;新記憶體模型 {id=&quot;new-mm&quot;}&quot;">​</a></h2><p>從 v2.2.0 起，Ktor 使用 Kotlin 的 1.7.20 版本，其中新的 Kotlin/Native 記憶體模型是 <a href="https://kotlinlang.org/docs/whatsnew1720.html#the-new-kotlin-native-memory-manager-enabled-by-default" target="_blank" rel="noreferrer">預設啟用</a> 的。 這意味著您無需為 <a href="./server-native">原生伺服器</a> 或目標為 <a href="./client-engines#native">Kotlin/Native</a> 的用戶端引擎明確啟用它。</p>`,21))])}const b=o(d,[["render",h]]);export{q as __pageData,b as default};
