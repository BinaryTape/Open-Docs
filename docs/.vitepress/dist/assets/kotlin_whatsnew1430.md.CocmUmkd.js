import{_ as k,C as h,c as r,o,ag as t,j as s,G as e,w as n,a}from"./chunks/framework.Bksy39di.js";const m=JSON.parse('{"title":"Kotlin 1.4.30 新特性","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/whatsnew1430.md","filePath":"kotlin/whatsnew1430.md","lastUpdated":1754307826000}'),d={name:"kotlin/whatsnew1430.md"};function c(g,i,E,y,u,b){const l=h("tab"),p=h("tabs");return o(),r("div",null,[i[4]||(i[4]=t(`<h1 id="kotlin-1-4-30-新特性" tabindex="-1">Kotlin 1.4.30 新特性 <a class="header-anchor" href="#kotlin-1-4-30-新特性" aria-label="Permalink to &quot;Kotlin 1.4.30 新特性&quot;">​</a></h1><p><em><a href="/kotlin/releases#release-details">发布日期：2021 年 2 月 3 日</a></em></p><p>Kotlin 1.4.30 提供了新语言特性的预览版本，将 Kotlin/JVM 编译器的新 IR 后端提升为 Beta 版，并提供了各种性能和功能性改进。</p><p>你还可以通过<a href="https://blog.jetbrains.com/kotlin/2021/01/kotlin-1-4-30-released/" target="_blank" rel="noreferrer">这篇博客文章</a>了解新特性。</p><h2 id="语言特性" tabindex="-1">语言特性 <a class="header-anchor" href="#语言特性" aria-label="Permalink to &quot;语言特性&quot;">​</a></h2><p>Kotlin 1.5.0 将带来新的语言特性——JVM records 支持、密封接口和稳定 inline class。在 Kotlin 1.4.30 中，你可以尝试这些特性和改进的预览模式。如果你能将反馈分享到对应的 YouTrack 工单中，我们将不胜感激，因为这有助于我们在 1.5.0 发布前解决问题。</p><ul><li><a href="#jvm-records-support">JVM records 支持</a></li><li><a href="#sealed-interfaces">密封接口</a>与<a href="#package-wide-sealed-class-hierarchies">密封类改进</a></li><li><a href="#improved-inline-classes">改进的 inline class</a></li></ul><p>要在预览模式下启用这些语言特性和改进，你需要通过添加特定的编译器选项来选择启用。详情请参见以下章节。</p><p>关于新特性预览的更多信息，请参阅<a href="https://blog.jetbrains.com/kotlin/2021/01/new-language-features-preview-in-kotlin-1-4-30" target="_blank" rel="noreferrer">这篇博客文章</a>。</p><h3 id="jvm-records-支持" tabindex="-1">JVM records 支持 <a class="header-anchor" href="#jvm-records-支持" aria-label="Permalink to &quot;JVM records 支持&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>JVM records 特性是<a href="/kotlin/components-stability">实验性的</a>。它可能随时移除或更改。 需要选择启用（详情请参见下文），并且你应仅将其用于求值目的。如果你能将反馈提交到 <a href="https://youtrack.jetbrains.com/issue/KT-42430" target="_blank" rel="noreferrer">YouTrack</a> 上，我们将不胜感激。</p></div><p><a href="https://openjdk.java.net/projects/jdk/16/" target="_blank" rel="noreferrer">JDK 16 发布</a>计划稳定一种新的 Java 类类型，称为 <a href="https://openjdk.java.net/jeps/395" target="_blank" rel="noreferrer">record</a>。为了提供 Kotlin 的所有优势并保持其与 Java 的互操作性，Kotlin 正在引入实验性的 record class 支持。</p><p>你可以像 Kotlin 中带有属性的类一样使用在 Java 中声明的 record class。无需额外步骤。</p><p>从 1.4.30 开始，你可以在 Kotlin 中使用 <code>@JvmRecord</code> 注解为<a href="/kotlin/data-classes">数据类</a>声明 record class：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmRecord</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>要尝试 JVM records 的预览版本，请添加编译器选项 <code>-Xjvm-enable-preview</code> 和 <code>-language-version 1.5</code>。</p><p>我们将继续致力于 JVM records 支持，如果你能通过这个 <a href="https://youtrack.jetbrains.com/issue/KT-42430" target="_blank" rel="noreferrer">YouTrack 工单</a>向我们分享你的反馈，我们将不胜感激。</p><p>关于实现、限制和语法的更多信息，请参阅 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/jvm-records.md" target="_blank" rel="noreferrer">KEEP</a>。</p><h3 id="密封接口" tabindex="-1">密封接口 <a class="header-anchor" href="#密封接口" aria-label="Permalink to &quot;密封接口&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>密封接口是<a href="/kotlin/components-stability">实验性的</a>。它们可能随时移除或更改。 需要选择启用（详情请参见下文），并且你应仅将其用于求值目的。如果你能将反馈提交到 <a href="https://youtrack.jetbrains.com/issue/KT-42433" target="_blank" rel="noreferrer">YouTrack</a> 上，我们将不胜感激。</p></div><p>在 Kotlin 1.4.30 中，我们发布了 <em>密封接口</em> 的原型。它们补充了密封类，使得构建更灵活的受限类层次结构成为可能。</p><p>它们可以作为“内部”接口，不能在同一模块之外实现。你可以依赖这个事实，例如，编写穷尽式 <code>when</code> 表达式。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Polygon</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rectangle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Polygon</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Triangle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Polygon</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// when() is exhaustive: no other polygon implementations can appear</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// after the module is compiled</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> draw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(polygon: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Polygon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (polygon) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Rectangle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Triangle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>另一个用例是：通过密封接口，你可以让一个类继承自两个或多个密封超类。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Fillable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Polygon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vertices: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rectangle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vertices: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Fillable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Polygon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*...*/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>要尝试密封接口的预览版本，请添加编译器选项 <code>-language-version 1.5</code>。一旦你切换到此版本，你将能够在接口上使用 <code>sealed</code> 修饰符。如果你能通过这个 <a href="https://youtrack.jetbrains.com/issue/KT-42433" target="_blank" rel="noreferrer">YouTrack 工单</a>向我们分享你的反馈，我们将不胜感激。</p><p><a href="/kotlin/sealed-classes">关于密封接口的更多信息</a>。</p><h3 id="包范围内的密封类层次结构" tabindex="-1">包范围内的密封类层次结构 <a class="header-anchor" href="#包范围内的密封类层次结构" aria-label="Permalink to &quot;包范围内的密封类层次结构&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>包范围内的密封类层次结构是<a href="/kotlin/components-stability">实验性的</a>。它们可能随时移除或更改。 需要选择启用（详情请参见下文），并且你应仅将其用于求值目的。如果你能将反馈提交到 <a href="https://youtrack.jetbrains.com/issue/KT-42433" target="_blank" rel="noreferrer">YouTrack</a> 上，我们将不胜感激。</p></div><p>密封类现在可以形成更灵活的层次结构。它们可以在同一编译单元和同一包的所有文件中拥有子类。以前，所有子类都必须出现在同一文件中。</p><p>直接子类可以是顶层的，也可以嵌套在任意数量的其他命名类、命名接口或命名对象中。密封类的子类必须具有适当限定的名称——它们不能是局部对象或匿名对象。</p><p>要尝试包范围内的密封类层次结构，请添加编译器选项 <code>-language-version 1.5</code>。如果你能通过这个 <a href="https://youtrack.jetbrains.com/issue/KT-42433" target="_blank" rel="noreferrer">YouTrack 工单</a>向我们分享你的反馈，我们将不胜感激。</p><p><a href="/kotlin/sealed-classes#inheritance">关于包范围内的密封类层次结构的更多信息</a>。</p><h3 id="改进的-inline-class" tabindex="-1">改进的 inline class <a class="header-anchor" href="#改进的-inline-class" aria-label="Permalink to &quot;改进的 inline class&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>Inline value class 处于 <a href="/kotlin/components-stability">Beta 版</a>。它们几乎稳定，但未来可能需要迁移步骤。我们将尽力减少你需要进行的任何更改。如果你能将反馈提交到 <a href="https://youtrack.jetbrains.com/issue/KT-42434" target="_blank" rel="noreferrer">YouTrack</a> 上，我们将不胜感激。</p></div><p>Kotlin 1.4.30 将 <a href="/kotlin/inline-classes">inline class</a> 提升为 <a href="/kotlin/components-stability">Beta 版</a>，并为它们带来了以下特性和改进：</p><ul><li><p>由于 inline class 是<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/doc-files/ValueBased.html" target="_blank" rel="noreferrer">基于值的</a>，你可以使用 <code>value</code> 修饰符定义它们。<code>inline</code> 和 <code>value</code> 修饰符现在彼此等效。在未来的 Kotlin 版本中，我们计划弃用 <code>inline</code> 修饰符。</p><p>从现在起，Kotlin 要求在类声明前为 JVM 后端添加 <code>@JvmInline</code> 注解：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// For JVM backends</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmInline</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div></li><li><p>Inline class 可以拥有 <code>init</code> 代码块。你可以在类实例化后立即添加要执行的代码：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmInline</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Negative</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>从 Java 代码调用带有 inline class 的函数：在 Kotlin 1.4.30 之前，由于名字修饰，你无法从 Java 调用接受 inline class 的函数。 从现在起，你可以手动禁用名字修饰。要从 Java 代码调用此类函数，你应在函数声明前添加 <code>@JvmName</code> 注解：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;computeUInt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { }</span></span></code></pre></div></li><li><p>在此版本中，我们更改了函数的<strong>名字修饰</strong>方案以修复不正确的行为。这些更改导致了 ABI 变更。</p><p>从 1.4.30 开始，Kotlin 编译器默认使用新的<strong>名字修饰</strong>方案。使用 <code>-Xuse-14-inline-classes-mangling-scheme</code> 编译器标志强制编译器使用旧的 1.4.0 <strong>名字修饰</strong>方案并保留二进制兼容性。</p></li></ul><p>Kotlin 1.4.30 将 inline class 提升为 Beta 版，我们计划在未来版本中使其稳定。如果你能通过这个 <a href="https://youtrack.jetbrains.com/issue/KT-42434" target="_blank" rel="noreferrer">YouTrack 工单</a>向我们分享你的反馈，我们将不胜感激。</p><p>要尝试 inline class 的预览版本，请添加编译器选项 <code>-Xinline-classes</code> 或 <code>-language-version 1.5</code>。</p><p>关于<strong>名字修饰</strong>算法的更多信息，请参阅 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/inline-classes.md" target="_blank" rel="noreferrer">KEEP</a>。</p><p><a href="/kotlin/inline-classes">关于 inline class 的更多信息</a>。</p><h2 id="kotlin-jvm" tabindex="-1">Kotlin/JVM <a class="header-anchor" href="#kotlin-jvm" aria-label="Permalink to &quot;Kotlin/JVM&quot;">​</a></h2><h3 id="jvm-ir-编译器后端达到-beta" tabindex="-1">JVM IR 编译器后端达到 Beta <a class="header-anchor" href="#jvm-ir-编译器后端达到-beta" aria-label="Permalink to &quot;JVM IR 编译器后端达到 Beta&quot;">​</a></h3><p>Kotlin/JVM 的<a href="/kotlin/whatsnew14#unified-backends-and-extensibility">基于 IR 的编译器后端</a>已达到 Beta，该后端于 1.4.0 以 <a href="/kotlin/components-stability">Alpha 版</a>推出。这是在 IR 后端成为 Kotlin/JVM 编译器默认后端之前的最后一个稳定前阶段。</p><p>我们现在取消了对使用 IR 编译器生成的二进制文件的限制。以前，你只能在启用新后端的情况下使用由新的 JVM IR 后端编译的代码。从 1.4.30 开始，不再有此限制，因此你可以使用新后端为第三方使用（例如库）构建组件。请尝试新后端的 Beta 版本，并在我们的<a href="https://kotl.in/issue" target="_blank" rel="noreferrer">问题跟踪器</a>中分享你的反馈。</p><p>要启用新的 JVM IR 后端，请将以下行添加到项目的配置文件中：</p>`,46)),s("ul",null,[s("li",null,[i[2]||(i[2]=s("p",null,"在 Gradle 中：",-1)),e(p,{group:"build-script"},{default:n(()=>[e(l,{title:"Kotlin","group-key":"kotlin"},{default:n(()=>i[0]||(i[0]=[s("div",{class:"language-kotlin vp-adaptive-theme"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"kotlin"),s("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"tasks."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"withType"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(org.jetbrains.kotlin.gradle.dsl.KotlinJvmCompile::"),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"class"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"  kotlinOptions.useIR "),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),s("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," true")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),e(l,{title:"Groovy","group-key":"groovy"},{default:n(()=>i[1]||(i[1]=[s("div",{class:"language-groovy vp-adaptive-theme"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"groovy"),s("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"tasks"),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"withType("),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"org.jetbrains.kotlin.gradle.dsl.KotlinJvmCompile"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"  kotlinOptions"),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"useIR "),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),s("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," true")]),a(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1})]),i[3]||(i[3]=t(`<li><p>在 Maven 中：</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">configuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;-Xuse-ir&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">configuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li>`,1))]),i[5]||(i[5]=t(`<p>关于 JVM IR 后端带来的更改的更多信息，请参阅<a href="https://blog.jetbrains.com/kotlin/2021/01/the-jvm-backend-is-in-beta-let-s-make-it-stable-together" target="_blank" rel="noreferrer">这篇博客文章</a>。</p><h2 id="kotlin-native" tabindex="-1">Kotlin/Native <a class="header-anchor" href="#kotlin-native" aria-label="Permalink to &quot;Kotlin/Native&quot;">​</a></h2><h3 id="性能改进" tabindex="-1">性能改进 <a class="header-anchor" href="#性能改进" aria-label="Permalink to &quot;性能改进&quot;">​</a></h3><p>Kotlin/Native 在 1.4.30 中获得了各种性能改进，从而缩短了编译时间。例如，在 <a href="https://github.com/kotlin-hands-on/kmm-networking-and-data-storage/tree/final" target="_blank" rel="noreferrer">使用 Kotlin Multiplatform Mobile 进行网络和数据存储</a> 示例中，重建 <code>framework</code> 所需的时间已从 9.5 秒（在 1.4.10 中）减少到 4.5 秒（在 1.4.30 中）。</p><h3 id="apple-watchos-64-位模拟器目标平台" tabindex="-1">Apple watchOS 64 位模拟器目标平台 <a class="header-anchor" href="#apple-watchos-64-位模拟器目标平台" aria-label="Permalink to &quot;Apple watchOS 64 位模拟器目标平台&quot;">​</a></h3><p>watchOS 的 x86 模拟器<strong>目标平台</strong>自 7.0 版本起已被弃用。为了跟上最新的 watchOS 版本，Kotlin/Native 提供了新的<strong>目标平台</strong> <code>watchosX64</code>，用于在 64 位架构上运行模拟器。</p><h3 id="支持-xcode-12-2-库" tabindex="-1">支持 Xcode 12.2 库 <a class="header-anchor" href="#支持-xcode-12-2-库" aria-label="Permalink to &quot;支持 Xcode 12.2 库&quot;">​</a></h3><p>我们添加了对 Xcode 12.2 随附的新库的支持。你现在可以从 Kotlin 代码中使用它们。</p><h2 id="kotlin-js" tabindex="-1">Kotlin/JS <a class="header-anchor" href="#kotlin-js" aria-label="Permalink to &quot;Kotlin/JS&quot;">​</a></h2><h3 id="顶层属性的惰性初始化" tabindex="-1">顶层属性的惰性初始化 <a class="header-anchor" href="#顶层属性的惰性初始化" aria-label="Permalink to &quot;顶层属性的惰性初始化&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>顶层属性的惰性初始化是<a href="/kotlin/components-stability">实验性的</a>。它可能随时移除或更改。 仅将其用于求值目的。如果你能将反馈提交到 <a href="https://youtrack.jetbrains.com/issue/KT-44320" target="_blank" rel="noreferrer">YouTrack</a> 上，我们将不胜感激。</p></div><p>Kotlin/JS 的 <a href="/kotlin/js-ir-compiler">IR 后端</a>正在获得顶层属性惰性初始化的原型实现。这减少了应用程序启动时初始化所有顶层属性的需要，并应显著改善应用程序启动时间。</p><p>我们将继续致力于惰性初始化，请你尝试当前原型，并将你的想法和结果分享到这个 <a href="https://youtrack.jetbrains.com/issue/KT-44320" target="_blank" rel="noreferrer">YouTrack 工单</a>或官方 <a href="https://kotlinlang.slack.com" target="_blank" rel="noreferrer">Kotlin Slack</a> 中的 <a href="https://kotlinlang.slack.com/archives/C0B8L3U69" target="_blank" rel="noreferrer"><code>#javascript</code></a> 频道（在此<a href="https://surveys.jetbrains.com/s3/kotlin-slack-sign-up" target="_blank" rel="noreferrer">获取邀请</a>）。</p><p>要使用惰性初始化，在使用 JS IR 编译器编译代码时添加 <code>-Xir-property-lazy-initialization</code> 编译器选项。</p><h2 id="gradle-项目改进" tabindex="-1">Gradle 项目改进 <a class="header-anchor" href="#gradle-项目改进" aria-label="Permalink to &quot;Gradle 项目改进&quot;">​</a></h2><h3 id="支持-gradle-配置缓存" tabindex="-1">支持 Gradle 配置缓存 <a class="header-anchor" href="#支持-gradle-配置缓存" aria-label="Permalink to &quot;支持 Gradle 配置缓存&quot;">​</a></h3><p>从 1.4.30 开始，Kotlin Gradle 插件支持<a href="https://docs.gradle.org/current/userguide/configuration_cache.html" target="_blank" rel="noreferrer">配置缓存</a>特性。它加快了构建过程：一旦你运行命令，Gradle 就会执行配置阶段并计算任务图。Gradle 会缓存结果并将其重复用于后续构建。</p><p>要开始使用此特性，你可以<a href="https://docs.gradle.org/current/userguide/configuration_cache.html#config_cache:usage" target="_blank" rel="noreferrer">使用 Gradle 命令</a>或<a href="https://docs.gradle.org/current/userguide/configuration_cache.html#config_cache:ide:intellij" target="_blank" rel="noreferrer">设置基于 IntelliJ 的 IDE</a>。</p><h2 id="标准库" tabindex="-1">标准库 <a class="header-anchor" href="#标准库" aria-label="Permalink to &quot;标准库&quot;">​</a></h2><h3 id="用于文本大小写转换的与区域设置无关的-api" tabindex="-1">用于文本大小写转换的与区域设置无关的 API <a class="header-anchor" href="#用于文本大小写转换的与区域设置无关的-api" aria-label="Permalink to &quot;用于文本大小写转换的与区域设置无关的 API&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>与区域设置无关的 API <strong>特性</strong>是<a href="/kotlin/components-stability">实验性的</a>。它可能随时移除或更改。 仅将其用于求值目的。如果你能将反馈提交到 <a href="https://youtrack.jetbrains.com/issue/KT-42437" target="_blank" rel="noreferrer">YouTrack</a> 上，我们将不胜感激。</p></div><p>此版本引入了实验性的与区域设置无关的 API，用于更改字符串和字符的大小写。当前的 <code>toLowerCase()</code>、<code>toUpperCase()</code>、<code>capitalize()</code>、<code>decapitalize()</code> API 函数是区域设置敏感的。这意味着不同的平台区域设置会影响代码行为。例如，在土耳其语区域设置中，当字符串 &quot;kotlin&quot; 使用 <code>toUpperCase</code> 转换时，结果是 &quot;KOTLİN&quot;，而不是 &quot;KOTLIN&quot;。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// current API</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Needs to be capitalized&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toUpperCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// NEEDS TO BE CAPITALIZED</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// new API</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Needs to be capitalized&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">uppercase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// NEEDS TO BE CAPITALIZED</span></span></code></pre></div><p>Kotlin 1.4.30 提供了以下替代方案：</p><table tabindex="0"><thead><tr><th><strong>早期版本</strong></th><th><strong>1.4.30 替代方案</strong></th></tr></thead><tbody><tr><td><code>String.toUpperCase()</code></td><td><code>String.uppercase()</code></td></tr><tr><td><code>String.toLowerCase()</code></td><td><code>String.lowercase()</code></td></tr><tr><td><code>String.capitalize()</code></td><td><code>String.replaceFirstChar { it.uppercase() }</code></td></tr><tr><td><code>String.decapitalize()</code></td><td><code>String.replaceFirstChar { it.lowercase() }</code></td></tr></tbody></table><ul><li><p>对于 <code>Char</code> 函数：</p><table tabindex="0"><thead><tr><th><strong>早期版本</strong></th><th><strong>1.4.30 替代方案</strong></th></tr></thead><tbody><tr><td><code>Char.toUpperCase()</code></td><td><code>Char.uppercaseChar(): Char</code><br><code>Char.uppercase(): String</code></td></tr><tr><td><code>Char.toLowerCase()</code></td><td><code>Char.lowercaseChar(): Char</code><br><code>Char.lowercase(): String</code></td></tr><tr><td><code>Char.toTitleCase()</code></td><td><code>Char.titlecaseChar(): Char</code><br><code>Char.titlecase(): String</code></td></tr></tbody></table></li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>对于 Kotlin/JVM，还存在带有显式 <code>Locale</code> 形参的重载 <code>uppercase()</code>、<code>lowercase()</code> 和 <code>titlecase()</code> 函数。</p></div><p>关于文本处理函数的完整更改列表，请参见 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/locale-agnostic-string-conversions.md" target="_blank" rel="noreferrer">KEEP</a>。</p><h3 id="char-到数字与代码的清晰转换" tabindex="-1">Char 到数字与代码的清晰转换 <a class="header-anchor" href="#char-到数字与代码的清晰转换" aria-label="Permalink to &quot;Char 到数字与代码的清晰转换&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>用于 <code>Char</code> 转换<strong>特性</strong>的明确 API 是<a href="/kotlin/components-stability">实验性的</a>。它可能随时移除或更改。 仅将其用于求值目的。如果你能将反馈提交到 <a href="https://youtrack.jetbrains.com/issue/KT-44333" target="_blank" rel="noreferrer">YouTrack</a> 上，我们将不胜感激。</p></div><p>当前的 <code>Char</code> 到数字的转换函数（返回以不同数字类型表示的 UTF-16 代码）经常与类似的 String 到 Int 转换（返回字符串的数值）混淆：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;4&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// returns 4</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;4&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// returns 52</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// and there was no common function that would return the numeric value 4 for Char &#39;4&#39;</span></span></code></pre></div><p>为了避免这种混淆，我们决定将 <code>Char</code> 转换分为以下两组命名清晰的函数：</p><ul><li><p>获取 <code>Char</code> 的整数代码并根据给定代码构造 <code>Char</code> 的函数：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(code: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Char</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(code: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UShort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Char</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Char.code: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span></span></code></pre></div></li><li><p>将 <code>Char</code> 转换为其所代表数字的数值的函数：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">digitToInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radix: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">digitToIntOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radix: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?</span></span></code></pre></div></li><li><p>一个 <code>Int</code> 的扩展函数，用于将其所代表的非负单个数字转换为相应的 <code>Char</code> 表示：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">digitToChar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radix: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Char</span></span></code></pre></div></li></ul><p>更多详情请参见 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/char-int-conversions.md" target="_blank" rel="noreferrer">KEEP</a>。</p><h2 id="序列化更新" tabindex="-1">序列化更新 <a class="header-anchor" href="#序列化更新" aria-label="Permalink to &quot;序列化更新&quot;">​</a></h2><p>随着 Kotlin 1.4.30 的发布，我们同时发布了 <code>kotlinx.serialization</code> <a href="https://github.com/Kotlin/kotlinx.serialization/releases/tag/v1.1.0-RC" target="_blank" rel="noreferrer">1.1.0-RC</a>，它包含一些新特性：</p><ul><li>Inline class 序列化支持</li><li>无符号原生类型序列化支持</li></ul><h3 id="inline-class-序列化支持" tabindex="-1">Inline class 序列化支持 <a class="header-anchor" href="#inline-class-序列化支持" aria-label="Permalink to &quot;Inline class 序列化支持&quot;">​</a></h3><p>从 Kotlin 1.4.30 开始，你可以使 inline class <a href="/kotlin/serialization">可序列化</a>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Serializable</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rgb: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>该<strong>特性</strong>需要新的 1.4.30 IR 编译器。</p></div><p>序列化框架在可序列化的 inline class 被用于其他可序列化类时不会对其进行装箱。</p><p>更多信息请参阅 <code>kotlinx.serialization</code> <a href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/inline-classes.md#serializable-inline-classes" target="_blank" rel="noreferrer">文档</a>。</p><h3 id="无符号原生类型序列化支持" tabindex="-1">无符号原生类型序列化支持 <a class="header-anchor" href="#无符号原生类型序列化支持" aria-label="Permalink to &quot;无符号原生类型序列化支持&quot;">​</a></h3><p>从 1.4.30 开始，你可以使用 <a href="https://github.com/Kotlin/kotlinx.serialization" target="_blank" rel="noreferrer">kotlinx.serialization</a> 的标准 JSON 序列化器来处理无符号原生类型：<code>UInt</code>、<code>ULong</code>、<code>UByte</code> 和 <code>UShort</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Serializable</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> counted: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UByte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> description: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> counted </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 239</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toUByte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Json.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">encodeToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(counted, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;tries&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>更多信息请参阅 <code>kotlinx.serialization</code> <a href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/inline-classes.md#unsigned-types-support-json-only" target="_blank" rel="noreferrer">文档</a>。</p>`,48))])}const C=k(d,[["render",c]]);export{m as __pageData,C as default};
