import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.Bksy39di.js";const E=JSON.parse('{"title":"与 C 语言的互操作","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/native-c-interop.md","filePath":"kotlin/native-c-interop.md","lastUpdated":1755514048000}'),l={name:"kotlin/native-c-interop.md"};function e(p,s,h,k,d,r){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="与-c-语言的互操作" tabindex="-1">与 C 语言的互操作 <a class="header-anchor" href="#与-c-语言的互操作" aria-label="Permalink to &quot;与 C 语言的互操作&quot;">​</a></h1><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>C 库导入目前处于 <a href="/kotlin/native-c-interop-stability">Beta</a> 阶段。所有通过 cinterop 工具从 C 库生成的 Kotlin 声明都应带有 <code>@ExperimentalForeignApi</code> 注解。 Kotlin/Native 随附的原生平台库（例如 Foundation、UIKit 和 POSIX）仅对某些 API 要求显式选择启用。</p></div><p>本文档涵盖了 Kotlin 与 C 互操作性的一般方面。Kotlin/Native 随附了一个 cinterop 工具， 你可以使用它快速生成与外部 C 库交互所需的一切。</p><p>该工具分析 C 头文件，并将 C 类型、函数和字符串直接映射到 Kotlin 中。 然后可以将生成的存根导入到 IDE 中，以启用代码补全和导航。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Kotlin 也提供了与 Objective-C 的互操作性。Objective-C 库同样通过 cinterop 工具导入。关于更多详情，请参见 <a href="/kotlin/native-objc-interop">Swift/Objective-C 互操作</a>。</p></div><h2 id="设置你的项目" tabindex="-1">设置你的项目 <a class="header-anchor" href="#设置你的项目" aria-label="Permalink to &quot;设置你的项目&quot;">​</a></h2><p>以下是使用需要消耗 C 库的项目的通用工作流：</p><ol><li>创建并配置一个<a href="/kotlin/native-definition-file">定义文件</a>。它描述了 cinterop 工具应将哪些内容包含到 Kotlin<a href="#bindings">绑定</a>中。</li><li>配置你的 Gradle 构建文件，以在构建过程中包含 cinterop。</li><li>编译并运行项目以生成最终的可执行文件。</li></ol><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>关于动手实践，请完成<a href="/kotlin/native-app-with-c-and-libcurl">使用 C 互操作创建应用</a>教程。</p></div><p>在许多情况下，无需配置与 C 库的自定义互操作性。相反，你可以使用<a href="/kotlin/native-platform-libs">平台库</a>中可用的平台标准化绑定 API。例如， 在 Linux/macOS 平台上的 POSIX、Windows 平台上的 Win32，或者 macOS/iOS 上的 Apple frameworks 都可以通过这种方式使用。</p><h2 id="绑定" tabindex="-1">绑定 <a class="header-anchor" href="#绑定" aria-label="Permalink to &quot;绑定&quot;">​</a></h2><h3 id="基本互操作类型" tabindex="-1">基本互操作类型 <a class="header-anchor" href="#基本互操作类型" aria-label="Permalink to &quot;基本互操作类型&quot;">​</a></h3><p>所有支持的 C 类型在 Kotlin 中都有相应的表示形式：</p><ul><li>有符号、无符号整型和浮点类型映射到具有相同宽度的对应 Kotlin 类型。</li><li>指针和数组映射到 <code>CPointer&lt;T&gt;?</code>。</li><li>枚举可以映射到 Kotlin 枚举或整型值，具体取决于启发式规则和<a href="/kotlin/native-definition-file#configure-enums-generation">定义文件设置</a>。</li><li>结构体和联合体映射到可以通过点表示法访问字段的类型，例如 <code>someStructInstance.field1</code>。</li><li><code>typedef</code> 表示为 <code>typealias</code>。</li></ul><p>此外，任何 C 类型都具有表示该类型左值的 Kotlin 类型，即位于内存中的值，而不是简单的不可变、自包含的值。 可以将其类比为 C++ 引用。对于结构体（以及 <code>typedef</code> 到结构体），这种表示是主要的，并与结构体本身同名。 对于 Kotlin 枚举，它被命名为 <code>\${type}.Var</code>；对于 <code>CPointer&lt;T&gt;</code>，它被命名为 <code>CPointerVar&lt;T&gt;</code>；对于大多数其他类型，它被命名为 <code>\${type}Var</code>。</p><p>对于同时具有两种表示形式的类型，带有左值的表示形式具有一个可变的 <code>.value</code> 属性，用于访问该值。</p><h4 id="指针类型" tabindex="-1">指针类型 <a class="header-anchor" href="#指针类型" aria-label="Permalink to &quot;指针类型&quot;">​</a></h4><p><code>CPointer&lt;T&gt;</code> 的类型实参 <code>T</code> 必须是上述左值类型之一。例如，C 类型 <code>struct S*</code> 映射到 <code>CPointer&lt;S&gt;</code>，<code>int8_t*</code> 映射到 <code>CPointer&lt;int_8tVar&gt;</code>，而 <code>char**</code> 映射到 <code>CPointer&lt;CPointerVar&lt;ByteVar&gt;&gt;</code>。</p><p>C 空指针表示为 Kotlin 的 <code>null</code>，并且指针类型 <code>CPointer&lt;T&gt;</code> 不可空，但 <code>CPointer&lt;T&gt;?</code> 可以为空。 此类型的值支持所有与处理 <code>null</code> 相关的 Kotlin 操作，例如 <code>?:</code>、<code>?.</code>、<code>!!</code> 等：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getenv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;PATH&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)?.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toKString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() ?: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span></span></code></pre></div><p>由于数组也映射到 <code>CPointer&lt;T&gt;</code>，因此它支持使用 <code>[]</code> 操作符通过索引访问值：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shift</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ptr: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ByteVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, length: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ptr[index] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ptr[index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>CPointer&lt;T&gt;</code> 的 <code>.pointed</code> 属性返回由该指针指向的类型 <code>T</code> 的左值。反向操作是 <code>.ptr</code>，它接收左值并返回指向它的指针。</p><p><code>void*</code> 映射到 <code>COpaquePointer</code> —— 这个特殊指针类型是任何其他指针类型的超类型。 因此，如果 C 函数接收 <code>void*</code>，Kotlin 绑定会接受任何 <code>CPointer</code>。</p><p>指针（包括 <code>COpaquePointer</code>）的转换可以通过 <code>.reinterpret&lt;T&gt;</code> 完成，例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intPtr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bytePtr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reinterpret</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IntVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span></code></pre></div><p>或者：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intPtr: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IntVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bytePtr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reinterpret</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>与 C 语言一样，这些 <code>.reinterpret</code> 转换是不安全的，并可能在应用程序中导致细微的内存问题。</p><p>此外，<code>CPointer&lt;T&gt;?</code> 与 <code>Long</code> 之间存在不安全转换，由 <code>.toLong()</code> 和 <code>.toCPointer&lt;T&gt;()</code> 扩展方法提供：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> longValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ptr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLong</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> originalPtr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> longValue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toCPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如果结果类型从上下文中已知，则可以借助类型推断省略类型实参。</p></div><h3 id="内存分配" tabindex="-1">内存分配 <a class="header-anchor" href="#内存分配" aria-label="Permalink to &quot;内存分配&quot;">​</a></h3><p>原生内存可以使用 <code>NativePlacement</code> 接口进行分配，例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> byteVar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> placement.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ByteVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span></code></pre></div><p>或者：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bytePtr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> placement.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">allocArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ByteVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>最合理的放置位置是对象 <code>nativeHeap</code>。它对应于使用 <code>malloc</code> 分配原生内存，并提供额外的 <code>.free()</code> 操作来释放已分配的内存：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kotlinx.cinterop.ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nativeHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">allocArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ByteVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(size)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nativeHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">free</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>nativeHeap</code> 要求手动释放内存。然而，将内存分配为生命周期绑定到词法作用域的情况通常很有用。如果此类内存能自动释放，将非常有帮助。</p><p>为解决此问题，你可以使用 <code>memScoped { }</code>。在花括号内，临时放置可用作隐式接收者，因此可以使用 <code>alloc</code> 和 <code>allocArray</code> 分配原生内存， 并且分配的内存将在离开作用域后自动释放。</p><p>例如，可以通过指针形参返回值的 C 函数可以这样使用：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> platform.posix.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fileSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> memScoped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> statBuf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> error </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> stat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, statBuf.ptr)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    statBuf.st_size</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="向绑定传递指针" tabindex="-1">向绑定传递指针 <a class="header-anchor" href="#向绑定传递指针" aria-label="Permalink to &quot;向绑定传递指针&quot;">​</a></h3><p>尽管 C 指针映射到 <code>CPointer&lt;T&gt; 类型</code>，但 C 函数的指针类型形参映射到 <code>CValuesRef&lt;T&gt;</code>。 当将 <code>CPointer&lt;T&gt;</code> 作为此类形参的值传递时，它会按原样传递给 C 函数。 然而，可以传递值序列而不是指针。在这种情况下，该序列是“按值”传递的， 即 C 函数接收指向该序列临时副本的指针，该副本仅在函数返回前有效。</p><p>指针形参的 <code>CValuesRef&lt;T&gt;</code> 表示旨在支持 C 数组字面量，无需显式原生内存分配。 为了构建不可变、自包含的 C 值序列，提供了以下方法：</p><ul><li><code>\${type}Array.toCValues()</code>，其中 <code>type</code> 是 Kotlin 原生类型</li><li><code>Array&lt;CPointer&lt;T&gt;?&gt;.toCValues()</code>，<code>List&lt;CPointer&lt;T&gt;?&gt;.toCValues()</code></li><li><code>cValuesOf(vararg elements: \${type})</code>，其中 <code>type</code> 是原生类型或指针</li></ul><p>例如：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// C:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> elements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elements</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cValuesOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="字符串" tabindex="-1">字符串 <a class="header-anchor" href="#字符串" aria-label="Permalink to &quot;字符串&quot;">​</a></h3><p>与其他指针不同，类型为 <code>const char*</code> 的形参表示为 Kotlin <code>String</code>。 因此，可以将任何 Kotlin 字符串传递给期望 C 字符串的绑定。</p><p>还有一些可用于手动在 Kotlin 和 C 字符串之间进行转换的工具：</p><ul><li><code>fun CPointer&lt;ByteVar&gt;.toKString(): String</code></li><li><code>val String.cstr: CValuesRef&lt;ByteVar&gt;</code>.</li></ul><p>要获取指针，<code>.cstr</code> 应该在原生内存中进行分配，例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cString </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlinString.cstr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nativeHeap)</span></span></code></pre></div><p>在所有情况下，C 字符串都应该被编码为 UTF-8。</p><p>要跳过自动转换并确保在绑定中使用原始指针，请将<a href="/kotlin/native-definition-file#set-up-string-conversion"><code>noStringConversion</code> 属性</a>添加到 <code>.def</code> 文件中：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">noStringConversion </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LoadCursorA LoadCursorW</span></span></code></pre></div><p>通过这种方式，任何类型为 <code>CPointer&lt;ByteVar&gt;</code> 的值都可以作为 <code>const char*</code> 类型的实参传递。如果需要传递 Kotlin 字符串，可以使用类似这样的代码：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kotlinx.cinterop.ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memScoped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    LoadCursorA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cursor.bmp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cstr.ptr)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// for ASCII or UTF-8 version</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    LoadCursorW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cursor.bmp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.wcstr.ptr) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// for UTF-16 version</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="作用域局部指针" tabindex="-1">作用域局部指针 <a class="header-anchor" href="#作用域局部指针" aria-label="Permalink to &quot;作用域局部指针&quot;">​</a></h3><p>可以使用 <code>memScoped {}</code> 下可用的 <code>CValues&lt;T&gt;.ptr</code> 扩展属性，为 <code>CValues&lt;T&gt;</code> 实例创建 C 表示的作用域稳定指针。 它允许使用需要 C 指针且生命周期绑定到特定 <code>MemScope</code> 的 API。例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kotlinx.cinterop.ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memScoped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrayOfNulls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ITEM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;?&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    arrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;one&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;two&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEachIndexed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { index, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> items[index] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cstr.ptr }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    menu </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> new_menu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Menu&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cstr.ptr, items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toCValues</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().ptr)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在此示例中，所有传递给 C API <code>new_menu()</code> 的值都具有其所属的最内层 <code>memScope</code> 的生命周期。 一旦控制流离开 <code>memScoped</code> 作用域，C 指针就会失效。</p><h3 id="按值传递和接收结构体" tabindex="-1">按值传递和接收结构体 <a class="header-anchor" href="#按值传递和接收结构体" aria-label="Permalink to &quot;按值传递和接收结构体&quot;">​</a></h3><p>当 C 函数按值接收或返回结构体/联合体 <code>T</code> 时，对应的实参类型或返回类型表示为 <code>CValue&lt;T&gt;</code>。</p><p><code>CValue&lt;T&gt;</code> 是一种不透明类型，因此无法通过相应的 Kotlin 属性访问结构体字段。 如果 API 将结构体用作不透明句柄，这可能没问题。但是，如果需要访问字段，则提供了以下转换方法：</p><ul><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/read-value.html" target="_blank" rel="noreferrer"><code>fun T.readValue(): CValue&lt;T&gt;</code></a> 将（左值）<code>T</code> 转换为 <code>CValue&lt;T&gt;</code>。因此，要构建 <code>CValue&lt;T&gt;</code>，<code>T</code> 可以被分配、填充，然后转换为 <code>CValue&lt;T&gt;</code>。</p></li><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/use-contents.html" target="_blank" rel="noreferrer"><code>CValue&lt;T&gt;.useContents(block: T.() -&gt; R): R</code></a> 将 <code>CValue&lt;T&gt;</code> 临时存储在内存中，然后运行传入的 lambda 表达式，并将此放置的值 <code>T</code> 作为接收者。 因此，要读取单个字段，可以使用以下代码：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fieldValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> structValue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useContents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div></li><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/c-value.html" target="_blank" rel="noreferrer"><code>fun cValue(initialize: T.() -&gt; Unit): CValue&lt;T&gt;</code></a> 应用所提供的 <code>initialize</code> 函数在内存中分配 <code>T</code>，并将结果转换为 <code>CValue&lt;T&gt;</code>。</p></li><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/copy.html" target="_blank" rel="noreferrer"><code>fun CValue&lt;T&gt;.copy(modify: T.() -&gt; Unit): CValue&lt;T&gt;</code></a> 创建现有 <code>CValue&lt;T&gt;</code> 的修改副本。原始值被放置在内存中，使用 <code>modify()</code> 函数进行修改，然后再次转换为新的 <code>CValue&lt;T&gt;</code>。</p></li><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/place-to.html" target="_blank" rel="noreferrer"><code>fun CValues&lt;T&gt;.placeTo(scope: AutofreeScope): CPointer&lt;T&gt;</code></a> 将 <code>CValues&lt;T&gt;</code> 放置到 <code>AutofreeScope</code> 中，并返回指向已分配内存的指针。当 <code>AutofreeScope</code> 被处理时，已分配的内存将自动释放。</p></li></ul><h3 id="回调" tabindex="-1">回调 <a class="header-anchor" href="#回调" aria-label="Permalink to &quot;回调&quot;">​</a></h3><p>要将 Kotlin 函数转换为指向 C 函数的指针，可以使用 <code>staticCFunction(::kotlinFunction)</code>。也可以 提供 lambda 表达式而不是函数引用。该函数或 lambda 表达式不得捕获任何值。</p><h4 id="向回调传递用户数据" tabindex="-1">向回调传递用户数据 <a class="header-anchor" href="#向回调传递用户数据" aria-label="Permalink to &quot;向回调传递用户数据&quot;">​</a></h4><p>C API 通常允许向回调传递一些用户数据。此类数据通常由用户在配置回调时提供。 例如，它作为 <code>void*</code> 传递给某个 C 函数（或写入结构体）。然而，Kotlin 对象的引用不能直接传递给 C。 因此，它们在配置回调之前需要包装，然后在回调内部解包，以便安全地从 Kotlin 经由 C 世界传递到 Kotlin。 这种包装可以通过 <code>StableRef</code> 类实现。</p><p>要包装引用：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stableRef </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> StableRef.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kotlinReference)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> voidPtr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stableRef.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asCPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>在这里，<code>voidPtr</code> 是一个 <code>COpaquePointer</code>，可以传递给 C 函数。</p><p>要解包引用：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stableRef </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> voidPtr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asStableRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KotlinClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlinReference </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stableRef.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>在这里，<code>kotlinReference</code> 是原始包装的引用。</p><p>创建的 <code>StableRef</code> 最终应使用 <code>.dispose()</code> 方法手动处理，以防止内存泄漏：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stableRef.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>此后它将变得无效，因此 <code>voidPtr</code> 不能再被解包。</p><h3 id="宏" tabindex="-1">宏 <a class="header-anchor" href="#宏" aria-label="Permalink to &quot;宏&quot;">​</a></h3><p>每个扩展为常量的 C 宏都表示为 Kotlin 属性。</p><p>当编译器可以推断类型时，没有形参的宏会受到支持：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FOO</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>在这种情况下，<code>FOO</code> 在 Kotlin 中可用。</p><p>为了支持其他宏，你可以通过用受支持的声明包装它们来手动暴露它们。例如， 函数式宏 <code>FOO</code> 可以通过<a href="/kotlin/native-definition-file#add-custom-declarations">向库添加自定义声明</a>来作为函数 <code>foo()</code> 暴露：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">headers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> library</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">base.h</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">---</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FOO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="可移植性" tabindex="-1">可移植性 <a class="header-anchor" href="#可移植性" aria-label="Permalink to &quot;可移植性&quot;">​</a></h3><p>有时 C 库的函数形参或结构体字段是平台依赖类型，例如 <code>long</code> 或 <code>size_t</code>。 Kotlin 本身不提供隐式整型转换或 C 风格整型转换（例如，<code>(size_t) intValue</code>）， 因此为了在这些情况下更容易编写可移植代码，提供了 <code>convert</code> 方法：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> \${type1}.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">convert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;\${</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">type2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}&gt;(): \${type2}</span></span></code></pre></div><p>这里，<code>type1</code> 和 <code>type2</code> 都必须是整型，可以是有符号的或无符号的。</p><p><code>.convert&lt;\${type}&gt;</code> 具有与 <code>.toByte</code>、<code>.toShort</code>、<code>.toInt</code>、<code>.toLong</code>、<code>.toUByte</code>、 <code>.toUShort</code>、<code>.toUInt</code> 或 <code>.toULong</code> 方法之一相同的语义，具体取决于 <code>type</code>。</p><p>使用 <code>convert</code> 的示例：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> platform.posix.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> zeroMemory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">COpaquePointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, size: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    memset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, size.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">convert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此外，类型形参可以自动推断，因此在某些情况下可以省略。</p><h3 id="对象固定" tabindex="-1">对象固定 <a class="header-anchor" href="#对象固定" aria-label="Permalink to &quot;对象固定&quot;">​</a></h3><p>Kotlin 对象可以被固定，即它们在内存中的位置被保证是稳定的，直到它们被解除固定， 并且指向此类对象内部数据的指针可以传递给 C 函数。</p><p>你可以采用以下几种方法：</p><ul><li><p>使用 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/use-pinned.html" target="_blank" rel="noreferrer"><code>usePinned()</code></a> 扩展函数， 它会固定一个对象，执行一个代码块，并在正常路径和异常路径上解除固定：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> platform.posix.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ByteArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    buffer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">usePinned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { pinned </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> recv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd, pinned.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addressOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), buffer.size.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">convert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                break</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Now \`buffer\` has raw data obtained from the \`recv()\` call.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这里，<code>pinned</code> 是一个特殊类型 <code>Pinned&lt;T&gt;</code> 的对象。它提供了有用的扩展，例如 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/address-of.html" target="_blank" rel="noreferrer"><code>.addressOf()</code></a>， 它允许获取固定数组体的地址。</p></li><li><p>使用 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/ref-to.html" target="_blank" rel="noreferrer"><code>.refTo()</code></a> 扩展函数， 它在底层功能类似，但在某些情况下可能有助于你减少样板代码：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> platform.posix.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ByteArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> recv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd, buffer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">refTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), buffer.size.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">convert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            break</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Now \`buffer\` has raw data obtained from the \`recv()\` call.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这里，<code>buffer.refTo(0)</code> 具有 <code>CValuesRef</code> 类型，它在进入 <code>recv()</code> 函数之前固定数组， 将数组的第零个元素的地址传递给函数，并在退出后解除固定数组。</p></li></ul><h3 id="前向声明" tabindex="-1">前向声明 <a class="header-anchor" href="#前向声明" aria-label="Permalink to &quot;前向声明&quot;">​</a></h3><p>要导入前向声明，请使用 <code>cnames</code> 包。例如，要导入在 C 库中声明的 <code>cstructName</code> 前向声明（该库具有 <code>library.package</code>）， 请使用特殊的前向声明包：<code>import cnames.structs.cstructName</code>。</p><p>考虑两个 cinterop 库：一个具有结构体的前向声明，另一个在另一个包中具有实际实现：</p><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// First C library</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> consumeStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Struct consumed</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Second C library</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Header:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdlib.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Implementation:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> produceStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> malloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s-&gt;data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>要在两个库之间传输对象，请在你的 Kotlin 代码中使用显式 <code>as</code> 转换：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin code:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    consumeStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">produceStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CPointer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cnames.structs.ForwardDeclaredStruct</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="下一步" tabindex="-1">下一步 <a class="header-anchor" href="#下一步" aria-label="Permalink to &quot;下一步&quot;">​</a></h2><p>通过完成以下教程，了解类型、函数和字符串如何在 Kotlin 和 C 之间映射：</p><ul><li><a href="/kotlin/mapping-primitive-data-types-from-c">从 C 映射原生数据类型</a></li><li><a href="/kotlin/mapping-struct-union-types-from-c">从 C 映射结构体和联合体类型</a></li><li><a href="/kotlin/mapping-function-pointers-from-c">从 C 映射函数指针</a></li><li><a href="/kotlin/mapping-strings-from-c">从 C 映射字符串</a></li></ul>`,111)]))}const c=i(l,[["render",e]]);export{E as __pageData,c as default};
