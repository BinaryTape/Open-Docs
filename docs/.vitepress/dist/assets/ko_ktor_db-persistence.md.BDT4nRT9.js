import{_ as c,a as p,b as r}from"./chunks/tutorial_persistence_database_tool_window.CIMhXNzI.js";import{_ as h,C as t,c as k,o as u,j as e,G as i,ag as g,a as s,w as o}from"./chunks/framework.Bksy39di.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ko/ktor/db-persistence.md","filePath":"ko/ktor/db-persistence.md","lastUpdated":1755457140000}'),b={name:"ko/ktor/db-persistence.md"};function m(v,a,E,y,q,C){const d=t("show-structure"),n=t("tldr"),l=t("link-summary");return u(),k("div",null,[a[2]||(a[2]=e("h1",{id:"exposed를-사용한-데이터베이스-영속성",tabindex:"-1"},[s("Exposed를 사용한 데이터베이스 영속성 "),e("a",{class:"header-anchor",href:"#exposed를-사용한-데이터베이스-영속성","aria-label":'Permalink to "Exposed를 사용한 데이터베이스 영속성"'},"​")],-1)),i(d,{for:"chapter",depth:"2"}),i(n,null,{default:o(()=>a[0]||(a[0]=[e("p",null,[e("b",null,"코드 예시"),s(": "),e("a",{href:"https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/tutorial-website-interactive-persistence"}," tutorial-website-interactive-persistence ")],-1),e("p",null,[e("b",null,"사용된 라이브러리"),s(": "),e("a",{href:"https://github.com/JetBrains/Exposed"},"Exposed"),s(", "),e("a",{href:"https://github.com/h2database/h2database"},"h2database")],-1)])),_:1}),i(l,null,{default:o(()=>a[1]||(a[1]=[s("Exposed ORM 프레임워크를 사용하여 웹사이트에 영속성을 추가하는 방법을 배웁니다.")])),_:1}),a[3]||(a[3]=g(`<p>이 튜토리얼 시리즈에서는 Ktor에서 간단한 블로그 애플리케이션을 만드는 방법을 보여드립니다:</p><ul><li>첫 번째 튜토리얼에서는 이미지 및 HTML 페이지와 같은 정적 콘텐츠를 호스팅하는 방법을 보여드렸습니다.</li><li>두 번째 튜토리얼에서는 FreeMarker 템플릿 엔진을 사용하여 애플리케이션에 상호 작용을 추가했습니다.</li><li><strong>이번 튜토리얼</strong>에서는 Exposed 프레임워크를 사용하여 웹사이트에 영속성을 추가합니다. H2 로컬 데이터베이스를 사용하여 게시글을 저장할 것입니다.</li><li><a href="./db-connection-pooling-caching">다음 튜토리얼</a>에서는 HikariCP 및 Ehcache 라이브러리를 각각 사용하여 데이터베이스 연결 풀링 및 캐싱을 구현하는 방법을 살펴보겠습니다.</li></ul><h2 id="add-dependencies" tabindex="-1">의존성 추가 <a class="header-anchor" href="#add-dependencies" aria-label="Permalink to &quot;의존성 추가 {id=&quot;add-dependencies&quot;}&quot;">​</a></h2><p>먼저, Exposed 및 H2 라이브러리에 대한 의존성을 추가해야 합니다. <code>gradle.properties</code> 파일을 열고 라이브러리 버전을 지정합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">exposed_version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.53</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">h2_version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">232</span></span></code></pre></div><p>그런 다음, <code>build.gradle.kts</code>를 열고 다음 의존성을 추가합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p><code>build.gradle.kts</code> 파일의 오른쪽 상단 모서리에 있는 <strong>Load Gradle Changes</strong> 아이콘을 클릭하여 새로 추가된 의존성을 설치합니다.</p><h2 id="model" tabindex="-1">모델 업데이트 <a class="header-anchor" href="#model" aria-label="Permalink to &quot;모델 업데이트 {id=&quot;model&quot;}&quot;">​</a></h2><p>Exposed는 <code>org.jetbrains.exposed.sql.Table</code> 클래스를 데이터베이스 테이블로 사용합니다. <code>Article</code> 모델을 업데이트하려면 <code>models/Article.kt</code> 파일을 열고 기존 코드를 다음으로 대체합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p><code>id</code>, <code>title</code>, <code>body</code> 컬럼은 게시글에 대한 정보를 저장합니다. <code>id</code> 컬럼은 기본 키로 작동합니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>만약 <code>Articles</code> 객체의 프로퍼티 <a href="https://www.jetbrains.com/help/idea/viewing-reference-information.html#type-info" target="_blank" rel="noreferrer">유형을 검사</a>한다면, 필요한 유형 인자를 가진 <code>Column</code> 유형을 가지고 있음을 알 수 있습니다: <code>id</code>는 <code>Column&lt;Int&gt;</code> 유형이고, <code>title</code>과 <code>body</code>는 모두 <code>Column&lt;String&gt;</code> 유형입니다.</p></div><h2 id="connect_db" tabindex="-1">데이터베이스 연결 <a class="header-anchor" href="#connect_db" aria-label="Permalink to &quot;데이터베이스 연결 {id=&quot;connect_db&quot;}&quot;">​</a></h2><p><a href="https://en.wikipedia.org/wiki/Data_access_object" target="_blank" rel="noreferrer">데이터 접근 객체</a>(DAO)는 특정 데이터베이스의 세부 사항을 노출하지 않고 데이터베이스에 대한 인터페이스를 제공하는 패턴입니다. 나중에 데이터베이스에 대한 특정 요청을 추상화하기 위해 <code>DAOFacade</code> 인터페이스를 정의할 것입니다.</p><p>Exposed를 사용하는 모든 데이터베이스 접근은 데이터베이스에 대한 연결을 얻는 것으로 시작됩니다. 이를 위해 JDBC URL과 드라이버 클래스 이름을 <code>Database.connect</code> 함수에 전달합니다. <code>com.example</code> 내부에 <code>dao</code> 패키지를 생성하고 새로운 <code>DatabaseSingleton.kt</code> 파일을 추가합니다. 그런 다음, 이 코드를 삽입합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><blockquote><p><code>driverClassName</code>과 <code>jdbcURL</code>이 여기에 하드코딩되어 있습니다. Ktor는 이러한 설정을 <a href="./server-configuration-file">커스텀 설정 그룹</a>으로 추출할 수 있도록 합니다.</p></blockquote><h3 id="create_table" tabindex="-1">테이블 생성 <a class="header-anchor" href="#create_table" aria-label="Permalink to &quot;테이블 생성 {id=&quot;create_table&quot;}&quot;">​</a></h3><p>연결을 얻은 후, 모든 SQL 문은 트랜잭션 내에 배치되어야 합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> database </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Database.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jdbcURL, driverClassName)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transaction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(database) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Statements here</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 코드 샘플에서는 기본 데이터베이스가 <code>transaction</code> 함수에 명시적으로 전달됩니다. 데이터베이스가 하나만 있는 경우 생략할 수 있습니다. 이 경우 Exposed는 트랜잭션을 위해 마지막으로 연결된 데이터베이스를 자동으로 사용합니다.</p><blockquote><p><code>Database.connect</code> 함수는 트랜잭션을 호출하기 전까지는 실제 데이터베이스 연결을 설정하지 않고, 단지 향후 연결을 위한 디스크립터만 생성한다는 점에 유의하십시오.</p></blockquote><p><code>Articles</code> 테이블이 이미 선언되어 있으므로, <code>init</code> 함수의 하단에서 <code>transaction</code> 호출 내부에 <code>SchemaUtils.create(Articles)</code>를 호출하여 데이터베이스에 이 테이블이 아직 존재하지 않는 경우 생성하도록 지시할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> database </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Database.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jdbcURL, driverClassName)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transaction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(database) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        SchemaUtils.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Articles)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="queries" tabindex="-1">쿼리 실행 <a class="header-anchor" href="#queries" aria-label="Permalink to &quot;쿼리 실행 {id=&quot;queries&quot;}&quot;">​</a></h3><p>편의를 위해 <code>DatabaseSingleton</code> 객체 내부에 유틸리티 함수 <code>dbQuery</code>를 생성하겠습니다. 이 함수는 데이터베이스에 대한 모든 향후 요청에 사용될 것입니다. 트랜잭션을 사용하여 블로킹 방식으로 접근하는 대신, 코루틴을 활용하여 각 쿼리를 자체 코루틴에서 시작하도록 하겠습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>결과적인 <code>DatabaseSingleton.kt</code> 파일은 다음과 같아야 합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h3 id="startup" tabindex="-1">시작 시 데이터베이스 설정 로드 <a class="header-anchor" href="#startup" aria-label="Permalink to &quot;시작 시 데이터베이스 설정 로드 {id=&quot;startup&quot;}&quot;">​</a></h3><p>마지막으로, 애플리케이션 시작 시 생성된 설정을 로드해야 합니다. <code>Application.kt</code>를 열고 <code>Application.module</code> 본문에서 <code>DatabaseSingleton.init</code>을 호출합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h2 id="persistence_logic" tabindex="-1">영속성 로직 구현 <a class="header-anchor" href="#persistence_logic" aria-label="Permalink to &quot;영속성 로직 구현 {id=&quot;persistence_logic&quot;}&quot;">​</a></h2><p>이제 게시글 업데이트에 필요한 작업을 추상화하는 인터페이스를 생성해 보겠습니다. <code>dao</code> 패키지 내부에 <code>DAOFacade.kt</code> 파일을 생성하고 다음 코드를 채웁니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>모든 게시글을 나열하고, ID로 게시글을 보고, 새 게시글을 추가, 편집 또는 삭제해야 합니다. 이 모든 함수는 내부적으로 데이터베이스 쿼리를 수행하므로, 중단 함수(suspending functions)로 정의됩니다.</p><p><code>DAOFacade</code> 인터페이스를 구현하려면, 해당 이름에 캐럿을 놓고 이 인터페이스 옆의 노란색 전구 아이콘을 클릭한 다음 <strong>Implement interface</strong>를 선택합니다. 호출된 대화 상자에서 기본 설정을 유지하고 <strong>OK</strong>를 클릭합니다.</p><p><strong>Implement Members</strong> 대화 상자에서 모든 함수를 선택하고 <strong>OK</strong>를 클릭합니다.</p><p><img src="`+c+'" alt="Implement Members" width="451"></p><p>IntelliJ IDEA는 <code>dao</code> 패키지 내부에 <code>DAOFacadeImpl.kt</code> 파일을 생성합니다. Exposed DSL을 사용하여 모든 함수를 구현해 봅시다.</p><h3 id="get_all" tabindex="-1">모든 게시글 가져오기 <a class="header-anchor" href="#get_all" aria-label="Permalink to &quot;모든 게시글 가져오기 {id=&quot;get_all&quot;}&quot;">​</a></h3><p>모든 항목을 반환하는 함수부터 시작하겠습니다. 우리의 요청은 <code>dbQuery</code> 호출 내에 래핑됩니다. <code>Table.selectAll</code> 확장 함수를 호출하여 데이터베이스에서 모든 데이터를 가져옵니다. <code>Articles</code> 객체는 <code>Table</code>의 서브클래스이므로, Exposed DSL 메서드를 사용하여 작업합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p><code>Table.selectAll</code>은 <code>Query</code> 인스턴스를 반환하므로, <code>Article</code> 인스턴스 목록을 얻으려면 각 행의 데이터를 수동으로 추출하여 우리의 데이터 클래스로 변환해야 합니다. 우리는 <code>ResultRow</code>로부터 <code>Article</code>을 생성하는 헬퍼 함수 <code>resultRowToArticle</code>을 사용하여 이를 수행합니다.</p><p><code>ResultRow</code>는 간결한 <code>get</code> 연산자를 사용하여 지정된 <code>Column</code>에 저장된 데이터를 가져오는 방법을 제공하며, 배열이나 맵과 유사하게 대괄호 문법을 사용할 수 있도록 합니다.</p><blockquote><p><code>Articles.id</code>의 타입은 <code>Column&lt;Int&gt;</code>이며, 이는 <code>Expression</code> 인터페이스를 구현합니다. 그렇기 때문에 어떤 컬럼이든 표현식으로 전달할 수 있습니다.</p></blockquote><h3 id="get_article" tabindex="-1">게시글 가져오기 <a class="header-anchor" href="#get_article" aria-label="Permalink to &quot;게시글 가져오기 {id=&quot;get_article&quot;}&quot;">​</a></h3><p>이제 하나의 게시글을 반환하는 함수를 구현해 봅시다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p><code>select</code> 함수는 확장 람다를 인자로 받습니다. 이 람다 내부의 암묵적 리시버는 <code>SqlExpressionBuilder</code> 타입입니다. 이 타입을 명시적으로 사용하지는 않지만, 이는 쿼리를 구축하는 데 사용하는 컬럼에 대한 유용한 연산들을 많이 정의합니다. 비교(<code>eq</code>, <code>less</code>, <code>greater</code>), 산술 연산(<code>plus</code>, <code>times</code>), 값이 제공된 값 목록에 속하는지 여부 확인(<code>inList</code>, <code>notInList</code>), 값이 null인지 non-null인지 확인하는 등 다양한 작업을 사용할 수 있습니다.</p><p><code>select</code>는 <code>Query</code> 값 목록을 반환합니다. 이전과 마찬가지로, 이를 게시글로 변환합니다. 우리의 경우 하나의 게시글이어야 하므로, 이를 결과로 반환합니다.</p><h3 id="add_article" tabindex="-1">새 게시글 추가 <a class="header-anchor" href="#add_article" aria-label="Permalink to &quot;새 게시글 추가 {id=&quot;add_article&quot;}&quot;">​</a></h3><p>테이블에 새 게시글을 삽입하려면 람다 인자를 받는 <code>Table.insert</code> 함수를 사용합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>이 람다 내부에서 어떤 컬럼에 어떤 값을 설정해야 하는지 지정합니다. <code>it</code> 인자는 <code>InsertStatement</code> 타입을 가지며, 이 타입에서 컬럼과 값을 인자로 받는 <code>set</code> 연산자를 호출할 수 있습니다.</p><h3 id="edit_article" tabindex="-1">게시글 편집 <a class="header-anchor" href="#edit_article" aria-label="Permalink to &quot;게시글 편집 {id=&quot;edit_article&quot;}&quot;">​</a></h3><p>기존 게시글을 업데이트하려면 <code>Table.update</code>를 사용합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h3 id="delete_article" tabindex="-1">게시글 삭제 <a class="header-anchor" href="#delete_article" aria-label="Permalink to &quot;게시글 삭제 {id=&quot;delete_article&quot;}&quot;">​</a></h3><p>마지막으로, <code>Table.deleteWhere</code>를 사용하여 데이터베이스에서 게시글을 제거합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h3 id="init-dao-facade" tabindex="-1">DAOFacade 초기화 <a class="header-anchor" href="#init-dao-facade" aria-label="Permalink to &quot;DAOFacade 초기화 {id=&quot;init-dao-facade&quot;}&quot;">​</a></h3><p><code>DAOFacade</code> 인스턴스를 생성하고, 애플리케이션 시작 전에 데이터베이스에 삽입될 샘플 게시글을 추가해 봅시다. <code>DAOFacadeImpl.kt</code> 하단에 다음 코드를 추가합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h2 id="update_routes" tabindex="-1">라우트 업데이트 <a class="header-anchor" href="#update_routes" aria-label="Permalink to &quot;라우트 업데이트 {id=&quot;update_routes&quot;}&quot;">​</a></h2><p>이제 라우트 핸들러 내에서 구현된 데이터베이스 작업을 사용할 준비가 되었습니다. <code>plugins/Routing.kt</code> 파일을 엽니다. 모든 게시글을 표시하려면 <code>get</code> 핸들러 내에서 <code>dao.allArticles</code>를 호출합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>새 게시글을 게시하려면 <code>post</code> 내에서 <code>dao.addNewArticle</code> 함수를 호출합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>게시글을 표시하고 편집하기 위해 <code>get(&quot;{id}&quot;)</code>와 <code>get(&quot;{id}/edit&quot;)</code> 내에서 각각 <code>dao.article</code>을 사용합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>마지막으로, <code>post(&quot;{id}&quot;)</code> 핸들러로 이동하여 <code>dao.editArticle</code>을 사용하여 게시글을 업데이트하고 <code>dao.deleteArticle</code>을 사용하여 삭제합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><blockquote><p>이 튜토리얼의 최종 프로젝트는 다음에서 찾을 수 있습니다: <a href="https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/tutorial-website-interactive-persistence" target="_blank" rel="noreferrer">tutorial-website-interactive-persistence</a>.</p></blockquote><h2 id="run_app" tabindex="-1">애플리케이션 실행 <a class="header-anchor" href="#run_app" aria-label="Permalink to &quot;애플리케이션 실행 {id=&quot;run_app&quot;}&quot;">​</a></h2><p>저희 저널 애플리케이션이 예상대로 작동하는지 확인해 봅시다. <code>Application.kt</code>의 <code>fun main(...)</code> 옆에 있는 <strong>Run</strong> 버튼을 눌러 애플리케이션을 실행할 수 있습니다:</p><p><img src="'+p+'" alt="Run Server" width="706"></p><p>IntelliJ IDEA가 애플리케이션을 시작하고, 몇 초 후에 앱이 실행 중이라는 확인 메시지를 볼 수 있습니다:</p><div class="language-Bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[main] INFO  Application - Responding at http://0.0.0.0:8080</span></span></code></pre></div><p>브라우저에서 <a href="http://localhost:8080/" target="_blank" rel="noreferrer"><code>http://localhost:8080/</code></a>를 열고 게시글을 생성, 편집 및 삭제해 보세요. 게시글은 <code>build/db.mv.db</code> 파일에 저장됩니다. IntelliJ IDEA에서는 <a href="https://www.jetbrains.com/help/idea/database-tool-window.html" target="_blank" rel="noreferrer">Database 도구 창</a>에서 이 파일의 내용을 확인할 수 있습니다.</p><p><img src="'+r+'" alt="Database tool window" width="706"></p>',82))])}const A=h(b,[["render",m]]);export{f as __pageData,A as default};
