import{_ as i,c as e,o as s,ag as t}from"./chunks/framework.Bksy39di.js";const k=JSON.parse('{"title":"Kotlin 1.4.20 新特性","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/whatsnew1420.md","filePath":"kotlin/whatsnew1420.md","lastUpdated":1754307826000}'),l={name:"kotlin/whatsnew1420.md"};function n(o,a,r,p,h,d){return s(),e("div",null,a[0]||(a[0]=[t(`<h1 id="kotlin-1-4-20-新特性" tabindex="-1">Kotlin 1.4.20 新特性 <a class="header-anchor" href="#kotlin-1-4-20-新特性" aria-label="Permalink to &quot;Kotlin 1.4.20 新特性&quot;">​</a></h1><p><em><a href="/kotlin/releases#release-details">发布日期：2020 年 11 月 23 日</a></em></p><p>Kotlin 1.4.20 提供了多项新的实验性特性，并为现有特性（包括 1.4.0 中添加的特性）提供了修复和改进。</p><p>你还可以在<a href="https://blog.jetbrains.com/kotlin/2020/11/kotlin-1-4-20-released/" target="_blank" rel="noreferrer">这篇博客文章</a>中了解更多包含示例的新特性。</p><h2 id="kotlin-jvm" tabindex="-1">Kotlin/JVM <a class="header-anchor" href="#kotlin-jvm" aria-label="Permalink to &quot;Kotlin/JVM&quot;">​</a></h2><p>Kotlin/JVM 的改进旨在使其与现代 Java 版本的特性保持同步：</p><ul><li><a href="#java-15-target">Java 15 目标平台</a></li><li><a href="#invokedynamic-string-concatenation">invokedynamic 字符串连接</a></li></ul><h3 id="java-15-目标平台" tabindex="-1">Java 15 目标平台 <a class="header-anchor" href="#java-15-目标平台" aria-label="Permalink to &quot;Java 15 目标平台&quot;">​</a></h3><p>现在 Java 15 可作为 Kotlin/JVM 的目标平台。</p><h3 id="invokedynamic-字符串连接" tabindex="-1">invokedynamic 字符串连接 <a class="header-anchor" href="#invokedynamic-字符串连接" aria-label="Permalink to &quot;invokedynamic 字符串连接&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>invokedynamic</code> 字符串连接是<a href="/kotlin/components-stability">实验性的</a>。它可能随时被删除或更改。需要显式启用（详见下文）。仅用于求值目的。我们非常感谢你通过 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 提供反馈。</p></div><p>Kotlin 1.4.20 可以在 JVM 9+ 目标平台下将字符串连接编译为 <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html#invokedynamic" target="_blank" rel="noreferrer">动态调用</a>，从而提升性能。</p><p>目前，此特性是实验性的，涵盖以下情况：</p><ul><li><code>String.plus</code> 的操作符形式 (<code>a + b</code>)、显式形式 (<code>a.plus(b)</code>) 和引用形式 (<code>(a::plus)(b)</code>)。</li><li>内联类和数据类上的 <code>toString</code>。</li><li>字符串模板，但只有一个非常量实参的除外（请参阅 <a href="https://youtrack.jetbrains.com/issue/KT-42457" target="_blank" rel="noreferrer">KT-42457</a>）。</li></ul><p>要启用 <code>invokedynamic</code> 字符串连接，请添加 <code>-Xstring-concat</code> 编译器选项并选择以下值之一：</p><ul><li><code>indy-with-constants</code>：使用 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/StringConcatFactory.html#makeConcatWithConstants-java.lang.invoke.MethodHandles.Lookup-java.lang.String-java.lang.invoke.MethodType-java.lang.String-java.lang.Object...-" target="_blank" rel="noreferrer">StringConcatFactory.makeConcatWithConstants()</a> 对字符串执行 <code>invokedynamic</code> 连接。</li><li><code>indy</code>：使用 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/StringConcatFactory.html#makeConcat-java.lang.invoke.MethodHandles.Lookup-java.lang.String-java.lang.invoke.MethodType-" target="_blank" rel="noreferrer">StringConcatFactory.makeConcat()</a> 对字符串执行 <code>invokedynamic</code> 连接。</li><li><code>inline</code>：切换回通过 <code>StringBuilder.append()</code> 进行的经典连接。</li></ul><h2 id="kotlin-js" tabindex="-1">Kotlin/JS <a class="header-anchor" href="#kotlin-js" aria-label="Permalink to &quot;Kotlin/JS&quot;">​</a></h2><p>Kotlin/JS 持续快速发展，在 1.4.20 中，你可以找到多项实验性特性和改进：</p><ul><li><a href="#gradle-dsl-changes">Gradle DSL 变更</a></li><li><a href="#new-wizard-templates">新向导模板</a></li><li><a href="#ignoring-compilation-errors-with-ir-compiler">IR 编译器忽略编译错误</a></li></ul><h3 id="gradle-dsl-变更" tabindex="-1">Gradle DSL 变更 <a class="header-anchor" href="#gradle-dsl-变更" aria-label="Permalink to &quot;Gradle DSL 变更&quot;">​</a></h3><p>Kotlin/JS 的 Gradle DSL 收到多项更新，简化了项目设置和自定义。这包括 webpack 配置调整、自动生成的 <code>package.json</code> 文件修改，以及对传递性依赖项的改进控制。</p><h4 id="webpack-配置的单一入口点" tabindex="-1">webpack 配置的单一入口点 <a class="header-anchor" href="#webpack-配置的单一入口点" aria-label="Permalink to &quot;webpack 配置的单一入口点&quot;">​</a></h4><p><code>browser</code> 目标平台现在提供一个新的配置块 <code>commonWebpackConfig</code>。在其中，你可以从单一入口点调整通用设置，而无需为 <code>webpackTask</code>、<code>runTask</code> 和 <code>testTask</code> 重复配置。</p><p>要为所有三个任务默认启用 CSS 支持，请在你的项目的 <code>build.gradle(.kts)</code> 文件中添加以下代码片段：</p><div class="language-groovy vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">groovy</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">browser {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    commonWebpackConfig {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        cssSupport</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">enabled </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    binaries</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">executable()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>了解更多关于 <a href="/kotlin/js-project-setup#webpack-bundling">配置 webpack 打包</a> 的信息。</p><h4 id="通过-gradle-进行-package-json-自定义" tabindex="-1">通过 Gradle 进行 package.json 自定义 <a class="header-anchor" href="#通过-gradle-进行-package-json-自定义" aria-label="Permalink to &quot;通过 Gradle 进行 package.json 自定义&quot;">​</a></h4><p>为了更好地控制 Kotlin/JS 包管理和发布，你现在可以通过 Gradle DSL 将属性添加到项目文件 <a href="https://nodejs.dev/learn/the-package-json-guide" target="_blank" rel="noreferrer"><code>package.json</code></a> 中。</p><p>要将自定义字段添加到 <code>package.json</code>，请在编译的 <code>packageJson</code> 代码块中使用 <code>customField</code> 函数：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(BOTH) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        compilations[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">packageJson</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            customField</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mapOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;one&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> to </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;two&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> to </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>了解更多关于 <a href="/kotlin/js-project-setup#package-json-customization"><code>package.json</code> 自定义</a> 的信息。</p><h4 id="yarn-选择性依赖项解析" tabindex="-1">Yarn 选择性依赖项解析 <a class="header-anchor" href="#yarn-选择性依赖项解析" aria-label="Permalink to &quot;Yarn 选择性依赖项解析&quot;">​</a></h4><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>Yarn 选择性依赖项解析的支持是<a href="/kotlin/components-stability">实验性的</a>。它可能随时被删除或更改。仅用于求值目的。我们非常感谢你通过 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 提供反馈。</p></div><p>Kotlin 1.4.20 提供了一种配置 Yarn <a href="https://classic.yarnpkg.com/en/docs/selective-version-resolutions/" target="_blank" rel="noreferrer">选择性依赖项解析</a> 的方式——这是用于覆盖你所依赖的包的依赖项的机制。</p><p>你可以在 Gradle 中通过 <code>YarnPlugin</code> 内部的 <code>YarnRootExtension</code> 来使用它。要影响项目解析的包版本，请使用 <code>resolution</code> 函数，并传入包名选择器（由 Yarn 指定）和应解析到的版本。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rootProject.plugins.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">YarnPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rootProject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">the</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">YarnRootExtension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        resolution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;react&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;16.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        resolution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;processor/decamelize&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;3.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这里，你所有需要 <code>react</code> 的 npm 依赖项都将收到版本 <code>16.0.0</code>，而 <code>processor</code> 将收到其依赖项 <code>decamelize</code> 的版本 <code>3.0.0</code>。</p><h4 id="禁用细粒度工作空间" tabindex="-1">禁用细粒度工作空间 <a class="header-anchor" href="#禁用细粒度工作空间" aria-label="Permalink to &quot;禁用细粒度工作空间&quot;">​</a></h4><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>禁用细粒度工作空间是<a href="/kotlin/components-stability">实验性的</a>。它可能随时被删除或更改。仅用于求值目的。我们非常感谢你通过 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 提供反馈。</p></div><p>为了加快构建时间，Kotlin/JS Gradle 插件只安装特定 Gradle 任务所需的依赖项。例如，<code>webpack-dev-server</code> 包只在你执行 <code>*Run</code> 任务之一时安装，而不在执行 assemble 任务时安装。这种行为在你并行运行多个 Gradle 进程时可能会带来问题。当依赖项要求冲突时，两次 npm 包安装可能会导致错误。</p><p>为了解决这个问题，Kotlin 1.4.20 包含一个选项来禁用这些所谓的“细粒度工作空间”。此特性目前通过 Gradle 中 <code>YarnPlugin</code> 内部的 <code>YarnRootExtension</code> 提供。要使用它，请将以下代码片段添加到你的 <code>build.gradle.kts</code> 文件中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rootProject.plugins.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">YarnPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rootProject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">the</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">YarnRootExtension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disableGranularWorkspaces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="新向导模板" tabindex="-1">新向导模板 <a class="header-anchor" href="#新向导模板" aria-label="Permalink to &quot;新向导模板&quot;">​</a></h3><p>为了在项目创建过程中为你提供更便捷的自定义方式，Kotlin 的项目向导提供了新的 Kotlin/JS 应用程序模板：</p><ul><li><strong>浏览器应用程序</strong> – 一个在浏览器中运行的最小 Kotlin/JS Gradle 项目。</li><li><strong>React 应用程序</strong> – 一个使用相应 <code>kotlin-wrappers</code> 的 React 应用。它提供了启用样式表、导航组件或状态容器集成的选项。</li><li><strong>Node.js 应用程序</strong> – 一个用于在 Node.js 运行时中运行的最小项目。它附带了一个选项，可以直接包含实验性的 <code>kotlinx-nodejs</code> 包。</li></ul><h3 id="ir-编译器忽略编译错误" tabindex="-1">IR 编译器忽略编译错误 <a class="header-anchor" href="#ir-编译器忽略编译错误" aria-label="Permalink to &quot;IR 编译器忽略编译错误&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><em>忽略编译错误</em> 模式是<a href="/kotlin/components-stability">实验性的</a>。它可能随时被删除或更改。需要显式启用（详见下文）。仅用于求值目的。我们非常感谢你通过 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 提供反馈。</p></div><p>Kotlin/JS 的 <a href="/kotlin/js-ir-compiler">IR 编译器</a> 带有一个新的实验性模式——<em>带错误编译</em>。在此模式下，即使代码包含错误，你也可以运行代码，例如，当整个应用程序尚未准备好时，你希望尝试某些功能。</p><p>此模式有两种容错策略：</p><ul><li><p><code>SEMANTIC</code>：编译器将接受语法正确但语义上不合理的代码，例如 <code>val x: String = 3</code>。</p></li><li><p><code>SYNTAX</code>：编译器将接受任何代码，即使它包含语法错误。</p></li></ul><p>要允许带错误编译，请添加 <code>-Xerror-tolerance-policy=</code> 编译器选项并选择上述值之一。</p><p><a href="/kotlin/js-ir-compiler">了解更多关于 Kotlin/JS IR 编译器</a> 的信息。</p><h2 id="kotlin-native" tabindex="-1">Kotlin/Native <a class="header-anchor" href="#kotlin-native" aria-label="Permalink to &quot;Kotlin/Native&quot;">​</a></h2><p>Kotlin/Native 在 1.4.20 中的优先级是性能和完善现有特性。以下是显著改进：</p><ul><li><a href="#escape-analysis">逃逸分析</a></li><li><a href="#performance-improvements-and-bug-fixes">性能改进和 Bug 修复</a></li><li><a href="#opt-in-wrapping-of-objective-c-exceptions">Objective-C 异常的显式包装</a></li><li><a href="#cocoapods-plugin-improvements">CocoaPods 插件改进</a></li><li><a href="#support-for-xcode-12-libraries">支持 Xcode 12 库</a></li></ul><h3 id="逃逸分析" tabindex="-1">逃逸分析 <a class="header-anchor" href="#逃逸分析" aria-label="Permalink to &quot;逃逸分析&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>逃逸分析机制是<a href="/kotlin/components-stability">实验性的</a>。它可能随时被删除或更改。仅用于求值目的。我们非常感谢你通过 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 提供反馈。</p></div><p>Kotlin/Native 接收了一个新 <a href="https://en.wikipedia.org/wiki/Escape_analysis" target="_blank" rel="noreferrer">逃逸分析</a> 机制的原型。它通过在栈而不是堆上分配特定对象来提高运行时性能。此机制在我们的基准测试中显示出平均 10% 的性能提升，我们将继续改进它，以使其进一步加速程序。</p><p>逃逸分析在发布构建（使用 <code>-opt</code> 编译器选项）的单独编译阶段运行。</p><p>如果你想禁用逃逸分析阶段，请使用 <code>-Xdisable-phases=EscapeAnalysis</code> 编译器选项。</p><h3 id="性能改进和-bug-修复" tabindex="-1">性能改进和 Bug 修复 <a class="header-anchor" href="#性能改进和-bug-修复" aria-label="Permalink to &quot;性能改进和 Bug 修复&quot;">​</a></h3><p>Kotlin/Native 在各个组件中都接收到性能改进和 Bug 修复，包括 1.4.0 中添加的组件，例如<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-share-on-platforms.html#share-code-on-similar-platforms" target="_blank" rel="noreferrer">代码共享机制</a>。</p><h3 id="objective-c-异常的显式包装" tabindex="-1">Objective-C 异常的显式包装 <a class="header-anchor" href="#objective-c-异常的显式包装" aria-label="Permalink to &quot;Objective-C 异常的显式包装&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>Objective-C 异常包装机制是<a href="/kotlin/components-stability">实验性的</a>。它可能随时被删除或更改。需要显式启用（详见下文）。仅用于求值目的。我们非常感谢你通过 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 提供反馈。</p></div><p>Kotlin/Native 现在可以在运行时处理从 Objective-C 代码抛出的异常，以避免程序崩溃。</p><p>你可以选择启用将 <code>NSException</code> 包装成 <code>ForeignException</code> 类型的 Kotlin 异常。它们持有原始 <code>NSException</code> 的引用。这使你能够获取根本原因的信息并妥善处理。</p><p>要启用 Objective-C 异常的包装，请在 <code>cinterop</code> 调用中指定 <code>-Xforeign-exception-mode objc-wrap</code> 选项，或将 <code>foreignExceptionMode = objc-wrap</code> 属性添加到 <code>.def</code> 文件中。如果你使用 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-overview.html" target="_blank" rel="noreferrer">CocoaPods 集成</a>，请在依赖项的 <code>pod {}</code> 构建脚本块中指定该选项，如下所示：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    extraOpts </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xforeign-exception-mode&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;objc-wrap&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>默认行为保持不变：当从 Objective-C 代码抛出异常时，程序会终止。</p><h3 id="cocoapods-插件改进" tabindex="-1">CocoaPods 插件改进 <a class="header-anchor" href="#cocoapods-插件改进" aria-label="Permalink to &quot;CocoaPods 插件改进&quot;">​</a></h3><p>Kotlin 1.4.20 延续了 CocoaPods 集成的一系列改进。具体来说，你可以尝试以下新特性：</p><ul><li><a href="#improved-task-execution">改进的任务执行</a></li><li><a href="#extended-dsl">扩展的 DSL</a></li><li><a href="#updated-integration-with-xcode">更新的 Xcode 集成</a></li></ul><h4 id="改进的任务执行" tabindex="-1">改进的任务执行 <a class="header-anchor" href="#改进的任务执行" aria-label="Permalink to &quot;改进的任务执行&quot;">​</a></h4><p>CocoaPods 插件获得了改进的任务执行流。例如，如果你添加一个新的 CocoaPods 依赖项，现有依赖项不会重新构建。添加额外目标平台也不会影响现有依赖项的重新构建。</p><h4 id="扩展的-dsl" tabindex="-1">扩展的 DSL <a class="header-anchor" href="#扩展的-dsl" aria-label="Permalink to &quot;扩展的 DSL&quot;">​</a></h4><p>向 Kotlin 项目添加 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-overview.html" target="_blank" rel="noreferrer">CocoaPods</a> 依赖项的 DSL 获得了新功能。</p><p>除了本地 Pods 和来自 CocoaPods 版本库的 Pods，你还可以添加对以下类型库的依赖项：</p><ul><li>来自自定义 spec 版本库的库。</li><li>来自 Git 版本库的远程库。</li><li>来自归档（也可通过任意 HTTP 地址获取）的库。</li><li>静态库。</li><li>带有自定义 cinterop 选项的库。</li></ul><p>了解更多关于在 Kotlin 项目中<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-libraries.html" target="_blank" rel="noreferrer">添加 CocoaPods 依赖项</a> 的信息。在 <a href="https://github.com/Kotlin/kmm-with-cocoapods-sample" target="_blank" rel="noreferrer">Kotlin with CocoaPods 示例</a> 中查找示例。</p><h4 id="更新的-xcode-集成" tabindex="-1">更新的 Xcode 集成 <a class="header-anchor" href="#更新的-xcode-集成" aria-label="Permalink to &quot;更新的 Xcode 集成&quot;">​</a></h4><p>为了与 Xcode 正常工作，Kotlin 需要对 Podfile 进行一些更改：</p><ul><li>如果你的 Kotlin Pod 具有任何 Git、HTTP 或 specRepo Pod 依赖项，你也应该在 Podfile 中指定它。</li><li>当你从自定义 spec 添加库时，你还应该在 Podfile 的开头指定 specs 的<a href="https://guides.cocoapods.org/syntax/podfile.html#source" target="_blank" rel="noreferrer">位置</a>。</li></ul><p>现在集成错误在 IDEA 中有详细的描述。因此，如果你的 Podfile 出现问题，你将立即知道如何修复它们。</p><p>了解更多关于<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-xcode.html" target="_blank" rel="noreferrer">创建 Kotlin Pods</a> 的信息。</p><h3 id="支持-xcode-12-库" tabindex="-1">支持 Xcode 12 库 <a class="header-anchor" href="#支持-xcode-12-库" aria-label="Permalink to &quot;支持 Xcode 12 库&quot;">​</a></h3><p>我们增加了对 Xcode 12 随附的新库的支持。现在你可以从 Kotlin 代码中使用它们。</p><h2 id="kotlin-多平台" tabindex="-1">Kotlin 多平台 <a class="header-anchor" href="#kotlin-多平台" aria-label="Permalink to &quot;Kotlin 多平台&quot;">​</a></h2><h3 id="更新的多平台库发布结构" tabindex="-1">更新的多平台库发布结构 <a class="header-anchor" href="#更新的多平台库发布结构" aria-label="Permalink to &quot;更新的多平台库发布结构&quot;">​</a></h3><p>从 Kotlin 1.4.20 开始，不再有单独的元数据发布。元数据 artifact 现在包含在_根_发布中，根发布代表整个库，当作为依赖项添加到公共源代码集时，会自动解析为相应的平台特有 artifact。</p><p>了解更多关于<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-publish-lib-setup.html" target="_blank" rel="noreferrer">发布多平台库</a> 的信息。</p><h4 id="与早期版本的兼容性" tabindex="-1">与早期版本的兼容性 <a class="header-anchor" href="#与早期版本的兼容性" aria-label="Permalink to &quot;与早期版本的兼容性&quot;">​</a></h4><p>这种结构变化破坏了具有<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-share-on-platforms.html#share-code-on-similar-platforms" target="_blank" rel="noreferrer">分层项目结构</a> 的项目之间的兼容性。如果一个多平台项目及其所依赖的库都具有分层项目结构，那么你需要将它们同时更新到 Kotlin 1.4.20 或更高版本。使用 Kotlin 1.4.20 发布的库无法用于更早版本发布的项目。</p><p>没有分层项目结构的项目和库保持兼容。</p><h2 id="标准库" tabindex="-1">标准库 <a class="header-anchor" href="#标准库" aria-label="Permalink to &quot;标准库&quot;">​</a></h2><p>Kotlin 1.4.20 的标准库提供了用于处理文件的新扩展和更好的性能。</p><ul><li><a href="#extensions-for-java-nio-file-path"><code>java.nio.file.Path</code> 的扩展</a></li><li><a href="#improved-string-replace-function-performance"><code>String.replace</code> 函数性能改进</a></li></ul><h3 id="java-nio-file-path-的扩展" tabindex="-1"><code>java.nio.file.Path</code> 的扩展 <a class="header-anchor" href="#java-nio-file-path-的扩展" aria-label="Permalink to &quot;\`java.nio.file.Path\` 的扩展&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>java.nio.file.Path</code> 的扩展是<a href="/kotlin/components-stability">实验性的</a>。它们可能随时被删除或更改。需要显式启用（详见下文）。仅用于求值目的。我们非常感谢你通过 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 提供反馈。</p></div><p>现在标准库为 <code>java.nio.file.Path</code> 提供了实验性扩展。以惯用的 Kotlin 方式使用现代 JVM 文件 API 现在类似于使用 <code>kotlin.io</code> 包中的 <code>java.io.File</code> 扩展。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// construct path with the div (/) operator</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> baseDir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/base&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> subDir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> baseDir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;subdirectory&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// list files in a directory</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlinFiles: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/home/user&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listDirectoryEntries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;*.kt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>这些扩展在 <code>kotlin-stdlib-jdk7</code> 模块的 <code>kotlin.io.path</code> 包中提供。要使用这些扩展，请<a href="/kotlin/opt-in-requirements">显式启用</a> 实验性注解 <code>@ExperimentalPathApi</code>。</p><h3 id="string-replace-函数性能改进" tabindex="-1"><code>String.replace</code> 函数性能改进 <a class="header-anchor" href="#string-replace-函数性能改进" aria-label="Permalink to &quot;\`String.replace\` 函数性能改进&quot;">​</a></h3><p><code>String.replace()</code> 的新实现加速了函数执行。区分大小写的变体使用基于 <code>indexOf</code> 的手动替换循环，而不区分大小写的变体则使用正则表达式匹配。</p><h2 id="kotlin-android-extensions" tabindex="-1">Kotlin Android Extensions <a class="header-anchor" href="#kotlin-android-extensions" aria-label="Permalink to &quot;Kotlin Android Extensions&quot;">​</a></h2><p>在 1.4.20 中，Kotlin Android Extensions 插件被废弃，<code>Parcelable</code> 实现生成器移至单独的插件。</p><ul><li><a href="#deprecation-of-synthetic-views">废弃合成视图</a></li><li><a href="#new-plugin-for-parcelable-implementation-generator"><code>Parcelable</code> 实现生成器的新插件</a></li></ul><h3 id="废弃合成视图" tabindex="-1">废弃合成视图 <a class="header-anchor" href="#废弃合成视图" aria-label="Permalink to &quot;废弃合成视图&quot;">​</a></h3><p><em>合成视图</em> 是 Kotlin Android Extensions 插件在一段时间前引入的，旨在简化与 UI 元素的交互并减少样板代码。现在 Google 提供了一种实现相同功能的原生机制——Android Jetpack 的<a href="https://developer.android.com/topic/libraries/view-binding" target="_blank" rel="noreferrer">视图绑定</a>，我们正在废弃合成视图以支持后者。</p><p>我们将 <code>Parcelable</code> 实现生成器从 <code>kotlin-android-extensions</code> 中提取出来，并开始对其余部分（合成视图）的废弃周期。目前，它们仍会带着废弃警告继续工作。将来，你需要将项目切换到其他解决方案。以下是<a href="https://goo.gle/kotlin-android-extensions-deprecation" target="_blank" rel="noreferrer">指南</a>，它将帮助你将 Android 项目从合成视图迁移到视图绑定。</p><h3 id="parcelable-实现生成器的新插件" tabindex="-1"><code>Parcelable</code> 实现生成器的新插件 <a class="header-anchor" href="#parcelable-实现生成器的新插件" aria-label="Permalink to &quot;\`Parcelable\` 实现生成器的新插件&quot;">​</a></h3><p><code>Parcelable</code> 实现生成器现在在新的 <code>kotlin-parcelize</code> 插件中可用。请应用此插件而非 <code>kotlin-android-extensions</code>。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p><code>kotlin-parcelize</code> 和 <code>kotlin-android-extensions</code> 不能在同一模块中同时应用。</p></div><p><code>@Parcelize</code> 注解已移至 <code>kotlinx.parcelize</code> 包。</p><p>了解更多关于 <code>Parcelable</code> 实现生成器在 <a href="https://developer.android.com/kotlin/parcelize" target="_blank" rel="noreferrer">Android 文档</a> 中的信息。</p>`,114)]))}const E=i(l,[["render",n]]);export{k as __pageData,E as default};
