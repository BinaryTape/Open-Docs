import{_ as k,C as e,c as d,o,ag as h,j as s,G as t,a as i,w as n}from"./chunks/framework.Bksy39di.js";const v=JSON.parse('{"title":"Kotlin에서 Java 호출하기","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/java-interop.md","filePath":"ko/kotlin/java-interop.md","lastUpdated":1754307826000}'),r={name:"ko/kotlin/java-interop.md"};function E(c,a,g,y,u,F){const l=e("tab"),p=e("tabs");return o(),d("div",null,[a[2]||(a[2]=h(`<h1 id="kotlin에서-java-호출하기" tabindex="-1">Kotlin에서 Java 호출하기 <a class="header-anchor" href="#kotlin에서-java-호출하기" aria-label="Permalink to &quot;Kotlin에서 Java 호출하기&quot;">​</a></h1><p>Kotlin은 Java와의 상호 운용성을 염두에 두고 설계되었습니다. 기존 Java 코드는 Kotlin에서 자연스럽게 호출될 수 있으며, Kotlin 코드 역시 Java에서 상당히 원활하게 사용될 수 있습니다. 이 섹션에서는 Kotlin에서 Java 코드를 호출하는 것에 대한 몇 가지 세부 정보를 설명합니다.</p><p>거의 모든 Java 코드는 문제 없이 사용될 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> java.util.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> demo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(source: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // &#39;for&#39; 루프는 Java 컬렉션에서도 작동합니다:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 연산자 규칙도 작동합니다:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">source.size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        list[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source[i] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// get 및 set이 호출됩니다</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="게터-getters-및-세터-setters" tabindex="-1">게터(Getters) 및 세터(Setters) <a class="header-anchor" href="#게터-getters-및-세터-setters" aria-label="Permalink to &quot;게터(Getters) 및 세터(Setters)&quot;">​</a></h2><p>게터 및 세터에 대한 Java 규칙(이름이 <code>get</code>으로 시작하는 인자 없는 메서드와 이름이 <code>set</code>으로 시작하는 단일 인자 메서드)을 따르는 메서드는 Kotlin에서 프로퍼티로 표현됩니다. 이러한 프로퍼티는 _합성 프로퍼티(synthetic properties)_라고도 불립니다. <code>Boolean</code> 접근자 메서드(게터의 이름이 <code>is</code>로 시작하고 세터의 이름이 <code>set</code>으로 시작하는 경우)는 게터 메서드와 동일한 이름을 가진 프로퍼티로 표현됩니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> java.util.Calendar</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> calendarDemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> calendar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Calendar.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (calendar.firstDayOfWeek </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Calendar.SUNDAY) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// getFirstDayOfWeek() 호출</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        calendar.firstDayOfWeek </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Calendar.MONDAY </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// setFirstDayOfWeek() 호출</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">calendar.isLenient) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// isLenient() 호출</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        calendar.isLenient </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // setLenient() 호출</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>위의 <code>calendar.firstDayOfWeek</code>는 합성 프로퍼티의 예시입니다.</p><p>Java 클래스에 세터만 있는 경우, Kotlin은 set-only 프로퍼티를 지원하지 않으므로 Kotlin에서는 프로퍼티로 보이지 않습니다.</p><h2 id="java-합성-프로퍼티-참조" tabindex="-1">Java 합성 프로퍼티 참조 <a class="header-anchor" href="#java-합성-프로퍼티-참조" aria-label="Permalink to &quot;Java 합성 프로퍼티 참조&quot;">​</a></h2><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>이 기능은 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적(Experimental)</a>입니다. 언제든지 삭제되거나 변경될 수 있습니다. 평가 목적으로만 사용하는 것을 권장합니다.</p></div><p>Kotlin 1.8.20부터 Java 합성 프로퍼티에 대한 참조를 생성할 수 있습니다. 다음 Java 코드를 고려하십시오:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String name;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getAge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Kotlin은 항상 <code>person.age</code>를 작성할 수 있도록 허용했으며, 여기서 <code>age</code>는 합성 프로퍼티입니다. 이제 <code>Person::age</code> 및 <code>person::age</code>에 대한 참조도 생성할 수 있습니다. <code>name</code>에도 동일하게 적용됩니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> persons </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Jack&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Sofie&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Peter&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    persons</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // Java 합성 프로퍼티에 대한 참조 호출:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sortedBy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Person::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // Kotlin 프로퍼티 문법을 통해 Java getter 호출:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person.name) }</span></span></code></pre></div>`,15)),a[3]||(a[3]=s("h3",{"initial-collapse-state":"collapsed",collapsible:"true",id:"java-합성-프로퍼티-참조를-활성화하는-방법",tabindex:"-1"},[i("Java 합성 프로퍼티 참조를 활성화하는 방법 "),s("a",{class:"header-anchor",href:"#java-합성-프로퍼티-참조를-활성화하는-방법","aria-label":'Permalink to "Java 합성 프로퍼티 참조를 활성화하는 방법 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),a[4]||(a[4]=s("p",null,[i("이 기능을 활성화하려면 "),s("code",null,"-language-version 2.1"),i(" 컴파일러 옵션을 설정하십시오. Gradle 프로젝트에서는 "),s("code",null,"build.gradle(.kts)"),i("에 다음을 추가하여 설정할 수 있습니다:")],-1)),t(p,{group:"build-script"},{default:n(()=>[t(l,{title:"Kotlin","group-key":"kotlin"},{default:n(()=>a[0]||(a[0]=[s("div",{class:"language-kotlin vp-adaptive-theme"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"kotlin"),s("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"tasks")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    ."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"withType"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"org"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"jetbrains"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"gradle"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"tasks"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"KotlinCompilationTask"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<*>>()")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    ."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"configureEach"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        compilerOptions")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            .languageVersion")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            ."),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"set"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"                org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_2_1")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            )")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")])])])],-1)])),_:1}),t(l,{title:"Groovy","group-key":"groovy"},{default:n(()=>a[1]||(a[1]=[s("div",{class:"language-groovy vp-adaptive-theme"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"groovy"),s("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"tasks")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    .withType("),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"org.jetbrains.kotlin.gradle.tasks.KotlinCompilationTask."),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"class)")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    .configureEach {")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        compilerOptions"),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"languageVersion")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"            ="),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}}," org.jetbrains.kotlin.gradle.dsl.KotlinVersion."),s("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"KOTLIN_2_1")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),a[5]||(a[5]=h(`<div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Kotlin 1.9.0 이전에는 이 기능을 활성화하려면 <code>-language-version 1.9</code> 컴파일러 옵션을 설정해야 했습니다.</p></div><h2 id="void를-반환하는-메서드" tabindex="-1">void를 반환하는 메서드 <a class="header-anchor" href="#void를-반환하는-메서드" aria-label="Permalink to &quot;void를 반환하는 메서드&quot;">​</a></h2><p>Java 메서드가 <code>void</code>를 반환하면 Kotlin에서 호출될 때 <code>Unit</code>을 반환합니다. 만약 누군가가 그 반환 값을 사용한다면, 값 자체가 미리 알려져 있기 때문에 (즉 <code>Unit</code>) Kotlin 컴파일러에 의해 호출 지점에서 할당될 것입니다.</p><h2 id="kotlin에서-키워드인-java-식별자-이스케이프" tabindex="-1">Kotlin에서 키워드인 Java 식별자 이스케이프 <a class="header-anchor" href="#kotlin에서-키워드인-java-식별자-이스케이프" aria-label="Permalink to &quot;Kotlin에서 키워드인 Java 식별자 이스케이프&quot;">​</a></h2><p>일부 Kotlin 키워드는 Java에서 유효한 식별자입니다: <code>in</code>, <code>object</code>, <code>is</code> 등. Java 라이브러리가 Kotlin 키워드를 메서드에 사용하는 경우, 백틱(\`) 문자로 이스케이프하여 메서드를 계속 호출할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">\`is\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bar)</span></span></code></pre></div><h2 id="널-안정성-및-플랫폼-타입" tabindex="-1">널 안정성 및 플랫폼 타입 <a class="header-anchor" href="#널-안정성-및-플랫폼-타입" aria-label="Permalink to &quot;널 안정성 및 플랫폼 타입&quot;">​</a></h2><p>Java의 모든 참조는 <code>null</code>일 수 있으며, 이로 인해 Java에서 오는 객체에 대해 Kotlin의 엄격한 널 안정성 요구 사항이 비현실적입니다. Java 선언의 타입은 Kotlin에서 특별한 방식으로 처리되며 <em>플랫폼 타입</em>이라고 불립니다. 이러한 타입에 대해서는 널 검사가 완화되어, 안전성 보장이 Java와 동일합니다 (자세한 내용은 <a href="#mapped-types">아래</a> 참조).</p><p>다음 예시를 고려하십시오:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// non-null (생성자 결과)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Item&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list.size </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// non-null (기본형 int)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 플랫폼 타입 추론됨 (일반 Java 객체)</span></span></code></pre></div><p>플랫폼 타입 변수에 대해 메서드를 호출할 때, Kotlin은 컴파일 시점에 널 가능성 오류를 발생시키지 않지만, 널 포인터 예외 또는 널이 전파되는 것을 방지하기 위해 Kotlin이 생성하는 어설션(assertion) 때문에 런타임에 호출이 실패할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">item.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">substring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 허용됨, item == null이면 예외 발생</span></span></code></pre></div><p>플랫폼 타입은 *표현 불가능(non-denotable)*하며, 언어에서 명시적으로 작성할 수 없음을 의미합니다. 플랫폼 값이 Kotlin 변수에 할당될 때, 타입 추론에 의존하거나 (<code>item</code>이 위 예시에서 그랬던 것처럼 변수가 추론된 플랫폼 타입을 가지게 됨), 기대하는 타입을 선택할 수 있습니다 (널 허용 및 널 불허 타입 모두 허용됨):</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nullable: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 허용됨, 항상 작동함</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> notNull: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 허용됨, 런타임에 실패할 수 있음</span></span></code></pre></div><p>널 불허 타입을 선택하면 컴파일러가 할당 시 어설션을 발생시킵니다. 이는 Kotlin의 널 불허 변수가 널을 가지는 것을 방지합니다. 어설션은 플랫폼 값을 널 불허 값을 예상하는 Kotlin 함수에 전달할 때와 다른 경우에도 발생합니다. 전반적으로 컴파일러는 널이 프로그램 전체에 멀리 전파되는 것을 방지하기 위해 최선을 다하지만, 제네릭(generics) 때문에 때로는 이를 완전히 제거하는 것이 불가능할 수도 있습니다.</p><h3 id="플랫폼-타입-표기법" tabindex="-1">플랫폼 타입 표기법 <a class="header-anchor" href="#플랫폼-타입-표기법" aria-label="Permalink to &quot;플랫폼 타입 표기법&quot;">​</a></h3><p>위에서 언급했듯이, 플랫폼 타입은 프로그램에서 명시적으로 언급될 수 없으므로, 언어에 대한 문법이 없습니다. 그럼에도 불구하고, 컴파일러와 IDE는 때때로 이를 표시해야 하므로 (예: 오류 메시지 또는 매개변수 정보), 이에 대한 니모닉(mnemonic) 표기법이 있습니다:</p><ul><li><code>T!</code>는 &quot;<code>T</code> 또는 <code>T?</code>&quot;를 의미합니다.</li><li><code>(Mutable)Collection&lt;T&gt;!</code>는 &quot;Java 컬렉션 <code>T</code>가 가변(mutable)일 수도 있고 아닐 수도 있으며, 널 허용(nullable)일 수도 있고 아닐 수도 있다&quot;를 의미합니다.</li><li><code>Array&lt;(out) T&gt;!</code>는 &quot;Java 배열 <code>T</code> (또는 <code>T</code>의 서브타입), 널 허용일 수도 있고 아닐 수도 있다&quot;를 의미합니다.</li></ul><h3 id="널-가능성-어노테이션" tabindex="-1">널 가능성 어노테이션 <a class="header-anchor" href="#널-가능성-어노테이션" aria-label="Permalink to &quot;널 가능성 어노테이션&quot;">​</a></h3><p>널 가능성 어노테이션이 있는 Java 타입은 플랫폼 타입이 아닌 실제 널 허용 또는 널 불허 Kotlin 타입으로 표현됩니다. 컴파일러는 다음을 포함하여 여러 종류의 널 가능성 어노테이션을 지원합니다:</p><ul><li><a href="https://www.jetbrains.com/idea/help/nullable-and-notnull-annotations.html" target="_blank" rel="noreferrer">JetBrains</a> (<code>org.jetbrains.annotations</code> 패키지의 <code>@Nullable</code> 및 <code>@NotNull</code>)</li><li><a href="https://jspecify.dev/" target="_blank" rel="noreferrer">JSpecify</a> (<code>org.jspecify.annotations</code>)</li><li>Android (<code>com.android.annotations</code> 및 <code>android.support.annotations</code>)</li><li>JSR-305 (<code>javax.annotation</code>, 자세한 내용은 아래 참조)</li><li>FindBugs (<code>edu.umd.cs.findbugs.annotations</code>)</li><li>Eclipse (<code>org.eclipse.jdt.annotation</code>)</li><li>Lombok (<code>lombok.NonNull</code>)</li><li>RxJava 3 (<code>io.reactivex.rxjava3.annotations</code>)</li></ul><p>특정 타입의 널 가능성 어노테이션 정보에 따라 컴파일러가 널 가능성 불일치를 보고하는지 여부를 지정할 수 있습니다. 컴파일러 옵션 <code>-Xnullability-annotations=@&lt;package-name&gt;:&lt;report-level&gt;</code>을 사용하십시오. 인자에는 완전한 정규화된 널 가능성 어노테이션 패키지와 다음 보고 수준 중 하나를 지정하십시오:</p><ul><li><code>ignore</code>: 널 가능성 불일치를 무시합니다.</li><li><code>warn</code>: 경고를 보고합니다.</li><li><code>strict</code>: 오류를 보고합니다.</li></ul><p>지원되는 널 가능성 어노테션 전체 목록은 <a href="https://github.com/JetBrains/kotlin/blob/master/core/compiler.common.jvm/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt" target="_blank" rel="noreferrer">Kotlin 컴파일러 소스 코드</a>에서 확인할 수 있습니다.</p><h3 id="타입-인자와-타입-매개변수-어노테이션" tabindex="-1">타입 인자와 타입 매개변수 어노테이션 <a class="header-anchor" href="#타입-인자와-타입-매개변수-어노테이션" aria-label="Permalink to &quot;타입 인자와 타입 매개변수 어노테이션&quot;">​</a></h3><p>제네릭 타입의 타입 인자와 타입 매개변수에도 널 가능성 정보를 제공하기 위해 어노테이션을 달 수 있습니다.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>이 섹션의 모든 예제는 <code>org.jetbrains.annotations</code> 패키지의 JetBrains 널 가능성 어노테이션을 사용합니다.</p></div><h4 id="타입-인자" tabindex="-1">타입 인자 <a class="header-anchor" href="#타입-인자" aria-label="Permalink to &quot;타입 인자&quot;">​</a></h4><p>다음 Java 선언의 어노테이션을 고려하십시오:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Set</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Collection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elements) { ... }</span></span></code></pre></div><p>이는 Kotlin에서 다음과 같은 시그니처를 초래합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mutable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Collection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) : (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mutable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span></code></pre></div><p>타입 인자에서 <code>@NotNull</code> 어노테이션이 누락되면 대신 플랫폼 타입을 얻게 됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mutable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Collection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">!&gt;) : (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mutable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">!&gt; { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span></code></pre></div><p>Kotlin은 또한 기본 클래스와 인터페이스의 타입 인자에 대한 널 가능성 어노테이션을 고려합니다. 예를 들어, 아래에 제공된 시그니처를 가진 두 개의 Java 클래스가 있습니다:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Derived</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nullable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p>Kotlin 코드에서 <code>Base&lt;String&gt;</code>이 가정되는 곳에 <code>Derived</code> 인스턴스를 전달하면 경고가 발생합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> takeBaseOfNotNullStrings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    takeBaseOfNotNullStrings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Derived</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// warning: nullability mismatch</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>Derived</code>의 상위 바운드(upper bound)는 <code>Base&lt;String?&gt;</code>으로 설정되며, 이는 <code>Base&lt;String&gt;</code>과 다릅니다.</p><p>Kotlin의 <a href="#java-generics-in-kotlin">Java 제네릭</a>에 대해 자세히 알아보십시오.</p><h4 id="타입-매개변수" tabindex="-1">타입 매개변수 <a class="header-anchor" href="#타입-매개변수" aria-label="Permalink to &quot;타입 매개변수&quot;">​</a></h4><p>기본적으로 Kotlin과 Java 모두에서 일반 타입 매개변수의 널 가능성은 정의되지 않습니다. Java에서는 널 가능성 어노테이션을 사용하여 이를 지정할 수 있습니다. <code>Base</code> 클래스의 타입 매개변수에 어노테이션을 달아 봅시다:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p><code>Base</code>를 상속할 때 Kotlin은 널 불허 타입 인자 또는 타입 매개변수를 예상합니다. 따라서 다음 Kotlin 코드는 경고를 발생시킵니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Derived</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// warning: K has undefined nullability</span></span></code></pre></div><p>상위 바운드 <code>K : Any</code>를 지정하여 이를 수정할 수 있습니다.</p><p>Kotlin은 또한 Java 타입 매개변수의 바운드에 대한 널 가능성 어노테이션을 지원합니다. <code>Base</code>에 바운드를 추가해 봅시다:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BaseWithBound</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNull</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p>Kotlin은 이를 다음과 같이 번역합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BaseWithBound</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {}</span></span></code></pre></div><p>따라서 널 허용 타입을 타입 인자 또는 타입 매개변수로 전달하면 경고가 발생합니다.</p><p>타입 인자 및 타입 매개변수 어노테이션은 Java 8 이상에서 작동합니다. 이 기능은 널 가능성 어노테이션이 <code>TYPE_USE</code> 타겟을 지원해야 합니다 (<code>org.jetbrains.annotations</code>는 버전 15 이상에서 이를 지원합니다).</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>널 가능성 어노테이션이 <code>TYPE_USE</code> 타겟 외에도 타입에 적용 가능한 다른 타겟을 지원하는 경우, <code>TYPE_USE</code>가 우선 순위를 가집니다. 예를 들어, <code>@Nullable</code>이 <code>TYPE_USE</code>와 <code>METHOD</code> 타겟을 모두 가지고 있다면, Java 메서드 시그니처 <code>@Nullable String[] f()</code>는 Kotlin에서 <code>fun f(): Array&lt;String?&gt;!</code>가 됩니다.</p></div><h3 id="jsr-305-지원" tabindex="-1">JSR-305 지원 <a class="header-anchor" href="#jsr-305-지원" aria-label="Permalink to &quot;JSR-305 지원&quot;">​</a></h3><p><a href="https://jcp.org/en/jsr/detail?id=305" target="_blank" rel="noreferrer">JSR-305</a>에 정의된 <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/Nonnull.html" target="_blank" rel="noreferrer"><code>@Nonnull</code></a> 어노테이션은 Java 타입의 널 가능성을 나타내는 데 지원됩니다.</p><p><code>@Nonnull(when = ...)</code> 값이 <code>When.ALWAYS</code>인 경우 어노테이션된 타입은 널 불허로 처리됩니다. <code>When.MAYBE</code> 및 <code>When.NEVER</code>는 널 허용 타입을 나타내며, <code>When.UNKNOWN</code>은 타입을 <a href="#null-safety-and-platform-types">플랫폼 타입</a>으로 강제합니다.</p><p>라이브러리는 JSR-305 어노테이션에 대해 컴파일될 수 있지만, 어노테이션 아티팩트(예: <code>jsr305.jar</code>)를 라이브러리 소비자를 위한 컴파일 종속성으로 만들 필요는 없습니다. Kotlin 컴파일러는 클래스패스에 어노테이션이 없어도 라이브러리에서 JSR-305 어노테이션을 읽을 수 있습니다.</p><p><a href="https://github.com/Kotlin/KEEP/blob/master/proposals/jsr-305-custom-nullability-qualifiers.md" target="_blank" rel="noreferrer">사용자 정의 널 가능성 한정자 (KEEP-79)</a>도 지원됩니다 (아래 참조).</p><h4 id="타입-한정자-별칭" tabindex="-1">타입 한정자 별칭 <a class="header-anchor" href="#타입-한정자-별칭" aria-label="Permalink to &quot;타입 한정자 별칭&quot;">​</a></h4><p>어노테이션 타입이 <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/meta/TypeQualifierNickname.html" target="_blank" rel="noreferrer"><code>@TypeQualifierNickname</code></a>과 JSR-305 <code>@Nonnull</code>(또는 <code>@CheckForNull</code>과 같은 다른 별칭)으로 모두 어노테이션된 경우, 해당 어노테이션 타입 자체는 정확한 널 가능성을 검색하는 데 사용되며 해당 널 가능성 어노테이션과 동일한 의미를 가집니다:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierNickname</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">when</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> When.ALWAYS)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Retention</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RetentionPolicy.RUNTIME)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> MyNonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierNickname</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CheckForNull</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 다른 타입 한정자 별칭에 대한 별칭</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Retention</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RetentionPolicy.RUNTIME)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> MyNullable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">MyNullable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">MyNonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Kotlin에서 (strict 모드): \`fun foo(x: String): String?\`</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(List&lt;@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">MyNonnull</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Kotlin에서 (strict 모드): \`fun bar(x: List&lt;String&gt;!): String!\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="타입-한정자-기본값" tabindex="-1">타입 한정자 기본값 <a class="header-anchor" href="#타입-한정자-기본값" aria-label="Permalink to &quot;타입 한정자 기본값&quot;">​</a></h4><p><a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/meta/TypeQualifierDefault.html" target="_blank" rel="noreferrer"><code>@TypeQualifierDefault</code></a>를 사용하면 어노테이션이 적용될 때 어노테이션된 요소의 범위 내에서 기본 널 가능성을 정의하는 어노테이션을 도입할 수 있습니다.</p><p>이러한 어노테이션 타입 자체는 <code>@Nonnull</code>(또는 해당 별칭)과 하나 이상의 <code>ElementType</code> 값을 가진 <code>@TypeQualifierDefault(...)</code>로 어노테이션되어야 합니다:</p><ul><li><code>ElementType.METHOD</code>: 메서드의 반환 타입용</li><li><code>ElementType.PARAMETER</code>: 값 매개변수용</li><li><code>ElementType.FIELD</code>: 필드용</li><li><code>ElementType.TYPE_USE</code>: 타입 인자, 타입 매개변수의 상위 바운드 및 와일드카드 타입을 포함한 모든 타입용</li></ul><p>기본 널 가능성은 타입 자체에 널 가능성 어노테이션이 어노테이션되어 있지 않고, 기본값이 타입 사용법과 일치하는 <code>ElementType</code>를 가진 타입 한정자 기본값 어노테이션으로 어노테이션된 가장 안쪽의 둘러싸는 요소에 의해 결정될 때 사용됩니다.</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ElementType.METHOD, ElementType.PARAMETER})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NonNullApi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">when</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> When.MAYBE)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE_USE})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NullableApi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NullableApi</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fun foo(x: String?): String?</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotNullApi</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 인터페이스의 기본값 오버라이드</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nullable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fun bar(x: String, y: String?): String</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // \`@NullableApi\`가 \`TYPE_USE\` 요소 타입을 가지고 있기 때문에 \`List&lt;String&gt;\` 타입 인수는 nullable로 간주됨:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">baz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fun baz(List&lt;String?&gt;?): String?</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 명시적으로 UNKNOWN으로 표시된 nullability 어노테이션이 있기 때문에 \`x\` 매개변수의 타입은 플랫폼 타입으로 유지됨:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">qux</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">when</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> When.UNKNOWN) String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fun baz(x: String!): String?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>이 예시의 타입은 strict 모드가 활성화된 경우에만 적용됩니다. 그렇지 않으면 플랫폼 타입으로 유지됩니다. <a href="#undermigration-annotation"><code>@UnderMigration</code> 어노테이션</a> 및 <a href="#compiler-configuration">컴파일러 구성</a> 섹션을 참조하십시오.</p></div><p>패키지 수준의 기본 널 가능성도 지원됩니다:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// FILE: test/package-info.java</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NonNullApi</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // &#39;test&#39; 패키지의 모든 타입을 기본적으로 non-nullable로 선언</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test;</span></span></code></pre></div><h4 id="undermigration-어노테이션" tabindex="-1">@UnderMigration 어노테이션 <a class="header-anchor" href="#undermigration-어노테이션" aria-label="Permalink to &quot;@UnderMigration 어노테이션&quot;">​</a></h4><p><code>@UnderMigration</code> 어노테이션(<code>kotlin-annotations-jvm</code> 별도 아티팩트에서 제공됨)은 라이브러리 유지보수자가 널 가능성 타입 한정자에 대한 마이그레이션 상태를 정의하는 데 사용할 수 있습니다.</p><p><code>@UnderMigration(status = ...)</code>의 상태 값은 컴파일러가 Kotlin에서 어노테이션된 타입의 부적절한 사용(예: <code>@MyNullable</code> 어노테이션이 달린 타입 값을 non-null로 사용)을 어떻게 처리하는지 지정합니다:</p><ul><li><code>MigrationStatus.STRICT</code>: 어노테이션이 일반 널 가능성 어노테이션처럼 작동합니다. 즉, 부적절한 사용에 대해 오류를 보고하고 어노테이션된 선언의 타입이 Kotlin에서 보이는 방식에 영향을 줍니다.</li><li><code>MigrationStatus.WARN</code>: 부적절한 사용이 오류 대신 컴파일 경고로 보고되지만, 어노테이션된 선언의 타입은 플랫폼 타입으로 유지됩니다.</li><li><code>MigrationStatus.IGNORE</code>: 컴파일러가 널 가능성 어노테이션을 완전히 무시하도록 합니다.</li></ul><p>라이브러리 유지보수자는 <code>@UnderMigration</code> 상태를 타입 한정자 별칭과 타입 한정자 기본값 모두에 추가할 수 있습니다:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Nonnull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">when</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> When.ALWAYS)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TypeQualifierDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ElementType.METHOD, ElementType.PARAMETER})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UnderMigration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">status</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MigrationStatus.WARN)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NonNullApi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 클래스 내 타입은 non-nullable이지만, \`@NonNullApi\`가 \`@UnderMigration(status = MigrationStatus.WARN)\`으로 어노테이션되어 있어 경고만 보고됨</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NonNullApi</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>널 가능성 어노테이션의 마이그레이션 상태는 해당 타입 한정자 별칭에 의해 상속되지 않지만, 기본 타입 한정자에서 사용될 때 적용됩니다.</p></div><p>기본 타입 한정자가 타입 한정자 별칭을 사용하고 둘 다 <code>@UnderMigration</code>인 경우, 기본 타입 한정자의 상태가 사용됩니다.</p><h4 id="컴파일러-구성" tabindex="-1">컴파일러 구성 <a class="header-anchor" href="#컴파일러-구성" aria-label="Permalink to &quot;컴파일러 구성&quot;">​</a></h4><p>JSR-305 검사는 다음 옵션(및 조합)과 함께 <code>-Xjsr305</code> 컴파일러 플래그를 추가하여 구성할 수 있습니다:</p><ul><li><p><code>-Xjsr305={strict|warn|ignore}</code>: <code>@UnderMigration</code> 어노테이션이 없는 경우의 동작을 설정합니다. 사용자 정의 널 가능성 한정자, 특히 <code>@TypeQualifierDefault</code>는 이미 많은 잘 알려진 라이브러리에서 확산되어 있으며, 사용자는 JSR-305 지원을 포함하는 Kotlin 버전으로 업데이트할 때 원활하게 마이그레이션해야 할 수 있습니다. Kotlin 1.1.60부터 이 플래그는 <code>@UnderMigration</code> 어노테이션이 없는 경우에만 영향을 줍니다.</p></li><li><p><code>-Xjsr305=under-migration:{strict|warn|ignore}</code>: <code>@UnderMigration</code> 어노테이션의 동작을 오버라이드합니다. 사용자는 라이브러리의 마이그레이션 상태에 대해 다른 관점을 가질 수 있습니다. 공식 마이그레이션 상태가 <code>WARN</code>일 때 오류를 원하거나, 반대로 마이그레이션 완료 전까지 일부 오류 보고를 연기하고 싶을 수도 있습니다.</p></li><li><p><code>-Xjsr305=@&lt;fq.name&gt;:{strict|warn|ignore}</code>: 단일 어노테이션의 동작을 오버라이드합니다. 여기서 <code>&lt;fq.name&gt;</code>은 어노테이션의 완전 정규화된 클래스 이름입니다. 여러 어노테이션에 대해 여러 번 나타날 수 있습니다. 이는 특정 라이브러리의 마이그레이션 상태를 관리하는 데 유용합니다.</p></li></ul><p><code>strict</code>, <code>warn</code>, <code>ignore</code> 값은 <code>MigrationStatus</code>와 동일한 의미를 가지며, <code>strict</code> 모드만이 어노테이션된 선언의 타입이 Kotlin에서 보이는 방식에 영향을 줍니다.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>참고: 내장 JSR-305 어노테이션인 <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/Nonnull.html" target="_blank" rel="noreferrer"><code>@Nonnull</code></a>, <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/3.0.1/javax/annotation/Nullable.html" target="_blank" rel="noreferrer"><code>@Nullable</code></a> 및 <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/CheckForNull.html" target="_blank" rel="noreferrer"><code>@CheckForNull</code></a>은 항상 활성화되어 있으며 <code>-Xjsr305</code> 플래그를 사용한 컴파일러 구성과 관계없이 Kotlin에서 어노테이션된 선언의 타입에 영향을 줍니다.</p></div><p>예를 들어, 컴파일러 인수에 <code>-Xjsr305=ignore -Xjsr305=under-migration:ignore -Xjsr305=@org.library.MyNullable:warn</code>를 추가하면 컴파일러는 <code>@org.library.MyNullable</code>로 어노테이션된 타입의 부적절한 사용에 대해 경고를 생성하고 다른 모든 JSR-305 어노테이션을 무시합니다.</p><p>기본 동작은 <code>-Xjsr305=warn</code>과 동일합니다. <code>strict</code> 값은 실험적인 것으로 간주되어야 합니다 (향후 더 많은 검사가 추가될 수 있습니다).</p><h2 id="매핑된-타입" tabindex="-1">매핑된 타입 <a class="header-anchor" href="#매핑된-타입" aria-label="Permalink to &quot;매핑된 타입&quot;">​</a></h2><p>Kotlin은 일부 Java 타입을 특별하게 처리합니다. 이러한 타입은 Java에서 &quot;있는 그대로&quot; 로드되지 않고, 해당하는 Kotlin 타입으로 _매핑_됩니다. 매핑은 컴파일 시점에만 중요하며, 런타임 표현은 변경되지 않습니다. Java의 기본 타입은 해당 Kotlin 타입으로 매핑됩니다 (<a href="#null-safety-and-platform-types">플랫폼 타입</a>을 염두에 두고):</p><table tabindex="0"><thead><tr><th><strong>Java 타입</strong></th><th><strong>Kotlin 타입</strong></th></tr></thead><tbody><tr><td><code>byte</code></td><td><code>kotlin.Byte</code></td></tr><tr><td><code>short</code></td><td><code>kotlin.Short</code></td></tr><tr><td><code>int</code></td><td><code>kotlin.Int</code></td></tr><tr><td><code>long</code></td><td><code>kotlin.Long</code></td></tr><tr><td><code>char</code></td><td><code>kotlin.Char</code></td></tr><tr><td><code>float</code></td><td><code>kotlin.Float</code></td></tr><tr><td><code>double</code></td><td><code>kotlin.Double</code></td></tr><tr><td><code>boolean</code></td><td><code>kotlin.Boolean</code></td></tr></tbody></table><p>일부 비기본(non-primitive) 내장 클래스도 매핑됩니다:</p><table tabindex="0"><thead><tr><th><strong>Java 타입</strong></th><th><strong>Kotlin 타입</strong></th></tr></thead><tbody><tr><td><code>java.lang.Object</code></td><td><code>kotlin.Any!</code></td></tr><tr><td><code>java.lang.Cloneable</code></td><td><code>kotlin.Cloneable!</code></td></tr><tr><td><code>java.lang.Comparable</code></td><td><code>kotlin.Comparable!</code></td></tr><tr><td><code>java.lang.Enum</code></td><td><code>kotlin.Enum!</code></td></tr><tr><td><code>java.lang.annotation.Annotation</code></td><td><code>kotlin.Annotation!</code></td></tr><tr><td><code>java.lang.CharSequence</code></td><td><code>kotlin.CharSequence!</code></td></tr><tr><td><code>java.lang.String</code></td><td><code>kotlin.String!</code></td></tr><tr><td><code>java.lang.Number</code></td><td><code>kotlin.Number!</code></td></tr><tr><td><code>java.lang.Throwable</code></td><td><code>kotlin.Throwable!</code></td></tr></tbody></table><p>Java의 박싱된(boxed) 기본 타입은 널 허용 Kotlin 타입으로 매핑됩니다:</p><table tabindex="0"><thead><tr><th><strong>Java 타입</strong></th><th><strong>Kotlin 타입</strong></th></tr></thead><tbody><tr><td><code>java.lang.Byte</code></td><td><code>kotlin.Byte?</code></td></tr><tr><td><code>java.lang.Short</code></td><td><code>kotlin.Short?</code></td></tr><tr><td><code>java.lang.Integer</code></td><td><code>kotlin.Int?</code></td></tr><tr><td><code>java.lang.Long</code></td><td><code>kotlin.Long?</code></td></tr><tr><td><code>java.lang.Character</code></td><td><code>kotlin.Char?</code></td></tr><tr><td><code>java.lang.Float</code></td><td><code>kotlin.Float?</code></td></tr><tr><td><code>java.lang.Double</code></td><td><code>kotlin.Double?</code></td></tr><tr><td><code>java.lang.Boolean</code></td><td><code>kotlin.Boolean?</code></td></tr></tbody></table><p>타입 매개변수로 사용되는 박싱된 기본 타입은 플랫폼 타입으로 매핑됩니다. 예를 들어, <code>List&lt;java.lang.Integer&gt;</code>는 Kotlin에서 <code>List&lt;Int!&gt;</code>가 됩니다.</p><p>컬렉션 타입은 Kotlin에서 읽기 전용 또는 가변일 수 있으므로, Java의 컬렉션은 다음과 같이 매핑됩니다 (이 표의 모든 Kotlin 타입은 <code>kotlin.collections</code> 패키지에 있습니다):</p><table tabindex="0"><thead><tr><th><strong>Java 타입</strong></th><th><strong>Kotlin 읽기 전용 타입</strong></th><th><strong>Kotlin 가변 타입</strong></th><th><strong>로드된 플랫폼 타입</strong></th></tr></thead><tbody><tr><td><code>Iterator&lt;T&gt;</code></td><td><code>Iterator&lt;T&gt;</code></td><td><code>MutableIterator&lt;T&gt;</code></td><td><code>(Mutable)Iterator&lt;T&gt;!</code></td></tr><tr><td><code>Iterable&lt;T&gt;</code></td><td><code>Iterable&lt;T&gt;</code></td><td><code>MutableIterable&lt;T&gt;</code></td><td><code>(Mutable)Iterable&lt;T&gt;!</code></td></tr><tr><td><code>Collection&lt;T&gt;</code></td><td><code>Collection&lt;T&gt;</code></td><td><code>MutableCollection&lt;T&gt;</code></td><td><code>(Mutable)Collection&lt;T&gt;!</code></td></tr><tr><td><code>Set&lt;T&gt;</code></td><td><code>Set&lt;T&gt;</code></td><td><code>MutableSet&lt;T&gt;</code></td><td><code>(Mutable)Set&lt;T&gt;!</code></td></tr><tr><td><code>List&lt;T&gt;</code></td><td><code>List&lt;T&gt;</code></td><td><code>MutableList&lt;T&gt;</code></td><td><code>(Mutable)List&lt;T&gt;!</code></td></tr><tr><td><code>ListIterator&lt;T&gt;</code></td><td><code>ListIterator&lt;T&gt;</code></td><td><code>MutableListIterator&lt;T&gt;</code></td><td><code>(Mutable)ListIterator&lt;T&gt;!</code></td></tr><tr><td><code>Map&lt;K, V&gt;</code></td><td><code>Map&lt;K, V&gt;</code></td><td><code>MutableMap&lt;K, V&gt;</code></td><td><code>(Mutable)Map&lt;K, V&gt;!</code></td></tr><tr><td><code>Map.Entry&lt;K, V&gt;</code></td><td><code>Map.Entry&lt;K, V&gt;</code></td><td><code>MutableMap.MutableEntry&lt;K,V&gt;</code></td><td><code>(Mutable)Map.(Mutable)Entry&lt;K, V&gt;!</code></td></tr></tbody></table><p>Java의 배열은 <a href="#java-arrays">아래</a>에서 언급된 대로 매핑됩니다:</p><table tabindex="0"><thead><tr><th><strong>Java 타입</strong></th><th><strong>Kotlin 타입</strong></th></tr></thead><tbody><tr><td><code>int[]</code></td><td><code>kotlin.IntArray!</code></td></tr><tr><td><code>String[]</code></td><td><code>kotlin.Array&lt;(out) String!&gt;!</code></td></tr></tbody></table><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>이러한 Java 타입의 정적 멤버는 Kotlin 타입의 <a href="/ko/kotlin/object-declarations#companion-objects">컴패니언 객체(companion objects)</a>에서 직접 접근할 수 없습니다. 이를 호출하려면 <code>java.lang.Integer.toHexString(foo)</code>와 같이 Java 타입의 완전 정규화된 이름(full qualified names)을 사용하십시오.</p></div><h2 id="kotlin의-java-제네릭" tabindex="-1">Kotlin의 Java 제네릭 <a class="header-anchor" href="#kotlin의-java-제네릭" aria-label="Permalink to &quot;Kotlin의 Java 제네릭&quot;">​</a></h2><p>Kotlin의 제네릭은 Java의 제네릭과 약간 다릅니다 (<a href="/ko/kotlin/generics">제네릭</a> 참조). Java 타입을 Kotlin으로 임포트할 때 다음 변환이 수행됩니다:</p><ul><li><p>Java의 와일드카드는 타입 프로젝션(type projections)으로 변환됩니다:</p><ul><li><code>Foo&lt;? extends Bar&gt;</code>는 <code>Foo&lt;out Bar!&gt;!</code>가 됩니다.</li><li><code>Foo&lt;? super Bar&gt;</code>는 <code>Foo&lt;in Bar!&gt;!</code>가 됩니다.</li></ul></li><li><p>Java의 로(raw) 타입은 스타 프로젝션(star projections)으로 변환됩니다:</p><ul><li><code>List</code>는 <code>List&lt;*&gt;!</code> (즉 <code>List&lt;out Any?&gt;!</code>)가 됩니다.</li></ul></li></ul><p>Java와 마찬가지로 Kotlin의 제네릭은 런타임에 유지되지 않습니다. 객체는 생성자에 전달된 실제 타입 인수에 대한 정보를 가지고 있지 않습니다. 예를 들어, <code>ArrayList&lt;Integer&gt;()</code>는 <code>ArrayList&lt;Character&gt;()</code>와 구별할 수 없습니다. 이로 인해 제네릭을 고려하는 <code>is</code> 검사를 수행하는 것이 불가능합니다. Kotlin은 스타 프로젝션된 제네릭 타입에 대해서만 <code>is</code> 검사를 허용합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 오류: 실제 Int 리스트인지 확인할 수 없음</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 하지만</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;*&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK: 리스트 내용에 대한 보장은 없음</span></span></code></pre></div><h2 id="java-배열" tabindex="-1">Java 배열 <a class="header-anchor" href="#java-배열" aria-label="Permalink to &quot;Java 배열&quot;">​</a></h2><p>Kotlin의 배열은 Java와 달리 불변입니다. 이는 Kotlin이 <code>Array&lt;String&gt;</code>을 <code>Array&lt;Any&gt;</code>에 할당하는 것을 허용하지 않아 발생할 수 있는 런타임 실패를 방지합니다. 서브클래스 배열을 슈퍼클래스 배열로 Kotlin 메서드에 전달하는 것도 금지되지만, Java 메서드의 경우 <code>Array&lt;(out) String&gt;!</code> 형태의 <a href="#null-safety-and-platform-types">플랫폼 타입</a>을 통해 허용됩니다.</p><p>배열은 Java 플랫폼에서 박싱/언박싱(boxing/unboxing) 연산의 비용을 피하기 위해 기본 데이터 타입과 함께 사용됩니다. Kotlin이 이러한 구현 세부 정보를 숨기기 때문에 Java 코드와 인터페이스하려면 해결 방법이 필요합니다. 이 경우를 처리하기 위해 모든 유형의 기본 배열(<code>IntArray</code>, <code>DoubleArray</code>, <code>CharArray</code> 등)에 대한 특수 클래스가 있습니다. 이들은 <code>Array</code> 클래스와 관련이 없으며 최대 성능을 위해 Java의 기본 배열로 컴파일됩니다.</p><p>정수형 배열(int array)을 인덱스로 받는 Java 메서드가 있다고 가정해 봅시다:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JavaArrayExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeIndices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">indices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // code here...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>기본 값 배열을 전달하려면 Kotlin에서 다음을 수행할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> javaObj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JavaArrayExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> intArrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">javaObj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeIndices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// int[]를 메서드에 전달</span></span></code></pre></div><p>JVM 바이트코드로 컴파일할 때 컴파일러는 배열 접근을 최적화하여 오버헤드가 발생하지 않도록 합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">array[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 실제 get() 및 set() 호출이 생성되지 않음</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 이터레이터가 생성되지 않음</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>인덱스를 사용하여 탐색할 때도 오버헤드가 발생하지 않습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.indices) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 이터레이터가 생성되지 않음</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    array[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>마지막으로, <code>in</code> 검사도 오버헤드가 없습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.indices) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// (i &gt;= 0 &amp;&amp; i &lt; array.size)와 동일</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array[i])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="java-가변-인자-varargs" tabindex="-1">Java 가변 인자(varargs) <a class="header-anchor" href="#java-가변-인자-varargs" aria-label="Permalink to &quot;Java 가변 인자(varargs)&quot;">​</a></h2><p>Java 클래스는 때때로 가변 인자(varargs)를 사용하여 인덱스에 대한 메서드 선언을 사용합니다:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JavaArrayExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeIndicesVarArg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">... </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">indices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // code here...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 경우 <code>IntArray</code>를 전달하려면 스프레드 연산자 <code>*</code>를 사용해야 합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> javaObj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JavaArrayExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> intArrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">javaObj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeIndicesVarArg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">array)</span></span></code></pre></div><h2 id="연산자" tabindex="-1">연산자 <a class="header-anchor" href="#연산자" aria-label="Permalink to &quot;연산자&quot;">​</a></h2><p>Java는 연산자 문법을 사용하는 것이 합리적인 메서드를 표시하는 방법이 없으므로, Kotlin은 올바른 이름과 시그니처를 가진 모든 Java 메서드를 연산자 오버로드 및 기타 규칙(<code>invoke()</code> 등)으로 사용할 수 있도록 허용합니다. infix 호출 문법을 사용하여 Java 메서드를 호출하는 것은 허용되지 않습니다.</p><h2 id="체크된-예외" tabindex="-1">체크된 예외 <a class="header-anchor" href="#체크된-예외" aria-label="Permalink to &quot;체크된 예외&quot;">​</a></h2><p>Kotlin에서는 모든 <a href="/ko/kotlin/exceptions">예외가 언체크드(unchecked)</a>입니다. 즉, 컴파일러가 어떤 예외도 강제로 catch하도록 하지 않습니다. 따라서 체크된 예외를 선언하는 Java 메서드를 호출할 때 Kotlin은 아무것도 강제하지 않습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(list: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;*&gt;, to: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Appendable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        to.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Java에서는 여기서 IOException을 catch해야 함</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="객체-메서드" tabindex="-1">객체 메서드 <a class="header-anchor" href="#객체-메서드" aria-label="Permalink to &quot;객체 메서드&quot;">​</a></h2><p>Java 타입이 Kotlin으로 임포트될 때, <code>java.lang.Object</code> 타입의 모든 참조는 <code>Any</code>로 변환됩니다. <code>Any</code>는 플랫폼 독립적(platform-specific)이지 않으므로, <code>toString()</code>, <code>hashCode()</code>, <code>equals()</code>만 멤버로 선언합니다. 따라서 <code>java.lang.Object</code>의 다른 멤버를 사용 가능하게 하려면 Kotlin은 <a href="/ko/kotlin/extensions">확장 함수(extension functions)</a>를 사용합니다.</p><h3 id="wait-notify" tabindex="-1">wait()/notify() <a class="header-anchor" href="#wait-notify" aria-label="Permalink to &quot;wait()/notify()&quot;">​</a></h3><p><code>wait()</code> 및 <code>notify()</code> 메서드는 <code>Any</code> 타입의 참조에서 사용할 수 없습니다. 이들은 일반적으로 <code>java.util.concurrent</code> 사용을 권장하며 사용이 권장되지 않습니다. 이 메서드를 정말 호출해야 하는 경우 <code>java.lang.Object</code>로 캐스트(cast)할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.lang.Object).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h3 id="getclass" tabindex="-1">getClass() <a class="header-anchor" href="#getclass" aria-label="Permalink to &quot;getClass()&quot;">​</a></h3><p>객체의 Java 클래스를 가져오려면 <a href="/ko/kotlin/reflection#class-references">클래스 참조(class reference)</a>에 있는 <code>java</code> 확장 프로퍼티를 사용하십시오:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fooClass </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.java</span></span></code></pre></div><p>위 코드는 <a href="/ko/kotlin/reflection#bound-class-references">바인딩된 클래스 참조(bound class reference)</a>를 사용합니다. <code>javaClass</code> 확장 프로퍼티를 사용할 수도 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fooClass </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo.javaClass</span></span></code></pre></div><p>이러한 목적으로 <code>ClassName.javaClass</code>를 사용하지 마십시오. 이는 <code>ClassName</code>의 컴패니언 객체 클래스를 참조하며, 이는 <code>ClassName.Companion::class.java</code>와 동일하고 <code>ClassName::class.java</code>와는 다릅니다.</p><p>각 기본 타입에 대해 두 개의 다른 Java 클래스가 있으며, Kotlin은 둘 다를 가져오는 방법을 제공합니다. 예를 들어, <code>Int::class.java</code>는 기본 타입 자체를 나타내는 클래스 인스턴스를 반환하며, 이는 Java의 <code>Integer.TYPE</code>에 해당합니다. 해당 래퍼(wrapper) 타입의 클래스를 얻으려면 <code>Int::class.javaObjectType</code>을 사용하십시오. 이는 Java의 <code>Integer.class</code>와 동일합니다.</p><p>기타 지원되는 경우로는 Kotlin 프로퍼티에 대한 Java 게터/세터 메서드 또는 backing 필드, Java 필드에 대한 <code>KProperty</code>, <code>KFunction</code>에 대한 Java 메서드 또는 생성자, 그리고 그 반대의 경우도 포함됩니다.</p><h2 id="sam-변환" tabindex="-1">SAM 변환 <a class="header-anchor" href="#sam-변환" aria-label="Permalink to &quot;SAM 변환&quot;">​</a></h2><p>Kotlin은 Java 및 <a href="/ko/kotlin/fun-interfaces">Kotlin 인터페이스</a> 모두에 대한 SAM(Single Abstract Method) 변환을 지원합니다. Java에 대한 이 지원은 Kotlin 함수 리터럴이 단일 비-기본(non-default) 메서드를 가진 Java 인터페이스 구현으로 자동 변환될 수 있음을 의미합니다. 단, 인터페이스 메서드의 매개변수 타입이 Kotlin 함수의 매개변수 타입과 일치해야 합니다.</p><p>이를 사용하여 SAM 인터페이스의 인스턴스를 생성할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> runnable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This runs in a runnable&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span></code></pre></div><p>...그리고 메서드 호출에서:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ThreadPoolExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Java 시그니처: void execute(Runnable command)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">executor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This runs in a thread pool&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span></code></pre></div><p>Java 클래스에 함수형 인터페이스를 인자로 받는 메서드가 여러 개 있는 경우, 람다를 특정 SAM 타입으로 변환하는 어댑터 함수를 사용하여 호출해야 하는 메서드를 선택할 수 있습니다. 이러한 어댑터 함수는 필요할 때 컴파일러에 의해 생성됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">executor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This runs in a thread pool&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) })</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>SAM 변환은 인터페이스에만 작동하며, 추상 클래스에는 작동하지 않습니다. 설령 추상 클래스에 단 하나의 추상 메서드만 있더라도 마찬가지입니다.</p></div><h2 id="kotlin에서-jni-사용하기" tabindex="-1">Kotlin에서 JNI 사용하기 <a class="header-anchor" href="#kotlin에서-jni-사용하기" aria-label="Permalink to &quot;Kotlin에서 JNI 사용하기&quot;">​</a></h2><p>네이티브(C 또는 C++) 코드로 구현된 함수를 선언하려면 <code>external</code> 한정자로 표시해야 합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Double</span></span></code></pre></div><p>나머지 절차는 Java에서와 정확히 동일하게 작동합니다.</p><p>프로퍼티 게터와 세터를 <code>external</code>로 표시할 수도 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myProperty: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> get</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> set</span></span></code></pre></div><p>내부적으로 이것은 <code>getMyProperty</code>와 <code>setMyProperty</code> 두 함수를 생성하며, 둘 다 <code>external</code>로 표시됩니다.</p><h2 id="lombok으로-생성된-선언을-kotlin에서-사용하기" tabindex="-1">Lombok으로 생성된 선언을 Kotlin에서 사용하기 <a class="header-anchor" href="#lombok으로-생성된-선언을-kotlin에서-사용하기" aria-label="Permalink to &quot;Lombok으로 생성된 선언을 Kotlin에서 사용하기&quot;">​</a></h2><p>Java의 Lombok으로 생성된 선언을 Kotlin 코드에서 사용할 수 있습니다. 동일한 Java/Kotlin 혼합 모듈에서 이러한 선언을 생성하고 사용해야 하는 경우, <a href="/ko/kotlin/lombok">Lombok 컴파일러 플러그인 페이지</a>에서 이를 수행하는 방법을 배울 수 있습니다. 다른 모듈에서 이러한 선언을 호출하는 경우, 해당 모듈을 컴파일하기 위해 이 플러그인을 사용할 필요는 없습니다.</p>`,158))])}const A=k(r,[["render",E]]);export{v as __pageData,A as default};
