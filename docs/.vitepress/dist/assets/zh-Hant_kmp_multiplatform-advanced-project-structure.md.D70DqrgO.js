import{_ as i,a as e,b as a,c as n,d as o,e as t,f as l,g as p,h as c,i as d}from"./chunks/ios-compilation-diagram.XqBtYEgD.js";import{_ as h,c as r,o as k,ag as E}from"./chunks/framework.Bksy39di.js";const C=JSON.parse('{"title":"多平台專案結構的進階概念","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kmp/multiplatform-advanced-project-structure.md","filePath":"zh-Hant/kmp/multiplatform-advanced-project-structure.md","lastUpdated":1755516278000}'),m={name:"zh-Hant/kmp/multiplatform-advanced-project-structure.md"};function u(g,s,y,F,v,M){return k(),r("div",null,s[0]||(s[0]=[E('<h1 id="多平台專案結構的進階概念" tabindex="-1">多平台專案結構的進階概念 <a class="header-anchor" href="#多平台專案結構的進階概念" aria-label="Permalink to &quot;多平台專案結構的進階概念&quot;">​</a></h1><p>本文解釋了 Kotlin Multiplatform 專案結構的進階概念，以及它們如何對應到 Gradle 的實作。此資訊對於需要處理 Gradle 建置的低階抽象 (例如 configurations, tasks, publications 等)，或正在為 Kotlin Multiplatform 建置建立 Gradle 外掛程式的情況會很有用。</p><p>本頁面在以下情況會很有用：</p><ul><li>需要在一組 Kotlin 未為其建立 source set 的目標之間共享程式碼。</li><li>想要為 Kotlin Multiplatform 建置建立 Gradle 外掛程式，或需要處理 Gradle 建置的低階抽象，例如 configurations, tasks, publications 等。</li></ul><p>了解多平台專案中依賴管理的一個關鍵點，是 Gradle 風格的專案或程式庫依賴與 Kotlin 特有的 source set 之間的 <code>dependsOn</code> 關係之間的差異：</p><ul><li><code>dependsOn</code> 是 common 和平台特定 source set 之間的一種關係，它啟用了 <a href="#dependson-and-source-set-hierarchies">source set 階層</a> 並普遍實現了多平台專案中的程式碼共享。對於預設的 source set，階層是自動管理的，但在特定情況下，您可能需要修改它。</li><li>程式庫和專案依賴通常像往常一樣運作，但要在多平台專案中正確管理它們，您應該了解 <a href="#dependencies-on-other-libraries-or-projects">Gradle 依賴如何解析</a> 為用於編譯的粒度化 <strong>source set → source set</strong> 依賴。</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在深入研究進階概念之前，我們建議學習 <a href="./multiplatform-discover-project">多平台專案結構的基礎知識</a>。</p></div><h2 id="dependson-與-source-set-階層" tabindex="-1">dependsOn 與 source set 階層 <a class="header-anchor" href="#dependson-與-source-set-階層" aria-label="Permalink to &quot;dependsOn 與 source set 階層&quot;">​</a></h2><p>通常，您會處理 <em>依賴</em> 而非 <em><code>dependsOn</code></em> 關係。然而，檢查 <code>dependsOn</code> 對於理解 Kotlin Multiplatform 專案的內部運作方式至關重要。</p><p><code>dependsOn</code> 是兩個 Kotlin source set 之間的一種 Kotlin 特有關係。這可能是 common 和平台特定 source set 之間的一種連接，例如，當 <code>jvmMain</code> source set 依賴於 <code>commonMain</code>，<code>iosArm64Main</code> 依賴於 <code>iosMain</code> 等等。</p><p>考慮一個使用 Kotlin source set <code>A</code> 和 <code>B</code> 的通用範例。運算式 <code>A.dependsOn(B)</code> 指示 Kotlin：</p><ol><li><code>A</code> 觀察來自 <code>B</code> 的 API，包括內部宣告。</li><li><code>A</code> 可以為來自 <code>B</code> 的 expected 宣告提供 actual 實作。這是一個必要且充分的條件，因為 <code>A</code> 只有在 <code>A.dependsOn(B)</code> 直接或間接存在時才能為 <code>B</code> 提供 <code>actuals</code>。</li><li><code>B</code> 除了其自身的目標之外，還應該編譯到 <code>A</code> 編譯到的所有目標。</li><li><code>A</code> 繼承 <code>B</code> 的所有常規依賴。</li></ol><p><code>dependsOn</code> 關係建立了一個稱為 source set 階層的樹狀結構。這是一個用於行動裝置開發的典型專案範例，包含 <code>androidTarget</code>、<code>iosArm64</code> (iPhone 裝置) 和 <code>iosSimulatorArm64</code> (適用於 Apple Silicon Mac 的 iPhone 模擬器)：</p><p><img src="'+i+'" alt="DependsOn 樹狀結構" width="700"></p><p>箭頭代表 <code>dependsOn</code> 關係。 這些關係在平台二進位檔編譯期間會被保留。這就是 Kotlin 如何理解 <code>iosMain</code> 應該能看到來自 <code>commonMain</code> 的 API，但不能看到來自 <code>iosArm64Main</code> 的 API：</p><p><img src="'+e+`" alt="編譯期間的 DependsOn 關係" width="700"></p><p><code>dependsOn</code> 關係是透過呼叫 <code>KotlinSourceSet.dependsOn(KotlinSourceSet)</code> 進行設定的，例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Targets declaration</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sourceSets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Example of configuring the dependsOn relation </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        iosArm64Main.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dependsOn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(commonMain)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>此範例展示了如何在建置指令碼中定義 <code>dependsOn</code> 關係。然而，Kotlin Gradle 外掛程式預設會建立 source set 並設定這些關係，因此您無需手動執行此操作。</li><li><code>dependsOn</code> 關係在建置指令碼中與 <code>dependencies {}</code> 區塊分開宣告。這是因為 <code>dependsOn</code> 不是常規依賴；相反，它是 Kotlin source set 之間的一種特定關係，對於跨不同目標共享程式碼是必需的。</li></ul><p>您不能使用 <code>dependsOn</code> 來宣告對已發布程式庫或另一個 Gradle 專案的常規依賴。例如，您不能設定 <code>commonMain</code> 依賴於 <code>kotlinx-coroutines-core</code> 程式庫的 <code>commonMain</code>，也不能呼叫 <code>commonTest.dependsOn(commonMain)</code>。</p><h3 id="宣告自訂-source-set" tabindex="-1">宣告自訂 source set <a class="header-anchor" href="#宣告自訂-source-set" aria-label="Permalink to &quot;宣告自訂 source set&quot;">​</a></h3><p>在某些情況下，您可能需要在專案中擁有一個自訂的中間 source set。考慮一個編譯到 JVM、JS 和 Linux 的專案，並且您只想在 JVM 和 JS 之間共享一些原始碼。在這種情況下，您應該為這對目標找到一個特定的 source set，如 <a href="./multiplatform-discover-project">多平台專案結構的基礎知識</a> 中所述。</p><p>Kotlin 不會自動建立此類型的 source set。這表示您應該使用 <code>by creating</code> 建構手動建立它：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    linuxX64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sourceSets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Create a source set named &quot;jvmAndJs&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jvmAndJsMain </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> creating</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // …</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>然而，Kotlin 仍然不知道如何處理或編譯此 source set。如果您繪製一個圖表，這個 source set 將是孤立的，並且不會有任何目標標籤：</p><p><img src="`+a+`" alt="缺少 dependsOn 關係" width="700"></p><p>為了解決這個問題，透過新增幾個 <code>dependsOn</code> 關係將 <code>jvmAndJsMain</code> 包含在階層中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    linuxX64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sourceSets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jvmAndJsMain </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> creating</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Don&#39;t forget to add dependsOn to commonMain</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dependsOn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(commonMain.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        jvmMain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dependsOn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jvmAndJsMain)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        jsMain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dependsOn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jvmAndJsMain)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在這裡，<code>jvmMain.dependsOn(jvmAndJsMain)</code> 將 JVM 目標新增到 <code>jvmAndJsMain</code>，而 <code>jsMain.dependsOn(jvmAndJsMain)</code> 將 JS 目標新增到 <code>jvmAndJsMain</code>。</p><p>最終的專案結構將如下所示：</p><p><img src="`+n+`" alt="最終專案結構" width="700"></p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>手動設定 <code>dependsOn</code> 關係會停用預設階層範本的自動應用。請參閱 <a href="./multiplatform-hierarchy#additional-configuration">額外設定</a> 以了解有關這些情況以及如何處理它們的更多資訊。</p></div><h2 id="對其他程式庫或專案的依賴" tabindex="-1">對其他程式庫或專案的依賴 <a class="header-anchor" href="#對其他程式庫或專案的依賴" aria-label="Permalink to &quot;對其他程式庫或專案的依賴&quot;">​</a></h2><p>在多平台專案中，您可以設定對已發布程式庫或另一個 Gradle 專案的常規依賴。</p><p>Kotlin Multiplatform 通常以典型的 Gradle 方式宣告依賴。與 Gradle 類似，您：</p><ul><li>在您的建置指令碼中使用 <code>dependencies {}</code> 區塊。</li><li>為依賴選擇適當的範圍，例如 <code>implementation</code> 或 <code>api</code>。</li><li>透過指定其座標來引用依賴，如果它已發布在 repo 中，例如 <code>&quot;com.google.guava:guava:32.1.2-jre&quot;</code>，或者如果它是在同一建置中的 Gradle 專案，則透過其路徑引用，例如 <code>project(&quot;:utils:concurrency&quot;)</code>。</li></ul><p>多平台專案中的依賴設定有一些特殊功能。每個 Kotlin source set 都有自己的 <code>dependencies {}</code> 區塊。這允許您在平台特定 source set 中宣告平台特定依賴：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Targets declaration</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sourceSets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        jvmMain.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // This is jvmMain&#39;s dependencies, so it&#39;s OK to add a JVM-specific dependency</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            implementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;com.google.guava:guava:32.1.2-jre&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Common 依賴更為複雜。考慮一個多平台專案，它宣告對多平台程式庫的依賴，例如 <code>kotlinx.coroutines</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    androidTarget</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Android</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// iPhone devices </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    iosSimulatorArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// iPhone simulator on Apple Silicon Mac</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sourceSets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        commonMain.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            implementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>依賴解析中有三個重要概念：</p><ol><li><p>多平台依賴會沿著 <code>dependsOn</code> 結構向下傳播。當您將依賴新增到 <code>commonMain</code> 時，它將自動新增到所有直接或間接在 <code>commonMain</code> 中宣告 <code>dependsOn</code> 關係的 source set。</p><p>在這種情況下，依賴確實自動新增到所有 <code>*Main</code> source set：<code>iosMain</code>、<code>jvmMain</code>、<code>iosSimulatorArm64Main</code> 和 <code>iosX64Main</code>。所有這些 source set 都從 <code>commonMain</code> source set 繼承 <code>kotlin-coroutines-core</code> 依賴，因此您無需手動將其複製貼上到所有這些 source set 中：</p><p><img src="`+o+'" alt="多平台依賴的傳播" width="700"></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>傳播機制允許您透過選擇特定的 source set 來選擇將接收宣告依賴的範圍。例如，如果您想在 iOS 上使用 <code>kotlinx.coroutines</code> 而不在 Android 上使用，則可以僅將此依賴新增到 <code>iosMain</code>。</p></div></li><li><p><em>source set → 多平台程式庫</em> 依賴，例如上面 <code>commonMain</code> 對 <code>org.jetbrians.kotlinx:kotlinx-coroutines-core:1.7.3</code> 的依賴，代表了依賴解析的中間狀態。解析的最終狀態始終由 <em>source set → source set</em> 依賴來表示。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>最終的 <em>source set → source set</em> 依賴不是 <code>dependsOn</code> 關係。</p></div><p>為了推斷粒度化的 <em>source set → source set</em> 依賴，Kotlin 會讀取與每個多平台程式庫一起發布的 source set 結構。在此步驟之後，每個程式庫在內部將不再是整體，而是其 source set 的集合。請參閱 <code>kotlinx-coroutines-core</code> 的此範例：</p><p><img src="'+t+'" alt="Source set 結構的序列化" width="700"></p></li><li><p>Kotlin 處理每個依賴關係，並將其解析為來自依賴的一組 source set。該集合中的每個依賴 source set 都必須具有 <em>相容的目標</em>。如果依賴 source set 編譯到的目標 <em>至少與消費端 source set 相同</em>，則它具有相容的目標。</p><p>考慮一個範例，其中範例專案中的 <code>commonMain</code> 編譯到 <code>androidTarget</code>、<code>iosX64</code> 和 <code>iosSimulatorArm64</code>：</p><ul><li>首先，它解析對 <code>kotlinx-coroutines-core.commonMain</code> 的依賴。發生這種情況是因為 <code>kotlinx-coroutines-core</code> 編譯到所有可能的 Kotlin 目標。因此，它的 <code>commonMain</code> 編譯到所有可能的目標，包括所需的 <code>androidTarget</code>、<code>iosX64</code> 和 <code>iosSimulatorArm64</code>。</li><li>其次，<code>commonMain</code> 依賴於 <code>kotlinx-coroutines-core.concurrentMain</code>。由於 <code>kotlinx-coroutines-core</code> 中的 <code>concurrentMain</code> 編譯到除 JS 之外的所有目標，因此它與消費專案的 <code>commonMain</code> 的目標匹配。</li></ul><p>然而，來自 coroutines 的 <code>iosX64Main</code> 等 source set 與消費者的 <code>commonMain</code> 不相容。儘管 <code>iosX64Main</code> 編譯到 <code>commonMain</code> 的其中一個目標，即 <code>iosX64</code>，但它不編譯到 <code>androidTarget</code> 或 <code>iosSimulatorArm64</code>。</p><p>依賴解析的結果直接影響 <code>kotlinx-coroutines-core</code> 中哪些程式碼可見：</p><p><img src="'+l+'" alt="Common 程式碼中 JVM 特定 API 的錯誤" width="700"></p></li></ol><h3 id="跨-source-set-對齊-common-依賴的版本" tabindex="-1">跨 source set 對齊 common 依賴的版本 <a class="header-anchor" href="#跨-source-set-對齊-common-依賴的版本" aria-label="Permalink to &quot;跨 source set 對齊 common 依賴的版本&quot;">​</a></h3><p>在 Kotlin Multiplatform 專案中，common source set 會被編譯多次，以產生 klib 並作為每個已設定的 <a href="./multiplatform-configure-compilations">編譯</a> 的一部分。為了產生一致的二進位檔，common 程式碼每次都應該針對相同版本的多平台依賴進行編譯。Kotlin Gradle 外掛程式有助於對齊這些依賴，確保每個 source set 的有效依賴版本相同。</p><p>在上面的範例中，假設您想將 <code>androidx.navigation:navigation-compose:2.7.7</code> 依賴新增到您的 <code>androidMain</code> source set。您的專案明確宣告 <code>commonMain</code> source set 的 <code>kotlinx-coroutines-core:1.7.3</code> 依賴，但版本 2.7.7 的 Compose Navigation 程式庫需要 Kotlin coroutines 1.8.0 或更新版本。</p><p>由於 <code>commonMain</code> 和 <code>androidMain</code> 會一起編譯，Kotlin Gradle 外掛程式會選擇兩個 coroutines 程式庫版本中的一個，並將 <code>kotlinx-coroutines-core:1.8.0</code> 應用於 <code>commonMain</code> source set。但為了讓 common 程式碼在所有已設定的目標上保持一致地編譯，iOS source set 也需要被限制為相同的依賴版本。 因此，Gradle 也將 <code>kotlinx.coroutines-*:1.8.0</code> 依賴傳播到 <code>iosMain</code> source set。</p><p><img src="'+p+'" alt="*Main source set 之間的依賴對齊" width="700"></p><p>依賴在 <code>*Main</code> source set 和 <a href="./multiplatform-discover-project#integration-with-tests"><code>*Test</code> source set</a> 之間分開對齊。<code>*Test</code> source set 的 Gradle 設定包含 <code>*Main</code> source set 的所有依賴，但反之不然。因此，您可以使用較新的程式庫版本測試您的專案，而不會影響您的主要程式碼。</p><p>例如，您的 <code>*Main</code> source set 中有 Kotlin coroutines 1.7.3 依賴，並傳播到專案中的每個 source set。然而，在 <code>iosTest</code> source set 中，您決定將版本升級到 1.8.0 以測試新的程式庫發布。根據相同的演算法，此依賴將在 <code>*Test</code> source set 的整個樹狀結構中傳播，因此每個 <code>*Test</code> source set 都將使用 <code>kotlinx.coroutines-*:1.8.0</code> 依賴進行編譯。</p><p><img src="'+c+'" alt="測試 source set 獨立於主要 source set 解析依賴"></p><h2 id="編譯" tabindex="-1">編譯 <a class="header-anchor" href="#編譯" aria-label="Permalink to &quot;編譯&quot;">​</a></h2><p>與單平台專案相反，Kotlin Multiplatform 專案需要多次編譯器啟動才能建置所有構件。每次編譯器啟動都是一次 <em>Kotlin 編譯</em>。</p><p>例如，以下是在前面提到的此 Kotlin 編譯期間為 iPhone 裝置生成二進位檔的方式：</p><p><img src="'+d+`" alt="iOS 的 Kotlin 編譯" width="700"></p><p>Kotlin 編譯按目標分組。預設情況下，Kotlin 為每個目標建立兩個編譯：用於生產原始碼的 <code>main</code> 編譯和用於測試原始碼的 <code>test</code> 編譯。</p><p>建置指令碼中的編譯以類似方式存取。您首先選擇一個 Kotlin 目標，然後存取其內部的 <code>compilations</code> 容器，最後按其名稱選擇必要的編譯：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Declare and configure the JVM target</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    jvm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mainCompilation: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KotlinJvmCompilation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> compilations.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,57)]))}const B=h(m,[["render",u]]);export{C as __pageData,B as default};
