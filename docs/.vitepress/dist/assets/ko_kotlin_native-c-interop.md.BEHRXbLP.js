import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.Bksy39di.js";const E=JSON.parse('{"title":"C 언어와의 상호 운용성","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/native-c-interop.md","filePath":"ko/kotlin/native-c-interop.md","lastUpdated":1754307826000}'),l={name:"ko/kotlin/native-c-interop.md"};function e(p,s,h,k,d,r){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="c-언어와의-상호-운용성" tabindex="-1">C 언어와의 상호 운용성 <a class="header-anchor" href="#c-언어와의-상호-운용성" aria-label="Permalink to &quot;C 언어와의 상호 운용성&quot;">​</a></h1><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>C 라이브러리 임포트 기능은 <a href="/ko/kotlin/native-c-interop-stability">베타</a>입니다. <code>cinterop</code> 도구가 C 라이브러리에서 생성하는 모든 Kotlin 선언에는 <code>@ExperimentalForeignApi</code> 어노테이션이 있어야 합니다. Kotlin/Native에 포함된 네이티브 플랫폼 라이브러리(예: Foundation, UIKit, POSIX)는 일부 API에 대해서만 옵트인(opt-in)이 필요합니다.</p></div><p>이 문서는 Kotlin과 C 언어의 상호 운용에 대한 일반적인 내용을 다룹니다. Kotlin/Native는 <code>cinterop</code> 도구를 제공하여 외부 C 라이브러리와 상호 작용하는 데 필요한 모든 것을 빠르게 생성할 수 있습니다.</p><p>이 도구는 C 헤더를 분석하고 C 타입, 함수, 문자열을 Kotlin으로 직접적으로 매핑합니다. 생성된 스텁은 IDE로 임포트되어 코드 완성 및 탐색 기능을 사용할 수 있게 합니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Kotlin은 Objective-C와의 상호 운용성도 제공합니다. Objective-C 라이브러리도 <code>cinterop</code> 도구를 통해 임포트됩니다. 더 자세한 내용은 <a href="/ko/kotlin/native-objc-interop">Swift/Objective-C 상호 운용</a>을 참조하세요.</p></div><h2 id="프로젝트-설정" tabindex="-1">프로젝트 설정 <a class="header-anchor" href="#프로젝트-설정" aria-label="Permalink to &quot;프로젝트 설정&quot;">​</a></h2><p>C 라이브러리를 사용해야 하는 프로젝트 작업 시 일반적인 워크플로우는 다음과 같습니다:</p><ol><li><a href="/ko/kotlin/native-definition-file">정의 파일</a>을 생성하고 구성합니다. 이는 <code>cinterop</code> 도구가 Kotlin <a href="#bindings">바인딩스</a>에 무엇을 포함해야 하는지 설명합니다.</li><li>Gradle 빌드 파일에 <code>cinterop</code>을 빌드 프로세스에 포함하도록 구성합니다.</li><li>최종 실행 파일을 생성하기 위해 프로젝트를 컴파일하고 실행합니다.</li></ol><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>실습 경험을 위해 <a href="/ko/kotlin/native-app-with-c-and-libcurl">C 상호 운용을 사용하는 앱 만들기</a> 튜토리얼을 완료하세요.</p></div><p>많은 경우, C 라이브러리와의 사용자 정의 상호 운용성을 구성할 필요가 없습니다. 대신, <a href="/ko/kotlin/native-platform-libs">플랫폼 라이브러리</a>라고 불리는 플랫폼 표준화 바인딩에서 사용 가능한 API를 사용할 수 있습니다. 예를 들어, Linux/macOS 플랫폼의 POSIX, Windows 플랫폼의 Win32, macOS/iOS의 Apple 프레임워크 등이 이러한 방식으로 사용 가능합니다.</p><h2 id="바인딩스" tabindex="-1">바인딩스 <a class="header-anchor" href="#바인딩스" aria-label="Permalink to &quot;바인딩스&quot;">​</a></h2><h3 id="기본-상호-운용-타입" tabindex="-1">기본 상호 운용 타입 <a class="header-anchor" href="#기본-상호-운용-타입" aria-label="Permalink to &quot;기본 상호 운용 타입&quot;">​</a></h3><p>지원되는 모든 C 타입은 Kotlin에서 해당 표현을 가집니다:</p><ul><li>부호 있는, 부호 없는 정수, 부동 소수점 타입은 동일한 너비의 Kotlin 대응 타입으로 매핑됩니다.</li><li>포인터와 배열은 <code>CPointer&lt;T&gt;?</code>로 매핑됩니다.</li><li>열거형(Enum)은 휴리스틱(heuristics)과 <a href="/ko/kotlin/native-definition-file#configure-enums-generation">정의 파일 설정</a>에 따라 Kotlin 열거형 또는 정수 값으로 매핑될 수 있습니다.</li><li>구조체(Struct)와 공용체(Union)는 <code>someStructInstance.field1</code>과 같이 점 표기법을 통해 필드를 사용할 수 있는 타입으로 매핑됩니다.</li><li><code>typedef</code>는 <code>typealias</code>로 표현됩니다.</li></ul><p>또한, 모든 C 타입은 해당 타입의 lvalue를 나타내는 Kotlin 타입을 가집니다. 즉, 단순하고 불변적인 자체 포함 값 대신 메모리에 위치한 값을 나타냅니다. C++ 참조를 유사한 개념으로 생각할 수 있습니다. 구조체(및 구조체에 대한 <code>typedef</code>s)의 경우, 이 표현이 주요 표현이며 구조체 자체와 동일한 이름을 가집니다. Kotlin 열거형의 경우 <code>\${type}.Var</code>로 명명되고, <code>CPointer&lt;T&gt;</code>의 경우 <code>CPointerVar&lt;T&gt;</code>로, 대부분의 다른 타입의 경우 <code>\${type}Var</code>로 명명됩니다.</p><p>두 표현을 모두 가지는 타입의 경우, lvalue를 가진 타입은 값을 액세스하기 위한 변경 가능한 <code>.value</code> 속성을 가집니다.</p><h4 id="포인터-타입" tabindex="-1">포인터 타입 <a class="header-anchor" href="#포인터-타입" aria-label="Permalink to &quot;포인터 타입&quot;">​</a></h4><p><code>CPointer&lt;T&gt;</code>의 타입 인자 <code>T</code>는 위에서 설명한 lvalue 타입 중 하나여야 합니다. 예를 들어, C 타입 <code>struct S*</code>는 <code>CPointer&lt;S&gt;</code>로, <code>int8_t*</code>는 <code>CPointer&lt;int_8tVar&gt;</code>로, <code>char**</code>는 <code>CPointer&lt;CPointerVar&lt;ByteVar&gt;&gt;</code>로 매핑됩니다.</p><p>C null 포인터는 Kotlin의 <code>null</code>로 표현되며, 포인터 타입 <code>CPointer&lt;T&gt;</code>는 null을 허용하지 않지만 <code>CPointer&lt;T&gt;?</code>는 허용합니다. 이 타입의 값은 <code>null</code> 처리에 관련된 모든 Kotlin 연산을 지원합니다. 예를 들어 <code>?:</code>, <code>?.</code>, <code>!!</code> 등이 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getenv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;PATH&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)?.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toKString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() ?: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span></span></code></pre></div><p>배열 또한 <code>CPointer&lt;T&gt;</code>로 매핑되므로, 인덱스로 값에 액세스하기 위한 <code>[]</code> 연산자를 지원합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shift</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ptr: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ByteVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, length: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ptr[index] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ptr[index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>CPointer&lt;T&gt;</code>의 <code>.pointed</code> 속성은 이 포인터가 가리키는 타입 <code>T</code>의 lvalue를 반환합니다. 역 연산은 <code>.ptr</code>이며, lvalue를 취하고 이에 대한 포인터를 반환합니다.</p><p><code>void*</code>는 <code>COpaquePointer</code>로 매핑됩니다. 이는 다른 모든 포인터 타입의 슈퍼타입인 특별한 포인터 타입입니다. 따라서 C 함수가 <code>void*</code>를 인자로 받으면, Kotlin 바인딩은 모든 <code>CPointer</code>를 허용합니다.</p><p>포인터(<code>COpaquePointer</code> 포함) 캐스팅은 <code>.reinterpret&lt;T&gt;</code>를 사용하여 수행할 수 있습니다. 예를 들어:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intPtr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bytePtr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reinterpret</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IntVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span></code></pre></div><p>또는:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intPtr: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IntVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bytePtr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reinterpret</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>C에서와 마찬가지로 이러한 <code>.reinterpret</code> 캐스트는 안전하지 않으며 애플리케이션에서 미묘한 메모리 문제로 이어질 수 있습니다.</p><p>또한, <code>.toLong()</code> 및 <code>.toCPointer&lt;T&gt;()</code> 확장 메서드를 통해 <code>CPointer&lt;T&gt;?</code>와 <code>Long</code> 사이의 안전하지 않은 캐스트를 사용할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> longValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ptr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLong</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> originalPtr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> longValue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toCPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>결과 타입이 문맥상 명확하다면, 타입 추론 덕분에 타입 인자를 생략할 수 있습니다.</p></div><h3 id="메모리-할당" tabindex="-1">메모리 할당 <a class="header-anchor" href="#메모리-할당" aria-label="Permalink to &quot;메모리 할당&quot;">​</a></h3><p>네이티브 메모리는 <code>NativePlacement</code> 인터페이스를 사용하여 할당할 수 있습니다. 예를 들어:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> byteVar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> placement.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ByteVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span></code></pre></div><p>또는:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bytePtr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> placement.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">allocArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ByteVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>가장 논리적인 배치는 <code>nativeHeap</code> 객체에 있습니다. 이는 <code>malloc</code>을 사용하여 네이티브 메모리를 할당하는 것에 해당하며, 할당된 메모리를 해제하기 위한 추가적인 <code>.free()</code> 연산을 제공합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kotlinx.cinterop.ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nativeHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">allocArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ByteVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(size)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nativeHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">free</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>nativeHeap</code>은 메모리를 수동으로 해제해야 합니다. 하지만, 어휘적 범위(lexical scope)에 수명(lifetime)이 바인딩된 메모리를 할당하는 것이 종종 유용합니다. 이러한 메모리가 자동으로 해제된다면 도움이 됩니다.</p><p>이를 해결하기 위해 <code>memScoped { }</code>를 사용할 수 있습니다. 중괄호(<code>{ }</code>) 안에서는 임시 배치가 암시적 리시버(implicit receiver)로 사용 가능하므로, <code>alloc</code> 및 <code>allocArray</code>를 사용하여 네이티브 메모리를 할당할 수 있으며, 할당된 메모리는 스코프를 벗어난 후 자동으로 해제됩니다.</p><p>예를 들어, 포인터 매개변수를 통해 값을 반환하는 C 함수는 다음과 같이 사용할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> platform.posix.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fileSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> memScoped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> statBuf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> error </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> stat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, statBuf.ptr)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    statBuf.st_size</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="바인딩에-포인터-전달" tabindex="-1">바인딩에 포인터 전달 <a class="header-anchor" href="#바인딩에-포인터-전달" aria-label="Permalink to &quot;바인딩에 포인터 전달&quot;">​</a></h3><p>C 포인터는 <code>CPointer&lt;T&gt;</code> 타입으로 매핑되지만, C 함수 포인터 타입 매개변수는 <code>CValuesRef&lt;T&gt;</code>로 매핑됩니다. 이러한 매개변수의 값으로 <code>CPointer&lt;T&gt;</code>를 전달할 때, 이는 C 함수에 그대로 전달됩니다. 하지만, 포인터 대신 값 시퀀스(sequence)를 전달할 수 있습니다. 이 경우, 시퀀스는 &quot;값으로&quot; 전달됩니다. 즉, C 함수는 해당 시퀀스의 임시 복사본에 대한 포인터를 받으며, 이는 함수가 반환될 때까지만 유효합니다.</p><p>포인터 매개변수의 <code>CValuesRef&lt;T&gt;</code> 표현은 명시적인 네이티브 메모리 할당 없이 C 배열 리터럴을 지원하도록 설계되었습니다. 불변의 자체 포함된 C 값 시퀀스를 구성하려면 다음 메서드를 사용할 수 있습니다:</p><ul><li><code>\${type}Array.toCValues()</code>, 여기서 <code>type</code>은 Kotlin 프리미티브 타입입니다.</li><li><code>Array&lt;CPointer&lt;T&gt;?&gt;.toCValues()</code>, <code>List&lt;CPointer&lt;T&gt;?&gt;.toCValues()</code></li><li><code>cValuesOf(vararg elements: \${type})</code>, 여기서 <code>type</code>은 프리미티브 또는 포인터입니다.</li></ul><p>예시:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// C:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> elements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elements</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cValuesOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="문자열" tabindex="-1">문자열 <a class="header-anchor" href="#문자열" aria-label="Permalink to &quot;문자열&quot;">​</a></h3><p>다른 포인터와 달리, <code>const char*</code> 타입의 매개변수는 Kotlin <code>String</code>으로 표현됩니다. 따라서 Kotlin 문자열을 C 문자열을 기대하는 바인딩에 전달할 수 있습니다.</p><p>Kotlin 문자열과 C 문자열을 수동으로 변환하는 데 사용할 수 있는 도구도 있습니다:</p><ul><li><code>fun CPointer&lt;ByteVar&gt;.toKString(): String</code></li><li><code>val String.cstr: CValuesRef&lt;ByteVar&gt;</code>.</li></ul><p>포인터를 얻으려면 <code>.cstr</code>이 네이티브 메모리에 할당되어야 합니다. 예를 들어:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cString </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlinString.cstr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nativeHeap)</span></span></code></pre></div><p>모든 경우에 C 문자열은 UTF-8로 인코딩되어야 합니다.</p><p>자동 변환을 건너뛰고 바인딩에서 원시 포인터가 사용되도록 하려면 <code>.def</code> 파일에 <a href="/ko/kotlin/native-definition-file#set-up-string-conversion"><code>noStringConversion</code> 속성</a>을 추가하세요:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">noStringConversion </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LoadCursorA LoadCursorW</span></span></code></pre></div><p>이러한 방식으로 <code>CPointer&lt;ByteVar&gt;</code> 타입의 모든 값은 <code>const char*</code> 타입의 인자로 전달될 수 있습니다. Kotlin 문자열을 전달해야 한다면, 다음과 같은 코드를 사용할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kotlinx.cinterop.ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memScoped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    LoadCursorA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cursor.bmp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cstr.ptr)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// for ASCII or UTF-8 version</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    LoadCursorW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cursor.bmp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.wcstr.ptr) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// for UTF-16 version</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="스코프-로컬-포인터" tabindex="-1">스코프 로컬 포인터 <a class="header-anchor" href="#스코프-로컬-포인터" aria-label="Permalink to &quot;스코프 로컬 포인터&quot;">​</a></h3><p><code>memScoped {}</code>에서 사용 가능한 <code>CValues&lt;T&gt;.ptr</code> 확장 속성을 사용하여 <code>CValues&lt;T&gt;</code> 인스턴스에 대한 C 표현의 스코프 안정(scope-stable) 포인터를 생성할 수 있습니다. 이는 특정 <code>MemScope</code>에 수명(lifetime)이 바인딩된 C 포인터를 요구하는 API를 사용할 수 있게 합니다. 예를 들어:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kotlinx.cinterop.ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memScoped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrayOfNulls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ITEM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;?&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    arrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;one&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;two&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEachIndexed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { index, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> items[index] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cstr.ptr }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    menu </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> new_menu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Menu&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cstr.ptr, items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toCValues</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().ptr)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 예시에서 C API <code>new_menu()</code>에 전달된 모든 값은 해당 값이 속한 가장 안쪽 <code>memScope</code>의 수명을 가집니다. 제어 흐름이 <code>memScoped</code> 스코프를 벗어나면 C 포인터는 유효하지 않게 됩니다.</p><h3 id="값으로-구조체-전달-및-수신" tabindex="-1">값으로 구조체 전달 및 수신 <a class="header-anchor" href="#값으로-구조체-전달-및-수신" aria-label="Permalink to &quot;값으로 구조체 전달 및 수신&quot;">​</a></h3><p>C 함수가 구조체/공용체 <code>T</code>를 값으로 받거나 반환할 때, 해당 인자 타입 또는 반환 타입은 <code>CValue&lt;T&gt;</code>로 표현됩니다.</p><p><code>CValue&lt;T&gt;</code>는 불투명(opaque) 타입이므로, 적절한 Kotlin 속성으로는 구조체 필드에 액세스할 수 없습니다. API가 구조체를 불투명 핸들로 사용하는 경우에는 문제가 되지 않을 수 있습니다. 하지만 필드 액세스가 필요한 경우, 다음 변환 메서드를 사용할 수 있습니다:</p><ul><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/read-value.html" target="_blank" rel="noreferrer"><code>fun T.readValue(): CValue&lt;T&gt;</code></a>는 (lvalue) <code>T</code>를 <code>CValue&lt;T&gt;</code>로 변환합니다. 따라서 <code>CValue&lt;T&gt;</code>를 구성하려면 <code>T</code>를 할당하고, 채운 다음, <code>CValue&lt;T&gt;</code>로 변환할 수 있습니다.</p></li><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/use-contents.html" target="_blank" rel="noreferrer"><code>CValue&lt;T&gt;.useContents(block: T.() -&gt; R): R</code></a>는 <code>CValue&lt;T&gt;</code>를 임시로 메모리에 저장한 다음, 이 배치된 <code>T</code> 값을 리시버로 사용하여 전달된 람다를 실행합니다. 따라서 단일 필드를 읽으려면 다음 코드를 사용할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fieldValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> structValue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useContents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div></li><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/c-value.html" target="_blank" rel="noreferrer"><code>fun cValue(initialize: T.() -&gt; Unit): CValue&lt;T&gt;</code></a>는 제공된 <code>initialize</code> 함수를 적용하여 <code>T</code>를 메모리에 할당하고 그 결과를 <code>CValue&lt;T&gt;</code>로 변환합니다.</p></li><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/copy.html" target="_blank" rel="noreferrer"><code>fun CValue&lt;T&gt;.copy(modify: T.() -&gt; Unit): CValue&lt;T&gt;</code></a>는 기존 <code>CValue&lt;T&gt;</code>의 수정된 복사본을 생성합니다. 원본 값은 메모리에 배치되고, <code>modify()</code> 함수를 사용하여 변경된 다음, 새로운 <code>CValue&lt;T&gt;</code>로 다시 변환됩니다.</p></li><li><p><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/place-to.html" target="_blank" rel="noreferrer"><code>fun CValues&lt;T&gt;.placeTo(scope: AutofreeScope): CPointer&lt;T&gt;</code></a>는 <code>CValues&lt;T&gt;</code>를 <code>AutofreeScope</code>에 배치하고, 할당된 메모리에 대한 포인터를 반환합니다. 할당된 메모리는 <code>AutofreeScope</code>가 해제될 때 자동으로 해제됩니다.</p></li></ul><h3 id="콜백" tabindex="-1">콜백 <a class="header-anchor" href="#콜백" aria-label="Permalink to &quot;콜백&quot;">​</a></h3><p>Kotlin 함수를 C 함수에 대한 포인터로 변환하려면 <code>staticCFunction(::kotlinFunction)</code>을 사용할 수 있습니다. 함수 참조 대신 람다를 제공할 수도 있습니다. 함수나 람다는 어떤 값도 캡처해서는 안 됩니다.</p><h4 id="콜백에-사용자-데이터-전달" tabindex="-1">콜백에 사용자 데이터 전달 <a class="header-anchor" href="#콜백에-사용자-데이터-전달" aria-label="Permalink to &quot;콜백에 사용자 데이터 전달&quot;">​</a></h4><p>종종 C API는 콜백에 일부 사용자 데이터를 전달할 수 있도록 허용합니다. 이러한 데이터는 일반적으로 콜백을 구성할 때 사용자에 의해 제공됩니다. 예를 들어, <code>void*</code>로 일부 C 함수에 전달되거나(또는 구조체에 기록됩니다). 그러나 Kotlin 객체에 대한 참조는 C로 직접 전달될 수 없습니다. 따라서 C 세계를 통해 Kotlin에서 Kotlin으로 안전하게 이동하려면, 콜백을 구성하기 전에 래핑하고 콜백 자체에서 언래핑해야 합니다. 이러한 래핑은 <code>StableRef</code> 클래스를 사용하여 가능합니다.</p><p>참조를 래핑하려면:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stableRef </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> StableRef.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kotlinReference)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> voidPtr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stableRef.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asCPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>여기서 <code>voidPtr</code>은 <code>COpaquePointer</code>이며 C 함수에 전달될 수 있습니다.</p><p>참조를 언래핑하려면:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stableRef </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> voidPtr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asStableRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KotlinClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlinReference </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stableRef.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>여기서 <code>kotlinReference</code>는 원래 래핑된 참조입니다.</p><p>메모리 누수를 방지하기 위해 생성된 <code>StableRef</code>는 최종적으로 <code>.dispose()</code> 메서드를 사용하여 수동으로 해제되어야 합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stableRef.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>그 후에는 유효하지 않게 되므로, <code>voidPtr</code>은 더 이상 언래핑할 수 없습니다.</p><h3 id="매크로" tabindex="-1">매크로 <a class="header-anchor" href="#매크로" aria-label="Permalink to &quot;매크로&quot;">​</a></h3><p>상수로 확장되는 모든 C 매크로는 Kotlin 속성으로 표현됩니다.</p><p>매개변수가 없는 매크로는 컴파일러가 타입을 추론할 수 있는 경우에 지원됩니다:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FOO</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>이 경우 <code>FOO</code>는 Kotlin에서 사용 가능합니다.</p><p>다른 매크로를 지원하려면, 지원되는 선언으로 래핑하여 수동으로 노출할 수 있습니다. 예를 들어, 함수와 유사한 매크로 <code>FOO</code>는 라이브러리에 <a href="/ko/kotlin/native-definition-file#add-custom-declarations">사용자 정의 선언을 추가</a>하여 함수 <code>foo()</code>로 노출될 수 있습니다:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">headers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> library</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">base.h</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">---</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FOO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="이식성" tabindex="-1">이식성 <a class="header-anchor" href="#이식성" aria-label="Permalink to &quot;이식성&quot;">​</a></h3><p>때때로 C 라이브러리에는 <code>long</code> 또는 <code>size_t</code>와 같이 플랫폼 종속적인 타입의 함수 매개변수나 구조체 필드가 있습니다. Kotlin 자체는 암시적 정수 캐스트나 C-스타일 정수 캐스트(예: <code>(size_t) intValue</code>)를 제공하지 않으므로, 이러한 경우 이식 가능한 코드를 더 쉽게 작성할 수 있도록 <code>convert</code> 메서드가 제공됩니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> \${type1}.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">convert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;\${</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">type2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}&gt;(): \${type2}</span></span></code></pre></div><p>여기서 <code>type1</code>과 <code>type2</code>는 각각 부호 있는 정수 타입 또는 부호 없는 정수 타입이어야 합니다.</p><p><code>.convert&lt;\${type}&gt;</code>는 <code>type</code>에 따라 <code>.toByte</code>, <code>.toShort</code>, <code>.toInt</code>, <code>.toLong</code>, <code>.toUByte</code>, <code>.toUShort</code>, <code>.toUInt</code> 또는 <code>.toULong</code> 메서드 중 하나와 동일한 의미를 가집니다.</p><p><code>convert</code> 사용 예시:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> platform.posix.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> zeroMemory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">COpaquePointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, size: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    memset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, size.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">convert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>또한, 타입 매개변수는 자동으로 추론될 수 있으므로 일부 경우에는 생략될 수 있습니다.</p><h3 id="객체-고정" tabindex="-1">객체 고정 <a class="header-anchor" href="#객체-고정" aria-label="Permalink to &quot;객체 고정&quot;">​</a></h3><p>Kotlin 객체는 고정(pinning)될 수 있습니다. 즉, 메모리 내 위치가 고정 해제될 때까지 안정적으로 유지되며, 이러한 객체의 내부 데이터에 대한 포인터는 C 함수에 전달될 수 있습니다.</p><p>취할 수 있는 몇 가지 접근 방식이 있습니다:</p><ul><li><p>객체를 고정하고, 블록을 실행하며, 정상 및 예외 경로에서 고정 해제하는 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/use-pinned.html" target="_blank" rel="noreferrer"><code>.usePinned()</code></a> 확장 함수를 사용합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> platform.posix.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ByteArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    buffer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">usePinned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { pinned </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> recv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd, pinned.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addressOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), buffer.size.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">convert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                break</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Now \`buffer\` has raw data obtained from the \`recv()\` call.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>여기서 <code>pinned</code>는 특별한 타입인 <code>Pinned&lt;T&gt;</code>의 객체입니다. 이는 고정된 배열 본문의 주소를 얻을 수 있는 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/address-of.html" target="_blank" rel="noreferrer"><code>.addressOf()</code></a>와 같은 유용한 확장을 제공합니다.</p></li><li><p>내부적으로 유사한 기능을 가지지만, 특정 경우에 상용구 코드를 줄이는 데 도움이 될 수 있는 <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/ref-to.html" target="_blank" rel="noreferrer"><code>.refTo()</code></a> 확장 함수를 사용합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.cinterop.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> platform.posix.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalForeignApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ByteArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> recv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd, buffer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">refTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), buffer.size.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">convert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            break</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Now \`buffer\` has raw data obtained from the \`recv()\` call.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>여기서 <code>buffer.refTo(0)</code>는 <code>recv()</code> 함수에 진입하기 전에 배열을 고정하고, 해당 배열의 0번째 요소 주소를 함수에 전달하며, 함수 종료 후 배열을 고정 해제하는 <code>CValuesRef</code> 타입입니다.</p></li></ul><h3 id="전방-선언" tabindex="-1">전방 선언 <a class="header-anchor" href="#전방-선언" aria-label="Permalink to &quot;전방 선언&quot;">​</a></h3><p>전방 선언을 임포트하려면 <code>cnames</code> 패키지를 사용합니다. 예를 들어, <code>library.package</code>를 가진 C 라이브러리에 선언된 <code>cstructName</code> 전방 선언을 임포트하려면, 특별한 전방 선언 패키지인 <code>import cnames.structs.cstructName</code>를 사용합니다.</p><p>구조체의 전방 선언을 가진 라이브러리와 다른 패키지에 실제 구현을 가진 두 개의 <code>cinterop</code> 라이브러리를 고려해 보세요:</p><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// First C library</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> consumeStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Struct consumed</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Second C library</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Header:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdlib.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Implementation:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> produceStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> malloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredStruct));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s-&gt;data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>두 라이브러리 간에 객체를 전송하려면 Kotlin 코드에서 명시적인 <code>as</code> 캐스트를 사용하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin code:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    consumeStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">produceStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CPointer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cnames.structs.ForwardDeclaredStruct</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="다음-단계" tabindex="-1">다음 단계 <a class="header-anchor" href="#다음-단계" aria-label="Permalink to &quot;다음 단계&quot;">​</a></h2><p>다음 튜토리얼을 완료하여 Kotlin과 C 간에 타입, 함수, 문자열이 어떻게 매핑되는지 알아보세요:</p><ul><li><a href="/ko/kotlin/mapping-primitive-data-types-from-c">C에서 기본 데이터 타입 매핑</a></li><li><a href="/ko/kotlin/mapping-struct-union-types-from-c">C에서 구조체 및 공용체 타입 매핑</a></li><li><a href="/ko/kotlin/mapping-function-pointers-from-c">C에서 함수 포인터 매핑</a></li><li><a href="/ko/kotlin/mapping-strings-from-c">C에서 문자열 매핑</a></li></ul>`,111)]))}const c=i(l,[["render",e]]);export{E as __pageData,c as default};
