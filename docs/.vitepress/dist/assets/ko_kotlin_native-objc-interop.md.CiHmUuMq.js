import{_ as o,C as h,c as d,o as k,ag as t,G as e,j as i,w as n,a}from"./chunks/framework.Bksy39di.js";const F=JSON.parse('{"title":"Swift/Objective-C와의 상호 운용성","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/native-objc-interop.md","filePath":"ko/kotlin/native-objc-interop.md","lastUpdated":1754307826000}'),r={name:"ko/kotlin/native-objc-interop.md"};function c(E,s,g,y,b,u){const l=h("tab"),p=h("tabs");return k(),d("div",null,[s[2]||(s[2]=t(`<h1 id="swift-objective-c와의-상호-운용성" tabindex="-1">Swift/Objective-C와의 상호 운용성 <a class="header-anchor" href="#swift-objective-c와의-상호-운용성" aria-label="Permalink to &quot;Swift/Objective-C와의 상호 운용성&quot;">​</a></h1><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Objective-C 라이브러리 임포트는 <a href="/ko/kotlin/native-c-interop-stability">베타</a> 단계에 있습니다. cinterop 도구를 통해 Objective-C 라이브러리에서 생성된 모든 Kotlin 선언은 <code>@ExperimentalForeignApi</code> 어노테이션을 포함해야 합니다. Kotlin/Native와 함께 제공되는 네이티브 플랫폼 라이브러리(예: Foundation, UIKit, POSIX)는 일부 API에 대해서만 옵트인(opt-in)이 필요합니다.</p></div><p>Kotlin/Native는 Objective-C를 통해 Swift와의 간접적인 상호 운용성을 제공합니다. 이 문서에서는 Swift/Objective-C 코드에서 Kotlin 선언을 사용하는 방법과 Kotlin 코드에서 Objective-C 선언을 사용하는 방법을 다룹니다.</p><p>유용하다고 생각할 만한 다른 자료:</p><ul><li>Swift 코드에서 Kotlin 선언을 사용하는 방법에 대한 예제 모음인 <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia" target="_blank" rel="noreferrer">Kotlin-Swift interopedia</a>.</li><li>Kotlin의 트레이싱 GC와 Objective-C의 ARC 간의 통합 세부 정보를 다루는 <a href="/ko/kotlin/native-arc-integration">Swift/Objective-C ARC 통합</a> 섹션.</li></ul><h2 id="kotlin으로-swift-objective-c-라이브러리-임포트" tabindex="-1">Kotlin으로 Swift/Objective-C 라이브러리 임포트 <a class="header-anchor" href="#kotlin으로-swift-objective-c-라이브러리-임포트" aria-label="Permalink to &quot;Kotlin으로 Swift/Objective-C 라이브러리 임포트&quot;">​</a></h2><p>Objective-C 프레임워크와 라이브러리는 빌드에 제대로 임포트되면 Kotlin 코드에서 사용할 수 있습니다(시스템 프레임워크는 기본적으로 임포트됨). 자세한 내용은 다음을 참조하세요:</p><ul><li><a href="/ko/kotlin/native-definition-file">라이브러리 정의 파일 생성 및 구성</a></li><li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-configure-compilations.html#configure-interop-with-native-languages" target="_blank" rel="noreferrer">네이티브 라이브러리 컴파일 구성</a></li></ul><p>Swift 라이브러리는 <code>@objc</code>를 사용하여 API가 Objective-C로 익스포트(export)되는 경우 Kotlin 코드에서 사용할 수 있습니다. 순수 Swift 모듈은 아직 지원되지 않습니다.</p><h2 id="swift-objective-c에서-kotlin-사용" tabindex="-1">Swift/Objective-C에서 Kotlin 사용 <a class="header-anchor" href="#swift-objective-c에서-kotlin-사용" aria-label="Permalink to &quot;Swift/Objective-C에서 Kotlin 사용&quot;">​</a></h2><p>Kotlin 모듈은 프레임워크로 컴파일되면 Swift/Objective-C 코드에서 사용할 수 있습니다:</p><ul><li>바이너리를 선언하는 방법은 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-build-native-binaries.html#declare-binaries" target="_blank" rel="noreferrer">최종 네이티브 바이너리 빌드</a>를 참조하세요.</li><li>예제는 <a href="https://github.com/Kotlin/kmm-basic-sample" target="_blank" rel="noreferrer">Kotlin Multiplatform 샘플 프로젝트</a>를 확인하세요.</li></ul><h3 id="objective-c-및-swift에서-kotlin-선언-숨기기" tabindex="-1">Objective-C 및 Swift에서 Kotlin 선언 숨기기 <a class="header-anchor" href="#objective-c-및-swift에서-kotlin-선언-숨기기" aria-label="Permalink to &quot;Objective-C 및 Swift에서 Kotlin 선언 숨기기&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>@HiddenFromObjC</code> 어노테이션은 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적</a>이며 <a href="/ko/kotlin/opt-in-requirements">옵트인</a>이 필요합니다.</p></div><p>Kotlin 코드를 Swift/Objective-C 친화적으로 만들려면 <code>@HiddenFromObjC</code> 어노테이션을 사용하여 Kotlin 선언을 Objective-C 및 Swift에서 숨길 수 있습니다. 이 어노테이션은 함수 또는 프로퍼티의 Objective-C 익스포트(export)를 비활성화합니다.</p><p>대신, <code>internal</code> 한정자(modifier)로 Kotlin 선언을 마크하여 컴파일 모듈 내에서의 가시성(visibility)을 제한할 수 있습니다. <code>@HiddenFromObjC</code>는 다른 Kotlin 모듈에는 보이게 하면서 Objective-C 및 Swift에서 Kotlin 선언을 숨기려는 경우에 사용하세요.</p><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/HiddenFromObjC.md" target="_blank" rel="noreferrer">Kotlin-Swift interopedia에서 예시 보기</a>.</p><h3 id="swift에서-리파이닝-refining-사용" tabindex="-1">Swift에서 리파이닝(Refining) 사용 <a class="header-anchor" href="#swift에서-리파이닝-refining-사용" aria-label="Permalink to &quot;Swift에서 리파이닝(Refining) 사용&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>@ShouldRefineInSwift</code> 어노테이션은 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적</a>이며 <a href="/ko/kotlin/opt-in-requirements">옵트인</a>이 필요합니다.</p></div><p><code>@ShouldRefineInSwift</code>는 Kotlin 선언을 Swift로 작성된 래퍼(wrapper)로 대체하는 데 도움을 줍니다. 이 어노테이션은 생성된 Objective-C API에서 함수 또는 프로퍼티를 <code>swift_private</code>로 마크합니다. 이러한 선언에는 <code>__</code> 접두사가 붙어 Swift에서 보이지 않게 됩니다.</p><p>여전히 Swift 코드에서 이러한 선언을 사용하여 Swift 친화적인 API를 생성할 수 있지만, Xcode 자동 완성(autocomplete)에는 제안되지 않습니다.</p><ul><li>Swift에서 Objective-C 선언을 리파이닝하는 방법에 대한 자세한 내용은 <a href="https://developer.apple.com/documentation/swift/improving-objective-c-api-declarations-for-swift" target="_blank" rel="noreferrer">공식 Apple 문서</a>를 참조하세요.</li><li><code>@ShouldRefineInSwift</code> 어노테이션을 사용하는 방법에 대한 예시는 <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/ShouldRefineInSwift.md" target="_blank" rel="noreferrer">Kotlin-Swift interopedia</a>를 참조하세요.</li></ul><h3 id="선언-이름-변경" tabindex="-1">선언 이름 변경 <a class="header-anchor" href="#선언-이름-변경" aria-label="Permalink to &quot;선언 이름 변경&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p><code>@ObjCName</code> 어노테이션은 <a href="/ko/kotlin/components-stability#stability-levels-explained">실험적</a>이며 <a href="/ko/kotlin/opt-in-requirements">옵트인</a>이 필요합니다.</p></div><p>Kotlin 선언의 이름 변경을 피하려면 <code>@ObjCName</code> 어노테이션을 사용하세요. 이 어노테이션은 Kotlin 컴파일러에게 어노테이션이 붙은 클래스, 인터페이스 또는 다른 Kotlin 엔티티에 대해 사용자 지정 Objective-C 및 Swift 이름을 사용하도록 지시합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@ObjCName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(swiftName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;MySwiftArray&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyKotlinArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @ObjCName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@ObjCName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;of&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) element: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TODO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Usage with the ObjCName annotations</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MySwiftArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(of: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;element&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/ObjCName.md" target="_blank" rel="noreferrer">Kotlin-Swift interopedia에서 다른 예시 보기</a>.</p><h3 id="kdoc-주석으로-문서화-제공" tabindex="-1">KDoc 주석으로 문서화 제공 <a class="header-anchor" href="#kdoc-주석으로-문서화-제공" aria-label="Permalink to &quot;KDoc 주석으로 문서화 제공&quot;">​</a></h3><p>문서화는 모든 API를 이해하는 데 필수적입니다. 공유 Kotlin API에 대한 문서를 제공하면 사용법, 해야 할 일과 하지 말아야 할 일 등에 대해 사용자에게 전달할 수 있습니다.</p><p>기본적으로, Objective-C 헤더를 생성할 때 <a href="/ko/kotlin/kotlin-doc">KDocs</a> 주석은 해당 주석으로 번역되지 않습니다. 예를 들어, KDoc이 포함된 다음 Kotlin 코드는:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Prints the sum of the arguments.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Properly handles the case when the sum doesn&#39;t fit in 32-bit integer.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLong</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b)</span></span></code></pre></div><p>주석 없이 Objective-C 선언을 생성합니다:</p><div class="language-objc vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">objc</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)printSumA:(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)a b:(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)b </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">swift_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;printSum(a:b:)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)));</span></span></code></pre></div><p>KDoc 주석 내보내기(export)를 활성화하려면 <code>build.gradle(.kts)</code>에 다음 컴파일러 옵션을 추가하세요:</p>`,34)),e(p,{group:"build-script"},{default:n(()=>[e(l,{title:"Kotlin","group-key":"kotlin"},{default:n(()=>s[0]||(s[0]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    targets."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"withType"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"org"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"jetbrains"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"gradle"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"plugin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"mpp"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"KotlinNativeTarget"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"> {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        compilations."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"get"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"main"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},").compilerOptions.options.freeCompilerArgs."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"add"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"-Xexport-kdoc"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),e(l,{title:"Groovy","group-key":"groovy"},{default:n(()=>s[1]||(s[1]=[i("div",{class:"language-groovy vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"groovy"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"kotlin {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    targets"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"withType("),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTarget"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        compilations"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"get("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"main"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"compilerOptions"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"options"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"freeCompilerArgs"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"add("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"-Xexport-kdoc"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),s[3]||(s[3]=t(`<p>그 후, Objective-C 헤더에는 해당 주석이 포함됩니다:</p><div class="language-objc vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">objc</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Prints the sum of the arguments.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Properly handles the case when the sum doesn&#39;t fit in 32-bit integer.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)printSumA:(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)a b:(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)b </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">swift_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;printSum(a:b:)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)));</span></span></code></pre></div><p>Xcode에서와 같이 자동 완성(autocompletion)에서 클래스 및 메서드에 대한 주석을 볼 수 있습니다. 함수 정의(<code> .h</code> 파일)로 이동하면 <code>@param</code>, <code>@return</code> 등에 대한 주석을 볼 수 있습니다.</p><p>알려진 제한 사항:</p><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>KDoc 주석을 생성된 Objective-C 헤더로 내보내기(export)하는 기능은 <a href="/ko/kotlin/components-stability">실험적</a>입니다. 이 기능은 언제든지 중단되거나 변경될 수 있습니다. 옵트인(opt-in)이 필요하며(자세한 내용은 아래 참조), 평가 목적으로만 사용해야 합니다. <a href="https://youtrack.jetbrains.com/issue/KT-38600" target="_blank" rel="noreferrer">YouTrack</a>을 통해 피드백을 주시면 감사하겠습니다.</p></div><ul><li>종속성 문서화는 <code>-Xexport-kdoc</code>로 직접 컴파일되지 않는 한 내보내기되지 않습니다. 이 기능은 실험적이므로, 이 옵션으로 컴파일된 라이브러리는 다른 컴파일러 버전과 호환되지 않을 수 있습니다.</li><li>KDoc 주석은 대부분 그대로 내보내기됩니다. 예를 들어 <code>@property</code>와 같은 많은 KDoc 기능은 지원되지 않습니다.</li></ul><h2 id="매핑" tabindex="-1">매핑 <a class="header-anchor" href="#매핑" aria-label="Permalink to &quot;매핑&quot;">​</a></h2><p>아래 표는 Kotlin 개념이 Swift/Objective-C로 어떻게 매핑되는지, 그리고 그 반대의 경우도 보여줍니다.</p><p>&quot;-&gt;&quot; 및 &quot;&lt;-&quot;는 매핑이 단방향으로만 진행됨을 나타냅니다.</p><table tabindex="0"><thead><tr><th>Kotlin</th><th>Swift</th><th>Objective-C</th><th>참고</th></tr></thead><tbody><tr><td><code>class</code></td><td><code>class</code></td><td><code>@interface</code></td><td><a href="#classes">참고</a></td></tr><tr><td><code>interface</code></td><td><code>protocol</code></td><td><code>@protocol</code></td><td></td></tr><tr><td><code>constructor</code>/<code>create</code></td><td>Initializer</td><td>Initializer</td><td><a href="#initializers">참고</a></td></tr><tr><td>Property</td><td>Property</td><td>Property</td><td><a href="#top-level-functions-and-properties">참고 1</a>, <a href="#setters">참고 2</a></td></tr><tr><td>Method</td><td>Method</td><td>Method</td><td><a href="#top-level-functions-and-properties">참고 1</a>, <a href="#method-names-translation">참고 2</a></td></tr><tr><td><code>enum class</code></td><td><code>class</code></td><td><code>@interface</code></td><td><a href="#enums">참고</a></td></tr><tr><td><code>suspend</code> -&gt;</td><td><code>completionHandler:</code>/ <code>async</code></td><td><code>completionHandler:</code></td><td><a href="#errors-and-exceptions">참고 1</a>, <a href="#suspending-functions">참고 2</a></td></tr><tr><td><code>@Throws fun</code></td><td><code>throws</code></td><td><code>error:(NSError**)error</code></td><td><a href="#errors-and-exceptions">참고</a></td></tr><tr><td>Extension</td><td>Extension</td><td>Category member</td><td><a href="#extensions-and-category-members">참고</a></td></tr><tr><td><code>companion</code> member &lt;-</td><td>Class method or property</td><td>Class method or property</td><td></td></tr><tr><td><code>null</code></td><td><code>nil</code></td><td><code>nil</code></td><td></td></tr><tr><td><code>Singleton</code></td><td><code>shared</code> or <code>companion</code> property</td><td><code>shared</code> or <code>companion</code> property</td><td><a href="#kotlin-singletons">참고</a></td></tr><tr><td>Primitive type</td><td>Primitive type / <code>NSNumber</code></td><td></td><td><a href="#primitive-types">참고</a></td></tr><tr><td><code>Unit</code> return type</td><td><code>Void</code></td><td><code>void</code></td><td></td></tr><tr><td><code>String</code></td><td><code>String</code></td><td><code>NSString</code></td><td><a href="#strings">참고</a></td></tr><tr><td><code>String</code></td><td><code>NSMutableString</code></td><td><code>NSMutableString</code></td><td><a href="#nsmutablestring">참고</a></td></tr><tr><td><code>List</code></td><td><code>Array</code></td><td><code>NSArray</code></td><td></td></tr><tr><td><code>MutableList</code></td><td><code>NSMutableArray</code></td><td><code>NSMutableArray</code></td><td></td></tr><tr><td><code>Set</code></td><td><code>Set</code></td><td><code>NSSet</code></td><td></td></tr><tr><td><code>MutableSet</code></td><td><code>NSMutableSet</code></td><td><code>NSMutableSet</code></td><td><a href="#collections">참고</a></td></tr><tr><td><code>Map</code></td><td><code>Dictionary</code></td><td><code>NSDictionary</code></td><td></td></tr><tr><td><code>MutableMap</code></td><td><code>NSMutableDictionary</code></td><td><code>NSMutableDictionary</code></td><td><a href="#collections">참고</a></td></tr><tr><td>Function type</td><td>Function type</td><td>Block pointer type</td><td><a href="#function-types">참고</a></td></tr><tr><td>Inline classes</td><td>Unsupported</td><td>Unsupported</td><td><a href="#unsupported">참고</a></td></tr></tbody></table><h3 id="클래스" tabindex="-1">클래스 <a class="header-anchor" href="#클래스" aria-label="Permalink to &quot;클래스&quot;">​</a></h3><h4 id="이름-변환" tabindex="-1">이름 변환 <a class="header-anchor" href="#이름-변환" aria-label="Permalink to &quot;이름 변환&quot;">​</a></h4><p>Objective-C 클래스는 원래 이름으로 Kotlin으로 임포트됩니다. 프로토콜은 <code>Protocol</code> 이름 접미사가 붙은 인터페이스로 임포트됩니다(예: <code>@protocol Foo</code> -&gt; <code>interface FooProtocol</code>). 이러한 클래스 및 인터페이스는 <a href="#importing-swift-objective-c-libraries-to-kotlin">빌드 구성에 지정된</a> 패키지(<code>platform.*</code> 패키지는 사전 구성된 시스템 프레임워크용)에 배치됩니다.</p><p>Kotlin 클래스 및 인터페이스의 이름은 Objective-C로 임포트될 때 접두사가 붙습니다. 접두사는 프레임워크 이름에서 파생됩니다.</p><p>Objective-C는 프레임워크 내에서 패키지를 지원하지 않습니다. Kotlin 컴파일러가 동일한 프레임워크 내에서 이름은 같지만 패키지가 다른 Kotlin 클래스를 발견하면 이름을 변경합니다. 이 알고리즘은 아직 안정적이지 않으며 Kotlin 릴리스 간에 변경될 수 있습니다. 이를 해결하려면 프레임워크 내의 충돌하는 Kotlin 클래스 이름을 변경할 수 있습니다.</p><h4 id="강력한-링크" tabindex="-1">강력한 링크 <a class="header-anchor" href="#강력한-링크" aria-label="Permalink to &quot;강력한 링크&quot;">​</a></h4><p>Kotlin 소스에서 Objective-C 클래스를 사용할 때마다 강력하게 링크된 심볼로 마크됩니다. 결과 빌드 아티팩트(artifact)에는 관련 심볼이 강력한 외부 참조로 언급됩니다.</p><p>이는 앱이 실행 중 동적으로 심볼을 링크하려고 시도하며, 사용할 수 없는 경우 앱이 충돌한다는 의미입니다. 심볼이 한 번도 사용되지 않았더라도 충돌이 발생할 수 있습니다. 특정 기기 또는 OS 버전에서 심볼을 사용할 수 없을 수도 있습니다.</p><p>이 문제를 해결하고 &quot;Symbol not found&quot; 오류를 방지하려면 클래스가 실제로 사용 가능한지 확인하는 Swift 또는 Objective-C 래퍼(wrapper)를 사용하세요. <a href="https://github.com/JetBrains/compose-multiplatform-core/pull/1278/files" target="_blank" rel="noreferrer">Compose Multiplatform 프레임워크에서 이 해결 방법이 어떻게 구현되었는지 확인하세요</a>.</p><h3 id="이니셜라이저" tabindex="-1">이니셜라이저 <a class="header-anchor" href="#이니셜라이저" aria-label="Permalink to &quot;이니셜라이저&quot;">​</a></h3><p>Swift/Objective-C 이니셜라이저는 Kotlin으로 생성자(constructor) 또는 <code>create</code>라는 이름의 팩토리 메서드(factory method)로 임포트됩니다. 후자는 Kotlin에 확장 생성자(extension constructor) 개념이 없기 때문에 Objective-C 카테고리 또는 Swift 확장으로 선언된 이니셜라이저에서 발생합니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Swift 이니셜라이저를 Kotlin으로 임포트하기 전에 <code>@objc</code>로 어노테이션을 붙이는 것을 잊지 마세요.</p></div><p>Kotlin 생성자는 Swift/Objective-C로 이니셜라이저로 임포트됩니다.</p><h3 id="세터" tabindex="-1">세터 <a class="header-anchor" href="#세터" aria-label="Permalink to &quot;세터&quot;">​</a></h3><p>슈퍼클래스의 읽기 전용 프로퍼티를 오버라이드하는 쓰기 가능한 Objective-C 프로퍼티는 프로퍼티 <code>foo</code>에 대한 <code>setFoo()</code> 메서드로 표현됩니다. 변경 가능한(mutable) 것으로 구현된 프로토콜의 읽기 전용 프로퍼티도 마찬가지입니다.</p><h3 id="최상위-함수-및-프로퍼티" tabindex="-1">최상위 함수 및 프로퍼티 <a class="header-anchor" href="#최상위-함수-및-프로퍼티" aria-label="Permalink to &quot;최상위 함수 및 프로퍼티&quot;">​</a></h3><p>최상위 Kotlin 함수와 프로퍼티는 특수 클래스의 멤버로 접근할 수 있습니다. 각 Kotlin 파일은 그러한 클래스로 변환됩니다. 예를 들면:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// MyLibraryUtils.kt</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> my.library</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span></code></pre></div><p>그런 다음 Swift에서 <code>foo()</code> 함수를 다음과 같이 호출할 수 있습니다:</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyLibraryUtilsKt.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Kotlin-Swift interopedia에서 최상위 Kotlin 선언에 접근하는 예제 모음을 확인하세요:</p><ul><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/Top-level%20functions.md" target="_blank" rel="noreferrer">최상위 함수</a></li><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/functionsandproperties/Top-level%20val%20properties.md" target="_blank" rel="noreferrer">최상위 읽기 전용 프로퍼티</a></li><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/functionsandproperties/Top-level%20mutable%20var%20properties.md" target="_blank" rel="noreferrer">최상위 변경 가능한 프로퍼티</a></li></ul><h3 id="메서드-이름-변환" tabindex="-1">메서드 이름 변환 <a class="header-anchor" href="#메서드-이름-변환" aria-label="Permalink to &quot;메서드 이름 변환&quot;">​</a></h3><p>일반적으로 Swift 인수 레이블(argument label)과 Objective-C 셀렉터 조각(selector piece)은 Kotlin 매개변수 이름으로 매핑됩니다. 이 두 개념은 의미론(semantics)이 다르므로, 때때로 Swift/Objective-C 메서드가 충돌하는 Kotlin 시그니처로 임포트될 수 있습니다. 이 경우, 충돌하는 메서드는 Kotlin에서 이름 있는 인수(named argument)를 사용하여 호출할 수 있습니다. 예를 들면:</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[player moveTo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LEFT byMeters</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[player moveTo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UP byInches</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>Kotlin에서는 다음과 같습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">player.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">moveTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(LEFT, byMeters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">player.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">moveTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UP, byInches </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>다음은 <code>kotlin.Any</code> 함수가 Swift/Objective-C에 매핑되는 방식입니다:</p><table tabindex="0"><thead><tr><th>Kotlin</th><th>Swift</th><th>Objective-C</th></tr></thead><tbody><tr><td><code>equals()</code></td><td><code>isEquals(_:)</code></td><td><code>isEquals:</code></td></tr><tr><td><code>hashCode()</code></td><td><code>hash</code></td><td><code>hash</code></td></tr><tr><td><code>toString()</code></td><td><code>description</code></td><td><code>description</code></td></tr></tbody></table><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Data%20classes.md" target="_blank" rel="noreferrer">Kotlin-Swift interopedia에서 데이터 클래스 예시 보기</a>.</p><p><a href="#change-declaration-names"><code>@ObjCName</code> 어노테이션</a>으로 Kotlin 선언의 이름을 변경하는 대신 Swift 또는 Objective-C에서 더 관용적인 이름을 지정할 수 있습니다.</p><h3 id="오류-및-예외" tabindex="-1">오류 및 예외 <a class="header-anchor" href="#오류-및-예외" aria-label="Permalink to &quot;오류 및 예외&quot;">​</a></h3><p>모든 Kotlin 예외는 비검사(unchecked) 예외이며, 이는 오류가 런타임에 포착됨을 의미합니다. 그러나 Swift는 컴파일 타임에 처리되는 검사(checked) 예외만 가집니다. 따라서 Swift 또는 Objective-C 코드가 예외를 던지는(throw) Kotlin 메서드를 호출하는 경우, Kotlin 메서드는 &quot;예상되는&quot; 예외 클래스 목록을 지정하는 <code>@Throws</code> 어노테이션으로 마크되어야 합니다.</p><p>Swift/Objective-C 프레임워크로 컴파일할 때, <code>@Throws</code> 어노테이션을 가지거나 상속하는 비-<code>suspend</code> 함수는 Objective-C에서는 <code>NSError*</code>-생성 메서드로, Swift에서는 <code>throws</code> 메서드로 표현됩니다. <code>suspend</code> 함수에 대한 표현은 항상 완료 핸들러(completion handler)에 <code>NSError*</code>/<code>Error</code> 매개변수를 가집니다.</p><p>Swift/Objective-C 코드에서 호출된 Kotlin 함수가 <code>@Throws</code>로 지정된 클래스 중 하나 또는 해당 서브클래스의 인스턴스인 예외를 던지는 경우, 해당 예외는 <code>NSError</code>로 전파됩니다. Swift/Objective-C에 도달하는 다른 Kotlin 예외는 처리되지 않은 것으로 간주되어 프로그램 종료를 유발합니다.</p><p><code>@Throws</code>가 없는 <code>suspend</code> 함수는 <code>CancellationException</code>만 전파합니다(<code>NSError</code>로). <code>@Throws</code>가 없는 비-<code>suspend</code> 함수는 Kotlin 예외를 전혀 전파하지 않습니다.</p><p>반대 방향의 역변환은 아직 구현되지 않았습니다. 즉, Swift/Objective-C 오류 던지기(error-throwing) 메서드는 예외 던지기(exception-throwing)로 Kotlin에 임포트되지 않습니다.</p><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/Exceptions.md" target="_blank" rel="noreferrer">Kotlin-Swift interopedia에서 예시 보기</a>.</p><h3 id="enum" tabindex="-1">Enum <a class="header-anchor" href="#enum" aria-label="Permalink to &quot;Enum&quot;">​</a></h3><p>Kotlin enum은 Objective-C로는 <code>@interface</code>로, Swift로는 <code>class</code>로 임포트됩니다. 이러한 데이터 구조는 각 enum 값에 해당하는 프로퍼티를 가집니다. 다음 Kotlin 코드를 고려해 보세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Colors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RED, GREEN, BLUE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Swift에서 이 enum 클래스의 프로퍼티에 다음과 같이 접근할 수 있습니다:</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Swift</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Colors.red</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Colors.green</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Colors.blue</span></span></code></pre></div><p>Swift <code>switch</code> 문에서 Kotlin enum 변수를 사용하려면 컴파일 오류를 방지하기 위해 <code>default</code> 문을 제공해야 합니다:</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> color {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .red</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;It&#39;s red&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .green</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;It&#39;s green&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .blue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;It&#39;s blue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    default:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fatalError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;No such color&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Enum%20classes.md" target="_blank" rel="noreferrer">Kotlin-Swift interopedia에서 다른 예시 보기</a>.</p><h3 id="중단-suspending-함수" tabindex="-1">중단(Suspending) 함수 <a class="header-anchor" href="#중단-suspending-함수" aria-label="Permalink to &quot;중단(Suspending) 함수&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>Swift 코드에서 <code>suspend</code> 함수를 <code>async</code>로 호출하는 지원은 <a href="/ko/kotlin/components-stability">실험적</a>입니다. 이 기능은 언제든지 중단되거나 변경될 수 있습니다. 평가 목적으로만 사용해야 합니다. <a href="https://youtrack.jetbrains.com/issue/KT-47610" target="_blank" rel="noreferrer">YouTrack</a>을 통해 피드백을 주시면 감사하겠습니다.</p></div><p>Kotlin의 <a href="/ko/kotlin/coroutines-basics">중단 함수</a> (<code>suspend</code>)는 생성된 Objective-C 헤더에서 콜백을 가진 함수 또는 Swift/Objective-C 용어로는 <a href="https://developer.apple.com/documentation/swift/calling_objective-c_apis_asynchronously" target="_blank" rel="noreferrer">완료 핸들러</a>로 표현됩니다.</p><p>Swift 5.5부터 Kotlin의 <code>suspend</code> 함수는 완료 핸들러(completion handler)를 사용하지 않고도 Swift에서 <code>async</code> 함수로 호출할 수 있습니다. 현재 이 기능은 매우 실험적이며 특정 제한 사항이 있습니다. 자세한 내용은 <a href="https://youtrack.jetbrains.com/issue/KT-47610" target="_blank" rel="noreferrer">이 YouTrack 이슈</a>를 참조하세요.</p><ul><li>Swift 문서에서 <a href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html" target="_blank" rel="noreferrer"><code>async</code>/<code>await</code> 메커니즘</a>에 대해 자세히 알아보세요.</li><li>동일한 기능을 구현하는 서드파티 라이브러리에 대한 예시 및 권장 사항은 <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/coroutines/Suspend%20functions.md" target="_blank" rel="noreferrer">Kotlin-Swift interopedia</a>를 참조하세요.</li></ul><h3 id="확장-extension-및-카테고리-멤버" tabindex="-1">확장(Extension) 및 카테고리 멤버 <a class="header-anchor" href="#확장-extension-및-카테고리-멤버" aria-label="Permalink to &quot;확장(Extension) 및 카테고리 멤버&quot;">​</a></h3><p>Objective-C 카테고리 및 Swift 확장의 멤버는 일반적으로 Kotlin으로 확장으로 임포트됩니다. 그렇기 때문에 이 선언은 Kotlin에서 오버라이드될 수 없으며, 확장 이니셜라이저는 Kotlin 생성자로 사용할 수 없습니다.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>현재 두 가지 예외가 있습니다. Kotlin 1.8.20부터 NSView 클래스(AppKit 프레임워크) 또는 UIView 클래스(UIKit 프레임워크)와 동일한 헤더에 선언된 카테고리 멤버는 해당 클래스의 멤버로 임포트됩니다. 이는 NSView 또는 UIView에서 서브클래스(subclass)하는 메서드를 오버라이드할 수 있음을 의미합니다.</p></div><p>&quot;일반&quot; Kotlin 클래스에 대한 Kotlin 확장은 Swift 및 Objective-C로 각각 확장 및 카테고리 멤버로 임포트됩니다. 다른 유형에 대한 Kotlin 확장은 추가 수신기(receiver) 매개변수를 가진 <a href="#top-level-functions-and-properties">최상위 선언</a>으로 처리됩니다. 이러한 유형에는 다음이 포함됩니다:</p><ul><li>Kotlin <code>String</code> 유형</li><li>Kotlin 컬렉션 유형 및 서브타입</li><li>Kotlin <code>interface</code> 유형</li><li>Kotlin 원시(primitive) 유형</li><li>Kotlin <code>inline</code> 클래스</li><li>Kotlin <code>Any</code> 유형</li><li>Kotlin 함수 유형 및 서브타입</li><li>Objective-C 클래스 및 프로토콜</li></ul><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/tree/main/docs/extensions" target="_blank" rel="noreferrer">Kotlin-Swift interopedia에서 예제 모음 보기</a>.</p><h3 id="kotlin-싱글톤" tabindex="-1">Kotlin 싱글톤 <a class="header-anchor" href="#kotlin-싱글톤" aria-label="Permalink to &quot;Kotlin 싱글톤&quot;">​</a></h3><p>Kotlin 싱글톤(<code>object</code> 선언으로 생성, <code>companion object</code> 포함)은 단일 인스턴스를 가진 클래스로 Swift/Objective-C로 임포트됩니다.</p><p>인스턴스는 <code>shared</code> 및 <code>companion</code> 프로퍼티를 통해 사용할 수 있습니다.</p><p>다음 Kotlin 코드의 경우:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">object</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Some value&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    companion</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Some value&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>다음과 같이 이 객체에 접근하세요:</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyObject.shared</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyObject.shared.x</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyClass.companion</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyClass.Companion.shared</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Objective-C에서 <code>[MySingleton mySingleton]</code>를 통해 객체에 접근하거나 Swift에서 <code>MySingleton()</code>을 통해 객체에 접근하는 것은 더 이상 사용되지 않습니다.</p></div><p>Kotlin-Swift interopedia에서 더 많은 예시를 확인하세요:</p><ul><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Objects.md" target="_blank" rel="noreferrer"><code>shared</code>를 사용하여 Kotlin 객체에 접근하는 방법</a></li><li><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Companion%20objects.md" target="_blank" rel="noreferrer">Swift에서 Kotlin <code>companion object</code>의 멤버에 접근하는 방법</a>.</li></ul><h3 id="원시-primitive-타입" tabindex="-1">원시(Primitive) 타입 <a class="header-anchor" href="#원시-primitive-타입" aria-label="Permalink to &quot;원시(Primitive) 타입&quot;">​</a></h3><p>Kotlin 원시(primitive) 타입 박스(box)는 특수 Swift/Objective-C 클래스로 매핑됩니다. 예를 들어, <code>kotlin.Int</code> 박스는 Swift에서는 <code>KotlinInt</code> 클래스 인스턴스로(Objective-C에서는 <code>\${prefix}Int</code> 인스턴스, 여기서 <code>prefix</code>는 프레임워크의 이름 접두사), 표현됩니다. 이 클래스들은 <code>NSNumber</code>에서 파생되었으므로, 인스턴스는 모든 해당 연산을 지원하는 적절한 <code>NSNumber</code>입니다.</p><p><code>NSNumber</code> 타입은 Swift/Objective-C 매개변수 타입 또는 반환 값으로 사용될 때 Kotlin 원시 타입으로 자동 변환되지 않습니다. 그 이유는 <code>NSNumber</code> 타입이 래핑된 원시 값 타입에 대한 충분한 정보를 제공하지 않기 때문입니다(예: <code>NSNumber</code>는 정적으로 <code>Byte</code>, <code>Boolean</code> 또는 <code>Double</code>인지 알 수 없습니다). 따라서 Kotlin 원시 값은 <code>NSNumber</code>로 <a href="#casting-between-mapped-types">수동으로 형변환(cast)되어야 합니다</a>.</p><h3 id="문자열-string" tabindex="-1">문자열(String) <a class="header-anchor" href="#문자열-string" aria-label="Permalink to &quot;문자열(String)&quot;">​</a></h3><p>Kotlin <code>String</code>이 Swift로 전달될 때, 먼저 Objective-C 객체로 익스포트(export)된 다음, Swift 컴파일러가 Swift 변환을 위해 한 번 더 복사합니다. 이로 인해 추가적인 런타임 오버헤드가 발생합니다.</p><p>이를 피하려면 Swift에서 Kotlin 문자열을 Objective-C <code>NSString</code>로 직접 접근해야 합니다. <a href="#see-the-conversion-example">변환 예시</a>를 참조하세요.</p><h4 id="nsmutablestring" tabindex="-1">NSMutableString <a class="header-anchor" href="#nsmutablestring" aria-label="Permalink to &quot;NSMutableString&quot;">​</a></h4><p><code>NSMutableString</code> Objective-C 클래스는 Kotlin에서 사용할 수 없습니다. <code>NSMutableString</code>의 모든 인스턴스는 Kotlin으로 전달될 때 복사됩니다.</p><h3 id="컬렉션-collection" tabindex="-1">컬렉션(Collection) <a class="header-anchor" href="#컬렉션-collection" aria-label="Permalink to &quot;컬렉션(Collection)&quot;">​</a></h3><h4 id="kotlin-objective-c-swift" tabindex="-1">Kotlin -&gt; Objective-C -&gt; Swift <a class="header-anchor" href="#kotlin-objective-c-swift" aria-label="Permalink to &quot;Kotlin -&gt; Objective-C -&gt; Swift&quot;">​</a></h4><p>Kotlin 컬렉션이 Swift로 전달될 때, 먼저 Objective-C 동등한(equivalent) 형태로 변환된 다음, Swift 컴파일러가 전체 컬렉션을 복사하여 <a href="#mappings">매핑 테이블</a>에 설명된 대로 Swift 네이티브 컬렉션으로 변환합니다.</p><p>이 마지막 변환은 성능 저하를 초래합니다. 이를 방지하려면 Swift에서 Kotlin 컬렉션을 사용할 때 명시적으로 Objective-C에 해당하는 <code>NSDictionary</code>, <code>NSArray</code>, <code>NSSet</code> 등으로 형변환(cast)해야 합니다.</p>`,89)),s[4]||(s[4]=i("h5",{"initial-collapse-state":"collapsed",collapsible:"true",id:"변환-예시-보기",tabindex:"-1"},[a("변환 예시 보기 "),i("a",{class:"header-anchor",href:"#변환-예시-보기","aria-label":'Permalink to "변환 예시 보기 {initial-collapse-state="collapsed" collapsible="true"}"'},"​")],-1)),s[5]||(s[5]=t(`<p>예를 들어, 다음 Kotlin 선언은:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> map: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Swift에서는 다음과 같이 보일 수 있습니다:</p><div class="language-Swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map[key]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ??</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre></div><p>여기서 <code>map</code>은 Swift의 <code>Dictionary</code>로 암시적으로 변환되며, 문자열 값은 Swift의 <code>String</code>으로 매핑됩니다. 이는 성능 저하를 초래합니다.</p><p>변환을 피하려면 <code>map</code>을 Objective-C의 <code>NSDictionary</code>로 명시적으로 형변환(cast)하고 값을 <code>NSString</code>으로 접근해야 합니다:</p><div class="language-Swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsMap: NSDictionary </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> map </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NSDictionary</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nsMap[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NSString)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">??</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre></div><p>이렇게 하면 Swift 컴파일러가 추가 변환 단계를 수행하지 않습니다.</p><h4 id="swift-objective-c-kotlin" tabindex="-1">Swift -&gt; Objective-C -&gt; Kotlin <a class="header-anchor" href="#swift-objective-c-kotlin" aria-label="Permalink to &quot;Swift -&gt; Objective-C -&gt; Kotlin&quot;">​</a></h4><p>Swift/Objective-C 컬렉션은 <code>NSMutableSet</code> 및 <code>NSMutableDictionary</code>를 제외하고 <a href="#mappings">매핑 테이블</a>에 설명된 대로 Kotlin으로 매핑됩니다.</p><p><code>NSMutableSet</code>은 Kotlin의 <code>MutableSet</code>으로 변환되지 않습니다. Kotlin <code>MutableSet</code>으로 객체를 전달하려면 이러한 종류의 Kotlin 컬렉션을 명시적으로 생성해야 합니다. 예를 들어, Kotlin에서는 <code>mutableSetOf()</code> 함수를 사용하고 Swift에서는 <code>KotlinMutableSet</code> 클래스를, Objective-C에서는 <code>\${prefix}MutableSet</code>을 사용하세요(<code>prefix</code>는 프레임워크 이름 접두사). <code>MutableMap</code>도 마찬가지입니다.</p><p><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/Collections.md" target="_blank" rel="noreferrer">Kotlin-Swift interopedia에서 예시 보기</a>.</p><h3 id="함수-타입" tabindex="-1">함수 타입 <a class="header-anchor" href="#함수-타입" aria-label="Permalink to &quot;함수 타입&quot;">​</a></h3><p>Kotlin 함수 타입 객체(예: 람다)는 Swift에서는 함수로, Objective-C에서는 블록으로 변환됩니다. <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/functionsandproperties/Functions%20returning%20function%20type.md" target="_blank" rel="noreferrer">Kotlin-Swift interopedia에서 람다를 사용하는 Kotlin 함수의 예시를 참조하세요</a>.</p><p>그러나 함수와 함수 타입을 번역할 때 매개변수와 반환 값의 타입이 매핑되는 방식에는 차이가 있습니다. 후자의 경우, 원시 타입은 박스화된 표현으로 매핑됩니다. Kotlin <code>Unit</code> 반환 값은 Swift/Objective-C에서 해당 <code>Unit</code> 싱글톤으로 표현됩니다. 이 싱글톤의 값은 다른 Kotlin <code>object</code>와 동일한 방식으로 검색할 수 있습니다. 위 <a href="#mappings">표</a>의 싱글톤을 참조하세요.</p><p>다음 Kotlin 함수를 고려해 보세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. }</span></span></code></pre></div><p>Swift에서는 다음과 같이 표현됩니다:</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (KotlinInt) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KotlinUnit)</span></span></code></pre></div><p>그리고 다음과 같이 호출할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Int32)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> KotlinUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="제네릭-generics" tabindex="-1">제네릭(Generics) <a class="header-anchor" href="#제네릭-generics" aria-label="Permalink to &quot;제네릭(Generics)&quot;">​</a></h3><p>Objective-C는 클래스에 정의된 &quot;경량 제네릭(lightweight generics)&quot;을 지원하지만, 기능 집합이 비교적 제한적입니다. Swift는 클래스에 정의된 제네릭을 임포트하여 컴파일러에 추가 타입 정보를 제공하는 데 도움을 줄 수 있습니다.</p><p>Objective-C 및 Swift의 제네릭 기능 지원은 Kotlin과 다르므로, 변환 시 일부 정보가 필연적으로 손실되지만, 지원되는 기능은 의미 있는 정보를 유지합니다.</p><p>Swift에서 Kotlin 제네릭을 사용하는 방법에 대한 구체적인 예시는 <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/ShouldRefineInSwift.md" target="_blank" rel="noreferrer">Kotlin-Swift interopedia</a>를 참조하세요.</p><h4 id="제한-사항" tabindex="-1">제한 사항 <a class="header-anchor" href="#제한-사항" aria-label="Permalink to &quot;제한 사항&quot;">​</a></h4><p>Objective-C 제네릭은 Kotlin이나 Swift의 모든 기능을 지원하지 않으므로, 변환 시 일부 정보가 손실됩니다.</p><p>제네릭은 클래스에만 정의할 수 있으며, 인터페이스(Objective-C 및 Swift의 프로토콜) 또는 함수에는 정의할 수 없습니다.</p><h4 id="null-허용-여부-nullability" tabindex="-1">Null 허용 여부(Nullability) <a class="header-anchor" href="#null-허용-여부-nullability" aria-label="Permalink to &quot;Null 허용 여부(Nullability)&quot;">​</a></h4><p>Kotlin과 Swift는 모두 null 허용 여부(nullability)를 타입 지정의 일부로 정의하는 반면, Objective-C는 타입의 메서드 및 프로퍼티에 null 허용 여부를 정의합니다. 따라서 다음 Kotlin 코드는:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Swift에서는 다음과 같이 보입니다:</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fun </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">myVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>잠재적으로 null을 허용하는 타입을 지원하려면 Objective-C 헤더에서 <code>myVal</code>을 null을 허용하는 반환 값으로 정의해야 합니다.</p><p>이를 완화하기 위해 제네릭 타입을 정의할 때 제네릭 타입이 <em>절대</em> null이 아니어야 한다면 null을 허용하지 않는 타입 제약 조건(constraint)을 제공하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이렇게 하면 Objective-C 헤더가 <code>myVal</code>을 null을 허용하지 않는 것으로 마크하도록 강제합니다.</p><h4 id="분산-variance" tabindex="-1">분산(Variance) <a class="header-anchor" href="#분산-variance" aria-label="Permalink to &quot;분산(Variance)&quot;">​</a></h4><p>Objective-C는 제네릭을 공변(covariant) 또는 반공변(contravariant)으로 선언할 수 있도록 허용합니다. Swift는 분산(variance)을 지원하지 않습니다. Objective-C에서 오는 제네릭 클래스는 필요에 따라 강제 형변환(force-cast)할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BaseData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GenVarOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">out</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arg: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> variOut </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GenVarOut</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SomeData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: sd)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> variOutAny : GenVarOut&lt;BaseData&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> variOut </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GenVarOut</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BaseData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><h4 id="제약-조건-constraints" tabindex="-1">제약 조건(Constraints) <a class="header-anchor" href="#제약-조건-constraints" aria-label="Permalink to &quot;제약 조건(Constraints)&quot;">​</a></h4><p>Kotlin에서는 제네릭 타입에 대한 상위 바운드(upper bounds)를 제공할 수 있습니다. Objective-C도 이를 지원하지만, 더 복잡한 경우에는 지원되지 않으며 현재 Kotlin-Objective-C 상호 운용성에서는 지원되지 않습니다. 여기서 예외는 null을 허용하지 않는 상위 바운드가 Objective-C 메서드/프로퍼티를 null을 허용하지 않는 것으로 만들 것입니다.</p><h4 id="비활성화" tabindex="-1">비활성화 <a class="header-anchor" href="#비활성화" aria-label="Permalink to &quot;비활성화&quot;">​</a></h4><p>프레임워크 헤더가 제네릭 없이 작성되도록 하려면 빌드 파일에 다음 컴파일러 옵션을 추가하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">binaries.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">framework</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    freeCompilerArgs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;-Xno-objc-generics&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="전방-선언-forward-declarations" tabindex="-1">전방 선언(Forward declarations) <a class="header-anchor" href="#전방-선언-forward-declarations" aria-label="Permalink to &quot;전방 선언(Forward declarations)&quot;">​</a></h3><p>전방 선언을 임포트하려면 <code>objcnames.classes</code> 및 <code>objcnames.protocols</code> 패키지를 사용하세요. 예를 들어, <code>library.package</code>를 가진 Objective-C 라이브러리에 선언된 <code>objcprotocolName</code> 전방 선언을 임포트하려면 특수 전방 선언 패키지인 <code>import objcnames.protocols.objcprotocolName</code>를 사용하세요.</p><p>두 개의 objcinterop 라이브러리를 고려해 보세요. 하나는 <code>objcnames.protocols.ForwardDeclaredProtocolProtocol</code>을 사용하고 다른 하나는 다른 패키지에 실제 구현이 있습니다:</p><div class="language-ObjC vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ObjC</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// First objcinterop library</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;Foundation/Foundation.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@protocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ForwardDeclaredProtocol;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NSString</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> consumeProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;ForwardDeclaredProtocol&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NSString</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> stringWithUTF8String:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Protocol&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-ObjC vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ObjC</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Second objcinterop library</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Header:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;Foundation/Foundation.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@protocol</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ForwardDeclaredProtocol</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@end</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Implementation:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ForwardDeclaredProtocolImpl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NSObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;ForwardDeclaredProtocol&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;ForwardDeclaredProtocol&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">produceProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ForwardDeclaredProtocolImpl </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>두 라이브러리 간에 객체를 전송하려면 Kotlin 코드에서 명시적인 <code>as</code> 형변환(cast)을 사용하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Kotlin code:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    consumeProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">produceProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> objcnames.protocols.ForwardDeclaredProtocolProtocol)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>해당 실제 클래스에서만 <code>objcnames.protocols.ForwardDeclaredProtocolProtocol</code>로 형변환(cast)할 수 있습니다. 그렇지 않으면 오류가 발생합니다.</p></div><h2 id="매핑된-타입-간의-형변환-casting" tabindex="-1">매핑된 타입 간의 형변환(Casting) <a class="header-anchor" href="#매핑된-타입-간의-형변환-casting" aria-label="Permalink to &quot;매핑된 타입 간의 형변환(Casting)&quot;">​</a></h2><p>Kotlin 코드를 작성할 때, 객체가 Kotlin 타입에서 동등한 Swift/Objective-C 타입으로(또는 그 반대로) 변환되어야 할 수 있습니다. 이 경우 일반적인 Kotlin 형변환(cast)을 사용할 수 있습니다. 예를 들면:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NSArray</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsString </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsNumber </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NSNumber</span></span></code></pre></div><h2 id="서브클래싱-subclassing" tabindex="-1">서브클래싱(Subclassing) <a class="header-anchor" href="#서브클래싱-subclassing" aria-label="Permalink to &quot;서브클래싱(Subclassing)&quot;">​</a></h2><h3 id="swift-objective-c에서-kotlin-클래스-및-인터페이스-서브클래싱" tabindex="-1">Swift/Objective-C에서 Kotlin 클래스 및 인터페이스 서브클래싱 <a class="header-anchor" href="#swift-objective-c에서-kotlin-클래스-및-인터페이스-서브클래싱" aria-label="Permalink to &quot;Swift/Objective-C에서 Kotlin 클래스 및 인터페이스 서브클래싱&quot;">​</a></h3><p>Kotlin 클래스 및 인터페이스는 Swift/Objective-C 클래스 및 프로토콜에 의해 서브클래싱될 수 있습니다.</p><h3 id="kotlin에서-swift-objective-c-클래스-및-프로토콜-서브클래싱" tabindex="-1">Kotlin에서 Swift/Objective-C 클래스 및 프로토콜 서브클래싱 <a class="header-anchor" href="#kotlin에서-swift-objective-c-클래스-및-프로토콜-서브클래싱" aria-label="Permalink to &quot;Kotlin에서 Swift/Objective-C 클래스 및 프로토콜 서브클래싱&quot;">​</a></h3><p>Swift/Objective-C 클래스 및 프로토콜은 Kotlin <code>final</code> 클래스로 서브클래싱될 수 있습니다. Swift/Objective-C 타입을 상속하는 비-<code>final</code> Kotlin 클래스는 아직 지원되지 않으므로, Swift/Objective-C 타입을 상속하는 복잡한 클래스 계층 구조를 선언하는 것은 불가능합니다.</p><p>일반 메서드는 Kotlin <code>override</code> 키워드를 사용하여 오버라이드될 수 있습니다. 이 경우, 오버라이드하는 메서드는 오버라이드된 메서드와 동일한 매개변수 이름을 가져야 합니다.</p><p>때로는 이니셜라이저를 오버라이드해야 할 필요가 있습니다. 예를 들어 <code>UIViewController</code>를 서브클래싱할 때입니다. Kotlin 생성자로 임포트된 이니셜라이저는 <code>@OverrideInit</code> 어노테이션으로 마크된 Kotlin 생성자에 의해 오버라이드될 수 있습니다:</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ViewController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UIViewController </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @OverrideInit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">coder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: NSCoder) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coder)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>오버라이드하는 생성자는 오버라이드된 생성자와 동일한 매개변수 이름과 타입을 가져야 합니다.</p><p>충돌하는 Kotlin 시그니처를 가진 다른 메서드를 오버라이드하려면 클래스에 <code>@ObjCSignatureOverride</code> 어노테이션을 추가할 수 있습니다. 이 어노테이션은 Objective-C 클래스에서 동일한 인수 타입이지만 다른 인수 이름을 가진 여러 함수가 상속되는 경우, Kotlin 컴파일러에게 충돌하는 오버로드(overload)를 무시하도록 지시합니다.</p><p>기본적으로 Kotlin/Native 컴파일러는 비지정 Objective-C 이니셜라이저를 <code>super()</code> 생성자로 호출하는 것을 허용하지 않습니다. 이 동작은 Objective-C 라이브러리에서 지정된 이니셜라이저가 제대로 마크되지 않은 경우 불편할 수 있습니다. 이러한 컴파일러 검사를 비활성화하려면 라이브러리의 <a href="/ko/kotlin/native-definition-file"><code>.def</code> 파일</a>에 <code>disableDesignatedInitializerChecks = true</code>를 추가하세요.</p><h2 id="c-기능" tabindex="-1">C 기능 <a class="header-anchor" href="#c-기능" aria-label="Permalink to &quot;C 기능&quot;">​</a></h2><p>라이브러리가 안전하지 않은(unsafe) 포인터, 구조체(struct) 등 일부 일반 C 기능을 사용하는 경우의 예시는 <a href="/ko/kotlin/native-c-interop">C와의 상호 운용성</a>을 참조하세요.</p><h2 id="지원되지-않음" tabindex="-1">지원되지 않음 <a class="header-anchor" href="#지원되지-않음" aria-label="Permalink to &quot;지원되지 않음&quot;">​</a></h2><p>Kotlin 프로그래밍 언어의 일부 기능은 아직 Objective-C 또는 Swift의 해당 기능으로 매핑되지 않았습니다. 현재, 생성된 프레임워크 헤더에서 다음 기능은 제대로 노출되지 않습니다:</p><ul><li>인라인(Inline) 클래스(인수는 기본 원시 타입 또는 <code>id</code>로 매핑됨)</li><li>표준 Kotlin 컬렉션 인터페이스(<code>List</code>, <code>Map</code>, <code>Set</code>) 및 기타 특수 클래스를 구현하는 사용자 지정 클래스</li><li>Objective-C 클래스의 Kotlin 서브클래스</li></ul>`,73))])}const v=o(r,[["render",c]]);export{F as __pageData,v as default};
