import{_ as a,c as i,o as e,ag as s}from"./chunks/framework.Bksy39di.js";const k=JSON.parse('{"title":"操作符重载","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/operator-overloading.md","filePath":"kotlin/operator-overloading.md","lastUpdated":1754307826000}'),d={name:"kotlin/operator-overloading.md"};function o(n,t,l,h,c,r){return e(),i("div",null,t[0]||(t[0]=[s(`<h1 id="操作符重载" tabindex="-1">操作符重载 <a class="header-anchor" href="#操作符重载" aria-label="Permalink to &quot;操作符重载&quot;">​</a></h1><p>Kotlin 允许你为类型上预定义的操作符集提供自定义实现。这些操作符具有预定义的符号表示（如 <code>+</code> 或 <code>*</code>）和优先级。要实现一个操作符，需为对应类型提供一个具有特定名称的<a href="/kotlin/functions#member-functions">成员函数</a>或<a href="/kotlin/extensions">扩展函数</a>。该类型会成为二元操作的左侧类型以及一元操作的实参类型。</p><p>要重载一个操作符，请使用 <code>operator</code> 修饰符标记相应的函数：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IndexedContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    operator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>当<a href="/kotlin/inheritance#overriding-methods">覆盖</a>你的操作符重载时，你可以省略 <code>operator</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OrdersList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IndexedContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*...*/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="一元操作" tabindex="-1">一元操作 <a class="header-anchor" href="#一元操作" aria-label="Permalink to &quot;一元操作&quot;">​</a></h2><h3 id="一元前缀操作符" tabindex="-1">一元前缀操作符 <a class="header-anchor" href="#一元前缀操作符" aria-label="Permalink to &quot;一元前缀操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表达式</th><th>转换为</th></tr></thead><tbody><tr><td><code>+a</code></td><td><code>a.unaryPlus()</code></td></tr><tr><td><code>-a</code></td><td><code>a.unaryMinus()</code></td></tr><tr><td><code>!a</code></td><td><code>a.not()</code></td></tr></tbody></table><p>该表表示，当编译器处理例如表达式 <code>+a</code> 时，它会执行以下步骤：</p><ul><li>确定 <code>a</code> 的类型，假设为 <code>T</code>。</li><li>查找一个带有 <code>operator</code> 修饰符且无形参的 <code>unaryPlus()</code> 函数，适用于接收者 <code>T</code>，这意味着它是一个成员函数或扩展函数。</li><li>如果该函数不存在或有歧义，则会报告编译错误。</li><li>如果该函数存在且其返回类型为 <code>R</code>，则表达式 <code>+a</code> 的类型为 <code>R</code>。</li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>这些操作以及所有其他操作都针对<a href="/kotlin/basic-types">基本类型</a>进行了优化，并且不会为它们引入函数调用的开销。</p></div><p>作为一个示例，以下是如何重载一元负号操作符的方法：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">operator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unaryMinus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">y)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> point </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">point)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// prints &quot;Point(x=-10, y=-20)&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="递增和递减" tabindex="-1">递增和递减 <a class="header-anchor" href="#递增和递减" aria-label="Permalink to &quot;递增和递减&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表达式</th><th>转换为</th></tr></thead><tbody><tr><td><code>a++</code></td><td><code>a.inc()</code> + 见下文</td></tr><tr><td><code>a--</code></td><td><code>a.dec()</code> + 见下文</td></tr></tbody></table><p><code>inc()</code> 和 <code>dec()</code> 函数必须返回一个值，该值将赋值给使用 <code>++</code> 或 <code>--</code> 操作的变量。它们不应修改调用 <code>inc</code> 或 <code>dec</code> 的对象。</p><p>编译器会针对<em>后缀</em>形式的操作符解析执行以下步骤，例如 <code>a++</code>：</p><ul><li>确定 <code>a</code> 的类型，假设为 <code>T</code>。</li><li>查找一个带有 <code>operator</code> 修饰符且无形参的 <code>inc()</code> 函数，适用于 <code>T</code> 类型的接收者。</li><li>检测该函数的返回类型是 <code>T</code> 的子类型。</li></ul><p>计算该表达式的效果是：</p><ul><li>将 <code>a</code> 的初始值存储到临时存储 <code>a0</code> 中。</li><li>将 <code>a0.inc()</code> 的结果赋值给 <code>a</code>。</li><li>将 <code>a0</code> 作为表达式的结果返回。</li></ul><p>对于 <code>a--</code>，步骤完全类似。</p><p>对于<em>前缀</em>形式 <code>++a</code> 和 <code>--a</code>，解析方式相同，效果是：</p><ul><li>将 <code>a.inc()</code> 的结果赋值给 <code>a</code>。</li><li>将 <code>a</code> 的新值作为表达式的结果返回。</li></ul><h2 id="二元操作" tabindex="-1">二元操作 <a class="header-anchor" href="#二元操作" aria-label="Permalink to &quot;二元操作&quot;">​</a></h2><h3 id="算术操作符" tabindex="-1">算术操作符 <a class="header-anchor" href="#算术操作符" aria-label="Permalink to &quot;算术操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表达式</th><th>转换为</th></tr></thead><tbody><tr><td><code>a + b</code></td><td><code>a.plus(b)</code></td></tr><tr><td><code>a - b</code></td><td><code>a.minus(b)</code></td></tr><tr><td><code>a * b</code></td><td><code>a.times(b)</code></td></tr><tr><td><code>a / b</code></td><td><code>a.div(b)</code></td></tr><tr><td><code>a % b</code></td><td><code>a.rem(b)</code></td></tr><tr><td><code>a..b</code></td><td><code>a.rangeTo(b)</code></td></tr><tr><td><code>a..&lt;b</code></td><td><code>a.rangeUntil(b)</code></td></tr></tbody></table><p>对于此表中的操作，编译器仅解析“转换为”列中的表达式。</p><p>下面是一个 <code>Counter</code> 类示例，它从给定值开始，并可以使用重载的 <code>+</code> 操作符进行递增：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dayIndex: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    operator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> plus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(increment: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dayIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> increment)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="in-操作符" tabindex="-1"><code>in</code> 操作符 <a class="header-anchor" href="#in-操作符" aria-label="Permalink to &quot;\`in\` 操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表达式</th><th>转换为</th></tr></thead><tbody><tr><td><code>a in b</code></td><td><code>b.contains(a)</code></td></tr><tr><td><code>a !in b</code></td><td><code>!b.contains(a)</code></td></tr></tbody></table><p>对于 <code>in</code> 和 <code>!in</code>，过程相同，但实参顺序颠倒。</p><h3 id="索引访问操作符" tabindex="-1">索引访问操作符 <a class="header-anchor" href="#索引访问操作符" aria-label="Permalink to &quot;索引访问操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表达式</th><th>转换为</th></tr></thead><tbody><tr><td><code>a[i]</code></td><td><code>a.get(i)</code></td></tr><tr><td><code>a[i, j]</code></td><td><code>a.get(i, j)</code></td></tr><tr><td><code>a[i_1, ..., i_n]</code></td><td><code>a.get(i_1, ..., i_n)</code></td></tr><tr><td><code>a[i] = b</code></td><td><code>a.set(i, b)</code></td></tr><tr><td><code>a[i, j] = b</code></td><td><code>a.set(i, j, b)</code></td></tr><tr><td><code>a[i_1, ..., i_n] = b</code></td><td><code>a.set(i_1, ..., i_n, b)</code></td></tr></tbody></table><p>方括号会转换为对 <code>get</code> 和 <code>set</code> 的调用，并带上相应数量的实参。</p><h3 id="invoke-操作符" tabindex="-1"><code>invoke</code> 操作符 <a class="header-anchor" href="#invoke-操作符" aria-label="Permalink to &quot;\`invoke\` 操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表达式</th><th>转换为</th></tr></thead><tbody><tr><td><code>a()</code></td><td><code>a.invoke()</code></td></tr><tr><td><code>a(i)</code></td><td><code>a.invoke(i)</code></td></tr><tr><td><code>a(i, j)</code></td><td><code>a.invoke(i, j)</code></td></tr><tr><td><code>a(i_1, ..., i_n)</code></td><td><code>a.invoke(i_1, ..., i_n)</code></td></tr></tbody></table><p>圆括号会转换为对 <code>invoke</code> 的调用，并带上相应数量的实参。</p><h3 id="增广赋值" tabindex="-1">增广赋值 <a class="header-anchor" href="#增广赋值" aria-label="Permalink to &quot;增广赋值&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表达式</th><th>转换为</th></tr></thead><tbody><tr><td><code>a += b</code></td><td><code>a.plusAssign(b)</code></td></tr><tr><td><code>a -= b</code></td><td><code>a.minusAssign(b)</code></td></tr><tr><td><code>a *= b</code></td><td><code>a.timesAssign(b)</code></td></tr><tr><td><code>a /= b</code></td><td><code>a.divAssign(b)</code></td></tr><tr><td><code>a %= b</code></td><td><code>a.remAssign(b)</code></td></tr></tbody></table><p>对于赋值操作，例如 <code>a += b</code>，编译器会执行以下步骤：</p><ul><li>如果右侧列的函数可用： <ul><li>如果对应的二元函数（即 <code>plusAssign()</code> 对应的 <code>plus()</code>）也可用，并且 <code>a</code> 是一个可变变量，且 <code>plus</code> 的返回类型是 <code>a</code> 类型的子类型，则报告错误（歧义）。</li><li>确保其返回类型为 <code>Unit</code>，否则报告错误。</li><li>为 <code>a.plusAssign(b)</code> 生成代码。</li></ul></li><li>否则，尝试为 <code>a = a + b</code> 生成代码（这包括一个类型检测：<code>a + b</code> 的类型必须是 <code>a</code> 的子类型）。</li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>赋值在 Kotlin 中<em>不是</em>表达式。</p></div><h3 id="相等和不相等操作符" tabindex="-1">相等和不相等操作符 <a class="header-anchor" href="#相等和不相等操作符" aria-label="Permalink to &quot;相等和不相等操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表达式</th><th>转换为</th></tr></thead><tbody><tr><td><code>a == b</code></td><td><code>a?.equals(b) ?: (b === null)</code></td></tr><tr><td><code>a != b</code></td><td><code>!(a?.equals(b) ?: (b === null))</code></td></tr></tbody></table><p>这些操作符仅与函数 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/equals.html" target="_blank" rel="noreferrer"><code>equals(other: Any?): Boolean</code></a> 配合使用，该函数可以被覆盖以提供自定义的相等性检测实现。任何其他同名函数（例如 <code>equals(other: Foo)</code>）都不会被调用。</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p><code>===</code> 和 <code>!==</code>（恒等检测）不可重载，因此没有适用于它们的约定。</p></div><p><code>==</code> 操作是特殊的：它会转换为一个复杂的表达式，用于筛选 <code>null</code> 值。<code>null == null</code> 始终为 true，而对于非空的 <code>x</code>，<code>x == null</code> 始终为 false，并且不会调用 <code>x.equals()</code>。</p><h3 id="比较操作符" tabindex="-1">比较操作符 <a class="header-anchor" href="#比较操作符" aria-label="Permalink to &quot;比较操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>表达式</th><th>转换为</th></tr></thead><tbody><tr><td><code>a &gt; b</code></td><td><code>a.compareTo(b) &gt; 0</code></td></tr><tr><td><code>a &lt; b</code></td><td><code>a.compareTo(b) &lt; 0</code></td></tr><tr><td><code>a &gt;= b</code></td><td><code>a.compareTo(b) &gt;= 0</code></td></tr><tr><td><code>a &lt;= b</code></td><td><code>a.compareTo(b) &lt;= 0</code></td></tr></tbody></table><p>所有比较都会转换为对 <code>compareTo</code> 的调用，该函数要求返回 <code>Int</code>。</p><h3 id="属性委托操作符" tabindex="-1">属性委托操作符 <a class="header-anchor" href="#属性委托操作符" aria-label="Permalink to &quot;属性委托操作符&quot;">​</a></h3><p><code>provideDelegate</code>、<code>getValue</code> 和 <code>setValue</code> 操作符函数在<a href="/kotlin/delegated-properties">委托属性</a>中进行了描述。</p><h2 id="命名函数的中缀调用" tabindex="-1">命名函数的中缀调用 <a class="header-anchor" href="#命名函数的中缀调用" aria-label="Permalink to &quot;命名函数的中缀调用&quot;">​</a></h2><p>你可以通过使用<a href="/kotlin/functions#infix-notation">中缀函数调用</a>来模拟自定义的中缀操作。</p>`,56)]))}const E=a(d,[["render",o]]);export{k as __pageData,E as default};
