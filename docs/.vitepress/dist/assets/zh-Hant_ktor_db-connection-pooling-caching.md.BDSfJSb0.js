import{_ as l,C as o,c as p,o as r,j as e,G as t,ag as h,a as i,w as c}from"./chunks/framework.Bksy39di.js";const x=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/ktor/db-connection-pooling-caching.md","filePath":"zh-Hant/ktor/db-connection-pooling-caching.md","lastUpdated":1755457140000}'),u={name:"zh-Hant/ktor/db-connection-pooling-caching.md"};function g(k,a,b,m,v,C){const n=o("show-structure"),s=o("tldr"),d=o("link-summary");return r(),p("div",null,[a[2]||(a[2]=e("h1",{id:"連線池和快取",tabindex:"-1"},[i("連線池和快取 "),e("a",{class:"header-anchor",href:"#連線池和快取","aria-label":'Permalink to "連線池和快取"'},"​")],-1)),t(n,{for:"chapter",depth:"2"}),t(s,null,{default:c(()=>a[0]||(a[0]=[e("p",null,[e("b",null,"程式碼範例"),i(": "),e("a",{href:"https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/tutorial-website-interactive-persistence-advanced"}," tutorial-website-interactive-persistence-advanced ")],-1),e("p",null,[e("b",null,"使用的函式庫"),i(": "),e("a",{href:"https://github.com/brettwooldridge/HikariCP"},"HikariCP"),i(", "),e("a",{href:"https://www.ehcache.org/"},"Ehcache")],-1)])),_:1}),t(d,null,{default:c(()=>a[1]||(a[1]=[i("了解如何實作資料庫連線池和快取。")])),_:1}),a[3]||(a[3]=h(`<p>在<a href="./db-persistence">先前教學</a>中，我們使用 Exposed 框架為網站新增了持久性。 在本教學中，我們將探討如何分別使用 HikariCP 和 Ehcache 函式庫實作資料庫連線池和快取。</p><h2 id="add-dependencies" tabindex="-1">新增相依性 <a class="header-anchor" href="#add-dependencies" aria-label="Permalink to &quot;新增相依性 {id=&quot;add-dependencies&quot;}&quot;">​</a></h2><p>首先，您需要為 HikariCP 和 Ehcache 函式庫新增相依性。 開啟 <code>gradle.properties</code> 檔案並指定函式庫版本：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ehcache_version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">logback_version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span></span></code></pre></div><p>接著，開啟 <code>build.gradle.kts</code> 並新增以下相依性：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>點擊 <code>build.gradle.kts</code> 檔案右上角的 <strong>Load Gradle Changes</strong> 圖示以安裝新新增的相依性。</p><h2 id="connection-pooling" tabindex="-1">連線池 <a class="header-anchor" href="#connection-pooling" aria-label="Permalink to &quot;連線池 {id=&quot;connection-pooling&quot;}&quot;">​</a></h2><p>Exposed 在每次 <code>transaction</code> 呼叫內部執行首次資料庫操作時，會在該 <code>transaction</code> 的範圍內啟動新的 JDBC 連線。 但建立多個 JDBC 連線會消耗大量資源：重複使用現有連線有助於提升效能。 _連線池_機制解決了這個問題。</p><p>在本節中，我們將使用 HikariCP 框架來管理應用程式中的 JDBC 連線池。</p><h3 id="connection-settings-config" tabindex="-1">將連線設定提取到設定檔中 <a class="header-anchor" href="#connection-settings-config" aria-label="Permalink to &quot;將連線設定提取到設定檔中 {id=&quot;connection-settings-config&quot;}&quot;">​</a></h3><p>在<a href="./db-persistence#connect_db">先前教學</a>中，我們在 <code>com/example/dao/DatabaseSingleton.kt</code> 檔案中使用了硬編碼的 <code>driverClassName</code> 和 <code>jdbcURL</code> 來建立資料庫連線：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>讓我們將資料庫連線設定提取到<a href="./server-configuration-file">自訂設定群組</a>。</p><ol><li><p>開啟 <code>src/main/resources/application.conf</code> 檔案，並在 <code>ktor</code> 群組之外新增 <code>storage</code> 群組，如下所示：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div></li><li><p>開啟 <code>com/example/dao/DatabaseSingleton.kt</code> 並更新 <code>init</code> 函數以從設定檔載入儲存設定：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p><code>init</code> 函數現在接受 <code>ApplicationConfig</code> 並使用 <code>config.property</code> 載入自訂設定。</p></li><li><p>最後，開啟 <code>com/example/Application.kt</code> 並將 <code>environment.config</code> 傳遞給 <code>DatabaseSingleton.init</code> 以在應用程式啟動時載入連線設定：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div></li></ol><h3 id="enable-connection-pooling" tabindex="-1">啟用連線池 <a class="header-anchor" href="#enable-connection-pooling" aria-label="Permalink to &quot;啟用連線池 {id=&quot;enable-connection-pooling&quot;}&quot;">​</a></h3><p>若要在 Exposed 中啟用連線池，您需要將 <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.sql/javax/sql/DataSource.html" target="_blank" rel="noreferrer">DataSource</a> 作為參數提供給 <code>Database.connect</code> 函數。 HikariCP 提供實作了 <code>DataSource</code> 介面的 <code>HikariDataSource</code> 類別。</p><ol><li><p>若要建立 <code>HikariDataSource</code>，開啟 <code>com/example/dao/DatabaseSingleton.kt</code> 並將 <code>createHikariDataSource</code> 函數新增到 <code>DatabaseSingleton</code> 物件：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>以下是一些資料來源設定的注意事項：</p><ul><li><code>createHikariDataSource</code> 函數將驅動程式類別名稱和資料庫 URL 作為參數。</li><li><code>maximumPoolSize</code> 屬性指定連線池可達到的最大大小。</li><li><code>isAutoCommit</code> 和 <code>transactionIsolation</code> 設定為與 Exposed 使用的預設設定同步。</li></ul></li><li><p>若要使用 <code>HikariDataSource</code>，將其傳遞給 <code>Database.connect</code> 函數：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>您現在可以<a href="./db-persistence#run_app">執行應用程式</a>並確保一切運作如常。</p></li></ol><h2 id="caching" tabindex="-1">快取 <a class="header-anchor" href="#caching" aria-label="Permalink to &quot;快取 {id=&quot;caching&quot;}&quot;">​</a></h2><p>您可以為資料庫補充資料庫快取。 快取是一種能夠將常用資料儲存在暫時記憶體中的技術，可以減少資料庫的工作負載和讀取常用資料所需的時間。</p><p>在本教學中，我們將使用 Ehcache 函式庫將快取組織在檔案中。</p><h3 id="cache-file-path" tabindex="-1">將快取檔案路徑新增到設定中 <a class="header-anchor" href="#cache-file-path" aria-label="Permalink to &quot;將快取檔案路徑新增到設定中 {id=&quot;cache-file-path&quot;}&quot;">​</a></h3><p>開啟 <code>src/main/resources/application.conf</code> 檔案，並將 <code>ehcacheFilePath</code> 屬性新增到 <code>storage</code> 群組：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>此屬性指定用於儲存快取資料的檔案路徑。 我們稍後會使用它來設定 <code>DAOFacade</code> 實作以使用快取。</p><h3 id="implement-caching" tabindex="-1">實作快取 <a class="header-anchor" href="#implement-caching" aria-label="Permalink to &quot;實作快取 {id=&quot;implement-caching&quot;}&quot;">​</a></h3><p>若要實作快取，我們需要提供另一個 <code>DAOFacade</code> 實作，它從快取傳回值，如果沒有快取值，則將其委派給資料庫介面。</p><ol><li><p>在 <code>com.example.dao</code> 套件中建立一個新的 <code>DAOFacadeCacheImpl.kt</code> 檔案，並將以下實作新增到其中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>以下是此程式碼範例的簡要概述：</p><ul><li>若要初始化和設定快取，我們定義一個 Ehcache <code>CacheManager</code> 實例。我們提供 <code>storagePath</code> 作為用於磁碟儲存的根目錄。</li><li>我們為按文章 ID 儲存文章的條目建立一個快取：<code>articlesCache</code> 將 <code>Int</code> 鍵映射到 <code>Article</code> 值。</li><li>然後我們提供本機記憶體和磁碟資源的大小限制。您可以從 <a href="https://www.ehcache.org/documentation/2.8/configuration/cache-size.html" target="_blank" rel="noreferrer">Ehcache 文件</a>中閱讀有關這些參數的更多資訊。</li><li>最後，我們透過呼叫 <code>cacheManager.getCache()</code> 並提供名稱、鍵和值類型來取得建立的快取。</li></ul></li><li><p>若要在快取中使用，<code>Article</code> 類別應該是可序列化的並實作 <code>java.io.Serializable</code>。 開啟 <code>com/example/models/Article.kt</code> 並將程式碼更新如下：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div></li><li><p>現在我們準備好實作 <code>DAOFacade</code> 的成員了。 回到 <code>DAOFacadeCacheImpl.kt</code>，新增以下方法：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><ul><li><code>allArticles</code>: 我們不嘗試快取所有文章；我們將此委派給主資料庫。</li><li><code>article</code>: 當我們取得一篇文章時，我們首先檢查它是否存在於快取中，只有在不存在的情況下，我們將此委派給主 <code>DAOFacade</code> 並將這篇文章新增到快取。</li><li><code>addNewArticle</code>: 當我們新增一篇文章時，我們將其委派給主 <code>DAOFacade</code>，但我們也將這篇文章新增到快取。</li><li><code>editArticle</code>: 編輯現有文章時，我們同時更新快取和資料庫。</li><li><code>deleteArticle</code>: 刪除時，我們需要同時從快取和主資料庫中刪除文章。</li></ul></li></ol><h3 id="init-dao-facade" tabindex="-1">初始化 DAOFacadeCacheImpl <a class="header-anchor" href="#init-dao-facade" aria-label="Permalink to &quot;初始化 DAOFacadeCacheImpl {id=&quot;init-dao-facade&quot;}&quot;">​</a></h3><p>讓我們建立一個 <code>DAOFacadeCacheImpl</code> 的實例，並新增一個範例文章，以便在應用程式啟動之前插入到資料庫中：</p><ol><li><p>首先，開啟 <code>DAOFacadeImpl.kt</code> 檔案並移除檔案底部 <code>dao</code> 變數的初始化。</p></li><li><p>接著，開啟 <code>com/example/plugins/Routing.kt</code> 並在 <code>configureRouting</code> 區塊內部初始化 <code>dao</code> 變數：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><p>這樣就完成了。 您現在可以<a href="./db-persistence#run_app">執行應用程式</a>並確保一切運作如常。</p></li></ol><blockquote><p>您可以在此找到包含連線池和快取的完整範例：<a href="https://github.com/ktorio/ktor-documentation/tree/3.2.3/codeSnippets/snippets/tutorial-website-interactive-persistence-advanced" target="_blank" rel="noreferrer">tutorial-website-interactive-persistence-advanced</a>。</p></blockquote>`,32))])}const y=l(u,[["render",g]]);export{x as __pageData,y as default};
