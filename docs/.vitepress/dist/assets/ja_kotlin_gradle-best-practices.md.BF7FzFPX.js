import{_ as i,C as n,c as o,o as p,ag as r,G as l,j as e,a as s}from"./chunks/framework.Bksy39di.js";const _=JSON.parse('{"title":"Gradle のベストプラクティス","description":"","frontmatter":{},"headers":[],"relativePath":"ja/kotlin/gradle-best-practices.md","filePath":"ja/kotlin/gradle-best-practices.md","lastUpdated":1754307826000}'),d={name:"ja/kotlin/gradle-best-practices.md"};function h(c,a,k,g,u,b){const t=n("TopicTitle");return p(),o("div",null,[a[0]||(a[0]=r(`<h1 id="gradle-のベストプラクティス" tabindex="-1">Gradle のベストプラクティス <a class="header-anchor" href="#gradle-のベストプラクティス" aria-label="Permalink to &quot;Gradle のベストプラクティス&quot;">​</a></h1><p><a href="https://docs.gradle.org/current/userguide/userguide.html" target="_blank" rel="noreferrer">Gradle</a> は、多くの Kotlin プロジェクトでビルドプロセスを自動化および管理するために使用されるビルドシステムです。</p><p>Gradle を最大限に活用することは、ビルドの管理や待機に費やす時間を減らし、より多くの時間をコーディングに費やすために不可欠です。ここでは、プロジェクトの<strong>整理</strong>と<strong>最適化</strong>という2つの主要な領域に分けられた一連のベストプラクティスを提供します。</p><h2 id="整理" tabindex="-1">整理 <a class="header-anchor" href="#整理" aria-label="Permalink to &quot;整理&quot;">​</a></h2><p>このセクションでは、明確さ、保守性、スケーラビリティを向上させるための Gradle プロジェクトの構造化に焦点を当てます。</p><h3 id="kotlin-dsl-を使用する" tabindex="-1">Kotlin DSL を使用する <a class="header-anchor" href="#kotlin-dsl-を使用する" aria-label="Permalink to &quot;Kotlin DSL を使用する&quot;">​</a></h3><p>従来の Groovy DSL の代わりに Kotlin DSL を使用します。これにより、別の言語を学習する手間が省け、厳密な型付けの利点が得られます。厳密な型付けにより、IDE はリファクタリングとオートコンプリートのサポートを向上させ、開発をより効率的にします。</p><p>詳細については、<a href="https://docs.gradle.org/current/userguide/kotlin_dsl.html" target="_blank" rel="noreferrer">Gradle の Kotlin DSL 入門</a>を参照してください。</p><p>Kotlin DSL が Gradle ビルドのデフォルトになったことについては、Gradle の<a href="https://blog.gradle.org/kotlin-dsl-is-now-the-default-for-new-gradle-builds" target="_blank" rel="noreferrer">ブログ</a>を読んでください。</p><h3 id="バージョンカタログを使用する" tabindex="-1">バージョンカタログを使用する <a class="header-anchor" href="#バージョンカタログを使用する" aria-label="Permalink to &quot;バージョンカタログを使用する&quot;">​</a></h3><p><code>libs.versions.toml</code> ファイルでバージョンカタログを使用して、依存関係管理を一元化します。これにより、バージョン、ライブラリ、プラグインをプロジェクト間で一貫して定義および再利用できます。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[versions]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kotlinxCoroutines </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;1.10.2&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[libraries]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kotlinxCoroutines </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { module </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;org.jetbrains.kotlinx:kotlinx-coroutines-core&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, version.ref </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;kotlinxCoroutines&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>以下の依存関係を <code>build.gradle.kts</code> ファイルに追加します。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    implementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(libs.kotlinxCoroutines)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>詳細については、Gradle のドキュメントの<a href="https://docs.gradle.org/current/userguide/dependency_management_basics.html#version_catalog" target="_blank" rel="noreferrer">依存関係管理の基本</a>を参照してください。</p>`,15)),l(t,{id:"コンベンションプラグインを使用する",level:"3",title:"コンベンションプラグインを使用する",labelRef:"advanced"}),a[1]||(a[1]=r('<p>コンベンションプラグインを使用して、複数のビルドファイルにわたる共通のビルドロジックをカプセル化し、再利用します。共有設定をプラグインに移動すると、ビルドスクリプトの簡素化とモジュール化に役立ちます。</p><p>初期設定には時間がかかる場合がありますが、完了すればメンテナンスや新しいビルドロジックの追加が容易になります。</p><p>詳細については、Gradle のドキュメントの<a href="https://docs.gradle.org/current/userguide/custom_plugins.html#sec:convention_plugins" target="_blank" rel="noreferrer">コンベンションプラグイン</a>を参照してください。</p><h2 id="最適化" tabindex="-1">最適化 <a class="header-anchor" href="#最適化" aria-label="Permalink to &quot;最適化&quot;">​</a></h2><p>このセクションでは、Gradle ビルドのパフォーマンスと効率を向上させる戦略を提供します。</p><h3 id="ローカルビルドキャッシュを使用する" tabindex="-1">ローカルビルドキャッシュを使用する <a class="header-anchor" href="#ローカルビルドキャッシュを使用する" aria-label="Permalink to &quot;ローカルビルドキャッシュを使用する&quot;">​</a></h3><p>ローカルビルドキャッシュを使用して、他のビルドで生成された出力を再利用することで時間を節約します。ビルドキャッシュは、以前に作成したすべてのビルドから出力を取得できます。</p><p>詳細については、Gradle のドキュメントの<a href="https://docs.gradle.org/current/userguide/build_cache.html" target="_blank" rel="noreferrer">ビルドキャッシュ</a>を参照してください。</p><h3 id="設定キャッシュを使用する" tabindex="-1">設定キャッシュを使用する <a class="header-anchor" href="#設定キャッシュを使用する" aria-label="Permalink to &quot;設定キャッシュを使用する&quot;">​</a></h3><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>設定キャッシュは、まだすべてのコア Gradle プラグインをサポートしていません。最新情報については、Gradle の<a href="https://docs.gradle.org/current/userguide/configuration_cache.html#config_cache:plugins:core" target="_blank" rel="noreferrer">サポートされているプラグインの表</a>を参照してください。</p></div><p>設定キャッシュを使用して、設定フェーズの結果をキャッシュし、後続のビルドで再利用することで、ビルドパフォーマンスを大幅に向上させます。Gradle がビルド設定または関連する依存関係に変更がないことを検出した場合、設定フェーズをスキップします。</p><p>詳細については、Gradle のドキュメントの<a href="https://docs.gradle.org/current/userguide/configuration_cache.html" target="_blank" rel="noreferrer">設定キャッシュ</a>を参照してください。</p><h3 id="複数のターゲットのビルド時間を改善する" tabindex="-1">複数のターゲットのビルド時間を改善する <a class="header-anchor" href="#複数のターゲットのビルド時間を改善する" aria-label="Permalink to &quot;複数のターゲットのビルド時間を改善する&quot;">​</a></h3><p>マルチプラットフォームプロジェクトに複数のターゲットが含まれている場合、<code>build</code> や <code>assemble</code> などのタスクは、各ターゲットに対して同じコードを複数回コンパイルし、コンパイル時間の延長につながる可能性があります。</p><p>特定のプラットフォームを積極的に開発およびテストしている場合は、代わりに該当する <code>linkDebug*</code> タスクを実行してください。</p><p>詳細については、<a href="/ja/kotlin/native-improving-compilation-time#gradle-configuration">コンパイル時間を改善するためのヒント</a>を参照してください。</p><h3 id="kapt-から-ksp-へ移行する" tabindex="-1">kapt から KSP へ移行する <a class="header-anchor" href="#kapt-から-ksp-へ移行する" aria-label="Permalink to &quot;kapt から KSP へ移行する&quot;">​</a></h3><p><a href="/ja/kotlin/kapt">kapt</a> コンパイラプラグインに依存するライブラリを使用している場合は、代わりに <a href="/ja/kotlin/ksp-overview">Kotlin Symbol Processing (KSP) API</a> の使用に切り替えられるかどうかを確認してください。KSP API は、アノテーション処理時間を短縮することでビルドパフォーマンスを向上させます。KSP は、中間 Java スタブを生成することなくソースコードを直接処理するため、kapt よりも高速で効率的です。</p><p>移行手順については、Google の<a href="https://developer.android.com/build/migrate-to-ksp" target="_blank" rel="noreferrer">移行ガイド</a>を参照してください。</p><p>KSP と kapt の比較について詳しく知るには、<a href="/ja/kotlin/ksp-why-ksp">なぜ KSP なのか</a>を確認してください。</p>',20)),l(t,{id:"モジュール化を使用する",level:"3",title:"モジュール化を使用する",labelRef:"advanced"}),a[2]||(a[2]=r(`<div class="note custom-block"><p class="custom-block-title">NOTE</p><p>モジュール化は、中規模から大規模のプロジェクトにのみメリットがあります。マイクロサービスアーキテクチャに基づくプロジェクトには利点を提供しません。</p></div><p>モジュール化されたプロジェクト構造を使用して、ビルド速度を向上させ、並行開発を容易にします。プロジェクトを1つのルートプロジェクトと1つ以上のサブプロジェクトに構成します。変更がサブプロジェクトの1つのみに影響する場合、Gradle はその特定のサブプロジェクトのみを再ビルドします。</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.</span></span>
<span class="line"><span>└── root-project/</span></span>
<span class="line"><span>    ├── settings.gradle.kts</span></span>
<span class="line"><span>    ├── app subproject/</span></span>
<span class="line"><span>    │   └── build.gradle.kts</span></span>
<span class="line"><span>    └── lib subproject/</span></span>
<span class="line"><span>        └── build.gradle.kts</span></span></code></pre></div><p>詳細については、Gradle のドキュメントの<a href="https://docs.gradle.org/current/userguide/multi_project_builds.html" target="_blank" rel="noreferrer">Gradle を使用したプロジェクトの構造化</a>を参照してください。</p>`,4)),l(t,{id:"ci-cd-をセットアップする",level:"3",title:"CI/CD をセットアップする",labelRef:"advanced"}),a[3]||(a[3]=e("p",null,[s("インクリメンタルビルドと依存関係のキャッシュを使用することで、ビルド時間を大幅に短縮するために CI/CD プロセスをセットアップします。これらの利点を得るには、永続ストレージを追加するか、リモートビルドキャッシュを使用します。"),e("a",{href:"https://github.com/features/actions",target:"_blank",rel:"noreferrer"},"GitHub"),s(" のような一部のプロバイダーは、このサービスをほぼすぐに利用できる形で提供しているため、このプロセスは時間のかかるものである必要はありません。")],-1)),a[4]||(a[4]=e("p",null,[e("a",{href:"https://cookbook.gradle.org/ci/",target:"_blank",rel:"noreferrer"},"継続的インテグレーションシステムでの Gradle の使用"),s("に関する Gradle のコミュニティクックブックを確認してください。")],-1)),l(t,{id:"リモートビルドキャッシュを使用する",level:"3",title:"リモートビルドキャッシュを使用する",labelRef:"advanced"}),a[5]||(a[5]=e("p",null,[e("a",{href:"#use-local-build-cache"},"ローカルビルドキャッシュ"),s("と同様に、リモートビルドキャッシュは、他のビルドからの出力を再利用することで時間を節約するのに役立ちます。それは、最後のビルドだけでなく、誰かがすでに実行した以前のすべてのビルドからタスク出力を取得できます。")],-1)),a[6]||(a[6]=e("p",null,"リモートビルドキャッシュは、キャッシュサーバーを使用してビルド間でタスク出力を共有します。たとえば、CI/CD サーバーがある開発環境では、サーバー上のすべてのビルドによってリモートキャッシュが埋められます。新しい機能を開発するためにメインブランチをチェックアウトすると、すぐにインクリメンタルビルドにアクセスできます。",-1)),a[7]||(a[7]=e("p",null,"インターネット接続が遅い場合、キャッシュされた結果の転送がタスクをローカルで実行するよりも遅くなる可能性があることに留意してください。",-1)),a[8]||(a[8]=e("p",null,[s("詳細については、Gradle のドキュメントの"),e("a",{href:"https://docs.gradle.org/current/userguide/build_cache.html",target:"_blank",rel:"noreferrer"},"ビルドキャッシュ"),s("を参照してください。")],-1))])}const m=i(d,[["render",h]]);export{_ as __pageData,m as default};
