import{_ as t}from"./chunks/xcode-swift-export-run-script-phase.CN5rl4tW.js";import{_ as l}from"./chunks/default-hierarchy-example-with-web.De_8QTGQ.js";import{_ as e,C as p,c as h,o as k,ag as i,G as n}from"./chunks/framework.Bksy39di.js";const m=JSON.parse('{"title":"Kotlin 2.2.20-Beta2 有什麼新功能","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/whatsnew-eap.md","filePath":"zh-Hant/kotlin/whatsnew-eap.md","lastUpdated":1754307826000}'),r={name:"zh-Hant/kotlin/whatsnew-eap.md"};function o(d,s,c,E,g,y){const a=p("TopicTitle");return k(),h("div",null,[s[0]||(s[0]=i(`<h1 id="kotlin-2-2-20-beta2-有什麼新功能" tabindex="-1">Kotlin 2.2.20-Beta2 有什麼新功能 <a class="header-anchor" href="#kotlin-2-2-20-beta2-有什麼新功能" aria-label="Permalink to &quot;Kotlin 2.2.20-Beta2 有什麼新功能&quot;">​</a></h1><p><em><a href="/zh-Hant/kotlin/eap#build-details">發佈日期：July 29, 2025</a></em></p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>本文件不涵蓋搶先體驗預覽版 (EAP) 的所有功能， 但它強調了一些主要改進。 請參閱 <a href="https://github.com/JetBrains/kotlin/releases/tag/v2.2.20-Beta2" target="_blank" rel="noreferrer">GitHub 變更日誌</a> 中的完整變更列表。</p></div><p>Kotlin 2.2.20-Beta2 版本已發佈！ 以下是此 EAP 版本的一些詳細資訊：</p><ul><li>Kotlin Multiplatform：<a href="#swift-export-available-by-default">預設啟用 Swift 匯出</a>、<a href="#shared-source-set-for-js-and-wasmjs-targets"><code>js</code> 和 <code>wasmJs</code> 目標的共享原始碼集</a>、<a href="#stable-cross-platform-compilation-for-kotlin-libraries">Kotlin 函式庫的穩定跨平台編譯</a>，以及<a href="#new-approach-for-declaring-common-dependencies">宣告通用依賴項的新方法</a>。</li><li>Language：<a href="#improved-overload-resolution-for-lambdas-with-suspend-function-types">將 Lambda 傳遞給帶有 suspend 函式類型的多載時，改進的多載解析</a>。</li><li>Kotlin/Native：<a href="#support-for-stack-canaries-in-binaries">二進制檔案中對堆疊 Canary 的支援</a> 和<a href="#smaller-binary-size-for-ios-targets">縮小 iOS 目標的二進制檔案大小</a>。</li><li>Kotlin/Wasm：<a href="#improved-exception-handling-in-kotlin-wasm-and-javascript-interop">Kotlin/Wasm 和 JavaScript 互通中的異常處理改進</a>。</li><li>Kotlin/JS：<a href="#usage-of-bigint-type-to-represent-kotlin-s-long-type"><code>Long</code> 值編譯為 JavaScript <code>BigInt</code></a>。</li></ul><h2 id="ide-支援" tabindex="-1">IDE 支援 <a class="header-anchor" href="#ide-支援" aria-label="Permalink to &quot;IDE 支援&quot;">​</a></h2><p>支援 Kotlin 2.2.20-Beta2 的 Kotlin 插件已捆綁在最新版本的 IntelliJ IDEA 和 Android Studio 中。 您無需更新 IDE 中的 Kotlin 插件。 您只需在建置腳本中將 <a href="/zh-Hant/kotlin/configure-build-for-eap">Kotlin 版本變更</a> 為 2.2.20-Beta2。</p><p>有關詳細資訊，請參閱<a href="/zh-Hant/kotlin/releases#update-to-a-new-kotlin-version">更新到新版本</a>。</p><h2 id="語言" tabindex="-1">語言 <a class="header-anchor" href="#語言" aria-label="Permalink to &quot;語言&quot;">​</a></h2><p>在 Kotlin 2.2.20-Beta2 中，您可以試用 Kotlin 2.3.0 計劃推出的語言功能，包括 <a href="#improved-overload-resolution-for-lambdas-with-suspend-function-types">將 Lambda 傳遞給帶有 suspend 函式類型的多載時，改進的多載解析</a> 和<a href="#support-for-return-statements-in-expression-bodies-with-explicit-return-types">支援在具有顯式返回型別的表達式主體中使用 return 陳述式</a>。</p><h3 id="將-lambda-傳遞給帶有-suspend-函式類型的多載時-改進的多載解析" tabindex="-1">將 Lambda 傳遞給帶有 suspend 函式類型的多載時，改進的多載解析 <a class="header-anchor" href="#將-lambda-傳遞給帶有-suspend-函式類型的多載時-改進的多載解析" aria-label="Permalink to &quot;將 Lambda 傳遞給帶有 suspend 函式類型的多載時，改進的多載解析&quot;">​</a></h3><p>以前，函式同時帶有常規函式型別和 <code>suspend</code> 函式型別的多載，在傳遞 Lambda 時會導致歧義錯誤。您可以使用顯式型別轉換來解決此錯誤，但編譯器錯誤地報告了「<code>No cast needed</code>」警告：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定義兩個多載</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Int) {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">suspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Int) {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 因多載解析歧義而失敗</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 使用顯式轉換，但編譯器錯誤地報告「無需轉換」警告</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Int)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>經過此變更，當您同時定義常規和 <code>suspend</code> 函式型別的多載時，不帶轉換的 Lambda 會解析為常規多載。使用 <code>suspend</code> 關鍵字可顯式解析為 suspend 多載：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 解析為 transform(() -&gt; Int)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 解析為 transform(suspend () -&gt; Int)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p>此行為將在 Kotlin 2.3.0 中預設啟用。要立即測試，請使用以下編譯器選項將您的語言版本設定為 <code>2.3</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">language</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">version </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.3</span></span></code></pre></div><p>或者在您的 <code>build.gradle(.kts)</code> 檔案中進行配置：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        languageVersion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_2_3)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我們非常感謝您在我們的問題追蹤器 <a href="https://youtrack.jetbrains.com/issue/KT-23610" target="_blank" rel="noreferrer">YouTrack</a> 中提供回饋。</p><h3 id="支援在具有顯式返回型別的表達式主體中使用-return-陳述式" tabindex="-1">支援在具有顯式返回型別的表達式主體中使用 return 陳述式 <a class="header-anchor" href="#支援在具有顯式返回型別的表達式主體中使用-return-陳述式" aria-label="Permalink to &quot;支援在具有顯式返回型別的表達式主體中使用 return 陳述式&quot;">​</a></h3><p>以前，在表達式主體中使用 <code>return</code> 會導致編譯器錯誤，因為它可能導致函式的返回型別被推斷為 <code>Nothing</code>。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 錯誤：表達式主體的函式禁止使用 return</span></span></code></pre></div><p>經過此變更，您現在可以在表達式主體中使用 <code>return</code>，只要明確寫出返回型別即可：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 明確指定返回型別</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDisplayNameOrDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userId: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDisplayName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userId ?: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;default&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 失敗，因為未明確指定返回型別</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDisplayNameOrDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userId: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDisplayName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userId ?: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;default&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>同樣地，在表達式主體函式中，Lambda 內部和巢狀表達式中的 <code>return</code> 陳述式以前會無意中編譯通過。Kotlin 現在支援這些情況，只要明確指定返回型別即可。沒有顯式返回型別的情況將在 Kotlin 2.3.0 中棄用：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回型別未明確指定，且 return 陳述式在 Lambda 內部</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 這將被棄用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> returnInsideLambda</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回型別未明確指定，且 return 陳述式在初始式內部</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 本地變數，這將被棄用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> returnInsideIf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">someCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> else</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;value&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        result</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此行為將在 Kotlin 2.3.0 中預設啟用。要立即測試，請使用以下編譯器選項將您的語言版本設定為 <code>2.3</code>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">language</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">version </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.3</span></span></code></pre></div><p>或者在您的 <code>build.gradle(.kts)</code> 檔案中進行配置：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        languageVersion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_2_3)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我們非常感謝您在我們的問題追蹤器 <a href="https://youtrack.jetbrains.com/issue/KT-76926" target="_blank" rel="noreferrer">YouTrack</a> 中提供回饋。</p>`,32)),n(a,{id:"kotlin-jvm-在-when-表達式中支援-invokedynamic",level:"2",title:"Kotlin/JVM：在 when 表達式中支援 invokedynamic",labelRef:"experimental-opt-in"}),s[1]||(s[1]=i(` <p>在 Kotlin 2.2.20-Beta2 中，您現在可以使用 <code>invokedynamic</code> 編譯 <code>when</code> 表達式。 以前，帶有多個型別檢查的 <code>when</code> 表達式會編譯為字節碼中一長串的 <code>instanceof</code> 檢查。</p><p>現在，您可以在 <code>when</code> 表達式中使用 <code>invokedynamic</code> 生成更小的字節碼，類似於 Java <code>switch</code> 陳述式生成的字節碼，當滿足以下條件時：</p><ul><li>除 <code>else</code> 之外的所有條件均為 <code>is</code> 或 <code>null</code> 檢查。</li><li>表達式不包含<a href="/zh-Hant/kotlin/control-flow#guard-conditions-in-when-expressions">守衛條件 (<code>if</code>)</a>。</li><li>條件不包括不能直接進行型別檢查的型別，例如可變的 Kotlin 集合 (<code>MutableList</code>) 或函式型別 (<code>kotlin.Function1</code>、<code>kotlin.Function2</code> 等)。</li><li>除了 <code>else</code> 之外，至少有兩個條件。</li><li>所有分支都檢查 <code>when</code> 表達式的相同主體。</li></ul><p>例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">open</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Example</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 將 invokedynamic 與 SwitchBootstraps.typeSwitch 搭配使用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> C </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>啟用新功能後，此範例中的 <code>when</code> 表達式編譯為單個 <code>invokedynamic</code> 型別開關，而非多個 <code>instanceof</code> 檢查。</p><p>要啟用此功能，請使用 JVM 目標 21 或更高版本編譯您的 Kotlin 程式碼，並新增以下編譯器選項：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">-Xwhen-expressions</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">indy</span></span></code></pre></div><p>或者將其新增到您 <code>build.gradle(.kts)</code> 檔案的 <code>compilerOptions {}</code> 區塊中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xwhen-expressions=indy&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此功能為<a href="/zh-Hant/kotlin/components-stability#stability-levels-explained">實驗性</a>。如果您有任何回饋或問題，請在 <a href="https://youtrack.jetbrains.com/issue/KT-65688" target="_blank" rel="noreferrer">YouTrack</a> 中分享。</p><h2 id="kotlin-多平台" tabindex="-1">Kotlin 多平台 <a class="header-anchor" href="#kotlin-多平台" aria-label="Permalink to &quot;Kotlin 多平台&quot;">​</a></h2><p>Kotlin 2.2.20-Beta2 為 Kotlin Multiplatform 帶來了重大變革：預設啟用 Swift 匯出，有一個新的共享原始碼集，您可以嘗試一種管理通用依賴項的新方法。</p>`,14)),n(a,{id:"預設啟用-swift-匯出",level:"3",title:"預設啟用 Swift 匯出",labelRef:"experimental-general"}),s[2]||(s[2]=i(' <p>Kotlin 2.2.20-Beta2 引入了對 Swift 匯出的實驗性支援。它允許您直接匯出 Kotlin 原始碼，並以地道的方式從 Swift 呼叫 Kotlin 程式碼，無需 Objective-C 標頭。</p><p>這應該會顯著改善 Apple 目標的多平台開發。例如，如果您有一個包含頂層函式的 Kotlin 模組，Swift 匯出允許乾淨、模組特定的匯入，消除令人困惑的 Objective-C 底線和混淆名稱。</p><p>主要功能包括：</p><ul><li><strong>多模組支援</strong>。每個 Kotlin 模組都作為單獨的 Swift 模組匯出，簡化了函式呼叫。</li><li><strong>套件支援</strong>。Kotlin 套件在匯出期間會被明確保留，避免在生成的 Swift 程式碼中發生命名衝突。</li><li><strong>型別別名</strong>。Kotlin 型別別名會被匯出並在 Swift 中保留，提高了可讀性。</li><li><strong>原始型別的增強型別空值性</strong>。與需要將 <code>Int?</code> 等型別封裝成 <code>KotlinInt</code> 等包裝類來保留空值性的 Objective-C 互通不同，Swift 匯出直接轉換空值性資訊。</li><li><strong>多載</strong>。您可以在 Swift 中呼叫 Kotlin 的多載函式而沒有歧義。</li><li><strong>扁平化的套件結構</strong>。您可以將 Kotlin 套件翻譯成 Swift 列舉，從生成的 Swift 程式碼中移除套件前綴。</li><li><strong>模組名稱客製化</strong>。您可以在 Kotlin 專案的 Gradle 設定中自訂生成的 Swift 模組名稱。</li></ul><h4 id="如何啟用-swift-匯出" tabindex="-1">如何啟用 Swift 匯出 <a class="header-anchor" href="#如何啟用-swift-匯出" aria-label="Permalink to &quot;如何啟用 Swift 匯出&quot;">​</a></h4><p>此功能目前是<a href="/zh-Hant/kotlin/components-stability#stability-levels-explained">實驗性</a>的，並且僅適用於使用<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-direct-integration.html" target="_blank" rel="noreferrer">直接整合</a>將 iOS 框架連接到 Xcode 專案的專案中。這是使用 IntelliJ IDEA 中的 Kotlin Multiplatform 插件或透過 <a href="https://kmp.jetbrains.com/" target="_blank" rel="noreferrer">網頁精靈</a> 建立的 Kotlin Multiplatform 專案的標準配置。</p><p>要試用 Swift 匯出，請配置您的 Xcode 專案：</p><ol><li>在 Xcode 中，開啟專案設定。</li><li>在 <strong>Build Phases</strong> 標籤頁上，找到帶有 <code>embedAndSignAppleFrameworkForXcode</code> 任務的 <strong>Run Script</strong> 階段。</li><li>調整腳本以改為在執行腳本階段使用 <code>embedSwiftExportForXcode</code> 任務：</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./gradlew</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> :</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Shared</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> module</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nam</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">:embedSwiftExportForXcode</span></span></code></pre></div><p><img src="'+t+`" alt="Add the Swift export script" width="700"></p><ol start="4"><li>建置專案。Swift 模組會生成在建置輸出目錄中。</li></ol><p>此功能預設可用。如果您在之前的版本中已啟用它，您現在可以從您的 <code>gradle.properties</code> 檔案中移除 <code>kotlin.experimental.swift-export.enabled</code>。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>為了節省時間，請克隆我們已設定好 Swift 匯出的<a href="https://github.com/Kotlin/swift-export-sample" target="_blank" rel="noreferrer">公開範例</a>。</p></div><p>有關 Swift 匯出的更多資訊，請參閱其 <a href="https://github.com/JetBrains/kotlin/tree/master/docs/swift-export#readme" target="_blank" rel="noreferrer">README</a>。</p><h4 id="提供回饋" tabindex="-1">提供回饋 <a class="header-anchor" href="#提供回饋" aria-label="Permalink to &quot;提供回饋&quot;">​</a></h4><p>我們計劃在未來的 Kotlin 版本中擴展並逐步穩定 Swift 匯出支援。在 Kotlin 2.2.20 之後，我們將專注於改進 Kotlin 和 Swift 之間的互通性，特別是在協程和流方面。</p><p>對 Swift 匯出的支援是 Kotlin Multiplatform 的一項重大變革。我們非常感謝您的回饋：</p><ul><li>在 Kotlin Slack 中直接聯絡開發團隊 – <a href="https://surveys.jetbrains.com/s3/kotlin-slack-sign-up?_gl=1*ju6cbn*_ga*MTA3MTk5NDkzMC4xNjQ2MDY3MDU4*_ga_9J976DJZ68*MTY1ODMzNzA3OS4xMDAuMS4xNjU4MzQwODEwLjYw" target="_blank" rel="noreferrer">取得邀請</a> 並加入 <a href="https://kotlinlang.slack.com/archives/C073GUW6WN9" target="_blank" rel="noreferrer">#swift-export</a> 頻道。</li><li>報告您在使用 Swift 匯出時遇到的任何問題，請在 <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack</a> 中提出。</li></ul><h3 id="js-和-wasmjs-目標的共享原始碼集" tabindex="-1">js 和 wasmJs 目標的共享原始碼集 <a class="header-anchor" href="#js-和-wasmjs-目標的共享原始碼集" aria-label="Permalink to &quot;js 和 wasmJs 目標的共享原始碼集&quot;">​</a></h3><p>以前，Kotlin Multiplatform 預設不包含針對 JavaScript (<code>js</code>) 和 WebAssembly (<code>wasmJs</code>) 網頁目標的共享原始碼集。 為了在 <code>js</code> 和 <code>wasmJs</code> 之間共享程式碼，您必須手動配置自定義原始碼集，或在兩個地方編寫程式碼，一個版本用於 <code>js</code>，另一個用於 <code>wasmJs</code>。例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// commonMain</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">expect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readCopiedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// jsMain</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Navigator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clipboard: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JS 和 Wasm 中不同的互通</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; } </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Navigator</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readCopiedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // JS 和 Wasm 中不同的互通</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.clipboard.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// wasmJsMain</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Navigator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clipboard: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JsString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Navigator</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readCopiedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.clipboard.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>從此版本開始，當使用預設層次結構範本時，Kotlin Gradle 插件為 Web 新增了一個共享原始碼集（包含 <code>webMain</code> 和 <code>webTest</code>）。</p><p>經過此變更，<code>web</code> 原始碼集成為 <code>js</code> 和 <code>wasmJs</code> 原始碼集的父級。更新後的原始碼集層次結構如下所示：</p><p><img src="`+l+`" alt="An example of using the default hierarchy template with web"></p><p>新的原始碼集允許您編寫一份程式碼，適用於 <code>js</code> 和 <code>wasmJs</code> 目標。 您可以將共享程式碼放在 <code>webMain</code> 中，它會自動適用於這兩個目標：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// commonMain</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">expect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readCopiedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// webMain</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Navigator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clipboard: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Clipboard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JsString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">external</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Navigator</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readCopiedText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.clipboard.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此更新簡化了 <code>js</code> 和 <code>wasmJs</code> 目標之間的程式碼共享。這在兩種情況下特別有用：</p><ul><li>對於想要添加對 <code>js</code> 和 <code>wasmJs</code> 目標支援的函式庫作者，無需重複程式碼。</li><li>對於建立以 Web 為目標的 Compose Multiplatform 應用程式的開發人員，啟用對 <code>js</code> 和 <code>wasmJs</code> 目標的交叉編譯，以實現更廣泛的瀏覽器相容性。鑑於這種回退模式，當您建立網站時，它將在所有瀏覽器上開箱即用：現代瀏覽器使用 <code>wasmJs</code>，而舊瀏覽器使用 <code>js</code>。</li></ul><p>要嘗試此功能，請在您的 <code>build.gradle(.kts)</code> 檔案的 <code>kotlin {}</code> 區塊中，使用<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-hierarchy.html#default-hierarchy-template" target="_blank" rel="noreferrer">預設層次結構範本</a>。</p><p>在使用預設層次結構之前，如果您有具有自定義共享原始碼集的專案，或者您重新命名了 <code>js(&quot;web&quot;)</code> 目標，請仔細考慮任何潛在衝突。要解決這些衝突，請重新命名衝突的原始碼集或目標，或不要使用預設層次結構。</p><h3 id="kotlin-函式庫的穩定跨平台編譯" tabindex="-1">Kotlin 函式庫的穩定跨平台編譯 <a class="header-anchor" href="#kotlin-函式庫的穩定跨平台編譯" aria-label="Permalink to &quot;Kotlin 函式庫的穩定跨平台編譯&quot;">​</a></h3><p>Kotlin 2.2.20-Beta2 完成了一個重要的<a href="https://youtrack.jetbrains.com/issue/KT-71290" target="_blank" rel="noreferrer">路線圖項目</a>，穩定化 Kotlin 函式庫的跨平台編譯。</p><p>您現在可以使用任何主機生成 <code>.klib</code> 構件，用於發佈 Kotlin 函式庫。這顯著簡化了發佈過程，特別是對於以前需要 Mac 機器才能實現的 Apple 目標。</p><p>此功能預設可用。如果您已啟用帶有 <code>kotlin.native.enableKlibsCrossCompilation=true</code> 的交叉編譯，您現在可以從您的 <code>gradle.properties</code> 檔案中移除它。</p><p>不幸的是，仍然存在一些限制。您仍然需要在以下情況下使用 Mac 機器：</p><ul><li>您的函式庫具有 <a href="/zh-Hant/kotlin/native-c-interop">cinterop 依賴</a>。</li><li>您的專案中設定了 <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-overview.html" target="_blank" rel="noreferrer">CocoaPods 整合</a>。</li><li>您需要為 Apple 目標建置或測試<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-build-native-binaries.html" target="_blank" rel="noreferrer">最終二進制檔案</a>。</li></ul><p>有關多平台函式庫發佈的更多資訊，請參閱我們的<a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-publish-lib-setup.html" target="_blank" rel="noreferrer">文件</a>。</p>`,38)),n(a,{id:"宣告通用依賴項的新方法",level:"3",title:"宣告通用依賴項的新方法",labelRef:"experimental-opt-in"}),s[3]||(s[3]=i(`<p>為了簡化使用 Gradle 設定多平台專案，Kotlin 2.2.20-Beta2 現在允許您在 <code>kotlin {}</code> 區塊中，透過使用頂層的 <code>dependencies {}</code> 區塊來宣告通用依賴項。這些依賴項的行為就像它們被宣告在 <code>commonMain</code> 原始碼集中一樣。此功能的工作方式與您用於 Kotlin/JVM 和僅 Android 專案的依賴項區塊類似，並且它現在在 Kotlin Multiplatform 中是<a href="/zh-Hant/kotlin/components-stability#stability-levels-explained">實驗性</a>的。在專案層級宣告通用依賴項減少了跨原始碼集的重複配置，並有助於簡化您的建置設定。您仍然可以根據需要在每個原始碼集中新增平台特定的依賴項。</p><p>要嘗試此功能，請在頂層 <code>dependencies {}</code> 區塊之前，新增 <code>@OptIn(ExperimentalKotlinGradlePluginApi::class)</code> 註解以選擇啟用。例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalKotlinGradlePluginApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        implementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我們非常感謝您在 <a href="https://youtrack.jetbrains.com/issue/KT-76446" target="_blank" rel="noreferrer">YouTrack</a> 中對此功能的回饋。</p><h2 id="kotlin-native" tabindex="-1">Kotlin/Native <a class="header-anchor" href="#kotlin-native" aria-label="Permalink to &quot;Kotlin/Native&quot;">​</a></h2><p>Kotlin 2.2.20-Beta2 為 Kotlin/Native 二進制檔案和偵錯帶來了改進。</p><h3 id="二進制檔案中對堆疊-canary-的支援" tabindex="-1">二進制檔案中對堆疊 Canary 的支援 <a class="header-anchor" href="#二進制檔案中對堆疊-canary-的支援" aria-label="Permalink to &quot;二進制檔案中對堆疊 Canary 的支援&quot;">​</a></h3><p>從 2.2.20-Beta2 開始，Kotlin 新增了對生成的 Kotlin/Native 二進制檔案中堆疊 Canary 的支援。作為堆疊保護的一部分，此安全功能可防止堆疊溢出，緩解一些常見的應用程式漏洞。它已經在 Swift 和 Objective-C 中可用，現在在 Kotlin 中也得到支援。</p><h4 id="如何啟用堆疊-canary" tabindex="-1">如何啟用堆疊 Canary <a class="header-anchor" href="#如何啟用堆疊-canary" aria-label="Permalink to &quot;如何啟用堆疊 Canary&quot;">​</a></h4><p>Kotlin/Native 中堆疊保護的實作遵循 <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-fstack-protector" target="_blank" rel="noreferrer">Clang</a> 中堆疊保護器的行為。</p><p>要啟用堆疊 Canary，請將以下屬性新增到您的 <code>gradle.properties</code> 檔案中：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.stackProtector=yes</span></span></code></pre></div><p>此屬性為所有容易受到堆疊溢出攻擊的 Kotlin 函式啟用此功能。替代模式為：</p><ul><li><code>kotlin.native.binary.stackProtector=strong</code>，它為容易受到堆疊溢出攻擊的函式使用更強大的啟發式演算法。</li><li><code>kotlin.native.binary.stackProtector=all</code>，它為所有函式啟用堆疊保護器。</li></ul><p>請注意，在某些情況下，堆疊保護可能會帶來效能成本。</p>`,15)),n(a,{id:"縮小-ios-目標的二進制檔案大小",level:"3",title:"縮小 iOS 目標的二進制檔案大小",labelRef:"experimental-general"}),s[4]||(s[4]=i(` <p>Kotlin 2.2.20-Beta2 引入了 <code>smallBinary</code> 選項，它可以幫助您縮小 iOS 目標的二進制檔案大小。 新選項有效地將 <code>-Oz</code> 設定為 LLVM 編譯階段編譯器的預設優化參數。</p><p>啟用 <code>smallBinary</code> 選項後，您可以使發佈的二進制檔案更小，並縮短建置時間。但是，在某些情況下它可能會影響運行時效能。</p><h4 id="如何啟用較小的二進制檔案大小" tabindex="-1">如何啟用較小的二進制檔案大小 <a class="header-anchor" href="#如何啟用較小的二進制檔案大小" aria-label="Permalink to &quot;如何啟用較小的二進制檔案大小&quot;">​</a></h4><p>新功能目前是<a href="/zh-Hant/kotlin/components-stability#stability-levels-explained">實驗性</a>的。要在您的專案中試用它，請使用 <code>-Xbinary=smallBinary=true</code> 編譯器選項，或使用以下內容更新您的 <code>gradle.properties</code> 檔案：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>kotlin.native.binary.smallBinary=true</span></span></code></pre></div><p>對於特定的二進制檔案，請在您的 <code>build.gradle(.kts)</code> 檔案中設定 <code>binaryOption(&quot;smallBinary&quot;, &quot;true&quot;)</code>。例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        iosX64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        iosArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        iosSimulatorArm64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        it.binaries.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">framework</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            binaryOption</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;smallBinary&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;true&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Kotlin 團隊感謝 <a href="https://github.com/troelsbjerre" target="_blank" rel="noreferrer">Troels Lund</a> 協助實作此功能。</p><h3 id="改進的偵錯器物件摘要" tabindex="-1">改進的偵錯器物件摘要 <a class="header-anchor" href="#改進的偵錯器物件摘要" aria-label="Permalink to &quot;改進的偵錯器物件摘要&quot;">​</a></h3><p>Kotlin/Native 現在為 LLDB 和 GDB 等偵錯工具生成更清晰的物件摘要。這提高了生成的偵錯資訊的可讀性，並簡化了您的偵錯體驗。</p><p>以前，如果您檢查一個物件，例如：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> point </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>您會看到有限的資訊，包括指向記憶體位址的指標：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(lldb) v point</span></span>
<span class="line"><span>(ObjHeader *) point = [x: ..., y: ...]</span></span>
<span class="line"><span>(lldb) v point-&gt;x</span></span>
<span class="line"><span>(int32_t *) x = 0x0000000100274048</span></span></code></pre></div><p>透過 Kotlin 2.2.20-Beta2，偵錯器顯示更豐富的細節，包括實際值：</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(lldb) v point</span></span>
<span class="line"><span>(ObjHeader *) point = Point(x=1, y=2)</span></span>
<span class="line"><span>(lldb) v point-&gt;x</span></span>
<span class="line"><span>(int32_t) point-&gt;x = 1</span></span></code></pre></div><p>Kotlin 團隊感謝 <a href="https://github.com/nikita-nazarov" target="_blank" rel="noreferrer">Nikita Nazarov</a> 協助實作此功能。</p><p>有關 Kotlin/Native 中偵錯的更多資訊，請參閱<a href="/zh-Hant/kotlin/native-debugging">文件</a>。</p><h2 id="kotlin-wasm" tabindex="-1">Kotlin/Wasm <a class="header-anchor" href="#kotlin-wasm" aria-label="Permalink to &quot;Kotlin/Wasm&quot;">​</a></h2><p>Kotlin/Wasm 獲得了一些生活品質改進，包括分離的 npm 依賴項和 JavaScript 互通的異常處理改進。</p><h3 id="分離的-npm-依賴項" tabindex="-1">分離的 npm 依賴項 <a class="header-anchor" href="#分離的-npm-依賴項" aria-label="Permalink to &quot;分離的 npm 依賴項&quot;">​</a></h3><p>以前，在您的 Kotlin/Wasm 專案中，所有 <a href="https://www.npmjs.com/" target="_blank" rel="noreferrer">npm</a> 依賴項都一同安裝在您的專案資料夾中。它包括您自己的依賴項和 Kotlin 工具鏈依賴項。這些依賴項也一併記錄在您的專案鎖定檔案（<code>package-lock.json</code> 或 <code>yarn.lock</code>）中。</p><p>因此，每當 Kotlin 工具鏈依賴項更新時，您都必須更新您的鎖定檔案，即使您沒有新增或更改任何內容。</p><p>從 Kotlin 2.2.20-Beta2 開始，Kotlin 工具鏈 npm 依賴項會安裝在您的專案之外。現在，工具鏈和使用者依賴項擁有單獨的目錄：</p><ul><li><p><strong>工具鏈依賴項目錄：</strong></p><p><code>&lt;kotlin-user-home&gt;/kotlin-npm-tooling/&lt;yarn|npm&gt;/hash/node_modules</code></p></li><li><p><strong>使用者依賴項目錄：</strong></p><p><code>build/wasm/node_modules</code></p></li></ul><p>此外，專案目錄中的鎖定檔案只包含使用者定義的依賴項。</p><p>此改進使您的鎖定檔案僅關注您自己的依賴項，有助於維護更整潔的專案，並減少對您檔案的不必要更改。</p><p>此變更預設啟用，適用於 <code>wasm-js</code> 目標。此變更尚未實作，適用於 <code>js</code> 目標。儘管計劃在未來版本中實作，但在 Kotlin 2.2.20-Beta2 中，npm 依賴項的行為對於 <code>js</code> 目標保持不變。</p><h3 id="kotlin-wasm-和-javascript-互通中的異常處理改進" tabindex="-1">Kotlin/Wasm 和 JavaScript 互通中的異常處理改進 <a class="header-anchor" href="#kotlin-wasm-和-javascript-互通中的異常處理改進" aria-label="Permalink to &quot;Kotlin/Wasm 和 JavaScript 互通中的異常處理改進&quot;">​</a></h3><p>以前，Kotlin 難以理解在 JavaScript (JS) 中拋出並傳遞到 Kotlin/Wasm 程式碼的異常（錯誤）。</p><p>在某些情況下，問題也會反向發生，當異常透過 Wasm 程式碼拋出或傳遞到 JS 時，並被包裝成 <code>WebAssembly.Exception</code>，沒有任何詳細資訊。這些 Kotlin 異常處理問題使偵錯變得困難。</p><p>從 Kotlin 2.2.20-Beta2 開始，異常處理的開發者體驗在兩個方向上都有所改進：</p><ul><li>當異常從 JavaScript 拋出時：您可以在 Kotlin 端看到更多資訊。 當此類異常透過 Kotlin 傳播回 JS 時，它不再被包裝成 WebAssembly。</li><li>當異常從 Kotlin 拋出時：它們現在可以在 JavaScript 端作為 JS 錯誤被捕獲。</li></ul><p>新的異常處理會自動工作，在支援 <a href="https://webassembly.github.io/exception-handling/js-api/#dom-webassembly-jstag" target="_blank" rel="noreferrer"><code>WebAssembly.JSTag</code></a> 功能的現代瀏覽器中：</p><ul><li>Chrome 115+</li><li>Firefox 129+</li><li>Safari 18.4+</li></ul><p>在舊瀏覽器中，異常處理行為保持不變。</p><h2 id="kotlin-js" tabindex="-1">Kotlin/JS <a class="header-anchor" href="#kotlin-js" aria-label="Permalink to &quot;Kotlin/JS&quot;">​</a></h2><p>Kotlin 2.2.20-Beta2 支援使用 <code>BigInt</code> 型別來表示 Kotlin 的 <code>Long</code> 型別，啟用在匯出宣告中使用 <code>Long</code>。此外，此版本新增了一個 DSL 函式，用於清理 Node.js 引數。</p>`,39)),n(a,{id:"使用-bigint-型別表示-kotlin-的-long-型別",level:"3",title:"使用 BigInt 型別表示 Kotlin 的 Long 型別",labelRef:"experimental-opt-in"}),s[5]||(s[5]=i(`<p>在 ES2020 標準之前，JavaScript (JS) 不支援原始型別，用於精確大於 53 位的整數。</p><p>因此，Kotlin/JS 以前將 <code>Long</code> 值（64 位寬）表示為包含兩個 <code>number</code> 屬性的 JavaScript 物件。此自定義實作使 Kotlin 和 JavaScript 之間的互通性更加複雜。</p><p>從 Kotlin 2.2.20-Beta2 開始，當編譯到現代 JavaScript (ES2020) 時，Kotlin/JS 現在使用 JavaScript 內建的 <code>BigInt</code> 型別來表示 Kotlin 的 <code>Long</code> 值。</p><p>此變更啟用<a href="#usage-of-long-in-exported-declarations">將 <code>Long</code> 型別匯出到 JavaScript</a>，該功能也隨 2.2.20-Beta2 一同引入。因此，此變更簡化了 Kotlin 和 JavaScript 之間的互通性。</p><p>要啟用它，請將以下編譯器選項新增到您的 <code>build.gradle(.kts)</code> 檔案中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-Xes-long-as-bigint&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此功能仍然是<a href="/zh-Hant/kotlin/components-stability#stability-levels-explained">實驗性</a>的。 請在我們的問題追蹤器 <a href="https://youtrack.jetbrains.com/issue/KT-57128" target="_blank" rel="noreferrer">YouTrack</a> 中報告任何問題。</p><h4 id="在匯出宣告中使用-long" tabindex="-1">在匯出宣告中使用 Long <a class="header-anchor" href="#在匯出宣告中使用-long" aria-label="Permalink to &quot;在匯出宣告中使用 Long&quot;">​</a></h4><p>因為 Kotlin/JS 使用了自定義的 <code>Long</code> 表示，因此很難提供一種直接的方式從 JavaScript 與 Kotlin 的 <code>Long</code> 進行互動。因此，您無法將使用 <code>Long</code> 型別的 Kotlin 程式碼匯出到 JavaScript。 此問題影響了任何使用 <code>Long</code> 的程式碼，例如函式參數、類屬性或建構函式。</p><p>既然 Kotlin 的 <code>Long</code> 型別可以編譯為 JavaScript 的 <code>BigInt</code> 型別，Kotlin/JS 支援將 <code>Long</code> 值匯出到 JavaScript，簡化了 Kotlin 和 JavaScript 程式碼之間的互通性。</p><p>要啟用此功能：</p><ol><li><p>允許在 Kotlin/JS 中匯出 <code>Long</code>。將以下編譯器引數新增到您的 <code>build.gradle(.kts)</code> 檔案中的 <code>freeCompilerArgs</code> 屬性：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// build.gradle.kts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        ..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        compilerOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {                   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            freeCompilerArgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-XXLanguage:+JsAllowLongInExportedDeclarations&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>啟用 <code>BigInt</code> 型別。有關如何啟用它，請參閱<a href="#usage-of-bigint-type-to-represent-kotlin-s-long-type">使用 <code>BigInt</code> 型別表示 Kotlin 的 <code>Long</code> 型別</a>。</p></li></ol><h3 id="用於更簡潔引數的新-dsl-函式" tabindex="-1">用於更簡潔引數的新 DSL 函式 <a class="header-anchor" href="#用於更簡潔引數的新-dsl-函式" aria-label="Permalink to &quot;用於更簡潔引數的新 DSL 函式&quot;">​</a></h3><p>當使用 Node.js 執行 Kotlin/JS 應用程式時，傳遞給程式 (<code>args</code>) 的引數以前包括：</p><ul><li>可執行檔 <code>Node</code> 的路徑。</li><li>您的腳本路徑。</li><li>您提供的實際命令列引數。</li></ul><p>然而，<code>args</code> 的預期行為是僅包含命令列引數。為了實現這一點，您必須手動跳過前兩個引數，在您的 <code>build.gradle(.kts)</code> 檔案或 Kotlin 程式碼中使用 <code>drop()</code> 函式：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">drop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">joinToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;, &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>這種變通方法是重複的、容易出錯的，並且在平台之間共享程式碼時效果不佳。</p><p>為了解決此問題，Kotlin 2.2.20-Beta2 引入了一個新的 DSL 函式，名為 <code>passCliArgumentsToMainFunction()</code>。</p><p>使用此函式，引數只包含命令列引數，並排除 <code>Node</code> 和腳本路徑：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 無需使用 drop()，只包含您的自定義引數</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">joinToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;, &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此變更減少了樣板程式碼，避免了手動刪除引數造成的錯誤，並提高了跨平台相容性。</p><p>要啟用此功能，請將以下 DSL 函式新增到您的 <code>build.gradle(.kts)</code> 檔案中：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    js</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        nodejs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            passCliArgumentsToMainFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="gradle-kotlin-native-任務的建置報告中新增編譯器效能指標" tabindex="-1">Gradle：Kotlin/Native 任務的建置報告中新增編譯器效能指標 <a class="header-anchor" href="#gradle-kotlin-native-任務的建置報告中新增編譯器效能指標" aria-label="Permalink to &quot;Gradle：Kotlin/Native 任務的建置報告中新增編譯器效能指標&quot;">​</a></h2><p>在 Kotlin 1.7.0 中，我們引入了<a href="/zh-Hant/kotlin/gradle-compilation-and-caches#build-reports">建置報告</a>以協助追蹤編譯器效能。從那時起，我們新增了更多指標，使這些報告更加詳細和有用，用於調查效能問題。</p><p>在 Kotlin 2.2.20-Beta2 中，建置報告現在包含適用於 Kotlin/Native 任務的編譯器效能指標。</p><p>要了解有關建置報告以及如何配置它們的更多資訊，請參閱<a href="/zh-Hant/kotlin/gradle-compilation-and-caches#enabling-build-reports">啟用建置報告</a>。</p><h2 id="maven-kotlin-maven-plugin-中對-kotlin-守護行程的支援" tabindex="-1">Maven：kotlin-maven-plugin 中對 Kotlin 守護行程的支援 <a class="header-anchor" href="#maven-kotlin-maven-plugin-中對-kotlin-守護行程的支援" aria-label="Permalink to &quot;Maven：kotlin-maven-plugin 中對 Kotlin 守護行程的支援&quot;">​</a></h2><p>隨著 <a href="/zh-Hant/kotlin/whatsnew22#new-experimental-build-tools-api">Kotlin 2.2.0 中建置工具 API</a> 的引入，Kotlin 2.2.20-Beta2 更進一步，透過在 <code>kotlin-maven-plugin</code> 中新增對 Kotlin 守護行程的支援。當使用 Kotlin 守護行程時，Kotlin 編譯器在一個獨立的程序中運行，這可以防止其他 Maven 插件覆寫系統屬性。您可以在此 <a href="https://youtrack.jetbrains.com/issue/KT-43894/Maven-Windows-error-RuntimeException-Could-not-find-installation-home-path" target="_blank" rel="noreferrer">YouTrack 問題</a> 中看到一個範例。</p><p>從 Kotlin 2.2.20-Beta2 開始，Kotlin 守護行程預設啟用。這為您帶來了<a href="/zh-Hant/kotlin/maven#enable-incremental-compilation">增量編譯</a>的額外好處，這可以幫助加快您的建置時間。如果您想恢復到以前的行為，請透過在您的 <code>pom.xml</code> 檔案中將以下屬性設定為 <code>false</code> 來選擇退出：</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">properties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kotlin.compiler.daemon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;false&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kotlin.compiler.daemon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">properties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Kotlin 2.2.20-Beta2 還引入了一個新的 <code>jvmArgs</code> 屬性，您可以使用它來自訂適用於 Kotlin 守護行程的預設 JVM 引數。例如，要覆寫 <code>-Xmx</code> 和 <code>-Xms</code> 選項，請將以下內容新增到您的 <code>pom.xml</code> 檔案中：</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">properties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kotlin.compiler.daemon.jvmArgs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Xmx1500m,Xms500m&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kotlin.compiler.daemon.jvmArgs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">properties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div>`,34)),n(a,{id:"標準函式庫-kotlin-js-中透過反射識別介面型別的支援",level:"2",title:"標準函式庫：Kotlin/JS 中透過反射識別介面型別的支援",labelRef:"experimental-opt-in"}),s[6]||(s[6]=i(`<p>Kotlin 2.2.20-Beta2 將實驗性 <code>KClass.isInterface</code> 屬性新增到 Kotlin/JS 標準函式庫。</p><p>透過此屬性，您現在可以檢查類引用是否代表 Kotlin 介面。這使 Kotlin/JS 更接近與 Kotlin/JVM 的對等，在 Kotlin/JVM 中，您可以使用 <code>KClass.java.isInterface</code> 來檢查類是否代表介面。</p><p>要選擇啟用，請使用 <code>@OptIn(ExperimentalStdlibApi::class)</code> 註解：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@OptIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ExperimentalStdlibApi::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inspect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(klass: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;*&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 對於介面列印 true</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(klass.isInterface)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我們非常感謝您在我們的問題追蹤器 <a href="https://youtrack.jetbrains.com/issue/KT-78581" target="_blank" rel="noreferrer">YouTrack</a> 中提供回饋。</p>`,5))])}const v=e(r,[["render",o]]);export{m as __pageData,v as default};
