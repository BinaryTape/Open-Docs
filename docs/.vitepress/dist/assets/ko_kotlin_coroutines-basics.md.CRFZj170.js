import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.Bksy39di.js";const c=JSON.parse('{"title":"코루틴 기본 개념","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/coroutines-basics.md","filePath":"ko/kotlin/coroutines-basics.md","lastUpdated":1754307826000}'),t={name:"ko/kotlin/coroutines-basics.md"};function p(e,s,h,k,o,d){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="코루틴-기본-개념" tabindex="-1">코루틴 기본 개념 <a class="header-anchor" href="#코루틴-기본-개념" aria-label="Permalink to &quot;코루틴 기본 개념&quot;">​</a></h1><p>이 섹션에서는 코루틴의 기본 개념을 다룹니다.</p><h2 id="첫-번째-코루틴" tabindex="-1">첫 번째 코루틴 <a class="header-anchor" href="#첫-번째-코루틴" aria-label="Permalink to &quot;첫 번째 코루틴&quot;">​</a></h2><p>_코루틴_은 일시 중단 가능한 계산의 인스턴스입니다. 이는 나머지 코드와 동시에 작동하는 코드 블록을 실행한다는 점에서 스레드와 개념적으로 유사합니다. 하지만 코루틴은 특정 스레드에 묶여 있지 않습니다. 한 스레드에서 실행을 일시 중단하고 다른 스레드에서 재개할 수 있습니다.</p><p>코루틴은 경량 스레드로 생각할 수 있지만, 실제 사용 방식이 스레드와 매우 다른 여러 중요한 차이점이 있습니다.</p><p>다음 코드를 실행하여 첫 번째 작동 코루틴을 만들어보세요.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// this: CoroutineScope</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 새로운 코루틴을 시작하고 계속 진행</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1초 동안 논블로킹 지연 (기본 시간 단위는 밀리초)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;World!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 지연 후 출력</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 이전 코루틴이 지연되는 동안 메인 코루틴은 계속 진행</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>전체 코드는 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-01.kt" target="_blank" rel="noreferrer">여기</a>에서 확인할 수 있습니다.</p></div><p>다음과 같은 결과를 확인할 수 있습니다.</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Hello</span></span>
<span class="line"><span>World!</span></span></code></pre></div><p>이 코드가 무엇을 하는지 자세히 살펴보겠습니다.</p><p><code>[launch]</code>는 _코루틴 빌더_입니다. 이는 나머지 코드와 동시에 새로운 코루틴을 시작하며, 이 코루틴은 독립적으로 계속 작동합니다. 그래서 <code>Hello</code>가 먼저 출력되었습니다.</p><p><code>[delay]</code>는 특별한 _일시 중단 함수_입니다. 이는 특정 시간 동안 코루틴을 _일시 중단_합니다. 코루틴을 일시 중단하는 것은 기본 스레드를 _블록_하지 않고, 다른 코루틴이 실행되어 기본 스레드를 사용하여 코드를 실행하도록 허용합니다.</p><p><code>[runBlocking]</code> 또한 일반적인 <code>fun main()</code>의 비 코루틴 세계와 <code>runBlocking { ... }</code> 중괄호 내부의 코루틴이 있는 코드를 연결하는 코루틴 빌더입니다. 이는 <code>runBlocking</code> 시작 중괄호 바로 뒤에 있는 <code>this: CoroutineScope</code> 힌트를 통해 IDE에서 강조 표시됩니다.</p><p>이 코드에서 <code>runBlocking</code>을 제거하거나 잊어버리면, <code>launch</code>는 <code>[CoroutineScope]</code>에만 선언되어 있기 때문에 <code>[launch]</code> 호출에서 오류가 발생합니다.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Unresolved reference: launch</span></span></code></pre></div><p><code>runBlocking</code>의 이름은 이를 실행하는 스레드(이 경우 — 메인 스레드)가 <code>runBlocking { ... }</code> 내부의 모든 코루틴이 실행을 완료할 때까지 호출 기간 동안 _블록_된다는 것을 의미합니다. <code>runBlocking</code>은 애플리케이션의 최상위 레벨에서 이처럼 사용되는 경우가 많으며, 실제 코드에서는 거의 볼 수 없습니다. 스레드는 비용이 많이 드는 리소스이며, 스레드를 블록하는 것은 비효율적이고 종종 바람직하지 않기 때문입니다.</p><h3 id="구조화된-동시성" tabindex="-1">구조화된 동시성 <a class="header-anchor" href="#구조화된-동시성" aria-label="Permalink to &quot;구조화된 동시성&quot;">​</a></h3><p>코루틴은 <strong>구조화된 동시성</strong> 원칙을 따릅니다. 이는 새로운 코루틴이 코루틴의 수명을 제한하는 특정 <code>[CoroutineScope]</code> 내에서만 시작될 수 있음을 의미합니다. 위 예시는 <code>[runBlocking]</code>이 해당 스코프를 설정함을 보여주며, 그래서 이전 예시는 1초 지연 후 <code>World!</code>가 출력될 때까지 기다린 다음 종료됩니다.</p><p>실제 애플리케이션에서는 많은 코루틴을 시작하게 될 것입니다. 구조화된 동시성은 코루틴이 손실되거나 누수되지 않도록 보장합니다. 외부 스코프는 모든 자식 코루틴이 완료될 때까지 완료될 수 없습니다. 또한 구조화된 동시성은 코드의 모든 오류가 적절하게 보고되고 절대 손실되지 않도록 보장합니다.</p><h2 id="함수-추출-리팩토링" tabindex="-1">함수 추출 리팩토링 <a class="header-anchor" href="#함수-추출-리팩토링" aria-label="Permalink to &quot;함수 추출 리팩토링&quot;">​</a></h2><p><code>launch { ... }</code> 내부의 코드 블록을 별도의 함수로 추출해봅시다. 이 코드에 대해 &quot;함수 추출&quot; 리팩토링을 수행하면, <code>suspend</code> 수정자가 붙은 새로운 함수를 얻게 됩니다. 이것이 첫 번째 _일시 중단 함수_입니다. 일시 중단 함수는 일반 함수와 마찬가지로 코루틴 내부에서 사용할 수 있지만, 추가적인 기능은 다른 일시 중단 함수(이 예시의 <code>delay</code>처럼)를 사용하여 코루틴의 실행을 _일시 중단_할 수 있다는 점입니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// this: CoroutineScope</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">doWorld</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 이것이 첫 번째 일시 중단 함수입니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doWorld</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;World!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//샘플 끝</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>전체 코드는 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-02.kt" target="_blank" rel="noreferrer">여기</a>에서 확인할 수 있습니다.</p></div><h2 id="스코프-빌더" tabindex="-1">스코프 빌더 <a class="header-anchor" href="#스코프-빌더" aria-label="Permalink to &quot;스코프 빌더&quot;">​</a></h2><p>다른 빌더가 제공하는 코루틴 스코프 외에도, <code>[coroutineScope][_coroutineScope]</code> 빌더를 사용하여 자신만의 스코프를 선언할 수 있습니다. 이는 코루틴 스코프를 생성하며, 시작된 모든 자식 코루틴이 완료될 때까지 완료되지 않습니다.</p><p><code>[runBlocking]</code>과 <code>[coroutineScope][_coroutineScope]</code> 빌더는 본문과 모든 자식 코루틴이 완료될 때까지 기다리기 때문에 비슷해 보일 수 있습니다. 주요 차이점은 <code>[runBlocking]</code> 메서드는 대기하는 동안 현재 스레드를 _블록_하는 반면, <code>[coroutineScope][_coroutineScope]</code>는 단순히 일시 중단하여 기본 스레드를 다른 용도로 사용할 수 있게 해준다는 점입니다. 이러한 차이 때문에 <code>[runBlocking]</code>은 일반 함수이고 <code>[coroutineScope][_coroutineScope]</code>는 일시 중단 함수입니다.</p><p>어떤 일시 중단 함수에서도 <code>coroutineScope</code>를 사용할 수 있습니다. 예를 들어, <code>Hello</code>와 <code>World</code>의 동시 출력을 <code>suspend fun doWorld()</code> 함수로 옮길 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    doWorld</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doWorld</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> coroutineScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// this: CoroutineScope</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;World!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>전체 코드는 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-03.kt" target="_blank" rel="noreferrer">여기</a>에서 확인할 수 있습니다.</p></div><p>이 코드도 다음과 같이 출력합니다.</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Hello</span></span>
<span class="line"><span>World!</span></span></code></pre></div><h2 id="스코프-빌더와-동시성" tabindex="-1">스코프 빌더와 동시성 <a class="header-anchor" href="#스코프-빌더와-동시성" aria-label="Permalink to &quot;스코프 빌더와 동시성&quot;">​</a></h2><p><code>[coroutineScope][_coroutineScope]</code> 빌더는 여러 동시 작업을 수행하기 위해 모든 일시 중단 함수 내에서 사용될 수 있습니다. <code>doWorld</code> 일시 중단 함수 내에서 두 개의 동시 코루틴을 시작해봅시다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// doWorld를 순차적으로 실행한 다음 &quot;Done&quot;을 실행</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    doWorld</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Done&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 두 섹션을 동시에 실행</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doWorld</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> coroutineScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// this: CoroutineScope</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;World 2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;World 1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>전체 코드는 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-04.kt" target="_blank" rel="noreferrer">여기</a>에서 확인할 수 있습니다.</p></div><p><code>launch { ... }</code> 블록 내부의 두 코드 조각은 <em>동시에</em> 실행되며, 시작 후 1초 뒤에 <code>World 1</code>이 먼저 출력되고, 2초 뒤에 <code>World 2</code>가 출력됩니다. <code>doWorld</code> 내의 <code>[coroutineScope][_coroutineScope]</code>는 둘 다 완료된 후에야 완료되므로, <code>doWorld</code>는 그 후에야 반환되고 <code>Done</code> 문자열이 출력되도록 허용합니다.</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Hello</span></span>
<span class="line"><span>World 1</span></span>
<span class="line"><span>World 2</span></span>
<span class="line"><span>Done</span></span></code></pre></div><h2 id="명시적-잡-job" tabindex="-1">명시적 잡(Job) <a class="header-anchor" href="#명시적-잡-job" aria-label="Permalink to &quot;명시적 잡(Job)&quot;">​</a></h2><p><code>[launch]</code> 코루틴 빌더는 시작된 코루틴에 대한 핸들이며 그 완료를 명시적으로 기다리는 데 사용될 수 있는 <code>[Job]</code> 객체를 반환합니다. 예를 들어, 자식 코루틴의 완료를 기다린 다음 &quot;Done&quot; 문자열을 출력할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> job </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 새로운 코루틴을 시작하고 해당 Job에 대한 참조 유지</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;World!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    job.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 자식 코루틴이 완료될 때까지 대기</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Done&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>전체 코드는 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-05.kt" target="_blank" rel="noreferrer">여기</a>에서 확인할 수 있습니다.</p></div><p>이 코드는 다음을 생성합니다.</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Hello</span></span>
<span class="line"><span>World!</span></span>
<span class="line"><span>Done</span></span></code></pre></div><h2 id="코루틴은-경량이다" tabindex="-1">코루틴은 경량이다 <a class="header-anchor" href="#코루틴은-경량이다" aria-label="Permalink to &quot;코루틴은 경량이다&quot;">​</a></h2><p>코루틴은 JVM 스레드보다 리소스 집약적이지 않습니다. 스레드를 사용할 때 JVM의 가용 메모리를 소모시키는 코드를 리소스 제한에 도달하지 않고 코루틴을 사용하여 표현할 수 있습니다. 예를 들어, 다음 코드는 각각 5초를 기다린 다음 마침표(&#39;.&#39;)를 출력하면서 아주 적은 메모리를 소비하는 50,000개의 고유한 코루틴을 시작합니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlinx.coroutines.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 많은 코루틴 시작</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5000L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>전체 코드는 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-06.kt" target="_blank" rel="noreferrer">여기</a>에서 확인할 수 있습니다.</p></div><p>스레드를 사용하여 동일한 프로그램을 작성하면(<code>runBlocking</code>을 제거하고, <code>launch</code>를 <code>thread</code>로 바꾸고, <code>delay</code>를 <code>Thread.sleep</code>으로 바꾸면) 많은 메모리를 소비할 것입니다. 운영 체제, JDK 버전 및 설정에 따라, 메모리 부족 오류를 발생시키거나 스레드를 천천히 시작하여 동시에 실행되는 스레드가 너무 많지 않도록 할 것입니다.</p>`,49)]))}const E=i(t,[["render",p]]);export{c as __pageData,E as default};
