import{_ as r,C as p,c as o,o as d,ag as e,G as t,w as n,j as i,a}from"./chunks/framework.Bksy39di.js";const f=JSON.parse('{"title":"Kotlin 1.5.0 有哪些新特性","description":"","frontmatter":{},"headers":[],"relativePath":"kotlin/whatsnew15.md","filePath":"kotlin/whatsnew15.md","lastUpdated":1754307826000}'),c={name:"kotlin/whatsnew15.md"};function g(E,s,y,u,F,b){const l=p("YouTubeVideo"),h=p("tab"),k=p("tabs");return d(),o("div",null,[s[4]||(s[4]=e(`<h1 id="kotlin-1-5-0-有哪些新特性" tabindex="-1">Kotlin 1.5.0 有哪些新特性 <a class="header-anchor" href="#kotlin-1-5-0-有哪些新特性" aria-label="Permalink to &quot;Kotlin 1.5.0 有哪些新特性&quot;">​</a></h1><p><em><a href="/kotlin/releases#release-details">发布日期：2021 年 5 月 5 日</a></em></p><p>Kotlin 1.5.0 引入了新的语言特性、稳定的基于 IR 的 JVM 编译器后端、性能改进以及稳定实验性的特性和弃用过时特性等演进性变更。</p><p>您还可以在<a href="https://blog.jetbrains.com/kotlin/2021/04/kotlin-1-5-0-released/" target="_blank" rel="noreferrer">发布博客文章</a>中找到这些变更的概述。</p><h2 id="语言特性" tabindex="-1">语言特性 <a class="header-anchor" href="#语言特性" aria-label="Permalink to &quot;语言特性&quot;">​</a></h2><p>Kotlin 1.5.0 带来了在 <a href="/kotlin/whatsnew1430#language-features">1.4.30 中预览</a>的新语言特性的稳定版本：</p><ul><li><a href="#jvm-records-support">JVM records 支持</a></li><li><a href="#sealed-interfaces">密封接口</a>和<a href="#package-wide-sealed-class-hierarchies">密封类改进</a></li><li><a href="#inline-classes">内联类</a></li></ul><p>这些特性的详细描述可在<a href="https://blog.jetbrains.com/kotlin/2021/02/new-language-features-preview-in-kotlin-1-4-30/" target="_blank" rel="noreferrer">这篇博客文章</a>和 Kotlin 文档的相应页面中找到。</p><h3 id="jvm-records-支持" tabindex="-1">JVM records 支持 <a class="header-anchor" href="#jvm-records-支持" aria-label="Permalink to &quot;JVM records 支持&quot;">​</a></h3><p>Java 正在快速演进，为了确保 Kotlin 能够与其保持互操作性，我们引入了对其最新特性之一 — <a href="https://openjdk.java.net/jeps/395" target="_blank" rel="noreferrer">record 类</a>的支持。</p><p>Kotlin 对 JVM records 的支持包括双向互操作性：</p><ul><li>在 Kotlin 代码中，您可以像使用带有属性的常规类一样使用 Java record 类。</li><li>要在 Java 代码中将 Kotlin 类用作 record，请将其设为 <code>data</code> 类并使用 <code>@JvmRecord</code> 注解标记它。</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmRecord</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><a href="/kotlin/jvm-records">了解更多关于在 Kotlin 中使用 JVM record 的信息</a>。</p>`,14)),t(l,{src:"https://www.youtube.com/v/iyEWXyuuseU",title:"Support for JVM Records in Kotlin 1.5.0"}),s[5]||(s[5]=e(`<h3 id="密封接口" tabindex="-1">密封接口 <a class="header-anchor" href="#密封接口" aria-label="Permalink to &quot;密封接口&quot;">​</a></h3><p>Kotlin 接口现在可以拥有 <code>sealed</code> 修饰符，它在接口上的工作方式与在类上相同：密封接口的所有实现都在编译期已知。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Polygon</span></span></code></pre></div><p>您可以依赖这一事实，例如，编写详尽的 <code>when</code> 表达式。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> draw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(polygon: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Polygon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> when</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (polygon) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Rectangle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Triangle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // else is not needed - all possible implementations are covered</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此外，密封接口支持更灵活的受限类层级结构，因为一个类可以直接继承多个密封接口。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FilledRectangle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Polygon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Fillable</span></span></code></pre></div><p><a href="/kotlin/sealed-classes">了解更多关于密封接口的信息</a>。</p>`,8)),t(l,{src:"https://www.youtube.com/v/d_Mor21W_60",title:"Sealed Interfaces and Sealed Classes Improvements"}),s[6]||(s[6]=e(`<h3 id="包级密封类层级结构" tabindex="-1">包级密封类层级结构 <a class="header-anchor" href="#包级密封类层级结构" aria-label="Permalink to &quot;包级密封类层级结构&quot;">​</a></h3><p>密封类现在可以在同一编译单元和同一包的所有文件中拥有子类。以前，所有子类都必须出现在同一个文件中。</p><p>直接子类可以是顶层类，也可以嵌套在任意数量的其他命名类、命名接口或命名对象中。</p><p>密封类的子类必须具有正确限定的名称 — 它们不能是局部或匿名对象。</p><p><a href="/kotlin/sealed-classes#inheritance">了解更多关于密封类层级结构的信息</a>。</p><h3 id="内联类" tabindex="-1">内联类 <a class="header-anchor" href="#内联类" aria-label="Permalink to &quot;内联类&quot;">​</a></h3><p>内联类是仅包含值的<a href="https://github.com/Kotlin/KEEP/blob/master/notes/value-classes.md" target="_blank" rel="noreferrer">基于值的</a>类的一个子集。您可以将它们用作某种类型值的包装器，而不会产生使用内存分配带来的额外开销。</p><p>内联类可以在类名之前使用 <code>value</code> 修饰符声明：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Password</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>JVM 后端还需要一个特殊的 <code>@JvmInline</code> 注解：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@JvmInline</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Password</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><code>inline</code> 修饰符现在已被弃用并带有警告。</p><p><a href="/kotlin/inline-classes">了解更多关于内联类的信息</a>。</p>`,13)),t(l,{src:"https://www.youtube.com/v/LpqvtgibbsQ",title:"From Inline to Value Classes"}),s[7]||(s[7]=e('<h2 id="kotlin-jvm" tabindex="-1">Kotlin/JVM <a class="header-anchor" href="#kotlin-jvm" aria-label="Permalink to &quot;Kotlin/JVM&quot;">​</a></h2><p>Kotlin/JVM 获得了一些改进，包括内部和面向用户的。以下是其中最值得关注的：</p><ul><li><a href="#stable-jvm-ir-backend">稳定的 JVM IR 后端</a></li><li><a href="#new-default-jvm-target-1-8">新的默认 JVM 目标：1.8</a></li><li><a href="#sam-adapters-via-invokedynamic">通过 invokedynamic 实现 SAM 适配器</a></li><li><a href="#lambdas-via-invokedynamic">通过 invokedynamic 实现 Lambda 表达式</a></li><li><a href="#deprecation-of-jvmdefault-and-old-xjvm-default-modes">@JvmDefault 和旧的 Xjvm-default 模式的弃用</a></li><li><a href="#improvements-to-handling-nullability-annotations">空安全注解处理的改进</a></li></ul><h3 id="稳定的-jvm-ir-后端" tabindex="-1">稳定的 JVM IR 后端 <a class="header-anchor" href="#稳定的-jvm-ir-后端" aria-label="Permalink to &quot;稳定的 JVM IR 后端&quot;">​</a></h3><p>Kotlin/JVM 编译器的<a href="/kotlin/whatsnew14#new-jvm-ir-backend">基于 IR 的后端</a>现在已<a href="/kotlin/components-stability">稳定</a>并默认启用。</p><p>从 <a href="/kotlin/whatsnew14">Kotlin 1.4.0</a> 开始，基于 IR 后端的早期版本可供预览，现在它已成为语言版本 <code>1.5</code> 的默认设置。对于更早的语言版本，旧后端仍默认使用。</p><p>您可以在<a href="https://blog.jetbrains.com/kotlin/2021/02/the-jvm-backend-is-in-beta-let-s-make-it-stable-together/" target="_blank" rel="noreferrer">这篇博客文章</a>中找到更多关于 IR 后端优势及其未来发展的详细信息。</p><p>如果您需要在 Kotlin 1.5.0 中使用旧后端，可以将以下行添加到项目的配置文件中：</p><ul><li>在 Gradle 中：</li></ul>',9)),t(k,{group:"build-script"},{default:n(()=>[t(h,{title:"Kotlin","group-key":"kotlin"},{default:n(()=>s[0]||(s[0]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"tasks."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"withType"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"org"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"jetbrains"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"gradle"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"dsl"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"."),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"KotlinJvmCompile"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"> {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"  kotlinOptions.useOldBackend "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," true")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),t(h,{title:"Groovy","group-key":"groovy"},{default:n(()=>s[1]||(s[1]=[i("div",{class:"language-groovy vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"groovy"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"tasks"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"withType("),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"org.jetbrains.kotlin.gradle.dsl.KotlinJvmCompile"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," kotlinOptions"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"useOldBackend "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," true")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),s[8]||(s[8]=e(`<ul><li>在 Maven 中：</li></ul><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">configuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;-Xuse-old-backend&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">configuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="新的默认-jvm-目标-1-8" tabindex="-1">新的默认 JVM 目标：1.8 <a class="header-anchor" href="#新的默认-jvm-目标-1-8" aria-label="Permalink to &quot;新的默认 JVM 目标：1.8&quot;">​</a></h3><p>Kotlin/JVM 编译的默认目标版本现在是 <code>1.8</code>。<code>1.6</code> 目标已弃用。</p><p>如果您需要针对 JVM 1.6 进行构建，仍可切换到此目标。了解如何操作：</p><ul><li><a href="/kotlin/gradle-compiler-options#attributes-specific-to-jvm">在 Gradle 中</a></li><li><a href="/kotlin/maven#attributes-specific-to-jvm">在 Maven 中</a></li><li><a href="/kotlin/compiler-reference#jvm-target-version">在命令行编译器中</a></li></ul><h3 id="通过-invokedynamic-实现-sam-适配器" tabindex="-1">通过 invokedynamic 实现 SAM 适配器 <a class="header-anchor" href="#通过-invokedynamic-实现-sam-适配器" aria-label="Permalink to &quot;通过 invokedynamic 实现 SAM 适配器&quot;">​</a></h3><p>Kotlin 1.5.0 现在使用动态调用（<code>invokedynamic</code>）来编译 SAM（单一抽象方法）转换：</p><ul><li>如果 SAM 类型是 [Java 接口]，则针对任何表达式</li><li>如果 SAM 类型是 [Kotlin 函数式接口]，则针对 lambda 表达式</li></ul><p>新的实现使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html#metafactory-java.lang.invoke.MethodHandles.Lookup-java.lang.String-java.lang.invoke.MethodType-java.lang.invoke.MethodType-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-" target="_blank" rel="noreferrer"><code>LambdaMetafactory.metafactory()</code></a>，辅助包装类在编译期间不再生成。这减小了应用程序 JAR 的大小，从而提高了 JVM 启动性能。</p><p>要回滚到基于匿名类生成的旧实现方案，请添加编译器选项 <code>-Xsam-conversions=class</code>。</p><p>了解如何<a href="/kotlin/gradle-compiler-options">在 Gradle</a>、<a href="/kotlin/maven#specify-compiler-options">Maven</a> 和<a href="/kotlin/compiler-reference#compiler-options">命令行编译器</a>中添加编译器选项。</p><h3 id="通过-invokedynamic-实现-lambda-表达式" tabindex="-1">通过 invokedynamic 实现 Lambda 表达式 <a class="header-anchor" href="#通过-invokedynamic-实现-lambda-表达式" aria-label="Permalink to &quot;通过 invokedynamic 实现 Lambda 表达式&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>将纯 Kotlin lambda 表达式编译为 invokedynamic 是<a href="/kotlin/components-stability">实验性的</a>。它可能随时被移除或更改。 需要选择启用（参见下方详细信息），您应该仅将其用于求值目的。我们感谢您在 <a href="https://youtrack.jetbrains.com/issue/KT-45375" target="_blank" rel="noreferrer">YouTrack</a> 中提供反馈。</p></div><p>Kotlin 1.5.0 引入了编译纯 Kotlin lambda 表达式（未转换为函数式接口实例的 lambda 表达式）为动态调用（<code>invokedynamic</code>）的实验性支持。该实现通过使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html#metafactory-java.lang.invoke.MethodHandles.Lookup-java.lang.String-java.lang.invoke.MethodType-java.lang.invoke.MethodType-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-" target="_blank" rel="noreferrer"><code>LambdaMetafactory.metafactory()</code></a> 生成更轻量的二进制文件，这实际上是在运行时生成必要的类。目前，与普通的 lambda 编译相比，它有三个限制：</p><ul><li>编译为 invokedynamic 的 lambda 表达式不可序列化。</li><li>对此类 lambda 表达式调用 <code>toString()</code> 会产生可读性较差的字符串表示。</li><li>实验性的 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect.jvm/reflect.html" target="_blank" rel="noreferrer"><code>reflect</code></a> API 不支持使用 <code>LambdaMetafactory</code> 创建的 lambda 表达式。</li></ul><p>要尝试此特性，请添加 <code>-Xlambdas=indy</code> 编译器选项。如果您能在<a href="https://youtrack.jetbrains.com/issue/KT-45375" target="_blank" rel="noreferrer">此 YouTrack 工单</a>中分享您的反馈，我们将不胜感激。</p><p>了解如何<a href="/kotlin/gradle-compiler-options">在 Gradle</a>、<a href="/kotlin/maven#specify-compiler-options">Maven</a> 和<a href="/kotlin/compiler-reference#compiler-options">命令行编译器</a>中添加编译器选项。</p><h3 id="jvmdefault-和旧的-xjvm-default-模式的弃用" tabindex="-1">@JvmDefault 和旧的 Xjvm-default 模式的弃用 <a class="header-anchor" href="#jvmdefault-和旧的-xjvm-default-模式的弃用" aria-label="Permalink to &quot;@JvmDefault 和旧的 Xjvm-default 模式的弃用&quot;">​</a></h3><p>在 Kotlin 1.4.0 之前，有 <code>@JvmDefault</code> 注解以及 <code>-Xjvm-default=enable</code> 和 <code>-Xjvm-default=compatibility</code> 模式。它们用于为 Kotlin 接口中的任何特定非抽象成员创建 JVM 默认方法。</p><p>在 Kotlin 1.4.0 中，我们<a href="https://blog.jetbrains.com/kotlin/2020/07/kotlin-1-4-m3-generating-default-methods-in-interfaces/" target="_blank" rel="noreferrer">引入了新的 <code>Xjvm-default</code> 模式</a>，它们为整个项目开启默认方法生成。</p><p>在 Kotlin 1.5.0 中，我们正在弃用 <code>@JvmDefault</code> 和旧的 Xjvm-default 模式：<code>-Xjvm-default=enable</code> 和 <code>-Xjvm-default=compatibility</code>。</p><p><a href="/kotlin/java-to-kotlin-interop#default-methods-in-interfaces">了解更多关于 Java 互操作中的默认方法</a>。</p><h3 id="空安全注解处理的改进" tabindex="-1">空安全注解处理的改进 <a class="header-anchor" href="#空安全注解处理的改进" aria-label="Permalink to &quot;空安全注解处理的改进&quot;">​</a></h3><p>Kotlin 支持使用<a href="/kotlin/java-interop#nullability-annotations">空安全注解</a>处理来自 Java 的类型可空性信息。Kotlin 1.5.0 为此特性引入了多项改进：</p><ul><li>它会读取编译后的 Java 库中用作依赖项的类型实参上的空安全注解。</li><li>它支持带有 <code>TYPE_USE</code> 目标的空安全注解，适用于： <ul><li>数组</li><li>可变参数</li><li>字段</li><li>类型形参及其界限</li><li>基类和接口的类型实参</li></ul></li><li>如果空安全注解具有适用于类型的多个目标，并且其中一个目标是 <code>TYPE_USE</code>，则优先使用 <code>TYPE_USE</code>。例如，如果 <code>@Nullable</code> 支持 <code>TYPE_USE</code> 和 <code>METHOD</code> 作为目标，则方法签名 <code>@Nullable String[] f()</code> 变为 <code>fun f(): Array&lt;String?&gt;!</code>。</li></ul><p>对于这些新支持的场景，从 Kotlin 调用 Java 时使用错误的类型可空性会产生警告。使用 <code>-Xtype-enhancement-improvements-strict-mode</code> 编译器选项可为这些场景启用严格模式（并报告错误）。</p><p><a href="/kotlin/java-interop#null-safety-and-platform-types">了解更多关于空安全和平台类型的信息</a>。</p><h2 id="kotlin-native" tabindex="-1">Kotlin/Native <a class="header-anchor" href="#kotlin-native" aria-label="Permalink to &quot;Kotlin/Native&quot;">​</a></h2><p>Kotlin/Native 现在性能更高且更稳定。值得关注的变更是：</p><ul><li><a href="#performance-improvements">性能改进</a></li><li><a href="#deactivation-of-the-memory-leak-checker">内存泄漏检查器的停用</a></li></ul><h3 id="性能改进" tabindex="-1">性能改进 <a class="header-anchor" href="#性能改进" aria-label="Permalink to &quot;性能改进&quot;">​</a></h3><p>在 1.5.0 中，Kotlin/Native 获得了一系列性能改进，可加快编译和执行速度。</p><p>编译器缓存现在在调试模式下受支持，适用于 <code>linuxX64</code>（仅在 Linux 主机上）和 <code>iosArm64</code> 目标平台。启用编译器缓存后，除了首次编译，大多数调试编译都会快得多。测量结果显示，在我们的测试项目中速度提高了约 200%。</p><p>要为新目标使用编译器缓存，请通过将以下行添加到项目的 <code>gradle.properties</code> 中来选择启用：</p><ul><li>对于 <code>linuxX64</code>：<code>kotlin.native.cacheKind.linuxX64=static</code></li><li>对于 <code>iosArm64</code>：<code>kotlin.native.cacheKind.iosArm64=static</code></li></ul><p>如果您在启用编译器缓存后遇到任何问题，请向我们的问题追踪器 <a href="https://kotl.in/issue" target="_blank" rel="noreferrer">YouTrack</a> 报告。</p><p>其他改进可加快 Kotlin/Native 代码的执行速度：</p><ul><li>琐碎的属性访问器被内联。</li><li>字符串字面量上的 <code>trimIndent()</code> 在编译期间求值。</li></ul><h3 id="内存泄漏检查器的停用" tabindex="-1">内存泄漏检查器的停用 <a class="header-anchor" href="#内存泄漏检查器的停用" aria-label="Permalink to &quot;内存泄漏检查器的停用&quot;">​</a></h3><p>内置的 Kotlin/Native 内存泄漏检查器已默认禁用。</p><p>它最初是为内部使用而设计的，并且只能在有限数量的场景中发现泄漏，而不是所有场景。此外，后来发现它存在可能导致应用程序崩溃的问题。因此我们决定关闭内存泄漏检查器。</p><p>内存泄漏检查器在某些场景下仍然有用，例如单元测试。对于这些场景，您可以通过添加以下代码行来启用它：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Platform.isMemoryLeakCheckerActive </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span></code></pre></div><p>请注意，不建议为应用程序运行时启用该检查器。</p><h2 id="kotlin-js" tabindex="-1">Kotlin/JS <a class="header-anchor" href="#kotlin-js" aria-label="Permalink to &quot;Kotlin/JS&quot;">​</a></h2><p>Kotlin/JS 在 1.5.0 中获得了演进性变更。我们正继续努力使 <a href="/kotlin/js-ir-compiler">JS IR 编译器后端</a>趋于稳定并发布其他更新：</p><ul><li><a href="#upgrade-to-webpack-5">webpack 升级到版本 5</a></li><li><a href="#frameworks-and-libraries-for-the-ir-compiler">IR 编译器的框架和库</a></li></ul><h3 id="webpack-升级到版本-5" tabindex="-1">webpack 升级到版本 5 <a class="header-anchor" href="#webpack-升级到版本-5" aria-label="Permalink to &quot;webpack 升级到版本 5&quot;">​</a></h3><p>Kotlin/JS Gradle 插件现在为浏览器目标使用 webpack 5，而不是 webpack 4。这是一个带来不兼容变更的重大 webpack 升级。如果您正在使用自定义 webpack 配置，请务必查看 <a href="https://webpack.js.org/blog/2020-10-10-webpack-5-release/" target="_blank" rel="noreferrer">webpack 5 发布说明</a>。</p><p><a href="/kotlin/js-project-setup#webpack-bundling">了解更多关于使用 webpack 打包 Kotlin/JS 项目的信息</a>。</p><h3 id="ir-编译器的框架和库" tabindex="-1">IR 编译器的框架和库 <a class="header-anchor" href="#ir-编译器的框架和库" aria-label="Permalink to &quot;IR 编译器的框架和库&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>Kotlin/JS IR 编译器处于 <a href="/kotlin/components-stability">Alpha</a> 阶段。它未来可能不兼容地更改并需要手动迁移。 我们感谢您在 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 中提供反馈。</p></div><p>除了开发 Kotlin/JS 编译器的基于 IR 的后端，我们还鼓励并帮助库作者以 <code>both</code> 模式构建他们的项目。这意味着他们可以为两种 Kotlin/JS 编译器生成构件，从而壮大新编译器的生态系统。</p><p>许多知名框架和库已可用于 IR 后端：<a href="https://kvision.io/" target="_blank" rel="noreferrer">KVision</a>、<a href="https://www.fritz2.dev/" target="_blank" rel="noreferrer">fritz2</a>、<a href="https://github.com/nacular/doodle" target="_blank" rel="noreferrer">doodle</a> 等。如果您在项目中使用它们，您已经可以使用 IR 后端构建它，并看到它带来的好处。</p><p>如果您正在编写自己的库，请<a href="/kotlin/js-ir-compiler#authoring-libraries-for-the-ir-compiler-with-backwards-compatibility">以 <code>both</code> 模式编译它</a>，以便您的客户端也可以使用新编译器。</p><h2 id="kotlin-multiplatform" tabindex="-1">Kotlin Multiplatform <a class="header-anchor" href="#kotlin-multiplatform" aria-label="Permalink to &quot;Kotlin Multiplatform&quot;">​</a></h2><p>在 Kotlin 1.5.0 中，<a href="#simplified-test-dependencies-usage-in-multiplatform-projects">简化了多平台项目中测试依赖项的使用</a>，现在由 Gradle 插件自动完成。</p><p>用于<a href="#new-api-for-getting-a-char-category-now-available-in-multiplatform-code">获取字符类别的新的 API 现已在多平台代码中可用</a>。</p><h2 id="标准库" tabindex="-1">标准库 <a class="header-anchor" href="#标准库" aria-label="Permalink to &quot;标准库&quot;">​</a></h2><p>标准库获得了一系列变更和改进，从稳定实验性部分到添加新特性：</p><ul><li><a href="#stable-unsigned-integer-types">稳定的无符号整数类型</a></li><li><a href="#stable-locale-agnostic-api-for-upper-lowercasing-text">稳定的与区域设置无关的文本大小写转换 API</a></li><li><a href="#stable-char-to-integer-conversion-api">稳定的 Char 到整数转换 API</a></li><li><a href="#stable-path-api">稳定的 Path API</a></li><li><a href="#floored-division-and-the-mod-operator">向下取整除法和模操作符</a></li><li><a href="#duration-api-changes">Duration API 变更</a></li><li><a href="#new-api-for-getting-a-char-category-now-available-in-multiplatform-code">用于获取字符类别的新的 API 现已在多平台代码中可用</a></li><li><a href="#new-collections-function-firstnotnullof">新的集合函数 firstNotNullOf()</a></li><li><a href="#strict-version-of-string-toboolean"><code>String?.toBoolean()</code> 的严格版本</a></li></ul><p>您可以在<a href="https://blog.jetbrains.com/kotlin/2021/04/kotlin-1-5-0-rc-released/" target="_blank" rel="noreferrer">这篇博客文章</a>中了解更多关于标准库变更的信息。</p>`,63)),t(l,{src:"https://www.youtube.com/v/MyTkiT2I6-8",title:"New Standard Library Features"}),s[9]||(s[9]=e(`<h3 id="稳定的无符号整数类型" tabindex="-1">稳定的无符号整数类型 <a class="header-anchor" href="#稳定的无符号整数类型" aria-label="Permalink to &quot;稳定的无符号整数类型&quot;">​</a></h3><p><code>UInt</code>、<code>ULong</code>、<code>UByte</code>、<code>UShort</code> 无符号整数类型现在已<a href="/kotlin/components-stability">稳定</a>。这些类型的操作、区间和数列也是如此。无符号数组及其操作仍处于 Beta 阶段。</p><p><a href="/kotlin/unsigned-integer-types">了解更多关于无符号整数类型的信息</a>。</p><h3 id="稳定的与区域设置无关的文本大小写转换-api" tabindex="-1">稳定的与区域设置无关的文本大小写转换 API <a class="header-anchor" href="#稳定的与区域设置无关的文本大小写转换-api" aria-label="Permalink to &quot;稳定的与区域设置无关的文本大小写转换 API&quot;">​</a></h3><p>此版本带来了新的与区域设置无关的文本大小写转换 API。它提供了 <code>toLowerCase()</code>、<code>toUpperCase()</code>、<code>capitalize()</code> 和 <code>decapitalize()</code> API 函数的替代方案，这些函数是区域设置敏感的。新的 API 帮助您避免因不同区域设置而导致的错误。</p><p>Kotlin 1.5.0 提供了以下完全<a href="/kotlin/components-stability">稳定</a>的替代方案：</p><ul><li><p>对于 <code>String</code> 函数：</p><table tabindex="0"><thead><tr><th><strong>早期版本</strong></th><th><strong>1.5.0 替代方案</strong></th></tr></thead><tbody><tr><td><code>String.toUpperCase()</code></td><td><code>String.uppercase()</code></td></tr><tr><td><code>String.toLowerCase()</code></td><td><code>String.lowercase()</code></td></tr><tr><td><code>String.capitalize()</code></td><td><code>String.replaceFirstChar { it.uppercase() }</code></td></tr><tr><td><code>String.decapitalize()</code></td><td><code>String.replaceFirstChar { it.lowercase() }</code></td></tr></tbody></table></li><li><p>对于 <code>Char</code> 函数：</p><table tabindex="0"><thead><tr><th><strong>早期版本</strong></th><th><strong>1.5.0 替代方案</strong></th></tr></thead><tbody><tr><td><code>Char.toUpperCase()</code></td><td><code>Char.uppercaseChar(): Char</code><br><code>Char.uppercase(): String</code></td></tr><tr><td><code>Char.toLowerCase()</code></td><td><code>Char.lowercaseChar(): Char</code><br><code>Char.lowercase(): String</code></td></tr><tr><td><code>Char.toTitleCase()</code></td><td><code>Char.titlecaseChar(): Char</code><br><code>Char.titlecase(): String</code></td></tr></tbody></table></li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>对于 Kotlin/JVM，还存在带有显式 <code>Locale</code> 形参的重载 <code>uppercase()</code>、<code>lowercase()</code> 和 <code>titlecase()</code> 函数。</p></div><p>旧的 API 函数已被标记为弃用，并将在未来的版本中移除。</p><p>请参阅 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/locale-agnostic-case-conversions.md" target="_blank" rel="noreferrer">KEEP</a> 中文本处理函数的完整变更列表。</p><h3 id="稳定的-char-到整数转换-api" tabindex="-1">稳定的 Char 到整数转换 API <a class="header-anchor" href="#稳定的-char-到整数转换-api" aria-label="Permalink to &quot;稳定的 Char 到整数转换 API&quot;">​</a></h3><p>从 Kotlin 1.5.0 开始，新的字符到编码和字符到数字转换函数已<a href="/kotlin/components-stability">稳定</a>。这些函数取代了当前的 API 函数，后者经常与类似的字符串到整数转换混淆。</p><p>新的 API 消除了这种命名混淆，使代码行为更透明和明确。</p><p>此版本引入了字符转换，它们分为以下几组命名清晰的函数：</p><ul><li>获取字符的整数编码以及从给定编码构造字符的函数：</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(code: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Char</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(code: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UShort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Char</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Char.code: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span></span></code></pre></div><ul><li>将字符转换为其所代表数字的数值的函数：</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">digitToInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radix: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">digitToIntOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radix: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?</span></span></code></pre></div><ul><li>一个用于 <code>Int</code> 的扩展函数，用于将其所代表的非负单数字转换为相应的字符表示：</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">digitToChar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radix: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Char</span></span></code></pre></div><p>旧的转换 API，包括 <code>Number.toChar()</code> 及其实现（除了 <code>Int.toChar()</code> 之外的所有）以及用于转换为数字类型的字符扩展，例如 <code>Char.toInt()</code>，现在已被弃用。</p><p><a href="https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/char-int-conversions.md" target="_blank" rel="noreferrer">了解更多关于 KEEP 中字符到整数转换 API 的信息</a>。</p><h3 id="稳定的-path-api" tabindex="-1">稳定的 Path API <a class="header-anchor" href="#稳定的-path-api" aria-label="Permalink to &quot;稳定的 Path API&quot;">​</a></h3><p>带有 <code>java.nio.file.Path</code> 扩展的<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io.path/java.nio.file.-path/" target="_blank" rel="noreferrer">实验性 Path API</a> 现在已<a href="/kotlin/components-stability">稳定</a>。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// construct path with the div (/) operator</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> baseDir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/base&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> subDir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> baseDir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;subdirectory&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// list files in a directory</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kotlinFiles: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/home/user&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listDirectoryEntries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;*.kt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><a href="/kotlin/whatsnew1420#extensions-for-java-nio-file-path">了解更多关于 Path API 的信息</a>。</p><h3 id="向下取整除法和模操作符" tabindex="-1">向下取整除法和模操作符 <a class="header-anchor" href="#向下取整除法和模操作符" aria-label="Permalink to &quot;向下取整除法和模操作符&quot;">​</a></h3><p>标准库中添加了新的模算术操作：</p><ul><li><code>floorDiv()</code> 返回<a href="https://en.wikipedia.org/wiki/Floor_and_ceiling_functions" target="_blank" rel="noreferrer">向下取整除法</a>的结果。它可用于整数类型。</li><li><code>mod()</code> 返回向下取整除法的余数（模数）。它可用于所有数值类型。</li></ul><p>这些操作看起来与现有的<a href="/kotlin/numbers#operations-on-numbers">整数除法</a>和 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/rem.html" target="_blank" rel="noreferrer"><code>rem()</code></a> 函数（或 <code>%</code> 操作符）非常相似，但它们在负数上的工作方式不同：</p><ul><li><code>a.floorDiv(b)</code> 与常规的 <code>/</code> 不同之处在于 <code>floorDiv</code> 将结果向下取整（朝向较小的整数），而 <code>/</code> 将结果截断为更接近 0 的整数。</li><li><code>a.mod(b)</code> 是 <code>a</code> 与 <code>a.floorDiv(b) * b</code> 之间的差值。它要么是零，要么与 <code>b</code> 的符号相同，而 <code>a % b</code> 可以有不同的符号。</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Floored division -5/3: \${(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floorDiv</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Modulus: \${(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mod</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Truncated division -5/3: \${</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Remainder: \${</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> %</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="duration-api-变更" tabindex="-1">Duration API 变更 <a class="header-anchor" href="#duration-api-变更" aria-label="Permalink to &quot;Duration API 变更&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">WARNING</p><p>Duration API 是<a href="/kotlin/components-stability">实验性的</a>。它可能随时被移除或更改。 仅将其用于求值目的。我们感谢您在 <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noreferrer">YouTrack</a> 中提供反馈。</p></div><p>存在一个实验性的 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/" target="_blank" rel="noreferrer"><code>Duration</code></a> 类，用于表示不同时间单位的持续时间量。在 1.5.0 中，Duration API 获得了以下变更：</p><ul><li>内部值表示现在使用 <code>Long</code> 而不是 <code>Double</code> 来提供更好的精度。</li><li>新的 API 用于将 <code>Duration</code> 转换为特定时间单位的 <code>Long</code> 值。它取代了旧的 API，后者使用 <code>Double</code> 值并且现在已被弃用。例如，<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/in-whole-minutes.html" target="_blank" rel="noreferrer"><code>Duration.inWholeMinutes</code></a> 返回表示为 <code>Long</code> 的持续时间值，并取代 <code>Duration.inMinutes</code>。</li><li>新的伴生函数，用于从数字构造 <code>Duration</code>。例如，<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/seconds.html" target="_blank" rel="noreferrer"><code>Duration.seconds(Int)</code></a> 创建一个表示整数秒数的 <code>Duration</code> 对象。旧的扩展属性，如 <code>Int.seconds</code>，现在已被弃用。</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.time.Duration</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kotlin.time.ExperimentalTime</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@ExperimentalTime</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> duration </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Duration.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">milliseconds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">120000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;There are \${duration.inWholeSeconds} seconds in \${duration.inWholeMinutes} minutes&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="用于获取字符类别的新的-api-现已在多平台代码中可用" tabindex="-1">用于获取字符类别的新的 API 现已在多平台代码中可用 <a class="header-anchor" href="#用于获取字符类别的新的-api-现已在多平台代码中可用" aria-label="Permalink to &quot;用于获取字符类别的新的 API 现已在多平台代码中可用&quot;">​</a></h3><p>Kotlin 1.5.0 引入了新的 API，用于在多平台项目中根据 Unicode 获取字符类别。多个函数现在可在所有平台和公共代码中使用。</p><p>检查字符是否为字母或数字的函数：</p><ul><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-digit.html" target="_blank" rel="noreferrer"><code>Char.isDigit()</code></a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-letter.html" target="_blank" rel="noreferrer"><code>Char.isLetter()</code></a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-letter-or-digit.html" target="_blank" rel="noreferrer"><code>Char.isLetterOrDigit()</code></a></li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chars </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;+&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (letterOrDigitList, notLetterOrDigitList) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chars.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isLetterOrDigit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(letterOrDigitList) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [a, 1]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(notLetterOrDigitList) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [+]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>检查字符大小写的函数：</p><ul><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-lower-case.html" target="_blank" rel="noreferrer"><code>Char.isLowerCase()</code></a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-upper-case.html" target="_blank" rel="noreferrer"><code>Char.isUpperCase()</code></a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-title-case.html" target="_blank" rel="noreferrer"><code>Char.isTitleCase()</code></a></li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chars </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ǅ&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ǈ&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ǋ&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ǲ&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;+&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (titleCases, notTitleCases) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chars.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isTitleCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(titleCases) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [ǅ, ǈ, ǋ, ǲ]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(notTitleCases) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [1, A, a, +]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>其他一些函数：</p><ul><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-defined.html" target="_blank" rel="noreferrer"><code>Char.isDefined()</code></a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-i-s-o-control.html" target="_blank" rel="noreferrer"><code>Char.isISOControl()</code></a></li></ul><p>属性 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/category.html" target="_blank" rel="noreferrer"><code>Char.category</code></a> 及其返回类型枚举类 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-char-category/" target="_blank" rel="noreferrer"><code>CharCategory</code></a>（表示根据 Unicode 字符的通用类别）现在也已在多平台项目中可用。</p><p><a href="/kotlin/characters">了解更多关于字符的信息</a>。</p><h3 id="新的集合函数-firstnotnullof" tabindex="-1">新的集合函数 firstNotNullOf() <a class="header-anchor" href="#新的集合函数-firstnotnullof" aria-label="Permalink to &quot;新的集合函数 firstNotNullOf()&quot;">​</a></h3><p>新的 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/first-not-null-of.html" target="_blank" rel="noreferrer"><code>firstNotNullOf()</code></a> 和 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/first-not-null-of-or-null.html" target="_blank" rel="noreferrer"><code>firstNotNullOfOrNull()</code></a> 函数将 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map-not-null.html" target="_blank" rel="noreferrer"><code>mapNotNull()</code></a> 与 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/first.html" target="_blank" rel="noreferrer"><code>first()</code></a> 或 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/first-or-null.html" target="_blank" rel="noreferrer"><code>firstOrNull()</code></a> 结合使用。它们使用自定义选择器函数映射原始集合并返回第一个非空值。如果没有这样的值，<code>firstNotNullOf()</code> 会抛出异常，而 <code>firstNotNullOfOrNull()</code> 会返回 null。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Kotlin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.5&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">firstNotNullOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toDoubleOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">firstNotNullOfOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toIntOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="string-toboolean-的严格版本" tabindex="-1"><code>String?.toBoolean()</code> 的严格版本 <a class="header-anchor" href="#string-toboolean-的严格版本" aria-label="Permalink to &quot;\`String?.toBoolean()\` 的严格版本&quot;">​</a></h3><p>两个新函数引入了现有 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-boolean.html" target="_blank" rel="noreferrer"><code>String?.toBoolean()</code></a> 的区分大小写的严格版本：</p><ul><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-boolean-strict.html" target="_blank" rel="noreferrer"><code>String.toBooleanStrict()</code></a> 对除字面量 <code>true</code> 和 <code>false</code> 之外的所有输入都抛出异常。</li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-boolean-strict-or-null.html" target="_blank" rel="noreferrer"><code>String.toBooleanStrictOrNull()</code></a> 对除字面量 <code>true</code> 和 <code>false</code> 之外的所有输入都返回 null。</li></ul><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;true&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toBooleanStrict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toBooleanStrictOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // println(&quot;1&quot;.toBooleanStrict())</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Exception</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="kotlin-test-库" tabindex="-1">kotlin-test 库 <a class="header-anchor" href="#kotlin-test-库" aria-label="Permalink to &quot;kotlin-test 库&quot;">​</a></h2><p><a href="https://kotlinlang.org/api/latest/kotlin.test/" target="_blank" rel="noreferrer">kotlin-test</a> 库引入了一些新特性：</p><ul><li><a href="#simplified-test-dependencies-usage-in-multiplatform-projects">简化了多平台项目中的测试依赖项使用</a></li><li><a href="#automatic-selection-of-a-testing-framework-for-kotlin-jvm-source-sets">自动选择 Kotlin/JVM 源代码集的测试框架</a></li><li><a href="#assertion-function-updates">断言函数更新</a></li></ul><h3 id="简化了多平台项目中的测试依赖项使用" tabindex="-1">简化了多平台项目中的测试依赖项使用 <a class="header-anchor" href="#简化了多平台项目中的测试依赖项使用" aria-label="Permalink to &quot;简化了多平台项目中的测试依赖项使用&quot;">​</a></h3><p>现在您可以使用 <code>kotlin-test</code> 依赖项在 <code>commonTest</code> 源代码集中添加测试依赖项，Gradle 插件将为每个测试源代码集推断相应的平台依赖项：</p><ul><li><code>kotlin-test-junit</code> 用于 JVM 源代码集，请参阅<a href="#automatic-selection-of-a-testing-framework-for-kotlin-jvm-source-sets">自动选择 Kotlin/JVM 源代码集的测试框架</a></li><li><code>kotlin-test-js</code> 用于 Kotlin/JS 源代码集</li><li><code>kotlin-test-common</code> 和 <code>kotlin-test-annotations-common</code> 用于公共源代码集</li><li>Kotlin/Native 源代码集没有额外的构件</li></ul><p>此外，您可以在任何共享或平台特有的源代码集中使用 <code>kotlin-test</code> 依赖项。</p><p>现有的带有显式依赖项的 <code>kotlin-test</code> 设置在 Gradle 和 Maven 中都将继续工作。</p><p>了解更多关于<a href="/kotlin/gradle-configure-project#set-dependencies-on-test-libraries">设置测试库依赖项</a>的信息。</p><h3 id="自动选择-kotlin-jvm-源代码集的测试框架" tabindex="-1">自动选择 Kotlin/JVM 源代码集的测试框架 <a class="header-anchor" href="#自动选择-kotlin-jvm-源代码集的测试框架" aria-label="Permalink to &quot;自动选择 Kotlin/JVM 源代码集的测试框架&quot;">​</a></h3><p>Gradle 插件现在会自动选择并添加测试框架的依赖项。您只需在公共源代码集中添加 <code>kotlin-test</code> 依赖项即可。</p><p>Gradle 默认使用 JUnit 4。因此，<code>kotlin(&quot;test&quot;)</code> 依赖项解析为 JUnit 4 的变体，即 <code>kotlin-test-junit</code>：</p>`,68)),t(k,{group:"build-script"},{default:n(()=>[t(h,{title:"Kotlin","group-key":"kotlin"},{default:n(()=>s[2]||(s[2]=[i("div",{class:"language-kotlin vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"kotlin"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    sourceSets"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"        val"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," commonTest "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"by"),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," getting"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"            dependencies"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"                implementation"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"kotlin"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"test"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")) "),i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"// This brings the dependency")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"                                               // on JUnit 4 transitively")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1}),t(h,{title:"Groovy","group-key":"groovy"},{default:n(()=>s[3]||(s[3]=[i("div",{class:"language-groovy vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"groovy"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"kotlin {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    sourceSets {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        commonTest {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            dependencies {")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"                implementation kotlin("),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"test"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") "),i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"// This brings the dependency ")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"                                              // on JUnit 4 transitively")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"            }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),a(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])],-1)])),_:1})]),_:1}),s[10]||(s[10]=e(`<p>您可以通过在测试任务中调用 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/testing/Test.html#useJUnitPlatform" target="_blank" rel="noreferrer"><code>useJUnitPlatform()</code></a> 或 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/testing/Test.html#useTestNG" target="_blank" rel="noreferrer"><code>useTestNG()</code></a> 来选择 JUnit 5 或 TestNG：</p><div class="language-groovy vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">groovy</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tasks {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    test {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // enable TestNG support</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        useTestNG()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // or</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // enable JUnit Platform (a.k.a. JUnit 5) support</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        useJUnitPlatform()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>您可以通过将 <code>kotlin.test.infer.jvm.variant=false</code> 行添加到项目的 <code>gradle.properties</code> 中来禁用自动测试框架选择。</p><p>了解更多关于<a href="/kotlin/gradle-configure-project#set-dependencies-on-test-libraries">设置测试库依赖项</a>的信息。</p><h3 id="断言函数更新" tabindex="-1">断言函数更新 <a class="header-anchor" href="#断言函数更新" aria-label="Permalink to &quot;断言函数更新&quot;">​</a></h3><p>此版本带来了新的断言函数并改进了现有函数。</p><p><code>kotlin-test</code> 库现在具有以下特性：</p><ul><li><p><strong>检查值的类型</strong></p><p>您可以使用新的 <code>assertIs&lt;T&gt;</code> 和 <code>assertIsNot&lt;T&gt;</code> 来检查值的类型：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Any</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;test&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assertIs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(s)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// throws AssertionError mentioning the actual type of s if the assertion fails</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // can now print s.length because of contract in assertIs</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\${s.length}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>由于类型擦除，此断言函数在以下示例中仅检查 <code>value</code> 是否为 <code>List</code> 类型，而不检查它是否为特定 <code>String</code> 元素类型的列表：<code>assertIs&lt;List&lt;String&gt;&gt;(value)</code>。</p></li><li><p><strong>比较数组、序列和任意可迭代容器的内容</strong></p><p>存在一组新的重载 <code>assertContentEquals()</code> 函数，用于比较不实现<a href="/kotlin/equality#structural-equality">结构相等性</a>的不同集合的内容：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> expectedArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> actualArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { it </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assertContentEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(expectedArray, actualArray)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong><code>assertEquals()</code> 和 <code>assertNotEquals()</code> 的新重载，用于 <code>Double</code> 和 <code>Float</code> 类型数字</strong></p><p><code>assertEquals()</code> 函数存在新的重载，使其可以比较两个 <code>Double</code> 或 <code>Float</code> 数字的绝对精度。精度值指定为函数的第三个形参：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> @Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(PI)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // precision parameter</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tolerance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.000001</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assertEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x, tolerance)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>检查集合和元素内容的新函数</strong></p><p>您现在可以使用 <code>assertContains()</code> 函数检查集合或元素是否包含某些内容。 您可以将它与 Kotlin 集合和具有 <code>contains()</code> 操作符的元素一起使用，例如 <code>IntRange</code>、<code>String</code> 等：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sampleList </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sample&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sample2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sampleString </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;sample&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assertContains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sampleList, sampleString)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// element in collection</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assertContains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sampleString, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;amp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// substring in string</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong><code>assertTrue()</code>、<code>assertFalse()</code>、<code>expect()</code> 函数现在是内联的</strong></p><p>从现在起，您可以将它们用作内联函数，因此可以在 lambda 表达式内部调用<a href="/kotlin/composing-suspending-functions">挂起函数</a>：</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBlocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deferred </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Kotlin is nice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assertTrue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Kotlin substring should be present&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        deferred.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Kotlin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><h2 id="kotlinx-库" tabindex="-1">kotlinx 库 <a class="header-anchor" href="#kotlinx-库" aria-label="Permalink to &quot;kotlinx 库&quot;">​</a></h2><p>随着 Kotlin 1.5.0 的发布，我们正在发布新版本的 kotlinx 库：</p><ul><li><code>kotlinx.coroutines</code> <a href="#coroutines-1-5-0-rc">1.5.0-RC</a></li><li><code>kotlinx.serialization</code> <a href="#serialization-1-2-1">1.2.1</a></li><li><code>kotlinx-datetime</code> <a href="#datetime-0-2-0">0.2.0</a></li></ul><h3 id="coroutines-1-5-0-rc" tabindex="-1">Coroutines 1.5.0-RC <a class="header-anchor" href="#coroutines-1-5-0-rc" aria-label="Permalink to &quot;Coroutines 1.5.0-RC&quot;">​</a></h3><p><code>kotlinx.coroutines</code> <a href="https://github.com/Kotlin/kotlinx.coroutines/releases/tag/1.5.0-RC" target="_blank" rel="noreferrer">1.5.0-RC</a> 随之而来：</p><ul><li><a href="/kotlin/channels">新的通道 API</a></li><li>稳定的<a href="/kotlin/async-programming#reactive-extensions">反应式集成</a></li><li>还有更多</li></ul><p>从 Kotlin 1.5.0 开始，<a href="/kotlin/whatsnew14#exclusion-of-the-deprecated-experimental-coroutines">实验性协程</a>已禁用，并且不再支持 <code>-Xcoroutines=experimental</code> 标志。</p><p>了解更多信息请参见<a href="https://github.com/Kotlin/kotlinx.coroutines/releases/tag/1.5.0-RC" target="_blank" rel="noreferrer">更新日志</a>和 [<code>kotlinx.coroutines</code> 1.5.0 <a href="https://blog.jetbrains.com/kotlin/2021/05/kotlin-coroutines-1-5-0-released/" target="_blank" rel="noreferrer">发布博客文章</a>。</p>`,16)),t(l,{src:"https://www.youtube.com/v/EVLnWOcR0is",title:"kotlinx.coroutines 1.5.0"}),s[11]||(s[11]=e('<h3 id="serialization-1-2-1" tabindex="-1">Serialization 1.2.1 <a class="header-anchor" href="#serialization-1-2-1" aria-label="Permalink to &quot;Serialization 1.2.1&quot;">​</a></h3><p><code>kotlinx.serialization</code> <a href="https://github.com/Kotlin/kotlinx.serialization/releases/tag/v1.2.1" target="_blank" rel="noreferrer">1.2.1</a> 随之而来：</p><ul><li>JSON 序列化性能改进</li><li>JSON 序列化中支持多个名称</li><li>从 <code>@Serializable</code> 类生成实验性的 <code>.proto</code> 模式</li><li>还有更多</li></ul><p>了解更多信息请参见<a href="https://github.com/Kotlin/kotlinx.serialization/releases/tag/v1.2.1" target="_blank" rel="noreferrer">更新日志</a>和 [<code>kotlinx.serialization</code> 1.2.1 <a href="https://blog.jetbrains.com/kotlin/2021/05/kotlinx-serialization-1-2-released/" target="_blank" rel="noreferrer">发布博客文章</a>。</p>',4)),t(l,{src:"https://www.youtube.com/v/698I_AH8h6s",title:"kotlinx.serialization 1.2.1"}),s[12]||(s[12]=e('<h3 id="datetime-0-2-0" tabindex="-1">dateTime 0.2.0 <a class="header-anchor" href="#datetime-0-2-0" aria-label="Permalink to &quot;dateTime 0.2.0&quot;">​</a></h3><p><code>kotlinx-datetime</code> <a href="https://github.com/Kotlin/kotlinx-datetime/releases/tag/v0.2.0" target="_blank" rel="noreferrer">0.2.0</a> 随之而来：</p><ul><li>可序列化的 Datetime 对象</li><li><code>DateTimePeriod</code> 和 <code>DatePeriod</code> 的标准化 API</li><li>还有更多</li></ul><p>了解更多信息请参见<a href="https://github.com/Kotlin/kotlinx-datetime/releases/tag/v0.2.0" target="_blank" rel="noreferrer">更新日志</a>和 [<code>kotlinx-datetime</code> 0.2.0 <a href="https://blog.jetbrains.com/kotlin/2021/05/kotlinx-datetime-0-2-0-is-out/" target="_blank" rel="noreferrer">发布博客文章</a>。</p><h2 id="迁移到-kotlin-1-5-0" tabindex="-1">迁移到 Kotlin 1.5.0 <a class="header-anchor" href="#迁移到-kotlin-1-5-0" aria-label="Permalink to &quot;迁移到 Kotlin 1.5.0&quot;">​</a></h2><p>IntelliJ IDEA 和 Android Studio 一旦可用，将建议将 Kotlin 插件更新到 1.5.0。</p><p>要将现有项目迁移到 Kotlin 1.5.0，只需将 Kotlin 版本更改为 <code>1.5.0</code> 并重新导入您的 Gradle 或 Maven 项目。 <a href="/kotlin/releases#update-to-a-new-kotlin-version">了解如何更新到 Kotlin 1.5.0</a>。</p><p>要使用 Kotlin 1.5.0 启动新项目，请更新 Kotlin 插件并从 <strong>File</strong> | <strong>New</strong> | <strong>Project</strong> 运行项目向导。</p><p>新的命令行编译器可在 <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.5.0" target="_blank" rel="noreferrer">GitHub 发布页面</a>下载。</p><p>Kotlin 1.5.0 是一个<a href="/kotlin/kotlin-evolution-principles#language-and-tooling-releases">特性发布</a>，因此可能为语言带来不兼容的变更。在 <a href="/kotlin/compatibility-guide-15">Kotlin 1.5 兼容性指南</a>中查找此类变更的详细列表。</p>',10))])}const v=r(c,[["render",g]]);export{f as __pageData,v as default};
