import{_ as i}from"./chunks/basic-strategy-graph.DHaXnO2A.js";import{_ as a,c as n,o as l,ag as t}from"./chunks/framework.Bksy39di.js";const y=JSON.parse('{"title":"사용자 지정 전략 그래프","description":"","frontmatter":{},"headers":[],"relativePath":"ko/koog/custom-strategy-graphs.md","filePath":"ko/koog/custom-strategy-graphs.md","lastUpdated":1755146406000}'),h={name:"ko/koog/custom-strategy-graphs.md"};function e(p,s,k,d,r,E){return l(),n("div",null,s[0]||(s[0]=[t(`<h1 id="사용자-지정-전략-그래프" tabindex="-1">사용자 지정 전략 그래프 <a class="header-anchor" href="#사용자-지정-전략-그래프" aria-label="Permalink to &quot;사용자 지정 전략 그래프&quot;">​</a></h1><p>전략 그래프는 Koog 프레임워크에서 에이전트 워크플로우의 중추입니다. 이는 에이전트가 입력을 처리하고, 도구와 상호작용하며, 출력을 생성하는 방식을 정의합니다. 전략 그래프는 엣지로 연결된 노드로 구성되며, 조건이 실행 흐름을 결정합니다.</p><p>전략 그래프를 생성하면 간단한 챗봇을 만들든, 복잡한 데이터 처리 파이프라인을 만들든, 그 중간의 어떤 것을 만들든 관계없이 특정 요구 사항에 맞춰 에이전트의 동작을 맞춤 설정할 수 있습니다.</p><h2 id="전략-그래프-아키텍처" tabindex="-1">전략 그래프 아키텍처 <a class="header-anchor" href="#전략-그래프-아키텍처" aria-label="Permalink to &quot;전략 그래프 아키텍처&quot;">​</a></h2><p>높은 수준에서 전략 그래프는 다음 구성 요소로 이루어집니다.</p><ul><li><strong>Strategy</strong>: <code>strategy</code> 함수를 사용하여 생성되는 그래프의 최상위 컨테이너이며, 제네릭 매개변수를 사용하여 지정된 입력 및 출력 타입을 가집니다.</li><li><strong>Subgraphs</strong>: 자체 도구 및 컨텍스트 세트를 가질 수 있는 그래프 섹션입니다.</li><li><strong>Nodes</strong>: 워크플로우의 개별 작업 또는 변환입니다.</li><li><strong>Edges</strong>: 노드 간 연결로, 전환 조건과 변환을 정의합니다.</li></ul><p>전략 그래프는 <code>nodeStart</code>라는 특수 노드에서 시작하여 <code>nodeFinish</code>에서 끝납니다. 이 노드들 사이의 경로는 그래프에 지정된 엣지와 조건에 의해 결정됩니다.</p><h2 id="전략-그래프-구성-요소" tabindex="-1">전략 그래프 구성 요소 <a class="header-anchor" href="#전략-그래프-구성-요소" aria-label="Permalink to &quot;전략 그래프 구성 요소&quot;">​</a></h2><h3 id="노드" tabindex="-1">노드 <a class="header-anchor" href="#노드" aria-label="Permalink to &quot;노드&quot;">​</a></h3><p>노드는 전략 그래프의 빌딩 블록입니다. 각 노드는 특정 작업을 나타냅니다.</p><p>Koog 프레임워크는 미리 정의된 노드를 제공하며, <code>node</code> 함수를 사용하여 사용자 지정 노드를 생성할 수도 있습니다.</p><p>자세한 내용은 <a href="./nodes-and-components">미리 정의된 노드 및 구성 요소</a> 및 <a href="./custom-nodes">사용자 지정 노드</a>를 참조하세요.</p><h3 id="엣지" tabindex="-1">엣지 <a class="header-anchor" href="#엣지" aria-label="Permalink to &quot;엣지&quot;">​</a></h3><p>엣지는 노드를 연결하고 전략 그래프에서 작업 흐름을 정의합니다. 엣지는 <code>edge</code> 함수와 <code>forwardTo</code> 중위 함수를 사용하여 생성됩니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sourceNode forwardTo targetNode)</span></span></code></pre></div><h4 id="조건" tabindex="-1">조건 <a class="header-anchor" href="#조건" aria-label="Permalink to &quot;조건&quot;">​</a></h4><p>조건은 전략 그래프에서 특정 엣지를 따라갈 시기를 결정합니다. 몇 가지 유형의 조건이 있으며, 다음은 일반적인 조건들입니다.</p><table tabindex="0"><thead><tr><th style="text-align:left;">조건 유형</th><th style="text-align:left;">설명</th></tr></thead><tbody><tr><td style="text-align:left;">onCondition</td><td style="text-align:left;">불리언 값을 반환하는 람다 표현식을 인자로 받는 범용 조건입니다.</td></tr><tr><td style="text-align:left;">onToolCall</td><td style="text-align:left;">LLM이 도구를 호출할 때 일치하는 조건입니다.</td></tr><tr><td style="text-align:left;">onAssistantMessage</td><td style="text-align:left;">LLM이 메시지로 응답할 때 일치하는 조건입니다.</td></tr><tr><td style="text-align:left;">onMultipleToolCalls</td><td style="text-align:left;">LLM이 여러 도구를 호출할 때 일치하는 조건입니다.</td></tr><tr><td style="text-align:left;">onToolNotCalled</td><td style="text-align:left;">LLM이 도구를 호출하지 않을 때 일치하는 조건입니다.</td></tr></tbody></table><p>대상 노드로 전달하기 전에 <code>transformed</code> 함수를 사용하여 출력을 변환할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sourceNode forwardTo targetNode </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        onCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input.length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        transformed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">uppercase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="서브그래프" tabindex="-1">서브그래프 <a class="header-anchor" href="#서브그래프" aria-label="Permalink to &quot;서브그래프&quot;">​</a></h3><p>서브그래프는 자체 도구 및 컨텍스트 세트로 작동하는 전략 그래프의 섹션입니다. 전략 그래프는 여러 서브그래프를 포함할 수 있습니다. 각 서브그래프는 <code>subgraph</code> 함수를 사용하여 정의됩니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strategy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> strategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;strategy-name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> firstSubgraph </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> subgraph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FirstInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FirstOutput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;first&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Define nodes and edges for this subgraph</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> secondSubgraph </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> subgraph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SecondInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SecondOutput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;second&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Define nodes and edges for this subgraph</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>서브그래프는 도구 레지스트리의 모든 도구를 사용할 수 있습니다. 그러나 이 레지스트리에서 서브그래프에서 사용할 수 있는 도구의 하위 집합을 지정하고 이를 <code>subgraph</code> 함수의 인수로 전달할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strategy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> strategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;strategy-name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> firstSubgraph </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> subgraph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FirstInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FirstOutput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;first&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        tools </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(someTool)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Define nodes and edges for this subgraph</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // Define other subgraphs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="기본-전략-그래프-생성" tabindex="-1">기본 전략 그래프 생성 <a class="header-anchor" href="#기본-전략-그래프-생성" aria-label="Permalink to &quot;기본 전략 그래프 생성&quot;">​</a></h2><p>기본 전략 그래프는 다음과 같이 작동합니다:</p><ol><li>LLM에 입력을 보냅니다.</li><li>LLM이 메시지로 응답하면 프로세스를 마칩니다.</li><li>LLM이 도구를 호출하면 도구를 실행합니다.</li><li>도구 결과를 LLM에 다시 보냅니다.</li><li>LLM이 메시지로 응답하면 프로세스를 마칩니다.</li><li>LLM이 다른 도구를 호출하면 도구를 실행하고, 프로세스는 4단계부터 반복됩니다.</li></ol><p><img src="`+i+`" alt="basic-strategy-graph"></p><p>다음은 기본 전략 그래프의 예시입니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myStrategy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> strategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;my-strategy&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodeCallLLM </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeLLMRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> executeToolCall </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeExecuteTool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sendToolResult </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeLLMSendToolResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodeStart forwardTo nodeCallLLM)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodeCallLLM forwardTo nodeFinish </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onAssistantMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodeCallLLM forwardTo executeToolCall </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onToolCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(executeToolCall forwardTo sendToolResult)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sendToolResult forwardTo nodeFinish </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onAssistantMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sendToolResult forwardTo executeToolCall </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onToolCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="고급-전략-기술" tabindex="-1">고급 전략 기술 <a class="header-anchor" href="#고급-전략-기술" aria-label="Permalink to &quot;고급 전략 기술&quot;">​</a></h2><h3 id="기록-압축" tabindex="-1">기록 압축 <a class="header-anchor" href="#기록-압축" aria-label="Permalink to &quot;기록 압축&quot;">​</a></h3><p>장기 실행 대화의 경우 기록이 커져 많은 토큰을 소비할 수 있습니다. 기록을 압축하는 방법은 <a href="./history-compression">기록 압축</a>을 참조하세요.</p><h3 id="병렬-도구-실행" tabindex="-1">병렬 도구 실행 <a class="header-anchor" href="#병렬-도구-실행" aria-label="Permalink to &quot;병렬 도구 실행&quot;">​</a></h3><p>여러 도구를 병렬로 실행해야 하는 워크플로우의 경우 <code>nodeExecuteMultipleTools</code> 노드를 사용할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> executeMultipleTools </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeExecuteMultipleTools</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> processMultipleResults </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeLLMSendMultipleToolResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(someNode forwardTo executeMultipleTools)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(executeMultipleTools forwardTo processMultipleResults)</span></span></code></pre></div><p>또한 스트리밍 데이터의 경우 <code>toParallelToolCallsRaw</code> 확장 함수를 사용할 수도 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parseMarkdownStreamToBooks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(markdownStream).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toParallelToolCallsRaw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(BookTool::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">collect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>자세한 내용은 <a href="./tools-overview#parallel-tool-calls">도구</a>를 참조하세요.</p><h3 id="병렬-노드-실행" tabindex="-1">병렬 노드 실행 <a class="header-anchor" href="#병렬-노드-실행" aria-label="Permalink to &quot;병렬 노드 실행&quot;">​</a></h3><p>병렬 노드 실행을 통해 여러 노드를 동시에 실행하여 성능을 향상시키고 복잡한 워크플로우를 구현할 수 있습니다.</p><p>병렬 노드 실행을 시작하려면 <code>parallel</code> 메서드를 사용하세요:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> calc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> parallel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nodeCalcTokens, nodeCalcSymbols, nodeCalcWords,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    selectByMax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { it }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>위 코드는 <code>calc</code>라는 노드를 생성하여 <code>nodeCalcTokens</code>, <code>nodeCalcSymbols</code>, <code>nodeCalcWords</code> 노드를 병렬로 실행하고, 그 결과를 <code>AsyncParallelResult</code> 인스턴스로 반환합니다.</p><p>병렬 노드 실행과 관련된 더 자세한 정보 및 상세한 참조는 <a href="./parallel-node-execution">병렬 노드 실행</a>을 참조하세요.</p><h3 id="조건부-분기" tabindex="-1">조건부 분기 <a class="header-anchor" href="#조건부-분기" aria-label="Permalink to &quot;조건부 분기&quot;">​</a></h3><p>특정 조건에 따라 다른 경로가 필요한 복잡한 워크플로우의 경우 조건부 분기를 사용할 수 있습니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> branchA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; { input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Logic for branch A</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Branch A: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$input</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> branchB </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; { input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Logic for branch B</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Branch B: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$input</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (someNode forwardTo branchA)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            onCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (someNode forwardTo branchB)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            onCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;B&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h2 id="모범-사례" tabindex="-1">모범 사례 <a class="header-anchor" href="#모범-사례" aria-label="Permalink to &quot;모범 사례&quot;">​</a></h2><p>사용자 지정 전략 그래프를 생성할 때 다음 모범 사례를 따르세요.</p><ul><li>간단하게 유지하세요. 간단한 그래프로 시작하여 필요에 따라 복잡성을 추가하세요.</li><li>그래프를 이해하기 쉽도록 노드와 엣지에 설명적인 이름을 지정하세요.</li><li>가능한 모든 경로와 엣지 케이스를 처리하세요.</li><li>다양한 입력으로 그래프를 테스트하여 예상대로 작동하는지 확인하세요.</li><li>나중에 참조할 수 있도록 그래프의 목적과 동작을 문서화하세요.</li><li>미리 정의된 전략 또는 일반적인 패턴을 시작점으로 사용하세요.</li><li>장기 실행 대화의 경우 기록 압축을 사용하여 토큰 사용량을 줄이세요.</li><li>서브그래프를 사용하여 그래프를 구성하고 도구 액세스를 관리하세요.</li></ul><h2 id="사용-예시" tabindex="-1">사용 예시 <a class="header-anchor" href="#사용-예시" aria-label="Permalink to &quot;사용 예시&quot;">​</a></h2><h3 id="어조-분석-전략" tabindex="-1">어조 분석 전략 <a class="header-anchor" href="#어조-분석-전략" aria-label="Permalink to &quot;어조 분석 전략&quot;">​</a></h3><p>어조 분석 전략은 기록 압축을 포함하는 도구 기반 전략의 좋은 예시입니다.</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toneStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, toolRegistry: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ToolRegistry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AIAgentStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> strategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodeSendInput </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeLLMRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodeExecuteTool </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeExecuteTool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodeSendToolResult </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeLLMSendToolResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodeCompressHistory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nodeLLMCompressHistory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ReceivedToolResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Define the flow of the agent</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodeStart forwardTo nodeSendInput)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // If the LLM responds with a message, finish</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            (nodeSendInput forwardTo nodeFinish)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    onAssistantMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // If the LLM calls a tool, execute it</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            (nodeSendInput forwardTo nodeExecuteTool)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    onToolCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // If the history gets too large, compress it</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            (nodeExecuteTool forwardTo nodeCompressHistory)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    onCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { prompt.messages.size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodeCompressHistory forwardTo nodeSendToolResult)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Otherwise, send the tool result directly</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            (nodeExecuteTool forwardTo nodeSendToolResult)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    onCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> llm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readSession</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { prompt.messages.size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // If the LLM calls another tool, execute it</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            (nodeSendToolResult forwardTo nodeExecuteTool)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    onToolCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // If the LLM responds with a message, finish</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            (nodeSendToolResult forwardTo nodeFinish)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    onAssistantMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 전략은 다음을 수행합니다:</p><ol><li>LLM에 입력을 보냅니다.</li><li>LLM이 메시지로 응답하면 전략이 프로세스를 마칩니다.</li><li>LLM이 도구를 호출하면 전략이 도구를 실행합니다.</li><li>기록이 너무 크면(100개 이상의 메시지) 전략은 도구 결과를 보내기 전에 압축합니다.</li><li>그렇지 않으면 전략은 도구 결과를 직접 보냅니다.</li><li>LLM이 다른 도구를 호출하면 전략이 이를 실행합니다.</li><li>LLM이 메시지로 응답하면 전략이 프로세스를 마칩니다.</li></ol><h2 id="문제-해결" tabindex="-1">문제 해결 <a class="header-anchor" href="#문제-해결" aria-label="Permalink to &quot;문제 해결&quot;">​</a></h2><p>사용자 지정 전략 그래프를 생성할 때 몇 가지 일반적인 문제가 발생할 수 있습니다. 다음은 몇 가지 문제 해결 팁입니다.</p><h3 id="그래프가-종료-노드에-도달하지-못함" tabindex="-1">그래프가 종료 노드에 도달하지 못함 <a class="header-anchor" href="#그래프가-종료-노드에-도달하지-못함" aria-label="Permalink to &quot;그래프가 종료 노드에 도달하지 못함&quot;">​</a></h3><p>그래프가 종료 노드에 도달하지 못하는 경우 다음을 확인하세요:</p><ul><li>시작 노드부터의 모든 경로가 최종적으로 종료 노드로 이어지는지 확인하세요.</li><li>조건이 너무 제한적이어서 엣지가 따라가지 못하는 경우가 없는지 확인하세요.</li><li>종료 조건이 없는 순환이 그래프에 없는지 확인하세요.</li></ul><h3 id="도구-호출이-실행되지-않음" tabindex="-1">도구 호출이 실행되지 않음 <a class="header-anchor" href="#도구-호출이-실행되지-않음" aria-label="Permalink to &quot;도구 호출이 실행되지 않음&quot;">​</a></h3><p>도구 호출이 실행되지 않는 경우 다음을 확인하세요:</p><ul><li>도구가 도구 레지스트리에 제대로 등록되어 있는지 확인하세요.</li><li>LLM 노드에서 도구 실행 노드로 가는 엣지에 올바른 조건(<code>onToolCall { true }</code>)이 있는지 확인하세요.</li></ul><h3 id="기록이-너무-커짐" tabindex="-1">기록이 너무 커짐 <a class="header-anchor" href="#기록이-너무-커짐" aria-label="Permalink to &quot;기록이 너무 커짐&quot;">​</a></h3><p>기록이 너무 커져 많은 토큰을 소비하는 경우 다음을 고려하세요:</p><ul><li>기록 압축 노드를 추가하세요.</li><li>조건을 사용하여 기록 크기를 확인하고 너무 커지면 압축하세요.</li><li>더 적극적인 압축 전략(예: 더 작은 N 값을 사용하는 <code>FromLastNMessages</code>)을 사용하세요.</li></ul><h3 id="그래프가-예상치-않게-동작함" tabindex="-1">그래프가 예상치 않게 동작함 <a class="header-anchor" href="#그래프가-예상치-않게-동작함" aria-label="Permalink to &quot;그래프가 예상치 않게 동작함&quot;">​</a></h3><p>그래프가 예상치 못한 분기를 따르는 경우 다음을 확인하세요:</p><ul><li>조건이 올바르게 정의되었는지 확인하세요.</li><li>조건이 예상된 순서로 평가되는지 확인하세요(엣지는 정의된 순서대로 확인됩니다).</li><li>더 일반적인 조건으로 우발적으로 조건을 덮어쓰지 않았는지 확인하세요.</li></ul><h3 id="성능-문제가-발생함" tabindex="-1">성능 문제가 발생함 <a class="header-anchor" href="#성능-문제가-발생함" aria-label="Permalink to &quot;성능 문제가 발생함&quot;">​</a></h3><p>그래프에 성능 문제가 있는 경우 다음을 고려하세요:</p><ul><li>불필요한 노드와 엣지를 제거하여 그래프를 단순화하세요.</li><li>독립적인 작업에는 병렬 도구 실행을 사용하세요.</li><li>기록을 압축하세요.</li><li>더 효율적인 노드와 작업을 사용하세요.</li></ul>`,75)]))}const c=a(h,[["render",e]]);export{y as __pageData,c as default};
