import{_ as a,c as i,o as e,ag as s}from"./chunks/framework.Bksy39di.js";const k=JSON.parse('{"title":"연산자 오버로딩","description":"","frontmatter":{},"headers":[],"relativePath":"ko/kotlin/operator-overloading.md","filePath":"ko/kotlin/operator-overloading.md","lastUpdated":1754307826000}'),d={name:"ko/kotlin/operator-overloading.md"};function o(n,t,l,h,c,r){return e(),i("div",null,t[0]||(t[0]=[s(`<h1 id="연산자-오버로딩" tabindex="-1">연산자 오버로딩 <a class="header-anchor" href="#연산자-오버로딩" aria-label="Permalink to &quot;연산자 오버로딩&quot;">​</a></h1><p>Kotlin에서는 타입에 대해 미리 정의된 연산자 집합에 대한 사용자 지정 구현을 제공할 수 있습니다. 이러한 연산자는 미리 정의된 기호 표현(예: <code>+</code> 또는 <code>*</code>)과 우선순위를 가집니다. 연산자를 구현하려면 해당 타입에 대해 특정 이름을 가진 <a href="/ko/kotlin/functions#member-functions">멤버 함수</a> 또는 <a href="/ko/kotlin/extensions">확장 함수</a>를 제공해야 합니다. 이 타입은 이항 연산의 좌변 타입이 되고, 단항 연산의 인자 타입이 됩니다.</p><p>연산자를 오버로드하려면 해당 함수를 <code>operator</code> 변경자로 표시해야 합니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IndexedContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    operator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>연산자 오버로드를 <a href="/ko/kotlin/inheritance#overriding-methods">오버라이드</a>할 때 <code>operator</code> 변경자를 생략할 수 있습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OrdersList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IndexedContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*...*/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="단항-연산" tabindex="-1">단항 연산 <a class="header-anchor" href="#단항-연산" aria-label="Permalink to &quot;단항 연산&quot;">​</a></h2><h3 id="단항-전위-연산자" tabindex="-1">단항 전위 연산자 <a class="header-anchor" href="#단항-전위-연산자" aria-label="Permalink to &quot;단항 전위 연산자&quot;">​</a></h3><table tabindex="0"><thead><tr><th>표현식</th><th>변환 대상</th></tr></thead><tbody><tr><td><code>+a</code></td><td><code>a.unaryPlus()</code></td></tr><tr><td><code>-a</code></td><td><code>a.unaryMinus()</code></td></tr><tr><td><code>!a</code></td><td><code>a.not()</code></td></tr></tbody></table><p>이 표는 컴파일러가 예를 들어 <code>+a</code>와 같은 표현식을 처리할 때 다음 단계를 수행한다는 것을 의미합니다:</p><ul><li><code>a</code>의 타입을 <code>T</code>라고 가정하고 결정합니다.</li><li>리시버 <code>T</code>에 대해 <code>operator</code> 변경자가 있고 매개변수가 없는 <code>unaryPlus()</code> 함수, 즉 멤버 함수 또는 확장 함수를 찾습니다.</li><li>함수가 없거나 모호하면 컴파일 오류입니다.</li><li>함수가 존재하고 반환 타입이 <code>R</code>이면 표현식 <code>+a</code>의 타입은 <code>R</code>입니다.</li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>이 연산들은 다른 모든 연산과 마찬가지로 <a href="/ko/kotlin/basic-types">기본 타입</a>에 최적화되어 있으며, 이들에 대한 함수 호출 오버헤드를 발생시키지 않습니다.</p></div><p>예를 들어, 단항 마이너스 연산자를 오버로드하는 방법은 다음과 같습니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">operator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unaryMinus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">y)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> point </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">point)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// prints &quot;Point(x=-10, y=-20)&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="증감-연산" tabindex="-1">증감 연산 <a class="header-anchor" href="#증감-연산" aria-label="Permalink to &quot;증감 연산&quot;">​</a></h3><table tabindex="0"><thead><tr><th>표현식</th><th>변환 대상</th></tr></thead><tbody><tr><td><code>a++</code></td><td><code>a.inc()</code> + 아래 참조</td></tr><tr><td><code>a--</code></td><td><code>a.dec()</code> + 아래 참조</td></tr></tbody></table><p><code>inc()</code> 및 <code>dec()</code> 함수는 <code>++</code> 또는 <code>--</code> 연산이 사용된 변수에 할당될 값을 반환해야 합니다. 이 함수들은 <code>inc</code> 또는 <code>dec</code>가 호출된 객체를 변경해서는 안 됩니다.</p><p>컴파일러는 예를 들어 <code>a++</code>와 같은 <em>후위</em> 형식의 연산자를 해결하기 위해 다음 단계를 수행합니다:</p><ul><li><code>a</code>의 타입을 <code>T</code>라고 가정하고 결정합니다.</li><li><code>operator</code> 변경자가 있고 매개변수가 없으며 타입 <code>T</code>의 리시버에 적용 가능한 <code>inc()</code> 함수를 찾습니다.</li><li>함수의 반환 타입이 <code>T</code>의 하위 타입인지 확인합니다.</li></ul><p>표현식을 계산하는 효과는 다음과 같습니다:</p><ul><li><code>a</code>의 초기 값을 임시 저장소 <code>a0</code>에 저장합니다.</li><li><code>a0.inc()</code>의 결과를 <code>a</code>에 할당합니다.</li><li><code>a0</code>를 표현식의 결과로 반환합니다.</li></ul><p><code>a--</code>의 경우 단계는 완전히 동일합니다.</p><p><em>전위</em> 형식인 <code>++a</code> 및 <code>--a</code>의 경우 해결 방식은 동일하며 효과는 다음과 같습니다:</p><ul><li><code>a.inc()</code>의 결과를 <code>a</code>에 할당합니다.</li><li><code>a</code>의 새 값을 표현식의 결과로 반환합니다.</li></ul><h2 id="이항-연산" tabindex="-1">이항 연산 <a class="header-anchor" href="#이항-연산" aria-label="Permalink to &quot;이항 연산&quot;">​</a></h2><h3 id="산술-연산자" tabindex="-1">산술 연산자 <a class="header-anchor" href="#산술-연산자" aria-label="Permalink to &quot;산술 연산자&quot;">​</a></h3><table tabindex="0"><thead><tr><th>표현식</th><th>변환 대상</th></tr></thead><tbody><tr><td><code>a + b</code></td><td><code>a.plus(b)</code></td></tr><tr><td><code>a - b</code></td><td><code>a.minus(b)</code></td></tr><tr><td><code>a * b</code></td><td><code>a.times(b)</code></td></tr><tr><td><code>a / b</code></td><td><code>a.div(b)</code></td></tr><tr><td><code>a % b</code></td><td><code>a.rem(b)</code></td></tr><tr><td><code>a..b</code></td><td><code>a.rangeTo(b)</code></td></tr><tr><td><code>a..&lt;b</code></td><td><code>a.rangeUntil(b)</code></td></tr></tbody></table><p>이 표의 연산자에 대해 컴파일러는 <em>변환 대상</em> 열의 표현식을 해결합니다.</p><p>다음은 주어진 값에서 시작하여 오버로드된 <code>+</code> 연산자를 사용하여 증가할 수 있는 <code>Counter</code> 클래스의 예입니다:</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dayIndex: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    operator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> plus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(increment: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dayIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> increment)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="in-연산자" tabindex="-1">in 연산자 <a class="header-anchor" href="#in-연산자" aria-label="Permalink to &quot;in 연산자&quot;">​</a></h3><table tabindex="0"><thead><tr><th>표현식</th><th>변환 대상</th></tr></thead><tbody><tr><td><code>a in b</code></td><td><code>b.contains(a)</code></td></tr><tr><td><code>a !in b</code></td><td><code>!b.contains(a)</code></td></tr></tbody></table><p><code>in</code> 및 <code>!in</code>의 경우 절차는 동일하지만 인수의 순서는 반대입니다.</p><h3 id="인덱스-접근-연산자" tabindex="-1">인덱스 접근 연산자 <a class="header-anchor" href="#인덱스-접근-연산자" aria-label="Permalink to &quot;인덱스 접근 연산자&quot;">​</a></h3><table tabindex="0"><thead><tr><th>표현식</th><th>변환 대상</th></tr></thead><tbody><tr><td><code>a[i]</code></td><td><code>a.get(i)</code></td></tr><tr><td><code>a[i, j]</code></td><td><code>a.get(i, j)</code></td></tr><tr><td><code>a[i_1, ..., i_n]</code></td><td><code>a.get(i_1, ..., i_n)</code></td></tr><tr><td><code>a[i] = b</code></td><td><code>a.set(i, b)</code></td></tr><tr><td><code>a[i, j] = b</code></td><td><code>a.set(i, j, b)</code></td></tr><tr><td><code>a[i_1, ..., i_n] = b</code></td><td><code>a.set(i_1, ..., i_n, b)</code></td></tr></tbody></table><p>대괄호는 적절한 수의 인수를 가진 <code>get</code> 및 <code>set</code> 호출로 변환됩니다.</p><h3 id="invoke-연산자" tabindex="-1">invoke 연산자 <a class="header-anchor" href="#invoke-연산자" aria-label="Permalink to &quot;invoke 연산자&quot;">​</a></h3><table tabindex="0"><thead><tr><th>표현식</th><th>변환 대상</th></tr></thead><tbody><tr><td><code>a()</code></td><td><code>a.invoke()</code></td></tr><tr><td><code>a(i)</code></td><td><code>a.invoke(i)</code></td></tr><tr><td><code>a(i, j)</code></td><td><code>a.invoke(i, j)</code></td></tr><tr><td><code>a(i_1, ..., i_n)</code></td><td><code>a.invoke(i_1, ..., i_n)</code></td></tr></tbody></table><p>괄호는 적절한 수의 인수를 가진 <code>invoke</code> 호출로 변환됩니다.</p><h3 id="복합-할당-연산" tabindex="-1">복합 할당 연산 <a class="header-anchor" href="#복합-할당-연산" aria-label="Permalink to &quot;복합 할당 연산&quot;">​</a></h3><table tabindex="0"><thead><tr><th>표현식</th><th>변환 대상</th></tr></thead><tbody><tr><td><code>a += b</code></td><td><code>a.plusAssign(b)</code></td></tr><tr><td><code>a -= b</code></td><td><code>a.minusAssign(b)</code></td></tr><tr><td><code>a *= b</code></td><td><code>a.timesAssign(b)</code></td></tr><tr><td><code>a /= b</code></td><td><code>a.divAssign(b)</code></td></tr><tr><td><code>a %= b</code></td><td><code>a.remAssign(b)</code></td></tr></tbody></table><p>예를 들어 <code>a += b</code>와 같은 할당 연산의 경우 컴파일러는 다음 단계를 수행합니다:</p><ul><li>오른쪽 열의 함수가 사용 가능한 경우: <ul><li>해당 이항 함수(<code>plusAssign()</code>의 경우 <code>plus()</code>)도 사용 가능하고, <code>a</code>가 가변 변수이며, <code>plus</code>의 반환 타입이 <code>a</code>의 타입의 하위 타입인 경우, 오류(모호성)를 보고합니다.</li><li>반환 타입이 <code>Unit</code>인지 확인하고, 그렇지 않으면 오류를 보고합니다.</li><li><code>a.plusAssign(b)</code>에 대한 코드를 생성합니다.</li></ul></li><li>그렇지 않으면 <code>a = a + b</code>에 대한 코드를 생성하려고 시도합니다 (여기에는 타입 검사가 포함됩니다: <code>a + b</code>의 타입은 <code>a</code>의 하위 타입이어야 합니다).</li></ul><div class="note custom-block"><p class="custom-block-title">NOTE</p><p>Kotlin에서 할당은 표현식이 <em>아닙니다</em>.</p></div><h3 id="동등-및-부등-연산자" tabindex="-1">동등 및 부등 연산자 <a class="header-anchor" href="#동등-및-부등-연산자" aria-label="Permalink to &quot;동등 및 부등 연산자&quot;">​</a></h3><table tabindex="0"><thead><tr><th>표현식</th><th>변환 대상</th></tr></thead><tbody><tr><td><code>a == b</code></td><td><code>a?.equals(b) ?: (b === null)</code></td></tr><tr><td><code>a != b</code></td><td><code>!(a?.equals(b) ?: (b === null))</code></td></tr></tbody></table><p>이 연산자들은 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/equals.html" target="_blank" rel="noreferrer"><code>equals(other: Any?): Boolean</code></a> 함수와만 작동하며, 이 함수는 사용자 지정 동등성 확인 구현을 제공하기 위해 오버라이드될 수 있습니다. 동일한 이름을 가진 다른 함수(예: <code>equals(other: Foo)</code>)는 호출되지 않습니다.</p><div class="note custom-block"><p class="custom-block-title">NOTE</p><p><code>===</code> 및 <code>!==</code>(동일성 검사)는 오버로드할 수 없으므로, 이에 대한 규칙은 존재하지 않습니다.</p></div><p><code>==</code> 연산은 특별합니다: <code>null</code>을 확인하는 복잡한 표현식으로 변환됩니다. <code>null == null</code>은 항상 <code>true</code>이며, <code>null</code>이 아닌 <code>x</code>에 대한 <code>x == null</code>은 항상 <code>false</code>이며 <code>x.equals()</code>를 호출하지 않습니다.</p><h3 id="비교-연산자" tabindex="-1">비교 연산자 <a class="header-anchor" href="#비교-연산자" aria-label="Permalink to &quot;비교 연산자&quot;">​</a></h3><table tabindex="0"><thead><tr><th>표현식</th><th>변환 대상</th></tr></thead><tbody><tr><td><code>a &gt; b</code></td><td><code>a.compareTo(b) &gt; 0</code></td></tr><tr><td><code>a &lt; b</code></td><td><code>a.compareTo(b) &lt; 0</code></td></tr><tr><td><code>a &gt;= b</code></td><td><code>a.compareTo(b) &gt;= 0</code></td></tr><tr><td><code>a &lt;= b</code></td><td><code>a.compareTo(b) &lt;= 0</code></td></tr></tbody></table><p>모든 비교는 <code>Int</code>를 반환하도록 요구되는 <code>compareTo</code> 호출로 변환됩니다.</p><h3 id="프로퍼티-위임-연산자" tabindex="-1">프로퍼티 위임 연산자 <a class="header-anchor" href="#프로퍼티-위임-연산자" aria-label="Permalink to &quot;프로퍼티 위임 연산자&quot;">​</a></h3><p><code>provideDelegate</code>, <code>getValue</code>, <code>setValue</code> 연산자 함수는 <a href="/ko/kotlin/delegated-properties">위임된 프로퍼티</a>에서 설명합니다.</p><h2 id="이름-있는-함수에-대한-중위-호출" tabindex="-1">이름 있는 함수에 대한 중위 호출 <a class="header-anchor" href="#이름-있는-함수에-대한-중위-호출" aria-label="Permalink to &quot;이름 있는 함수에 대한 중위 호출&quot;">​</a></h2><p><a href="/ko/kotlin/functions#infix-notation">중위 함수 호출</a>을 사용하여 사용자 지정 중위 연산을 시뮬레이션할 수 있습니다.</p>`,56)]))}const E=a(d,[["render",o]]);export{k as __pageData,E as default};
