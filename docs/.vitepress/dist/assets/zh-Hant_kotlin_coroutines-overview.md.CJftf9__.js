import{_ as e}from"./chunks/get-started-coroutines.DKuC7weC.js";import{_ as t,c as r,o as n,ag as a}from"./chunks/framework.Bksy39di.js";const f=JSON.parse('{"title":"協程","description":"","frontmatter":{},"headers":[],"relativePath":"zh-Hant/kotlin/coroutines-overview.md","filePath":"zh-Hant/kotlin/coroutines-overview.md","lastUpdated":1754307826000}'),i={name:"zh-Hant/kotlin/coroutines-overview.md"};function l(c,o,s,h,u,d){return n(),r("div",null,o[0]||(o[0]=[a('<h1 id="協程" tabindex="-1">協程 <a class="header-anchor" href="#協程" aria-label="Permalink to &quot;協程&quot;">​</a></h1><p>應用程式通常需要同時執行多個任務，例如回應使用者輸入、載入資料或更新螢幕。 為支援此功能，它們依賴於並行處理 (concurrency)，這允許操作獨立執行而不會相互阻塞。</p><p>執行並行任務最常見的方式是使用執行緒 (threads)，它們是由作業系統管理的獨立執行路徑。 然而，執行緒相對笨重，建立過多的執行緒可能導致效能問題。</p><p>為支援高效的並行處理，Kotlin 使用基於 <em>協程</em> (coroutines) 的非同步程式設計，讓您可以使用暫停函數 (suspending functions) 以自然、循序的方式編寫非同步程式碼。 協程是執行緒的輕量級替代方案。 它們可以在不阻塞系統資源的情況下暫停，並且資源友好，使其更適合細粒度的並行處理。</p><p>大多數協程功能由 <a href="https://github.com/Kotlin/kotlinx.coroutines" target="_blank" rel="noreferrer"><code>kotlinx.coroutines</code></a> 函式庫提供， 該函式庫包含用於啟動協程、處理並行、使用非同步流等工具。</p><p>如果您是 Kotlin 協程的新手，請在深入研究更複雜的主題之前，先從 <a href="/zh-Hant/kotlin/coroutines-basics">協程基礎</a> 指南開始。 本指南透過簡單的範例介紹了暫停函數、協程建構器 (coroutine builders) 和結構化並行 (structured concurrency) 的關鍵概念：</p><p><a href="/zh-Hant/kotlin/coroutines-basics"><img src="'+e+'" width="700" alt="Get started with coroutines" style=""></a></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>查看 <a href="https://github.com/JetBrains/kotlinconf-app" target="_blank" rel="noreferrer">KotlinConf app</a> 以獲取範例專案，了解協程如何在實踐中使用。</p></div><h2 id="協程概念" tabindex="-1">協程概念 <a class="header-anchor" href="#協程概念" aria-label="Permalink to &quot;協程概念&quot;">​</a></h2><p><code>kotlinx.coroutines</code> 函式庫提供了用於並行執行任務、結構化協程執行和管理共享狀態的核心建構塊。</p><h3 id="暫停函數和協程建構器" tabindex="-1">暫停函數和協程建構器 <a class="header-anchor" href="#暫停函數和協程建構器" aria-label="Permalink to &quot;暫停函數和協程建構器&quot;">​</a></h3><p>Kotlin 中的協程建立在暫停函數之上，這些函數允許程式碼暫停和恢復而不會阻塞執行緒。 <code>suspend</code> 關鍵字標記了可以非同步執行長時間操作的函數。</p><p>要啟動新的協程，請使用 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/" target="_blank" rel="noreferrer"><code>CoroutineScope</code></a> 上的擴展函數，例如 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html" target="_blank" rel="noreferrer"><code>.launch()</code></a> 和 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html" target="_blank" rel="noreferrer"><code>.async()</code></a>。 這些建構器定義了協程的生命週期並提供了協程上下文。</p><p>您可以在 <a href="/zh-Hant/kotlin/coroutines-basics">協程基礎</a> 和 <a href="/zh-Hant/kotlin/coroutines-and-channels">組合暫停函數</a> 中了解更多關於這些建構器的資訊。</p><h3 id="協程上下文和行為" tabindex="-1">協程上下文和行為 <a class="header-anchor" href="#協程上下文和行為" aria-label="Permalink to &quot;協程上下文和行為&quot;">​</a></h3><p>從 <code>CoroutineScope</code> 啟動協程會建立一個管理其執行的上下文。 <code>.launch()</code> 和 <code>.async()</code> 等建構器函數會自動建立一組元素，定義協程的行為方式：</p><ul><li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/" target="_blank" rel="noreferrer"><code>Job</code></a> 介面追蹤協程的生命週期並啟用結構化並行。</li><li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/" target="_blank" rel="noreferrer"><code>CoroutineDispatcher</code></a> 控制協程的執行位置，例如在背景執行緒上或 UI 應用程式的主執行緒上。</li><li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/" target="_blank" rel="noreferrer"><code>CoroutineExceptionHandler</code></a> 處理未捕獲的異常。</li></ul><p>這些以及其他可能的元素組成了 <em>協程上下文</em> (coroutine context)，它預設繼承自協程的父級。 此上下文形成一個層次結構，實現結構化並行，相關的協程可以一起被 <a href="/zh-Hant/kotlin/cancellation-and-timeouts">取消</a> 或作為一個群組 <a href="/zh-Hant/kotlin/exception-handling">處理異常</a>。</p><h3 id="非同步流和共享可變狀態" tabindex="-1">非同步流和共享可變狀態 <a class="header-anchor" href="#非同步流和共享可變狀態" aria-label="Permalink to &quot;非同步流和共享可變狀態&quot;">​</a></h3><p>Kotlin 提供了多種協程通訊的方式。 根據您希望如何在協程之間共享值，使用以下選項之一：</p><ul><li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/" target="_blank" rel="noreferrer"><code>Flow</code></a> 僅在協程主動收集時才產生值。</li><li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/" target="_blank" rel="noreferrer"><code>Channel</code></a> 允許多個協程傳送和接收值，每個值僅傳遞給一個協程。</li><li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/" target="_blank" rel="noreferrer"><code>SharedFlow</code></a> 持續將每個值與所有活躍的收集協程共享。</li></ul><p>當多個協程需要存取或更新相同的資料時，它們會 <em>共享可變狀態</em> (share mutable state)。 如果沒有協調，這可能導致競爭條件 (race conditions)，操作會以不可預測的方式相互干擾。 為了安全地管理共享可變狀態，請使用 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/#" target="_blank" rel="noreferrer"><code>StateFlow</code></a> 包裝共享資料。 然後，您可以從一個協程更新它，並從其他協程收集其最新值。</p><p>更多資訊請參閱 <a href="/zh-Hant/kotlin/flow">非同步流</a>、<a href="/zh-Hant/kotlin/channels">通道</a> 和 <a href="/zh-Hant/kotlin/coroutines-and-channels">協程與通道教學</a>。</p><h2 id="接下來" tabindex="-1">接下來 <a class="header-anchor" href="#接下來" aria-label="Permalink to &quot;接下來&quot;">​</a></h2><ul><li>在 <a href="/zh-Hant/kotlin/coroutines-basics">協程基礎指南</a> 中學習協程、暫停函數和建構器的基礎知識。</li><li>在 <a href="/zh-Hant/kotlin/coroutine-context-and-dispatchers">組合暫停函數</a> 中探索如何組合暫停函數並建構協程管道。</li><li>了解如何使用 IntelliJ IDEA 中的內建工具 <a href="/zh-Hant/kotlin/debug-coroutines-with-idea">除錯協程</a>。</li><li>對於 Flow 特定除錯，請參閱 <a href="/zh-Hant/kotlin/debug-flow-with-idea">使用 IntelliJ IDEA 除錯 Kotlin Flow</a> 教學。</li><li>閱讀 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md" target="_blank" rel="noreferrer">使用協程進行 UI 程式設計指南</a> 以了解基於協程的 UI 開發。</li><li>查看 <a href="https://developer.android.com/kotlin/coroutines/coroutines-best-practices" target="_blank" rel="noreferrer">在 Android 中使用協程的最佳實踐</a>。</li><li>查閱 <a href="https://kotlinlang.org/api/kotlinx.coroutines/" target="_blank" rel="noreferrer"><code>kotlinx.coroutines</code> API 參考</a>。</li></ul>',25)]))}const x=t(i,[["render",l]]);export{f as __pageData,x as default};
