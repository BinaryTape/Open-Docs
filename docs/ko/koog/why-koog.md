# Koog를 선택하는 이유

Koog는 JetBrains 수준의 품질로 실제 문제를 해결하기 위해 설계되었습니다. Koog는 고급 AI 알고리즘, 즉시 사용 가능한 검증된 기술, Kotlin DSL, 그리고 기존 프레임워크를 뛰어넘는 강력한 멀티플랫폼 지원을 제공합니다.

## JVM 및 Kotlin 애플리케이션과의 통합

Koog는 JVM 및 Kotlin 개발자를 위해 특별히 설계된 Kotlin 도메인 특화 언어(DSL)를 제공합니다. 이를 통해 Kotlin 및 Java 기반 애플리케이션에 원활하게 통합되어 생산성을 크게 향상시키고 전반적인 개발자 경험을 개선합니다.

## JetBrains 제품을 통한 실제 환경 검증

Koog는 내부 AI 에이전트를 포함한 여러 JetBrains 제품의 기반이 됩니다. 이러한 실제 환경 통합을 통해 Koog는 실제 사용 사례에 대해 지속적으로 테스트, 개선 및 검증됩니다. Koog는 실제로 작동하는 것에 중점을 두며, 광범위한 피드백과 실제 제품 시나리오에서 얻은 통찰력을 반영합니다. 이러한 통합은 Koog에 다른 프레임워크와 차별화되는 강점을 제공합니다.

## 즉시 사용 가능한 고급 솔루션

Koog는 에이전트 시스템 개발을 간소화하고 가속화하는 사전 구축된 조합 가능한 솔루션을 포함하고 있어, 기본 구성 요소만 제공하는 프레임워크와 차별화됩니다.

*   **여러 히스토리 압축 전략.** Koog는 장기 대화를 압축하고 관리하는 고급 전략을 즉시 제공하여, 접근 방식에 대한 수동 실험의 필요성을 없앱니다. ML 엔지니어에 의해 테스트 및 개선된 세밀하게 조정된 프롬프트, 기술 및 알고리즘을 통해 검증된 방법을 사용하여 성능을 향상시킬 수 있습니다. 압축 전략에 대한 자세한 내용은 [히스토리 압축](https://docs.koog.ai/history-compression/)을 참조하십시오. Koog가 실제 시나리오에서 압축 및 컨텍스트 관리를 처리하는 방법에 대해 알아보려면 [이 문서](https://blog.jetbrains.com/ai/2025/07/when-tool-calling-becomes-an-addiction-debugging-llm-patterns-in-koog/)를 확인하십시오.
*   **원활한 LLM 전환.** 기존 대화 기록을 잃지 않고, 언제든지 새로운 사용 가능한 도구 세트와 함께 대화를 다른 대규모 언어 모델(LLM)로 전환할 수 있습니다. Koog는 자동으로 기록을 다시 작성하고 사용할 수 없는 도구를 처리하여 원활한 전환과 자연스러운 상호 작용 흐름을 가능하게 합니다.
*   **고급 지속성.** Koog는 단순히 채팅 메시지 대신 전체 에이전트 상태 머신을 복원할 수 있도록 합니다. 이는 체크포인트, 오류 복구, 그리고 상태 머신 실행의 어느 지점으로든 되돌릴 수 있는 기능과 같은 기능을 가능하게 합니다.
*   **강력한 재시도 구성 요소.** Koog는 에이전트 시스템 내의 모든 작업 세트를 래핑하고 구성 가능한 조건을 충족할 때까지 재시도할 수 있는 재시도 메커니즘을 포함합니다. 신뢰할 수 있는 결과를 보장하기 위해 각 시도에 대한 피드백을 제공하고 조정할 수 있습니다. LLM 호출이 시간 초과되거나, 도구가 예상대로 작동하지 않거나, 네트워크 문제가 발생하는 경우에도 Koog는 임시적인 실패 시에도 에이전트가 복원력을 유지하고 효과적으로 작동하도록 보장합니다. 더 자세한 기술 내용은 [재시도 기능](https://docs.koog.ai/history-compression/)을 참조하십시오.
*   **Markdown DSL을 사용한 구조화된 타입 스트리밍.** Koog는 Markdown DSL을 사용하여 LLM 출력을 스트리밍하고 이를 구조화된 타입 이벤트로 파싱합니다. 헤더, 글머리 기호 또는 정규식 패턴과 같은 특정 요소에 대한 핸들러를 등록하고 관련 부분만 실시간으로 수신할 수 있습니다. 이 접근 방식은 Markdown을 사용하여 사람이 읽을 수 있는 피드백을 제공하고, 구조화된 타이핑을 사용하여 기계가 파싱할 수 있는 데이터를 제공함으로써 투명성 부족을 효과적으로 없애고 사용자 경험을 향상시킵니다. 또한 예측 가능한 출력과 점진적 콘텐츠 렌더링을 통한 동적 사용자 인터페이스를 보장합니다.

## 광범위한 통합, 멀티플랫폼 지원, 향상된 관측 가능성

Koog는 다양한 플랫폼 및 환경 전반에서 에이전트 애플리케이션의 개발 및 배포를 지원합니다.

*   **멀티플랫폼 지원.** JVM, JS, WasmJS, Android 및 iOS 대상에 에이전트 애플리케이션을 배포할 수 있습니다.
*   **광범위한 AI 통합.** Koog는 OpenAI 및 Anthropic을 포함한 주요 LLM 제공업체는 물론, Bedrock과 같은 엔터프라이즈급 AI 클라우드와도 통합됩니다. 또한 Ollama와 같은 로컬 모델도 지원합니다. 사용 가능한 제공업체 전체 목록은 [LLM 제공업체](https://docs.koog.ai/llm-providers/)를 참조하십시오.
*   **OpenTelemetry 지원.** Koog는 AI 애플리케이션 모니터링 및 디버깅을 위해 [W&B Weave](https://wandb.ai/site/weave/) 및 [Langfuse](https://langfuse.com/)와 같은 인기 있는 관측 가능성 제공업체와의 즉시 사용 가능한 통합을 제공합니다. 네이티브 OpenTelemetry 지원을 통해 시스템에서 이미 사용하는 동일한 도구를 사용하여 에이전트를 추적, 로깅 및 측정할 수 있습니다. 더 자세히 알아보려면 [OpenTelemetry](https://docs.koog.ai/opentelemetry-support/)를 참조하십시오.
*   **Spring Boot 및 Ktor 통합.** Koog는 널리 사용되는 엔터프라이즈 환경과 통합됩니다.
    *   Ktor 서버가 있는 경우, Koog를 플러그인으로 설치하고 구성 파일을 사용하여 제공업체를 구성하며, LLM 클라이언트를 수동으로 연결하지 않고도 모든 경로에서 에이전트를 직접 호출할 수 있습니다.
    *   Spring Boot의 경우, Koog는 즉시 사용 가능한 빈(beans)과 자동 구성된 LLM 클라이언트를 제공하여 AI 기반 워크플로 구축을 쉽게 시작할 수 있도록 합니다.

## ML 엔지니어 및 제품 팀과의 협력

Koog의 고유한 장점은 JetBrains ML 엔지니어 및 제품 팀과의 직접적인 협력입니다. 이는 Koog로 구축된 기능이 이론적인 것에 그치지 않고, 실제 제품 요구 사항을 기반으로 테스트되고 개선되도록 보장합니다. 이는 Koog가 다음을 포함한다는 것을 의미합니다.

*   실제 성능에 최적화된 **세밀하게 조정된 프롬프트 및 전략**.
*   고유한 히스토리 압축 전략과 같이 제품 개발을 통해 발견되고 검증된 **검증된 엔지니어링 접근 방식**. [이 상세 문서](https://blog.jetbrains.com/ai/2025/07/when-tool-calling-becomes-an-addiction-debugging-llm-patterns-in-koog/)에서 더 자세히 알아볼 수 있습니다.
*   Koog가 효율성을 유지하고 변화하는 요구 사항에 적응할 수 있도록 지원하는 **지속적인 개선**.

## 개발자 커뮤니티에 대한 약속

Koog 팀은 강력한 개발자 커뮤니티를 구축하는 데 깊이 전념하고 있습니다. 피드백을 적극적으로 수집하고 통합함으로써 Koog는 개발자의 요구를 효과적으로 충족시키기 위해 발전합니다. 우리는 개발자 역량 강화를 위해 다양한 AI 아키텍처, 포괄적인 벤치마크, 상세한 사용 사례 가이드 및 교육 자료에 대한 지원을 적극적으로 확대하고 있습니다.

## 시작하는 방법

*   [개요](https://docs.koog.ai/)에서 Koog의 기능을 살펴보세요.
*   [시작하기](https://docs.koog.ai/getting-started/) 가이드로 첫 번째 Koog 에이전트를 구축하세요.
*   Koog의 최신 업데이트는 [릴리스 노트](https://github.com/JetBrains/koog/blob/main/CHANGELOG.md)에서 확인하세요.
*   [예제](https://docs.koog.ai/examples/)에서 배우세요.