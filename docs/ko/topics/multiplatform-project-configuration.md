[//]: # (title: Kotlin Multiplatform 프로젝트를 위한 구성 선택)

기존 프로젝트에 코틀린 멀티플랫폼을 추가하거나 새 프로젝트를 시작할 때, 코드를 구성하는 방법에는 여러 가지가 있습니다. 일반적으로 하나 이상의 코틀린 멀티플랫폼 공유 모듈을 생성하고 이를 안드로이드 및 iOS 앱에서 사용합니다.

특정 상황에 가장 적합한 접근 방식을 선택하려면 다음 질문들을 고려해야 합니다.

*   [코틀린 멀티플랫폼 모듈이 생성한 iOS 프레임워크를 iOS 앱에서 어떻게 사용하나요?](#connect-a-kotlin-multiplatform-module-to-an-ios-app)
    직접 통합하나요, CocoaPods를 통해서 통합하나요, 아니면 Swift 패키지 관리자(SPM)를 사용하나요?
*   [코틀린 멀티플랫폼 공유 모듈이 하나인가요, 여러 개인가요?](#module-configurations)
    여러 공유 모듈에 대한 엄브렐라 모듈은 무엇이어야 하나요?
*   [모든 코드를 모노레포에 저장하나요, 아니면 다른 저장소에 저장하나요?](#repository-configurations)
*   [코틀린 멀티플랫폼 모듈 프레임워크를 로컬 또는 원격 의존성으로 사용하나요?](#code-sharing-workflow)

이 질문들에 답하면 프로젝트에 가장 적합한 구성을 선택하는 데 도움이 될 것입니다.

## 코틀린 멀티플랫폼 모듈을 iOS 앱에 연결하기

코틀린 멀티플랫폼 공유 모듈을 iOS 앱에서 사용하려면 먼저 이 공유 모듈에서 [iOS 프레임워크](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/WhatAreFrameworks.html)를 생성해야 합니다. 그런 다음 이를 iOS 프로젝트의 의존성으로 추가해야 합니다.

![Kotlin Multiplatform shared module](kmp-shared-module.svg){width=700}

이 프레임워크는 로컬 또는 원격 의존성으로 사용할 수 있습니다.

다음 방법 중 하나로 iOS 프로젝트에 코틀린 멀티플랫폼 모듈 프레임워크에 대한 의존성을 추가할 수 있습니다.

*   **직접 통합 (Direct integration)**. iOS 앱 빌드에 새 실행 스크립트 단계를 추가하여 프레임워크를 직접 연결합니다. Xcode에서 이 작업을 수행하는 방법은 [프레임워크를 iOS 프로젝트에 연결하기](multiplatform-integrate-in-existing-app.md#configure-the-ios-project-to-use-a-kmp-framework)를 참조하세요.

    안드로이드 스튜디오 마법사로 프로젝트를 생성할 때 **일반 프레임워크 (Regular framework)** 옵션을 선택하면 이 설정이 자동으로 생성됩니다.

*   **CocoaPods 통합 (CocoaPods integration)**. Swift 및 Objective-C 프로젝트에서 널리 사용되는 의존성 관리자인 [CocoaPods](https://cocoapods.org/)를 통해 프레임워크를 연결합니다. 이는 로컬 또는 원격 의존성일 수 있습니다. 자세한 내용은 [코틀린 Gradle 프로젝트를 CocoaPods 의존성으로 사용하기](multiplatform-cocoapods-xcode.md)를 참조하세요.

    로컬 CocoaPods 의존성으로 워크플로를 설정하려면 마법사로 프로젝트를 생성하거나 스크립트를 수동으로 편집할 수 있습니다.

*   **SPM 사용 (Using SPM)**. Swift 코드 배포 관리를 위한 Apple 도구인 Swift 패키지 관리자(SPM)를 사용하여 프레임워크를 연결합니다. 저희는 [SPM 공식 지원을 위해 작업 중](https://youtrack.jetbrains.com/issue/KT-53877)입니다. 현재는 XCFrameworks를 사용하여 Swift 패키지에 대한 의존성을 설정할 수 있습니다. 자세한 내용은 [Swift 패키지 내보내기 설정](multiplatform-spm-export.md)을 참조하세요.

## 모듈 구성

코틀린 멀티플랫폼 프로젝트에서 사용할 수 있는 모듈 구성 옵션은 단일 모듈 또는 여러 개의 공유 모듈입니다.

### 단일 공유 모듈

가장 간단한 모듈 구성은 프로젝트에 단일 코틀린 멀티플랫폼 공유 모듈만 포함하는 것입니다.

![Single shared module](single-shared-module.svg){width=700}

안드로이드 앱은 일반 코틀린 모듈처럼 코틀린 멀티플랫폼 공유 모듈에 의존할 수 있습니다. 하지만 iOS는 코틀린을 직접 사용할 수 없으므로 iOS 앱은 코틀린 멀티플랫폼 모듈이 생성한 iOS 프레임워크에 의존해야 합니다.

<table>
  <tr>
     <th>장점</th>
     <th>단점</th>
  </tr>
  <tr>
  <td>
    <list>
       <li>단일 모듈로 구성된 간단한 설계는 인지 부하를 줄여줍니다. 기능을 어디에 넣을지, 논리적으로 어떻게 분할할지 고민할 필요가 없습니다.</li>
       <li>시작점으로 훌륭합니다.</li>
</list>
</td>
<td>
<list>
  <li>공유 모듈이 커질수록 컴파일 시간이 증가합니다.</li>
  <li>이 설계는 별도의 기능을 갖거나 앱이 필요한 기능에만 의존하는 것을 허용하지 않습니다.</li>
</list>
</td>
</tr>
</table>

### 여러 개의 공유 모듈

공유 모듈이 커지면 이를 기능 모듈로 분할하는 것이 좋습니다.
이는 단일 모듈을 사용하는 것과 관련된 확장성 문제를 피하는 데 도움이 됩니다.

안드로이드 앱은 모든 기능 모듈에 직접 의존하거나, 필요한 경우 일부에만 의존할 수 있습니다.

iOS 앱은 코틀린 멀티플랫폼 모듈이 생성한 하나의 프레임워크에 의존할 수 있습니다. 여러 모듈을 사용하는 경우, 사용 중인 모든 모듈에 의존하는 _엄브렐라 모듈_이라는 추가 모듈을 추가해야 하며, 그 다음에는 모든 모듈을 포함하는 _엄브렐라 프레임워크_를 구성해야 합니다.

> 엄브렐라 프레임워크 번들에는 프로젝트의 모든 공유 모듈이 포함되어 있으며 iOS 앱으로 임포트됩니다.
>
{style="tip"}

<table>
  <tr>
     <th>장점</th>
     <th>단점</th>
  </tr>
  <tr>
  <td>
    <list>
       <li>공유 코드의 관심사 분리.</li>
       <li>향상된 확장성.</li>
       </list>
</td>
<td>
<list>
  <li>엄브렐라 프레임워크 설정을 포함한 더 복잡한 설정.</li>
 <li>모듈 간의 더 복잡한 의존성 관리.</li>
</list>
</td>
</tr>
</table>

엄브렐라 모듈을 설정하려면 모든 기능 모듈에 의존하는 별도의 모듈을 추가하고 이 모듈에서 프레임워크를 생성합니다.

![Umbrella framework](umbrella-framework.svg){width=700}

안드로이드 앱은 일관성을 위해 엄브렐라 모듈에 의존하거나 별도의 기능 모듈에 의존할 수 있습니다. 엄브렐라 모듈은 종종 유용한 유틸리티 함수와 의존성 주입 설정 코드를 포함합니다.

특히 프레임워크 아티팩트가 원격 의존성으로 사용될 때, 일부 모듈만 엄브렐라 프레임워크로 내보낼 수 있습니다.
이렇게 하는 주된 이유는 자동 생성된 코드를 제외하여 최종 아티팩트의 크기를 줄이는 것입니다.

엄브렐라 프레임워크 접근 방식의 알려진 제약 사항은 iOS 앱이 일부 기능 모듈만 사용할 수 없다는 것입니다. 모든 모듈을 자동으로 사용합니다. 이 기능 개선 가능성에 대해서는 [KT-42247](https://youtrack.jetbrains.com/issue/KT-42247) 및 [KT-42250](https://youtrack.jetbrains.com/issue/KT-42250)에 귀하의 사례를 설명해 주세요.

> 아래 예시에서 iOS 앱이 엄브렐라 모듈에 의존한다는 것은 이 모듈에서 생성된 엄브렐라 프레임워크에도 의존한다는 의미입니다.
>
{style="tip"}

#### 엄브렐라 프레임워크가 왜 필요한가요? {initial-collapse-state="collapsed" collapsible="true"}

여러 코틀린 멀티플랫폼 공유 모듈에서 생성된 여러 프레임워크를 iOS 앱에 포함하는 것이 가능하지만, 이 접근 방식은 권장하지 않습니다. 코틀린 멀티플랫폼 모듈이 프레임워크로 컴파일되면, 결과 프레임워크에는 모든 의존성이 포함됩니다. 둘 이상의 모듈이 동일한 의존성을 사용하고 별도의 프레임워크로 iOS에 노출되면, Kotlin/Native 컴파일러가 의존성을 중복시킵니다.

이러한 중복은 여러 문제를 야기합니다. 첫째, iOS 앱 크기가 불필요하게 커집니다. 둘째, 의존성의 코드 구조가 중복된 의존성의 코드 구조와 호환되지 않습니다. 이는 iOS 애플리케이션 내에서 동일한 의존성을 가진 두 모듈을 통합하려 할 때 문제를 발생시킵니다. 예를 들어, 다른 모듈들이 동일한 의존성을 통해 전달하는 모든 상태는 연결되지 않을 것입니다. 이는 예상치 못한 동작과 버그로 이어질 수 있습니다. 정확한 제한 사항에 대한 자세한 내용은 [TouchLab 문서](https://touchlab.co/multiple-kotlin-frameworks-in-application/)를 참조하세요.

코틀린은 공통 프레임워크 의존성을 생성하지 않습니다. 그렇지 않으면 중복이 발생하고, 앱에 추가하는 모든 코틀린 바이너리는 가능한 한 작아야 하기 때문입니다. 전체 코틀린 런타임과 모든 의존성의 코드를 포함하는 것은 낭비입니다. 코틀린 컴파일러는 특정 빌드에 필요한 만큼 정확하게 바이너리를 줄일 수 있습니다. 하지만 다른 빌드에 무엇이 필요할지 알지 못하므로 의존성을 공유하려는 시도는 실현 불가능합니다. 이 문제의 영향을 최소화하기 위한 다양한 옵션을 모색 중입니다.

이 문제에 대한 해결책은 엄브렐라 프레임워크를 사용하는 것입니다. 이는 중복된 의존성으로 인한 iOS 앱의 비대화를 방지하고, 결과 아티팩트 최적화에 도움을 주며, 의존성 간의 비호환성으로 인한 좌절감을 해소합니다.

## 저장소 구성

새로운 및 기존 코틀린 멀티플랫폼 프로젝트에서 사용할 수 있는 저장소 구성 옵션은 여러 가지가 있으며, 하나의 저장소 또는 여러 저장소의 조합을 사용할 수 있습니다.

### 모노레포: 모든 것을 하나의 저장소에

일반적인 저장소 구성은 모노레포 구성이라고 합니다. 이 접근 방식은 코틀린 멀티플랫폼 샘플 및 튜토리얼에서 사용됩니다. 이 경우 저장소에는 안드로이드 및 iOS 앱뿐만 아니라 공유 모듈 또는 엄브렐라 모듈을 포함한 여러 모듈이 포함됩니다.

![Monorepo configuration](monorepo-configuration-1.svg){width=700}

![Monorepo configuration](monorepo-configuration-2.svg){width=700}

일반적으로 iOS 앱은 직접 또는 CocoaPods 통합을 사용하여 코틀린 멀티플랫폼 공유 모듈을 일반 프레임워크로 사용합니다. 자세한 내용 및 튜토리얼 링크는 [코틀린 멀티플랫폼 모듈을 iOS 앱에 연결하기](#connect-a-kotlin-multiplatform-module-to-an-ios-app)를 참조하세요.

저장소가 버전 관리 하에 있는 경우, 앱과 공유 모듈은 동일한 버전을 갖습니다.

<table>
  <tr>
     <th>장점</th>
     <th>단점</th>
  </tr>
  <tr>
  <td>
    <list>
       <li>마법사의 도움으로 쉽게 설정할 수 있습니다.</li>
       <li>iOS 개발자는 모든 코드가 동일한 저장소에 위치하므로 코틀린 멀티플랫폼 코드와 쉽게 작업할 수 있습니다.</li>
</list>
</td>
<td>
<list>
  <li>iOS 개발자는 익숙하지 않은 도구를 설정하고 구성해야 합니다.</li>
<li>이 접근 방식은 이미 다른 저장소에 저장되어 있는 기존 앱에는 종종 작동하지 않습니다.</li>
</list>
</td>
</tr>
</table>

기존 안드로이드 및 iOS 앱이 이미 다른 저장소에 저장되어 있는 경우, 코드를 병합하는 대신 코틀린 멀티플랫폼 부분을 안드로이드 저장소 또는 별도의 저장소에 추가할 수 있습니다.

### 두 개의 저장소: 안드로이드 + 공유 | iOS

또 다른 프로젝트 구성은 두 개의 저장소를 갖는 것입니다. 이 경우 코틀린 멀티플랫폼 저장소에는 안드로이드 앱과 엄브렐라 모듈을 포함한 공유 모듈이 모두 포함되며, Xcode 프로젝트에는 iOS 앱이 포함됩니다.

![Two repository configuration](two-repositories.svg){width=700}

안드로이드 및 iOS 앱은 별도로 버전 관리할 수 있으며, 공유 모듈은 안드로이드 앱과 함께 버전 관리됩니다.

### 세 개의 저장소: 안드로이드 | iOS | 공유

또 다른 옵션은 코틀린 멀티플랫폼 모듈을 위한 별도의 저장소를 갖는 것입니다. 이 경우 안드로이드 및 iOS 앱은 별도의 저장소에 저장되며, 프로젝트의 공유 코드에는 여러 기능 모듈과 iOS용 엄브렐라 모듈이 포함될 수 있습니다.

![Three repository configuration](three-repositories.svg){width=700}

각 프로젝트는 별도로 버전 관리할 수 있습니다. 코틀린 멀티플랫폼 모듈은 안드로이드 또는 JVM 플랫폼용으로도 버전 관리되고 게시되어야 합니다. 기능 모듈을 독립적으로 게시하거나 엄브렐라 모듈만 게시하고 안드로이드 앱이 여기에 의존하도록 할 수 있습니다.

안드로이드 아티팩트를 별도로 게시하는 것은 코틀린 멀티플랫폼 모듈이 안드로이드 프로젝트의 일부인 시나리오에 비해 안드로이드 개발자에게 추가적인 복잡성을 제공할 수 있습니다.

안드로이드와 iOS 팀 모두 동일한 버전 관리된 아티팩트를 사용할 때, 버전 일치 상태로 작동합니다.
팀 관점에서 볼 때, 이는 공유 코틀린 멀티플랫폼 코드가 안드로이드 개발자에게 "소유"된다는 인상을 피하게 합니다. 기능 개발을 위해 버전 관리된 내부 코틀린 및 Swift 패키지를 이미 게시하는 대규모 프로젝트의 경우, 공유 코틀린 아티팩트를 게시하는 것은 기존 워크플로의 일부가 됩니다.

### 여러 저장소: 안드로이드 | iOS | 여러 라이브러리

여러 플랫폼의 여러 앱 간에 기능을 공유해야 하는 경우, 코틀린 멀티플랫폼 코드를 사용하여 여러 저장소를 사용하는 것이 좋습니다. 예를 들어, 전체 제품에 공통적인 로깅 라이브러리를 자체 버전 관리와 함께 별도의 저장소에 저장할 수 있습니다.

이 경우 여러 코틀린 멀티플랫폼 라이브러리 저장소를 가집니다. 여러 iOS 앱이 "라이브러리 프로젝트"의 다른 하위 집합을 사용하는 경우, 각 앱은 라이브러리 프로젝트에 필요한 의존성을 가진 엄브렐라 모듈을 포함하는 추가 저장소를 가질 수 있습니다.

![Many repository configuration](many-repositories.svg){width=700}

여기서 각 라이브러리는 안드로이드 또는 JVM 플랫폼용으로도 버전 관리되고 게시되어야 합니다. 앱과 각 라이브러리는 별도로 버전 관리할 수 있습니다.

## 코드 공유 워크플로

iOS 앱은 코틀린 멀티플랫폼 공유 모듈에서 생성된 프레임워크를 _로컬_ 또는 _원격_ 의존성으로 사용할 수 있습니다. 로컬 의존성은 iOS 빌드에서 프레임워크에 로컬 경로를 제공하여 사용할 수 있습니다. 이 경우 프레임워크를 게시할 필요가 없습니다. 또는 프레임워크를 어딘가에 게시하고 iOS 앱이 다른 타사 의존성처럼 원격 의존성으로 사용하게 할 수도 있습니다.

### 로컬: 소스 배포

로컬 배포는 iOS 앱이 게시할 필요 없이 코틀린 멀티플랫폼 모듈 프레임워크를 사용하는 방식입니다. iOS 앱은 프레임워크를 직접 통합하거나 CocoaPods를 사용하여 통합할 수 있습니다.

이 워크플로는 일반적으로 안드로이드 및 iOS 팀 구성원 모두 공유 코틀린 멀티플랫폼 코드를 편집하기를 원할 때 사용됩니다. iOS 개발자는 안드로이드 스튜디오를 설치하고 코틀린 및 Gradle에 대한 기본적인 지식이 필요합니다.

로컬 배포 방식에서는 iOS 앱 빌드가 iOS 프레임워크 생성을 트리거합니다. 이는 iOS 개발자가 코틀린 멀티플랫폼 코드에 대한 변경 사항을 즉시 확인할 수 있음을 의미합니다.

![Local source distribution](local-source-distribution.svg){width=700}

이 시나리오는 일반적으로 두 가지 경우에 사용됩니다. 첫째, 아티팩트를 게시할 필요 없이 모노레포 프로젝트 구성에서 기본 워크플로로 사용될 수 있습니다. 둘째, 원격 워크플로에 더해 로컬 개발을 위해 사용될 수 있습니다. 자세한 내용은 [로컬 개발을 위한 로컬 의존성 설정](#setting-up-a-local-dependency-for-local-development)을 참조하세요.

이 워크플로는 모든 팀 구성원이 프로젝트 전체의 코드를 편집할 준비가 되어 있을 때 가장 효과적입니다. 여기에는 공통 부분 변경 후 안드로이드 및 iOS 부분 모두가 포함됩니다. 이상적으로는 모든 팀 구성원이 안드로이드 스튜디오와 Xcode를 설치하여 공통 코드 변경 후 두 앱을 모두 열고 실행할 수 있어야 합니다.

<table>
  <tr>
     <th>장점</th>
     <th>단점</th>
  </tr>
  <tr>
  <td>
    <list>
       <li>안드로이드 및 iOS 팀 구성원 모두 코틀린 멀티플랫폼 코드를 쉽게 편집할 수 있어 공유 코드 생성 및 유지 관리가 공동의 책임이 됩니다. 이는 팀의 고립을 방지하고 협업을 장려하는 데 도움이 됩니다.</li>
       <li>이 접근 방식은 공유 코드의 별도 버전 관리 및 게시를 요구하지 않습니다.</li>
       <li>iOS 팀 구성원이 아티팩트 생성 및 게시를 기다릴 필요가 없으므로 개발 워크플로가 더 빠릅니다.</li>
   </list>
</td>
<td>
  <list>
    <li>팀 구성원은 자신의 기기에 전체 개발 환경을 설정해야 합니다.</li>
    <li>iOS 개발자는 안드로이드 스튜디오 및 Gradle 사용법을 배워야 합니다.</li>
    <li>더 많은 코드가 공유되고 팀이 커짐에 따라 변경 사항 관리가 어려워집니다.</li>
  </list>
</td>
</tr>
</table>

### 원격: 아티팩트 배포

원격 배포는 프레임워크 아티팩트가 CocoaPod 또는 SPM을 사용하는 Swift 패키지로 게시되고 iOS 앱에서 사용되는 것을 의미합니다. 안드로이드 앱은 바이너리 의존성을 로컬 또는 원격으로 사용할 수 있습니다.

원격 배포는 종종 기존 프로젝트에 기술을 점진적으로 도입하기 위해 사용됩니다. 이는 iOS 개발자를 위한 워크플로 및 빌드 프로세스를 크게 변경하지 않습니다. 두 개 이상의 저장소를 가진 팀은 주로 원격 배포를 사용하여 프로젝트 코드를 저장합니다.

시작점으로 [KMMBridge](https://touchlab.co/trykmmbridge)를 사용하는 것이 좋습니다. 이는 원격 배포 워크플로를 크게 단순화하는 빌드 도구 세트입니다. 또는 유사한 워크플로를 직접 설정할 수도 있습니다.

![Remote artifact distribution](remote-artifact-distribution.svg){width=700}

<table>
  <tr>
     <th>장점</th>
     <th>단점</th>
  </tr>
  <tr>
  <td>참여하지 않는 iOS 팀 구성원은 코틀린으로 코딩하거나 안드로이드 스튜디오 및 Gradle과 같은 도구 사용법을 배울 필요가 없습니다. 이는 팀의 진입 장벽을 크게 낮춥니다.</td>
<td>
  <list>
    <li>공유 코드 편집 및 빌드 프로세스에 게시 및 버전 관리가 포함되므로 iOS 개발자를 위한 워크플로가 느려집니다.</li>
   <li>iOS에서 공유 코틀린 코드를 디버깅하기 어렵습니다.</li>
   <li>iOS 팀 구성원이 공유 코드에 기여할 가능성이 현저히 줄어듭니다.</li>
   <li>공유 코드의 유지 관리는 전적으로 참여하는 팀 구성원에게 달려 있습니다.</li>
  </list>
</td>
</tr>
</table>

#### 로컬 개발을 위한 로컬 의존성 설정

많은 팀은 iOS 개발자를 위한 개발 프로세스를 동일하게 유지하기 위해 코틀린 멀티플랫폼 기술을 채택할 때 원격 배포 워크플로를 선택합니다. 그러나 이 워크플로에서는 코틀린 멀티플랫폼 코드를 변경하기 어렵습니다.
코틀린 멀티플랫폼 모듈에서 생성된 프레임워크에 대한 로컬 의존성을 사용하여 추가적인 "로컬 개발" 워크플로를 설정하는 것을 권장합니다.

개발자가 새로운 기능을 추가할 때, 코틀린 멀티플랫폼 모듈을 로컬 의존성으로 사용하는 것으로 전환합니다.
이를 통해 공통 코틀린 코드를 변경하고, iOS에서 동작을 즉시 확인하며, 코틀린 코드를 디버깅할 수 있습니다. 기능이 준비되면 원격 의존성으로 다시 전환하고 그에 따라 변경 사항을 게시할 수 있습니다. 먼저 공유 모듈에 변경 사항을 게시하고, 그 후에만 앱에 변경 사항을 적용합니다.

원격 배포 워크플로에는 CocoaPods 통합 또는 SPM을 사용하고, 로컬 배포 워크플로에는 프레임워크를 직접 통합합니다.

<!-- This tutorial [TODO] describes how to switch workflows by choosing the corresponding scheme in Xcode:
[TODO screenshot] -->

CocoaPods를 사용하는 경우, CocoaPods를 로컬 배포 워크플로에 사용할 수도 있습니다. [TouchLab 문서](https://touchlab.co/kmmbridgecocoapodslocal)에 설명된 대로 환경 변수를 변경하여 전환합니다.