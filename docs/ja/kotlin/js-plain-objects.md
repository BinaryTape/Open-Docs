[//]: # (title: JSプレーンオブジェクトコンパイラプラグイン)

<primary-label ref="experimental-general"/>

JavaScript (JS) プレーンオブジェクトコンパイラプラグイン（`js-plain-objects`）を使用すると、型安全な方法でプレーンJSオブジェクトを作成およびコピーできます。

ここでは、プレーンJSオブジェクトに関する情報と、Kotlin/JSプロジェクトで`js-plain-objects`コンパイラプラグインを使用する方法について説明します。

> `js-plain-objects`プラグインは、新しいK2 Kotlinコンパイラでのみ動作します。
>
{style="warning"}

## プレーンJSオブジェクト

プレーンオブジェクトとは、オブジェクトリテラル（`{}`）を介して作成され、データプロパティを含むシンプルなJSオブジェクトです。
多くのJS APIは、設定やデータ交換のためにプレーンJSオブジェクトを受け取ったり、返したりします。

`js-plain-objects`プラグインを使用すると、オブジェクトの形状を記述するためにKotlinの`external interface`を宣言し、`@JsPlainObject`でアノテーションを付けます。
コンパイラはその後、Kotlinの型安全性を維持しながら、そのようなオブジェクトを構築およびコピーするための便利な関数を生成します。

## プラグインを有効にする

プロジェクトのGradle設定ファイルに`js-plain-objects`プラグインを追加します。以下にKotlin DSLの例を示します。

<tabs group="js-plain-objects">
<tab title="Kotlin" group-key="kotlin">

```kotlin
// build.gradle.kts
plugins {
    kotlin("multiplatform") version "%kotlinVersion%"
    kotlin("plugin.js-plain-objects") version "%kotlinVersion%"
}

kotlin {
    js {
        browser() // or nodejs()
    }
}
```

</tab>
<tab title="Groovy" group-key="groovy">

```groovy
// build.gradle
plugins {
    id 'org.jetbrains.kotlin.multiplatform' version '%kotlinVersion%'
    id 'org.jetbrains.kotlin.plugin.js-plain-objects' version '%kotlinVersion%'
}

kotlin {
    js {
        browser() // or nodejs()
    }
}
```

</tab>
</tabs>

## プレーンオブジェクト型を宣言する

`js-plain-objects`プラグインを有効にすると、プレーンオブジェクト型を宣言できます。
`external interface`に`@JsPlainObject`をアノテーションとして付けます。例：

```kotlin
@JsPlainObject
external interface User {
    val name: String
    val age: Int
    // You can use nullable types to declare a property as optional
    val email: String? 
}
```

プラグインがこのようなインターフェースを処理すると、オブジェクトの作成とコピーのための2つのヘルパー関数を持つコンパニオンオブジェクトを生成します。

```kotlin
@JsPlainObject
external interface User {
    val name: String
    val age: Int
    val email: String?

    // Generated by the plugin
    @JsExport.Ignore
    companion object {
        inline operator fun invoke(name: String, age: Int, email: String? = NOTHING): User =
            js("({ name: name, age: age, email: email })")

        inline fun copy(source: User, name: String = NOTHING, age: Int = NOTHING, email: String? = NOTHING): User =
            js("Object.assign({}, source, { name: name, age: age, email: email })")
    }
}
```

上記の例から：

*   `name`と`age`はnull許容マークなしで宣言されているため、必須です。
*   `email`はnull許容として宣言されているため、オプションであり、作成時にスキップできます。
*   演算子`invoke`は、指定されたプロパティを持つ新しいプレーンJSオブジェクトを構築します。
*   `copy`関数は、`source`をシャローコピーし、指定されたプロパティを上書きすることによって新しいオブジェクトを作成します。
*   これらのヘルパーがJSエクスポートに漏洩するのを避けるため、コンパニオンは`@JsExport.Ignore`でマークされています。

## プレーンオブジェクトを使用する

生成されたヘルパーを使用してオブジェクトを作成およびコピーします。

```kotlin
fun main() {
    val user = User(name = "Name", age = 10)
    val copy = User.copy(user, age = 11, email = "some@user.com")

    println(JSON.stringify(user))
    // { "name": "Name", "age": 10 }
    println(JSON.stringify(copy))
    // { "name": "Name", "age": 11, "email": "some@user.com" }
}
```

KotlinコードはJavaScriptにコンパイルされます：

```javascript
function main () {
    var user = { name: "Name", age: 10 };
    var copy = Object.assign({}, user, { age: 11, email: "some@user.com" });

    println(JSON.stringify(user));
    // { "name": "Name", "age": 10 }
    println(JSON.stringify(copy));
    // { "name": "Name", "age": 11, "email": "some@user.com" }
}
```

このアプローチで作成されたJavaScriptオブジェクトはすべて安全です。誤ったプロパティ名または値の型を使用した場合、コンパイル時エラーが発生します。生成されたコードはシンプルなオブジェクトリテラルと`Object.assign`呼び出しとしてインライン化されるため、このアプローチはゼロコストでもあります。

## 次へ

JavaScriptとの相互運用性については、[KotlinからJavaScriptコードを使用する](js-interop.md)および[動的型](dynamic-type.md)のドキュメントで詳細をご確認ください。