[//]: # (title: 演算子のオーバーロード)

Kotlinでは、型に対して定義済みの演算子セットのカスタム実装を提供できます。これらの演算子は、事前に定義された記号表現（`+`や`*`など）と優先順位を持っています。演算子を実装するには、対応する型に特定の名前を持つ[メンバ関数](functions.md#member-functions)または[拡張関数](extensions.md)を提供します。この型は、二項演算の場合は左側のオペランドの型となり、単項演算の場合は引数の型となります。

演算子をオーバーロードするには、対応する関数に`operator`修飾子を付けます。

```kotlin
interface IndexedContainer {
    operator fun get(index: Int)
}
```
演算子のオーバーロードを[オーバーライド](inheritance.md#overriding-methods)する際は、`operator`を省略できます。

```kotlin
class OrdersList: IndexedContainer {
    override fun get(index: Int) { /*...*/ }   
}
```

## 単項演算

### 単項プレフィックス演算子

| 式 | 変換先 |
|------------|---------------|
| `+a` | `a.unaryPlus()` |
| `-a` | `a.unaryMinus()` |
| `!a` | `a.not()` |

この表は、コンパイラが例えば`+a`という式を処理する際に、以下のステップを実行することを示しています。

* `a`の型を決定します。それを`T`とします。
* レシーバ`T`に対して、`operator`修飾子を持ち、パラメータのない`unaryPlus()`関数、つまりメンバ関数または拡張関数を探します。
* その関数が存在しないか、曖昧である場合、コンパイルエラーとなります。
* その関数が存在し、その戻り値の型が`R`である場合、式`+a`は型`R`を持ちます。

> これらの演算子は、他のすべての演算子と同様に、[基本型](basic-types.md)に対して最適化されており、関数呼び出しのオーバーヘッドは発生しません。
>
{style="note"}

例として、単項マイナス演算子をオーバーロードする方法を示します。

```kotlin
data class Point(val x: Int, val y: Int)

operator fun Point.unaryMinus() = Point(-x, -y)

val point = Point(10, 20)

fun main() {
   println(-point)  // "Point(x=-10, y=-20)"と出力されます
}
```
{kotlin-runnable="true"}

### インクリメントとデクリメント

| 式 | 変換先 |
|------------|---------------|
| `a++` | `a.inc()` + 以下を参照 |
| `a--` | `a.dec()` + 以下を参照 |

`inc()`および`dec()`関数は値を返さなければならず、その値は`++`または`--`演算子が使用された変数に代入されます。これらは、`inc`または`dec`が呼び出されたオブジェクト自体を変更してはなりません。

コンパイラは、*後置*形式の演算子（例: `a++`）の解決のために、以下のステップを実行します。

* `a`の型を決定します。それを`T`とします。
* `operator`修飾子を持ち、パラメータがなく、型`T`のレシーバに適用可能な`inc()`関数を探します。
* 関数の戻り値の型が`T`のサブタイプであることを確認します。

式を計算する効果は以下の通りです。

* `a`の初期値を一時ストレージ`a0`に格納します。
* `a0.inc()`の結果を`a`に代入します。
* `a0`を式の結果として返します。

`a--`の場合も、ステップは完全に同様です。

*前置*形式の`++a`および`--a`の場合も解決は同じように機能し、効果は以下の通りです。

* `a.inc()`の結果を`a`に代入します。
* `a`の新しい値を式の結果として返します。

## 二項演算

### 算術演算子 

| 式 | 変換先 |
| -----------|-------------- |
| `a + b` | `a.plus(b)` |
| `a - b` | `a.minus(b)` |
| `a * b` | `a.times(b)` |
| `a / b` | `a.div(b)` |
| `a % b` | `a.rem(b)` |
| `a..b` | `a.rangeTo(b)` |
| `a..<b` | `a.rangeUntil(b)` |

この表の演算子の場合、コンパイラは単に「変換先」列の式を解決します。

以下は、与えられた値から始まり、オーバーロードされた`+`演算子を使用してインクリメントできる`Counter`クラスの例です。

```kotlin
data class Counter(val dayIndex: Int) {
    operator fun plus(increment: Int): Counter {
        return Counter(dayIndex + increment)
    }
}
```

### `in`演算子

| 式 | 変換先 |
| -----------|-------------- |
| `a in b` | `b.contains(a)` |
| `a !in b` | `!b.contains(a)` |

`in`および`!in`の場合も手順は同じですが、引数の順序が逆になります。

### 添字アクセス演算子

| 式 | 変換先 |
| -------|-------------- |
| `a[i]`  | `a.get(i)` |
| `a[i, j]`  | `a.get(i, j)` |
| `a[i_1, ...,  i_n]`  | `a.get(i_1, ...,  i_n)` |
| `a[i] = b` | `a.set(i, b)` |
| `a[i, j] = b` | `a.set(i, j, b)` |
| `a[i_1, ...,  i_n] = b` | `a.set(i_1, ..., i_n, b)` |

角括弧は、適切な数の引数を持つ`get`および`set`への呼び出しに変換されます。

### `invoke`演算子

| 式 | 変換先 |
|--------|---------------|
| `a()`  | `a.invoke()` |
| `a(i)`  | `a.invoke(i)` |
| `a(i, j)`  | `a.invoke(i, j)` |
| `a(i_1, ...,  i_n)`  | `a.invoke(i_1, ...,  i_n)` |

丸括弧は、適切な数の引数を持つ`invoke`への呼び出しに変換されます。

### 複合代入

| 式 | 変換先 |
|------------|---------------|
| `a += b` | `a.plusAssign(b)` |
| `a -= b` | `a.minusAssign(b)` |
| `a *= b` | `a.timesAssign(b)` |
| `a /= b` | `a.divAssign(b)` |
| `a %= b` | `a.remAssign(b)` |

代入演算、例えば`a += b`の場合、コンパイラは以下のステップを実行します。

* 右の列の関数が利用可能な場合：
  * 対応する二項関数（つまり`plusAssign()`に対する`plus()`）も利用可能で、`a`が可変変数であり、`plus`の戻り値の型が`a`の型のサブタイプである場合、エラー（曖昧さ）を報告します。
  * その戻り値の型が`Unit`であることを確認し、そうでない場合はエラーを報告します。
  * `a.plusAssign(b)`のコードを生成します。
* そうでない場合、`a = a + b`のコードを生成しようとします（これには型チェックが含まれます：`a + b`の型は`a`のサブタイプでなければなりません）。

> Kotlinでは、代入は式では*ありません*。
>
{style="note"}

### 等価および非等価演算子

| 式 | 変換先 |
|------------|---------------|
| `a == b` | `a?.equals(b) ?: (b === null)` |
| `a != b` | `!(a?.equals(b) ?: (b === null))` |

これらの演算子は、カスタムの等価性チェック実装を提供するためにオーバーライドできる関数[`equals(other: Any?): Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/equals.html)でのみ機能します。同じ名前の他の関数（`equals(other: Foo)`など）は呼び出されません。

> `===`および`!==`（同一性チェック）はオーバーロードできないため、それらに関する規則は存在しません。
>
{style="note"}

`==`演算は特殊です。これは`null`をスクリーニングする複雑な式に変換されます。`null == null`は常に`true`であり、非`null`の`x`に対する`x == null`は常に`false`となり、`x.equals()`は呼び出されません。

### 比較演算子

| 式 | 変換先 |
|--------|---------------|
| `a > b`  | `a.compareTo(b) > 0` |
| `a < b`  | `a.compareTo(b) < 0` |
| `a >= b` | `a.compareTo(b) >= 0` |
| `a <= b` | `a.compareTo(b) <= 0` |

すべての比較は、`Int`を返す必要がある`compareTo`への呼び出しに変換されます。

### プロパティ委譲演算子

`provideDelegate`、`getValue`、および`setValue`演算子関数は、[委譲プロパティ](delegated-properties.md)で説明されています。

## 名前付き関数のinfix呼び出し

[infix関数呼び出し](functions.md#infix-notation)を使用することで、カスタムのinfix演算をシミュレートできます。