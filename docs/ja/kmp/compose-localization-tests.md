# ローカライゼーションのテスト
<show-structure depth="2"/>

ローカライゼーションをテストするには、異なるロケールに対して正しい翻訳された文字列が表示されること、およびフォーマットとレイアウトがロケールの要件に適応することを確認します。

## 各プラットフォームでのロケールテスト

### Android

Androidでは、**設定 | システム | 言語と入力 | 言語**からデバイスのシステムロケールを変更できます。
自動テストの場合、`adb`シェルを使用してエミュレーター上で直接ロケールを変更できます。

```shell
adb -e shell
setprop persist.sys.locale [BCP-47 language tag];stop;sleep 5;start
```

このコマンドはエミュレーターを再起動し、新しいロケールでアプリを再起動できるようにします。

あるいは、Espressoのようなフレームワークを使用して、テスト実行前にロケールをプログラムで設定することも可能です。
例えば、`LocaleTestRule()`を使用してテスト中のロケール切り替えを自動化できます。

### iOS

iOSでは、**設定 | 一般 | 言語と地域**からデバイスのシステム言語と地域を変更できます。
XCUITestフレームワークを使用した自動UIテストの場合、起動引数を使用してロケールの変更をシミュレートします。

```swift
app.launchArguments = [
    "-AppleLanguages", "(es)",
    "-AppleLocale", "es_ES"
]
```

### デスクトップ

デスクトップでは、JVMロケールは通常、オペレーティングシステムのロケールにデフォルトで設定されます。
設定場所は、異なるデスクトッププラットフォームによって異なります。

UIが初期化される前に、テストセットアップまたはアプリケーションのエントリポイントでJVMのデフォルトロケールをプログラムで設定できます。

```java
java.util.Locale.setDefault(java.util.Locale("es_ES"))
```

### Web

簡単な確認のためには、ブラウザの設定で言語設定を変更できます。
自動テストの場合、SeleniumやPuppeteerのようなブラウザ自動化ツールでロケールの変更をシミュレートできます。

あるいは、`window.navigator.languages`プロパティの読み取り専用の制限を回避して、カスタムロケールを導入することも可能です。詳細については、[](compose-resource-environment.md)チュートリアルを参照してください。

## 主要なテストシナリオ

### カスタムロケール

* ロケールをプログラムで上書きします。
* UI要素、フォーマットされた文字列、レイアウトが、選択されたロケールに正しく適応することを確認します。これには、該当する場合の右から左へのテキストの処理も含まれます。

### デフォルトリソース

デフォルトリソースは、指定されたロケールに対して翻訳が利用できない場合に使用されます。
アプリケーションは、これらのデフォルトに正しくフォールバックする必要があります。

* 上記で説明したプラットフォーム固有の方法を使用して、ロケールをサポートされていない値に設定します。
* フォールバックメカニズムがデフォルトリソースを正しくロードし、適切に表示することを確認します。

### ロケール固有のケース

一般的なローカライゼーションの問題を回避するため、以下のロケール固有のケースを考慮してください。

* 日付の書式設定 (`MM/dd/yyyy` vs. `dd/MM/yyyy`) や数値の書式設定など、[ロケール固有の書式設定](compose-regional-format.md)をテストします。
* アラビア語やヘブライ語のような右から左への言語で文字列、レイアウト、および配置が適切に表示されることを確認しながら、[RTLとLTRの動作](compose-rtl.md)を検証します。