# ローカライズのテスト
<show-structure depth="2"/>

ローカライズをテストするには、異なるロケールで正しい翻訳済み文字列が表示されることを確認し、
書式設定とレイアウトがロケールの要件に適応していることを検証します。

## 異なるプラットフォームでのロケールのテスト

### Android

Androidでは、デバイスのシステムロケールを**設定 | システム | 言語と入力 | 言語**から変更できます。
自動テストの場合、`adb`シェルを使用してエミュレーター上で直接ロケールを変更できます。

```shell
adb -e shell
setprop persist.sys.locale [BCP-47 language tag];stop;sleep 5;start
```

このコマンドはエミュレーターを再起動し、新しいロケールでアプリを再起動できるようにします。

または、Espressoのようなフレームワークを使用して、テスト実行前にプログラムでロケールを設定することもできます。
例えば、`LocaleTestRule()`を使用してテスト中にロケールの切り替えを自動化できます。

### iOS

iOSでは、デバイスのシステム言語と地域を**設定 | 一般 | 言語と地域**から変更できます。
XCUITestフレームワークを使用したUI自動テストの場合、起動引数を使用してロケールの変更をシミュレートします。

```swift
app.launchArguments = [
    "-AppleLanguages", "(es)",
    "-AppleLocale", "es_ES"
]
```

### デスクトップ

デスクトップでは、JVMのロケールは通常、オペレーティングシステムのロケールにデフォルト設定されます。
設定の場所はデスクトッププラットフォームによって異なります。

UIが初期化される前に、テスト設定またはアプリケーションのエントリポイントでJVMのデフォルトロケールをプログラムで設定できます。

```java
java.util.Locale.setDefault(java.util.Locale("es_ES"))
``` 

### Web

素早い確認のためには、ブラウザの設定で言語設定を変更できます。
自動テストの場合、SeleniumやPuppeteerのようなブラウザ自動化ツールでロケールの変更をシミュレートできます。

または、`window.navigator.languages`プロパティの読み取り専用制限を迂回して、
カスタムロケールを導入することもできます。詳細については、[](compose-resource-environment.md)チュートリアルで確認してください。

## 主要なテストシナリオ

### カスタムロケール

*   ロケールをプログラムでオーバーライドします。
*   UI要素、書式設定された文字列、およびレイアウトが選択されたロケールに正しく適応することを確認します。
    これには、該当する場合の右から左へのテキストの処理も含まれます。

### デフォルトリソース

デフォルトリソースは、指定されたロケールで翻訳が利用できない場合に使用されます。
アプリケーションはこれらのデフォルトに正しくフォールバックする必要があります。

*   上記で説明したプラットフォーム固有の方法を使用して、ロケールをサポートされていない値に設定します。
*   フォールバックメカニズムがデフォルトのリソースを正しくロードし、適切に表示することを確認します。

### ロケール固有のケース

一般的なローカライズの問題を避けるために、以下のロケール固有のケースを検討してください。

*   日付の書式設定（`MM/dd/yyyy` vs. `dd/MM/yyyy`）や数値の書式設定など、
    [ロケール固有の書式設定](compose-regional-format.md)をテストします。
*   [RTLおよびLTRの動作](compose-rtl.md)を検証し、アラビア語やヘブライ語のような右から左への言語で、
    文字列、レイアウト、および配置が適切に表示されることを確認します。